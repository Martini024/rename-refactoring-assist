{
  "results": [
  {
      "path": "https://github.com/apache/flink/blob/012b8936e119d1bfadadee3182cf86d25c6dd019^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java",
      "locators": [
          {
              "line": 363,
              "column": 36
          },
          {
              "line": 380,
              "column": 21
          },
          {
              "line": 381,
              "column": 21
          }
      ],
      "old_name": "pair",
      "new_name": "tuple",
      "ctx": {
          "symbolName": "pair",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Pair<Integer, Integer>",
          "scopeHint": "in createBufferPoolFactory(...)",
          "filePath": "ResultPartitionFactory.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * The minimum pool size should be <code>numberOfSubpartitions + 1</code> for two\n     * considerations:\n     *\n     * <p>1. StreamTask can only process input if there is at-least one available buffer on output\n     * side, so it might cause stuck problem if the minimum pool size is exactly equal to the number\n     * of subpartitions, because every subpartition might maintain a partial unfilled buffer.\n     *\n     * <p>2. Increases one more buffer for every output LocalBufferPool to avoid performance\n     * regression if processing input is based on at-least one buffer available on output side.\n     */\n    @VisibleForTesting\n    SupplierWithException<BufferPool, IOException> createBufferPoolFactory(\n            int numberOfSubpartitions, ResultPartitionType type) {\n        return () -> {\n            Pair<Integer, Integer> pair =\n                    NettyShuffleUtils.getMinMaxNetworkBuffersPerResultPartition(\n                            configuredNetworkBuffersPerChannel,\n                            floatingNetworkBuffersPerGate,\n                            sortShuffleMinParallelism,\n                            sortShuffleMinBuffers,\n                            numberOfSubpartitions,\n                            tieredStorage.isPresent(),\n                            tieredStorage\n                                    .map(\n                                            storage ->\n                                                    storage.getTieredStorageConfiguration()\n                                                            .getTotalExclusiveBufferNum())\n                                    .orElse(0),\n                            type);\n\n            return bufferPoolFactory.createBufferPool(\n                    pair.getLeft(),\n                    pair.getRight(),\n                    numberOfSubpartitions,\n                    maxBuffersPerChannel,\n                    isOverdraftBufferNeeded(type) ? maxOverdraftBuffersPerGate : 0);\n        };\n    }",
          "conflictNames": [
              "numberOfSubpartitions",
              "type"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/012b8936e119d1bfadadee3182cf86d25c6dd019^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/GateBuffersSpecTest.java",
      "locators": [
          {
              "line": 49,
              "column": 13
          },
          {
              "line": 56,
              "column": 17
          },
          {
              "line": 69,
              "column": 13
          },
          {
              "line": 76,
              "column": 17
          },
          {
              "line": 88,
              "column": 13
          },
          {
              "line": 95,
              "column": 17
          },
          {
              "line": 108,
              "column": 13
          },
          {
              "line": 115,
              "column": 17
          },
          {
              "line": 130,
              "column": 13
          },
          {
              "line": 137,
              "column": 17
          },
          {
              "line": 185,
              "column": 17
          },
          {
              "line": 190,
              "column": 36
          },
          {
              "line": 191,
              "column": 28
          }
      ],
      "old_name": "targetTotalBuffersPerGate",
      "new_name": "maxBuffersPerGate",
      "ctx": {
          "symbolName": "targetTotalBuffersPerGate",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in testCalculationWithSufficientRequiredBuffers(...)",
          "filePath": "GateBuffersSpecTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@ParameterizedTest\n    @MethodSource(\"parameters\")\n    void testCalculationWithSufficientRequiredBuffers(ResultPartitionType partitionType) {\n        int numInputChannels = 499;\n        GateBuffersSpec gateBuffersSpec = createGateBuffersSpec(numInputChannels, partitionType);\n\n        int minFloating = 1;\n        int maxFloating = 8;\n        int numExclusivePerChannel = 2;\n        int targetTotalBuffersPerGate = 1006;\n\n        checkBuffersInGate(\n                gateBuffersSpec,\n                minFloating,\n                maxFloating,\n                numExclusivePerChannel,\n                targetTotalBuffersPerGate);\n    }",
          "conflictNames": [
              "partitionType",
              "numInputChannels",
              "gateBuffersSpec",
              "minFloating",
              "maxFloating",
              "numExclusivePerChannel"
          ]
      },
      "suggestions": [
          {
              "name": "maxBuffersPerGate",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/012b8936e119d1bfadadee3182cf86d25c6dd019^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/GateBuffersSpecTest.java",
      "locators": [
          {
              "line": 47,
              "column": 13
          },
          {
              "line": 54,
              "column": 17
          },
          {
              "line": 67,
              "column": 13
          },
          {
              "line": 74,
              "column": 17
          },
          {
              "line": 86,
              "column": 13
          },
          {
              "line": 93,
              "column": 17
          },
          {
              "line": 106,
              "column": 13
          },
          {
              "line": 113,
              "column": 17
          },
          {
              "line": 128,
              "column": 13
          },
          {
              "line": 135,
              "column": 17
          },
          {
              "line": 183,
              "column": 17
          },
          {
              "line": 187,
              "column": 73
          }
      ],
      "old_name": "maxFloating",
      "new_name": "expectedBuffersPerGate",
      "ctx": {
          "symbolName": "maxFloating",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in testCalculationWithSufficientRequiredBuffers(...)",
          "filePath": "GateBuffersSpecTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@ParameterizedTest\n    @MethodSource(\"parameters\")\n    void testCalculationWithSufficientRequiredBuffers(ResultPartitionType partitionType) {\n        int numInputChannels = 499;\n        GateBuffersSpec gateBuffersSpec = createGateBuffersSpec(numInputChannels, partitionType);\n\n        int minFloating = 1;\n        int maxFloating = 8;\n        int numExclusivePerChannel = 2;\n        int targetTotalBuffersPerGate = 1006;\n\n        checkBuffersInGate(\n                gateBuffersSpec,\n                minFloating,\n                maxFloating,\n                numExclusivePerChannel,\n                targetTotalBuffersPerGate);\n    }",
          "conflictNames": [
              "partitionType",
              "numInputChannels",
              "gateBuffersSpec",
              "minFloating",
              "numExclusivePerChannel",
              "targetTotalBuffersPerGate"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/012b8936e119d1bfadadee3182cf86d25c6dd019^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/GateBuffersSpecTest.java",
      "locators": [
          {
              "line": 46,
              "column": 13
          },
          {
              "line": 53,
              "column": 17
          },
          {
              "line": 66,
              "column": 13
          },
          {
              "line": 73,
              "column": 17
          },
          {
              "line": 85,
              "column": 13
          },
          {
              "line": 92,
              "column": 17
          },
          {
              "line": 105,
              "column": 13
          },
          {
              "line": 112,
              "column": 17
          },
          {
              "line": 127,
              "column": 13
          },
          {
              "line": 134,
              "column": 17
          },
          {
              "line": 182,
              "column": 17
          },
          {
              "line": 186,
              "column": 76
          }
      ],
      "old_name": "minFloating",
      "new_name": "minBuffersPerGate",
      "ctx": {
          "symbolName": "minFloating",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in testCalculationWithSufficientRequiredBuffers(...)",
          "filePath": "GateBuffersSpecTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@ParameterizedTest\n    @MethodSource(\"parameters\")\n    void testCalculationWithSufficientRequiredBuffers(ResultPartitionType partitionType) {\n        int numInputChannels = 499;\n        GateBuffersSpec gateBuffersSpec = createGateBuffersSpec(numInputChannels, partitionType);\n\n        int minFloating = 1;\n        int maxFloating = 8;\n        int numExclusivePerChannel = 2;\n        int targetTotalBuffersPerGate = 1006;\n\n        checkBuffersInGate(\n                gateBuffersSpec,\n                minFloating,\n                maxFloating,\n                numExclusivePerChannel,\n                targetTotalBuffersPerGate);\n    }",
          "conflictNames": [
              "partitionType",
              "numInputChannels",
              "gateBuffersSpec",
              "maxFloating",
              "numExclusivePerChannel",
              "targetTotalBuffersPerGate"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/012b8936e119d1bfadadee3182cf86d25c6dd019^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java",
      "locators": [
          {
              "line": 624,
              "column": 17
          },
          {
              "line": 627,
              "column": 66
          },
          {
              "line": 644,
              "column": 17
          },
          {
              "line": 649,
              "column": 17
          },
          {
              "line": 653,
              "column": 67
          }
      ],
      "old_name": "excessMax",
      "new_name": "delta",
      "ctx": {
          "symbolName": "excessMax",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in redistributeBuffers(...)",
          "filePath": "NetworkBufferPool.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "// Must be called from synchronized block\n    private void redistributeBuffers() {\n        assert Thread.holdsLock(factoryLock);\n\n        if (resizableBufferPools.isEmpty()) {\n            return;\n        }\n\n        // All buffers, which are not among the required ones\n        final int numAvailableMemorySegment = totalNumberOfMemorySegments - numTotalRequiredBuffers;\n\n        if (numAvailableMemorySegment == 0) {\n            // in this case, we need to redistribute buffers so that every pool gets its minimum\n            for (LocalBufferPool bufferPool : resizableBufferPools) {\n                bufferPool.setNumBuffers(bufferPool.getNumberOfRequiredMemorySegments());\n            }\n            return;\n        }\n\n        /*\n         * With buffer pools being potentially limited, let's distribute the available memory\n         * segments based on the capacity of each buffer pool, i.e. the maximum number of segments\n         * an unlimited buffer pool can take is numAvailableMemorySegment, for limited buffer pools\n         * it may be less. Based on this and the sum of all these values (totalCapacity), we build\n         * a ratio that we use to distribute the buffers.\n         */\n\n        long totalCapacity = 0; // long to avoid int overflow\n\n        for (LocalBufferPool bufferPool : resizableBufferPools) {\n            int excessMax =\n                    bufferPool.getMaxNumberOfMemorySegments()\n                            - bufferPool.getNumberOfRequiredMemorySegments();\n            totalCapacity += Math.min(numAvailableMemorySegment, excessMax);\n        }\n\n        // no capacity to receive additional buffers?\n        if (totalCapacity == 0) {\n            return; // necessary to avoid div by zero when nothing to re-distribute\n        }\n\n        // since one of the arguments of 'min(a,b)' is a positive int, this is actually\n        // guaranteed to be within the 'int' domain\n        // (we use a checked downCast to handle possible bugs more gracefully).\n        final int memorySegmentsToDistribute =\n                MathUtils.checkedDownCast(Math.min(numAvailableMemorySegment, totalCapacity));\n\n        long totalPartsUsed = 0; // of totalCapacity\n        int numDistributedMemorySegment = 0;\n        for (LocalBufferPool bufferPool : resizableBufferPools) {\n            int excessMax =\n                    bufferPool.getMaxNumberOfMemorySegments()\n                            - bufferPool.getNumberOfRequiredMemorySegments();\n\n            // shortcut\n            if (excessMax == 0) {\n                continue;\n            }\n\n            totalPartsUsed += Math.min(numAvailableMemorySegment, excessMax);\n\n            // avoid remaining buffers by looking at the total capacity that should have been\n            // re-distributed up until here\n            // the downcast will always succeed, because both arguments of the subtraction are in\n            // the 'int' domain\n            final int mySize =\n                    MathUtils.checkedDownCast(\n                            memorySegmentsToDistribute * totalPartsUsed / totalCapacity\n                                    - numDistributedMemorySegment);\n\n            numDistributedMemorySegment += mySize;\n            bufferPool.setNumBuffers(bufferPool.getNumberOfRequiredMemorySegments() + mySize);\n        }\n\n        assert (totalPartsUsed == totalCapacity);\n        assert (numDistributedMemorySegment == memorySegmentsToDistribute);\n    }",
          "conflictNames": [
              "numAvailableMemorySegment",
              "totalCapacity",
              "memorySegmentsToDistribute",
              "totalPartsUsed",
              "numDistributedMemorySegment",
              "excessMax",
              "mySize"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/012b8936e119d1bfadadee3182cf86d25c6dd019^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java",
      "locators": [
          {
              "line": 641,
              "column": 14
          },
          {
              "line": 653,
              "column": 13
          },
          {
              "line": 661,
              "column": 58
          },
          {
              "line": 668,
              "column": 17
          }
      ],
      "old_name": "totalPartsUsed",
      "new_name": "totalAllocated",
      "ctx": {
          "symbolName": "totalPartsUsed",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "long",
          "scopeHint": "in redistributeBuffers(...)",
          "filePath": "NetworkBufferPool.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "// Must be called from synchronized block\n    private void redistributeBuffers() {\n        assert Thread.holdsLock(factoryLock);\n\n        if (resizableBufferPools.isEmpty()) {\n            return;\n        }\n\n        // All buffers, which are not among the required ones\n        final int numAvailableMemorySegment = totalNumberOfMemorySegments - numTotalRequiredBuffers;\n\n        if (numAvailableMemorySegment == 0) {\n            // in this case, we need to redistribute buffers so that every pool gets its minimum\n            for (LocalBufferPool bufferPool : resizableBufferPools) {\n                bufferPool.setNumBuffers(bufferPool.getNumberOfRequiredMemorySegments());\n            }\n            return;\n        }\n\n        /*\n         * With buffer pools being potentially limited, let's distribute the available memory\n         * segments based on the capacity of each buffer pool, i.e. the maximum number of segments\n         * an unlimited buffer pool can take is numAvailableMemorySegment, for limited buffer pools\n         * it may be less. Based on this and the sum of all these values (totalCapacity), we build\n         * a ratio that we use to distribute the buffers.\n         */\n\n        long totalCapacity = 0; // long to avoid int overflow\n\n        for (LocalBufferPool bufferPool : resizableBufferPools) {\n            int excessMax =\n                    bufferPool.getMaxNumberOfMemorySegments()\n                            - bufferPool.getNumberOfRequiredMemorySegments();\n            totalCapacity += Math.min(numAvailableMemorySegment, excessMax);\n        }\n\n        // no capacity to receive additional buffers?\n        if (totalCapacity == 0) {\n            return; // necessary to avoid div by zero when nothing to re-distribute\n        }\n\n        // since one of the arguments of 'min(a,b)' is a positive int, this is actually\n        // guaranteed to be within the 'int' domain\n        // (we use a checked downCast to handle possible bugs more gracefully).\n        final int memorySegmentsToDistribute =\n                MathUtils.checkedDownCast(Math.min(numAvailableMemorySegment, totalCapacity));\n\n        long totalPartsUsed = 0; // of totalCapacity\n        int numDistributedMemorySegment = 0;\n        for (LocalBufferPool bufferPool : resizableBufferPools) {\n            int excessMax =\n                    bufferPool.getMaxNumberOfMemorySegments()\n                            - bufferPool.getNumberOfRequiredMemorySegments();\n\n            // shortcut\n            if (excessMax == 0) {\n                continue;\n            }\n\n            totalPartsUsed += Math.min(numAvailableMemorySegment, excessMax);\n\n            // avoid remaining buffers by looking at the total capacity that should have been\n            // re-distributed up until here\n            // the downcast will always succeed, because both arguments of the subtraction are in\n            // the 'int' domain\n            final int mySize =\n                    MathUtils.checkedDownCast(\n                            memorySegmentsToDistribute * totalPartsUsed / totalCapacity\n                                    - numDistributedMemorySegment);\n\n            numDistributedMemorySegment += mySize;\n            bufferPool.setNumBuffers(bufferPool.getNumberOfRequiredMemorySegments() + mySize);\n        }\n\n        assert (totalPartsUsed == totalCapacity);\n        assert (numDistributedMemorySegment == memorySegmentsToDistribute);\n    }",
          "conflictNames": [
              "numAvailableMemorySegment",
              "totalCapacity",
              "excessMax",
              "memorySegmentsToDistribute",
              "numDistributedMemorySegment",
              "mySize"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/012b8936e119d1bfadadee3182cf86d25c6dd019^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputGateSpecUtils.java",
      "locators": [
          {
              "line": 46,
              "column": 13
          },
          {
              "line": 55,
              "column": 62
          }
      ],
      "old_name": "targetRequiredBuffersPerGate",
      "new_name": "targetExpectedBuffersPerGate",
      "ctx": {
          "symbolName": "targetRequiredBuffersPerGate",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in createGateBuffersSpec(...)",
          "filePath": "InputGateSpecUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static GateBuffersSpec createGateBuffersSpec(\n            Optional<Integer> configuredMaxRequiredBuffersPerGate,\n            int configuredNetworkBuffersPerChannel,\n            int configuredFloatingNetworkBuffersPerGate,\n            ResultPartitionType partitionType,\n            int numInputChannels,\n            boolean enableTieredStorage) {\n        int maxRequiredBuffersThresholdPerGate =\n                getEffectiveMaxRequiredBuffersPerGate(\n                        partitionType, configuredMaxRequiredBuffersPerGate, enableTieredStorage);\n        int targetRequiredBuffersPerGate =\n                getRequiredBuffersTargetPerGate(\n                        numInputChannels, configuredNetworkBuffersPerChannel);\n        int targetTotalBuffersPerGate =\n                getTotalBuffersTargetPerGate(\n                        numInputChannels,\n                        configuredNetworkBuffersPerChannel,\n                        configuredFloatingNetworkBuffersPerGate);\n        int requiredBuffersPerGate =\n                Math.min(maxRequiredBuffersThresholdPerGate, targetRequiredBuffersPerGate);\n\n        int effectiveExclusiveBuffersPerChannel =\n                getExclusiveBuffersPerChannel(\n                        configuredNetworkBuffersPerChannel,\n                        numInputChannels,\n                        requiredBuffersPerGate);\n        int effectiveExclusiveBuffersPerGate =\n                getEffectiveExclusiveBuffersPerGate(\n                        numInputChannels, effectiveExclusiveBuffersPerChannel);\n\n        int requiredFloatingBuffers = requiredBuffersPerGate - effectiveExclusiveBuffersPerGate;\n        int totalFloatingBuffers = targetTotalBuffersPerGate - effectiveExclusiveBuffersPerGate;\n\n        checkState(requiredFloatingBuffers > 0, \"Must be positive.\");\n        checkState(\n                requiredFloatingBuffers <= totalFloatingBuffers,\n                \"Wrong number of floating buffers.\");\n\n        return new GateBuffersSpec(\n                effectiveExclusiveBuffersPerChannel,\n                requiredFloatingBuffers,\n                totalFloatingBuffers,\n                targetTotalBuffersPerGate);\n    }",
          "conflictNames": [
              "configuredMaxRequiredBuffersPerGate",
              "configuredNetworkBuffersPerChannel",
              "configuredFloatingNetworkBuffersPerGate",
              "partitionType",
              "numInputChannels",
              "enableTieredStorage",
              "maxRequiredBuffersThresholdPerGate",
              "targetTotalBuffersPerGate",
              "requiredBuffersPerGate",
              "effectiveExclusiveBuffersPerChannel",
              "effectiveExclusiveBuffersPerGate",
              "requiredFloatingBuffers",
              "totalFloatingBuffers"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/012b8936e119d1bfadadee3182cf86d25c6dd019^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputGateSpecUtils.java",
      "locators": [
          {
              "line": 49,
              "column": 13
          },
          {
              "line": 67,
              "column": 36
          },
          {
              "line": 78,
              "column": 17
          }
      ],
      "old_name": "targetTotalBuffersPerGate",
      "new_name": "maxBuffersPerGate",
      "ctx": {
          "symbolName": "targetTotalBuffersPerGate",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in createGateBuffersSpec(...)",
          "filePath": "InputGateSpecUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static GateBuffersSpec createGateBuffersSpec(\n            Optional<Integer> configuredMaxRequiredBuffersPerGate,\n            int configuredNetworkBuffersPerChannel,\n            int configuredFloatingNetworkBuffersPerGate,\n            ResultPartitionType partitionType,\n            int numInputChannels,\n            boolean enableTieredStorage) {\n        int maxRequiredBuffersThresholdPerGate =\n                getEffectiveMaxRequiredBuffersPerGate(\n                        partitionType, configuredMaxRequiredBuffersPerGate, enableTieredStorage);\n        int targetRequiredBuffersPerGate =\n                getRequiredBuffersTargetPerGate(\n                        numInputChannels, configuredNetworkBuffersPerChannel);\n        int targetTotalBuffersPerGate =\n                getTotalBuffersTargetPerGate(\n                        numInputChannels,\n                        configuredNetworkBuffersPerChannel,\n                        configuredFloatingNetworkBuffersPerGate);\n        int requiredBuffersPerGate =\n                Math.min(maxRequiredBuffersThresholdPerGate, targetRequiredBuffersPerGate);\n\n        int effectiveExclusiveBuffersPerChannel =\n                getExclusiveBuffersPerChannel(\n                        configuredNetworkBuffersPerChannel,\n                        numInputChannels,\n                        requiredBuffersPerGate);\n        int effectiveExclusiveBuffersPerGate =\n                getEffectiveExclusiveBuffersPerGate(\n                        numInputChannels, effectiveExclusiveBuffersPerChannel);\n\n        int requiredFloatingBuffers = requiredBuffersPerGate - effectiveExclusiveBuffersPerGate;\n        int totalFloatingBuffers = targetTotalBuffersPerGate - effectiveExclusiveBuffersPerGate;\n\n        checkState(requiredFloatingBuffers > 0, \"Must be positive.\");\n        checkState(\n                requiredFloatingBuffers <= totalFloatingBuffers,\n                \"Wrong number of floating buffers.\");\n\n        return new GateBuffersSpec(\n                effectiveExclusiveBuffersPerChannel,\n                requiredFloatingBuffers,\n                totalFloatingBuffers,\n                targetTotalBuffersPerGate);\n    }",
          "conflictNames": [
              "configuredMaxRequiredBuffersPerGate",
              "configuredNetworkBuffersPerChannel",
              "configuredFloatingNetworkBuffersPerGate",
              "partitionType",
              "numInputChannels",
              "enableTieredStorage",
              "maxRequiredBuffersThresholdPerGate",
              "targetRequiredBuffersPerGate",
              "requiredBuffersPerGate",
              "effectiveExclusiveBuffersPerChannel",
              "effectiveExclusiveBuffersPerGate",
              "requiredFloatingBuffers",
              "totalFloatingBuffers"
          ]
      },
      "suggestions": [
          {
              "name": "maxBuffersPerGate",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/012b8936e119d1bfadadee3182cf86d25c6dd019^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputGateSpecUtils.java",
      "locators": [
          {
              "line": 54,
              "column": 13
          },
          {
              "line": 61,
              "column": 25
          },
          {
              "line": 66,
              "column": 39
          },
          {
              "line": 102,
              "column": 8
          },
          {
              "line": 107,
              "column": 17
          },
          {
              "line": 109,
              "column": 23
          },
          {
              "line": 112,
              "column": 18
          }
      ],
      "old_name": "requiredBuffersPerGate",
      "new_name": "expectedBuffersPerGate",
      "ctx": {
          "symbolName": "requiredBuffersPerGate",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in createGateBuffersSpec(...)",
          "filePath": "InputGateSpecUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static GateBuffersSpec createGateBuffersSpec(\n            Optional<Integer> configuredMaxRequiredBuffersPerGate,\n            int configuredNetworkBuffersPerChannel,\n            int configuredFloatingNetworkBuffersPerGate,\n            ResultPartitionType partitionType,\n            int numInputChannels,\n            boolean enableTieredStorage) {\n        int maxRequiredBuffersThresholdPerGate =\n                getEffectiveMaxRequiredBuffersPerGate(\n                        partitionType, configuredMaxRequiredBuffersPerGate, enableTieredStorage);\n        int targetRequiredBuffersPerGate =\n                getRequiredBuffersTargetPerGate(\n                        numInputChannels, configuredNetworkBuffersPerChannel);\n        int targetTotalBuffersPerGate =\n                getTotalBuffersTargetPerGate(\n                        numInputChannels,\n                        configuredNetworkBuffersPerChannel,\n                        configuredFloatingNetworkBuffersPerGate);\n        int requiredBuffersPerGate =\n                Math.min(maxRequiredBuffersThresholdPerGate, targetRequiredBuffersPerGate);\n\n        int effectiveExclusiveBuffersPerChannel =\n                getExclusiveBuffersPerChannel(\n                        configuredNetworkBuffersPerChannel,\n                        numInputChannels,\n                        requiredBuffersPerGate);\n        int effectiveExclusiveBuffersPerGate =\n                getEffectiveExclusiveBuffersPerGate(\n                        numInputChannels, effectiveExclusiveBuffersPerChannel);\n\n        int requiredFloatingBuffers = requiredBuffersPerGate - effectiveExclusiveBuffersPerGate;\n        int totalFloatingBuffers = targetTotalBuffersPerGate - effectiveExclusiveBuffersPerGate;\n\n        checkState(requiredFloatingBuffers > 0, \"Must be positive.\");\n        checkState(\n                requiredFloatingBuffers <= totalFloatingBuffers,\n                \"Wrong number of floating buffers.\");\n\n        return new GateBuffersSpec(\n                effectiveExclusiveBuffersPerChannel,\n                requiredFloatingBuffers,\n                totalFloatingBuffers,\n                targetTotalBuffersPerGate);\n    }",
          "conflictNames": [
              "configuredMaxRequiredBuffersPerGate",
              "configuredNetworkBuffersPerChannel",
              "configuredFloatingNetworkBuffersPerGate",
              "partitionType",
              "numInputChannels",
              "enableTieredStorage",
              "maxRequiredBuffersThresholdPerGate",
              "targetRequiredBuffersPerGate",
              "targetTotalBuffersPerGate",
              "effectiveExclusiveBuffersPerChannel",
              "effectiveExclusiveBuffersPerGate",
              "requiredFloatingBuffers",
              "totalFloatingBuffers"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/012b8936e119d1bfadadee3182cf86d25c6dd019^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputGateSpecUtils.java",
      "locators": [
          {
              "line": 67,
              "column": 13
          },
          {
              "line": 71,
              "column": 44
          },
          {
              "line": 77,
              "column": 17
          }
      ],
      "old_name": "totalFloatingBuffers",
      "new_name": "minBuffersPerGate",
      "ctx": {
          "symbolName": "totalFloatingBuffers",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in createGateBuffersSpec(...)",
          "filePath": "InputGateSpecUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static GateBuffersSpec createGateBuffersSpec(\n            Optional<Integer> configuredMaxRequiredBuffersPerGate,\n            int configuredNetworkBuffersPerChannel,\n            int configuredFloatingNetworkBuffersPerGate,\n            ResultPartitionType partitionType,\n            int numInputChannels,\n            boolean enableTieredStorage) {\n        int maxRequiredBuffersThresholdPerGate =\n                getEffectiveMaxRequiredBuffersPerGate(\n                        partitionType, configuredMaxRequiredBuffersPerGate, enableTieredStorage);\n        int targetRequiredBuffersPerGate =\n                getRequiredBuffersTargetPerGate(\n                        numInputChannels, configuredNetworkBuffersPerChannel);\n        int targetTotalBuffersPerGate =\n                getTotalBuffersTargetPerGate(\n                        numInputChannels,\n                        configuredNetworkBuffersPerChannel,\n                        configuredFloatingNetworkBuffersPerGate);\n        int requiredBuffersPerGate =\n                Math.min(maxRequiredBuffersThresholdPerGate, targetRequiredBuffersPerGate);\n\n        int effectiveExclusiveBuffersPerChannel =\n                getExclusiveBuffersPerChannel(\n                        configuredNetworkBuffersPerChannel,\n                        numInputChannels,\n                        requiredBuffersPerGate);\n        int effectiveExclusiveBuffersPerGate =\n                getEffectiveExclusiveBuffersPerGate(\n                        numInputChannels, effectiveExclusiveBuffersPerChannel);\n\n        int requiredFloatingBuffers = requiredBuffersPerGate - effectiveExclusiveBuffersPerGate;\n        int totalFloatingBuffers = targetTotalBuffersPerGate - effectiveExclusiveBuffersPerGate;\n\n        checkState(requiredFloatingBuffers > 0, \"Must be positive.\");\n        checkState(\n                requiredFloatingBuffers <= totalFloatingBuffers,\n                \"Wrong number of floating buffers.\");\n\n        return new GateBuffersSpec(\n                effectiveExclusiveBuffersPerChannel,\n                requiredFloatingBuffers,\n                totalFloatingBuffers,\n                targetTotalBuffersPerGate);\n    }",
          "conflictNames": [
              "configuredMaxRequiredBuffersPerGate",
              "configuredNetworkBuffersPerChannel",
              "configuredFloatingNetworkBuffersPerGate",
              "partitionType",
              "numInputChannels",
              "enableTieredStorage",
              "maxRequiredBuffersThresholdPerGate",
              "targetRequiredBuffersPerGate",
              "targetTotalBuffersPerGate",
              "requiredBuffersPerGate",
              "effectiveExclusiveBuffersPerChannel",
              "effectiveExclusiveBuffersPerGate",
              "requiredFloatingBuffers"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/012b8936e119d1bfadadee3182cf86d25c6dd019^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java",
      "locators": [
          {
              "line": 1228,
              "column": 13
          },
          {
              "line": 1231,
              "column": 13
          },
          {
              "line": 1233,
              "column": 43
          }
      ],
      "old_name": "targetTotalBuffersPerGate",
      "new_name": "maxBuffersPerGate",
      "ctx": {
          "symbolName": "targetTotalBuffersPerGate",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in verifyBuffersInBufferPool(...)",
          "filePath": "SingleInputGateTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void verifyBuffersInBufferPool(boolean isPipeline, int subpartitionRandSize)\n            throws Exception {\n        IntermediateResultPartitionID[] partitionIds =\n                new IntermediateResultPartitionID[] {\n                    new IntermediateResultPartitionID(),\n                    new IntermediateResultPartitionID(),\n                    new IntermediateResultPartitionID()\n                };\n\n        IndexRange subpartitionIndexRange = new IndexRange(0, subpartitionRandSize - 1);\n        NettyShuffleEnvironmentBuilder nettyShuffleEnvironmentBuilder =\n                new NettyShuffleEnvironmentBuilder();\n        Optional<Integer> expectMaxRequiredBuffersPerGate =\n                isPipeline\n                        ? Optional.of(\n                                InputGateSpecUtils.DEFAULT_MAX_REQUIRED_BUFFERS_PER_GATE_FOR_STREAM)\n                        : Optional.of(\n                                InputGateSpecUtils.DEFAULT_MAX_REQUIRED_BUFFERS_PER_GATE_FOR_BATCH);\n        nettyShuffleEnvironmentBuilder.setMaxRequiredBuffersPerGate(\n                expectMaxRequiredBuffersPerGate);\n        NettyShuffleEnvironment netEnv = nettyShuffleEnvironmentBuilder.build();\n\n        SingleInputGate gate =\n                createSingleInputGate(\n                        partitionIds,\n                        isPipeline ? ResultPartitionType.PIPELINED : ResultPartitionType.BLOCKING,\n                        subpartitionIndexRange,\n                        netEnv,\n                        ResourceID.generate(),\n                        new TestingConnectionManager(),\n                        new TestingResultPartitionManager(new NoOpResultSubpartitionView()));\n        gate.setup();\n\n        for (InputChannel inputChannel : gate.inputChannels()) {\n            if (inputChannel instanceof RemoteInputChannel) {\n                assertThat(((RemoteInputChannel) inputChannel).getInitialCredit()).isEqualTo(0);\n            }\n        }\n\n        int targetTotalBuffersPerGate = 2 * partitionIds.length * subpartitionRandSize + 8;\n        int requiredFloatingBuffersPerGate;\n        int totalFloatingBuffersPerGate;\n        if (targetTotalBuffersPerGate >= expectMaxRequiredBuffersPerGate.get()) {\n            requiredFloatingBuffersPerGate = expectMaxRequiredBuffersPerGate.get();\n            totalFloatingBuffersPerGate = targetTotalBuffersPerGate;\n        } else {\n            requiredFloatingBuffersPerGate = 1;\n            totalFloatingBuffersPerGate = 8;\n        }\n        assertThat(gate.getBufferPool().getNumberOfRequiredMemorySegments())\n                .isEqualTo(requiredFloatingBuffersPerGate);\n        assertThat(gate.getBufferPool().getMaxNumberOfMemorySegments())\n                .isEqualTo(totalFloatingBuffersPerGate);\n    }",
          "conflictNames": [
              "isPipeline",
              "subpartitionRandSize",
              "partitionIds",
              "subpartitionIndexRange",
              "nettyShuffleEnvironmentBuilder",
              "expectMaxRequiredBuffersPerGate",
              "netEnv",
              "gate",
              "requiredFloatingBuffersPerGate",
              "totalFloatingBuffersPerGate"
          ]
      },
      "suggestions": [
          {
              "name": "maxBuffersPerGate",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/012b8936e119d1bfadadee3182cf86d25c6dd019^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java",
      "locators": [
          {
              "line": 1230,
              "column": 13
          },
          {
              "line": 1233,
              "column": 13
          },
          {
              "line": 1236,
              "column": 13
          },
          {
              "line": 1241,
              "column": 28
          }
      ],
      "old_name": "totalFloatingBuffersPerGate",
      "new_name": "minBuffersPerGate",
      "ctx": {
          "symbolName": "totalFloatingBuffersPerGate",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in verifyBuffersInBufferPool(...)",
          "filePath": "SingleInputGateTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void verifyBuffersInBufferPool(boolean isPipeline, int subpartitionRandSize)\n            throws Exception {\n        IntermediateResultPartitionID[] partitionIds =\n                new IntermediateResultPartitionID[] {\n                    new IntermediateResultPartitionID(),\n                    new IntermediateResultPartitionID(),\n                    new IntermediateResultPartitionID()\n                };\n\n        IndexRange subpartitionIndexRange = new IndexRange(0, subpartitionRandSize - 1);\n        NettyShuffleEnvironmentBuilder nettyShuffleEnvironmentBuilder =\n                new NettyShuffleEnvironmentBuilder();\n        Optional<Integer> expectMaxRequiredBuffersPerGate =\n                isPipeline\n                        ? Optional.of(\n                                InputGateSpecUtils.DEFAULT_MAX_REQUIRED_BUFFERS_PER_GATE_FOR_STREAM)\n                        : Optional.of(\n                                InputGateSpecUtils.DEFAULT_MAX_REQUIRED_BUFFERS_PER_GATE_FOR_BATCH);\n        nettyShuffleEnvironmentBuilder.setMaxRequiredBuffersPerGate(\n                expectMaxRequiredBuffersPerGate);\n        NettyShuffleEnvironment netEnv = nettyShuffleEnvironmentBuilder.build();\n\n        SingleInputGate gate =\n                createSingleInputGate(\n                        partitionIds,\n                        isPipeline ? ResultPartitionType.PIPELINED : ResultPartitionType.BLOCKING,\n                        subpartitionIndexRange,\n                        netEnv,\n                        ResourceID.generate(),\n                        new TestingConnectionManager(),\n                        new TestingResultPartitionManager(new NoOpResultSubpartitionView()));\n        gate.setup();\n\n        for (InputChannel inputChannel : gate.inputChannels()) {\n            if (inputChannel instanceof RemoteInputChannel) {\n                assertThat(((RemoteInputChannel) inputChannel).getInitialCredit()).isEqualTo(0);\n            }\n        }\n\n        int targetTotalBuffersPerGate = 2 * partitionIds.length * subpartitionRandSize + 8;\n        int requiredFloatingBuffersPerGate;\n        int totalFloatingBuffersPerGate;\n        if (targetTotalBuffersPerGate >= expectMaxRequiredBuffersPerGate.get()) {\n            requiredFloatingBuffersPerGate = expectMaxRequiredBuffersPerGate.get();\n            totalFloatingBuffersPerGate = targetTotalBuffersPerGate;\n        } else {\n            requiredFloatingBuffersPerGate = 1;\n            totalFloatingBuffersPerGate = 8;\n        }\n        assertThat(gate.getBufferPool().getNumberOfRequiredMemorySegments())\n                .isEqualTo(requiredFloatingBuffersPerGate);\n        assertThat(gate.getBufferPool().getMaxNumberOfMemorySegments())\n                .isEqualTo(totalFloatingBuffersPerGate);\n    }",
          "conflictNames": [
              "isPipeline",
              "subpartitionRandSize",
              "partitionIds",
              "subpartitionIndexRange",
              "nettyShuffleEnvironmentBuilder",
              "expectMaxRequiredBuffersPerGate",
              "netEnv",
              "gate",
              "targetTotalBuffersPerGate",
              "requiredFloatingBuffersPerGate"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/012b8936e119d1bfadadee3182cf86d25c6dd019^1/flink-runtime/src/main/java/org/apache/flink/runtime/shuffle/NettyShuffleUtils.java",
      "locators": [
          {
              "line": 173,
              "column": 32
          },
          {
              "line": 191,
              "column": 51
          },
          {
              "line": 191,
              "column": 74
          }
      ],
      "old_name": "minAndMax",
      "new_name": "tuple",
      "ctx": {
          "symbolName": "minAndMax",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Pair<Integer, Integer>",
          "scopeHint": "in getNumBuffersToAnnounceForResultPartition(...)",
          "filePath": "NettyShuffleUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static int getNumBuffersToAnnounceForResultPartition(\n            ResultPartitionType type,\n            int configuredNetworkBuffersPerChannel,\n            int floatingBuffersPerGate,\n            int sortShuffleMinParallelism,\n            int sortShuffleMinBuffers,\n            int numSubpartitions) {\n\n        Pair<Integer, Integer> minAndMax =\n                getMinMaxNetworkBuffersPerResultPartition(\n                        configuredNetworkBuffersPerChannel,\n                        floatingBuffersPerGate,\n                        sortShuffleMinParallelism,\n                        sortShuffleMinBuffers,\n                        numSubpartitions,\n                        false,\n                        0,\n                        type);\n\n        // In order to avoid network buffer request timeout (see FLINK-12852), we announce\n        // network buffer requirement by below:\n        // 1. For canBePipelined shuffle, the floating buffers may not be returned in time due to\n        // back pressure so we need to include all the floating buffers in the announcement, i.e. we\n        // should take the max value;\n        // 2. For blocking shuffle, it is back pressure free and floating buffers can be recycled\n        // in time, so that the minimum required buffers would be enough.\n        int ret = type.canBePipelinedConsumed() ? minAndMax.getRight() : minAndMax.getLeft();\n\n        if (ret == Integer.MAX_VALUE) {\n            // Should never reach this branch. Result partition will allocate an unbounded\n            // buffer pool only when type is ResultPartitionType.PIPELINED. But fine-grained\n            // resource management is disabled in such case.\n            throw new IllegalArgumentException(\n                    \"Illegal to announce network memory requirement as Integer.MAX_VALUE, partition type: \"\n                            + type);\n        }\n        return ret;\n    }",
          "conflictNames": [
              "type",
              "configuredNetworkBuffersPerChannel",
              "floatingBuffersPerGate",
              "sortShuffleMinParallelism",
              "sortShuffleMinBuffers",
              "numSubpartitions",
              "ret"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/012b8936e119d1bfadadee3182cf86d25c6dd019^1/flink-runtime/src/main/java/org/apache/flink/runtime/shuffle/NettyShuffleUtils.java",
      "locators": [
          {
              "line": 52,
              "column": 60
          },
          {
              "line": 62,
              "column": 60
          },
          {
              "line": 76,
              "column": 13
          },
          {
              "line": 78,
              "column": 13
          },
          {
              "line": 80,
              "column": 13
          },
          {
              "line": 82,
              "column": 36
          },
          {
              "line": 90,
              "column": 44
          },
          {
              "line": 97,
              "column": 24
          },
          {
              "line": 97,
              "column": 38
          },
          {
              "line": 173,
              "column": 32
          },
          {
              "line": 190,
              "column": 33
          },
          {
              "line": 191,
              "column": 51
          },
          {
              "line": 191,
              "column": 74
          }
      ],
      "old_name": "min",
      "new_name": "expected",
      "ctx": {
          "symbolName": "min",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in getMinMaxNetworkBuffersPerResultPartition(...)",
          "filePath": "NettyShuffleUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Calculates and returns local network buffer pool size used by the result partition. The\n     * left/right value of the returned pair represent the min/max buffers require by the pool.\n     */\n    public static Pair<Integer, Integer> getMinMaxNetworkBuffersPerResultPartition(\n            final int configuredNetworkBuffersPerChannel,\n            final int numFloatingBuffersPerGate,\n            final int sortShuffleMinParallelism,\n            final int sortShuffleMinBuffers,\n            final int numSubpartitions,\n            final boolean enableTieredStorage,\n            final int tieredStoreExclusiveBuffers,\n            final ResultPartitionType type) {\n        boolean isSortShuffle =\n                type.isBlockingOrBlockingPersistentResultPartition()\n                        && numSubpartitions >= sortShuffleMinParallelism;\n        int min;\n        if (isSortShuffle) {\n            min = sortShuffleMinBuffers;\n        } else {\n            min =\n                    enableTieredStorage\n                            ? Math.min(tieredStoreExclusiveBuffers, numSubpartitions + 1)\n                            : (numSubpartitions + 1);\n        }\n        int max =\n                type.isBounded()\n                        ? numSubpartitions * configuredNetworkBuffersPerChannel\n                                + numFloatingBuffersPerGate\n                        : (isSortShuffle\n                                ? Math.max(min, 4 * numSubpartitions)\n                                : NetworkBufferPool.UNBOUNDED_POOL_SIZE);\n        // for each upstream hash-based blocking/pipelined subpartition, at least one buffer is\n        // needed even the configured network buffers per channel is 0 and this behavior is for\n        // performance. If it's not guaranteed that each subpartition can get at least one buffer,\n        // more partial buffers with little data will be outputted to network/disk and recycled to\n        // be used by other subpartitions which can not get a buffer for data caching.\n        return Pair.of(min, Math.max(min, max));\n    }",
          "conflictNames": [
              "configuredNetworkBuffersPerChannel",
              "numFloatingBuffersPerGate",
              "sortShuffleMinParallelism",
              "sortShuffleMinBuffers",
              "numSubpartitions",
              "enableTieredStorage",
              "tieredStoreExclusiveBuffers",
              "type",
              "isSortShuffle",
              "max"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/01743000c10720598dfb6f27d849da2283772e50^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/FlinkFilterCalcMergeRule.java",
      "locators": [
          {
              "line": 52,
              "column": 23
          },
          {
              "line": 61,
              "column": 49
          }
      ],
      "old_name": "projectExprs",
      "new_name": "expandProjects",
      "ctx": {
          "symbolName": "projectExprs",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<RexNode>",
          "scopeHint": "in onMatch(...)",
          "filePath": "FlinkFilterCalcMergeRule.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void onMatch(RelOptRuleCall call) {\n        LogicalFilter filter = call.rel(0);\n        LogicalCalc calc = call.rel(1);\n\n        List<RexNode> projectExprs = calc.getProgram().getExprList();\n        List<RexLocalRef> projects = calc.getProgram().getProjectList();\n        InputRefVisitor inputRefVisitor = new InputRefVisitor();\n        filter.getCondition().accept(inputRefVisitor);\n        boolean existNonDeterministicRef =\n                Arrays.stream(inputRefVisitor.getFields())\n                        .anyMatch(\n                                i ->\n                                        !RexUtil.isDeterministic(\n                                                projectExprs.get(projects.get(i).getIndex())));\n\n        if (!existNonDeterministicRef) {\n            super.onMatch(call);\n        }\n    }",
          "conflictNames": [
              "call",
              "filter",
              "calc",
              "projects",
              "inputRefVisitor",
              "existNonDeterministicRef"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0195f00e00f32346eea5f6aca6f4535edd73bf1f^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/functions/sql/ml/SqlMLPredictTableFunction.java",
      "locators": [
          {
              "line": 218,
              "column": 29
          },
          {
              "line": 219,
              "column": 25
          }
      ],
      "old_name": "castCall",
      "new_name": "call",
      "ctx": {
          "symbolName": "castCall",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SqlCall",
          "scopeHint": "in checkConfig(...)",
          "filePath": "SqlMLPredictTableFunction.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static Optional<RuntimeException> checkConfig(SqlCallBinding callBinding) {\n            if (callBinding.getOperandCount() < PARAM_NAMES.size()) {\n                return Optional.empty();\n            }\n\n            SqlNode configNode = callBinding.operand(3);\n            if (!configNode.getKind().equals(SqlKind.MAP_VALUE_CONSTRUCTOR)) {\n                return Optional.of(new ValidationException(\"Config param should be a MAP.\"));\n            }\n\n            // Map operands can only be SqlCharStringLiteral or cast of SqlCharStringLiteral\n            SqlCall mapCall = (SqlCall) configNode;\n            for (int i = 0; i < mapCall.operandCount(); i++) {\n                SqlNode operand = mapCall.operand(i);\n                if (operand instanceof SqlCharStringLiteral) {\n                    continue;\n                }\n                if (operand.getKind().equals(SqlKind.CAST)) {\n                    SqlCall castCall = (SqlCall) operand;\n                    if (castCall.operand(0) instanceof SqlCharStringLiteral) {\n                        continue;\n                    }\n                }\n                return Optional.of(\n                        new ValidationException(\n                                String.format(\n                                        \"ML_PREDICT config param can only be a MAP of string literals. The item at position %d is %s.\",\n                                        i, operand)));\n            }\n\n            return Optional.empty();\n        }",
          "conflictNames": [
              "callBinding",
              "configNode",
              "mapCall",
              "i",
              "operand"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/01c3fd67ac46898bd520477ae861cd29cceaa636^1/flink-connectors/flink-connector-hive/src/test/java/org/apache/flink/connectors/hive/HiveSourceTest.java",
      "locators": [
          {
              "line": 94,
              "column": 29
          },
          {
              "line": 106,
              "column": 20
          },
          {
              "line": 114,
              "column": 9
          },
          {
              "line": 137,
              "column": 20
          },
          {
              "line": 141,
              "column": 20
          },
          {
              "line": 151,
              "column": 29
          },
          {
              "line": 176,
              "column": 20
          },
          {
              "line": 186,
              "column": 29
          },
          {
              "line": 211,
              "column": 20
          }
      ],
      "old_name": "hiveSource",
      "new_name": "hiveSourceBuilder",
      "ctx": {
          "symbolName": "hiveSource",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "HiveSource<RowData>",
          "scopeHint": "in testDynamicParallelismInference(...)",
          "filePath": "HiveSourceTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testDynamicParallelismInference() throws Exception {\n        // test non-partitioned table\n        ObjectPath tablePath1 = new ObjectPath(\"default\", \"hiveNonPartTbl\");\n        createTable(tablePath1, hiveCatalog, false);\n\n        HiveSource<RowData> hiveSource =\n                new HiveSourceBuilder(\n                                new JobConf(hiveCatalog.getHiveConf()),\n                                new Configuration(),\n                                HiveShimLoader.getHiveVersion(),\n                                tablePath1.getDatabaseName(),\n                                tablePath1.getObjectName(),\n                                Collections.emptyMap())\n                        .buildWithDefaultBulkFormat();\n\n        DynamicParallelismInference.Context context =\n                genDynamicParallelismContext(10, Collections.emptyList());\n        assertThat(hiveSource.inferParallelism(context)).isEqualTo(1);\n\n        hiveCatalog.dropTable(tablePath1, false);\n\n        // test partitioned table\n        ObjectPath tablePath2 = new ObjectPath(\"default\", \"hiveTbl1\");\n        createTable(tablePath2, hiveCatalog, true);\n\n        hiveSource =\n                new HiveSourceBuilder(\n                                new JobConf(hiveCatalog.getHiveConf()),\n                                new Configuration(),\n                                HiveShimLoader.getHiveVersion(),\n                                tablePath2.getDatabaseName(),\n                                tablePath2.getObjectName(),\n                                Collections.emptyMap())\n                        .setPartitions(\n                                partitionSpecs.stream()\n                                        .map(\n                                                spec ->\n                                                        HiveTablePartition.ofPartition(\n                                                                hiveCatalog.getHiveConf(),\n                                                                hiveCatalog.getHiveVersion(),\n                                                                tablePath2.getDatabaseName(),\n                                                                tablePath2.getObjectName(),\n                                                                new LinkedHashMap<>(spec)))\n                                        .collect(Collectors.toList()))\n                        .buildWithDefaultBulkFormat();\n\n        // test inferred parallelism less than maxParallelism\n        context = genDynamicParallelismContext(10, Collections.emptyList());\n        assertThat(hiveSource.inferParallelism(context)).isEqualTo(3);\n\n        // test inferred parallelism larger than maxParallelism\n        context = genDynamicParallelismContext(2, Collections.emptyList());\n        assertThat(hiveSource.inferParallelism(context)).isEqualTo(2);\n\n        hiveCatalog.dropTable(tablePath2, false);\n    }",
          "conflictNames": [
              "tablePath1",
              "context",
              "tablePath2"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/02110ceb58dc6838ac965477d174c6760eff53f2^1/flink-libraries/flink-state-processing-api/src/test/java/org/apache/flink/state/api/SavepointWriterUidModificationITCase.java",
      "locators": [
          {
              "line": 189,
              "column": 74
          },
          {
              "line": 195,
              "column": 50
          },
          {
              "line": 195,
              "column": 62
          },
          {
              "line": 197,
              "column": 34
          },
          {
              "line": 200,
              "column": 34
          },
          {
              "line": 211,
              "column": 29
          },
          {
              "line": 214,
              "column": 58
          }
      ],
      "old_name": "assertion",
      "new_name": "validationParameter",
      "ctx": {
          "symbolName": "assertion",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Tuple2<Collection<Integer>, String>",
          "scopeHint": "in runAndValidate(...)",
          "filePath": "SavepointWriterUidModificationITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "ption {\n        final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n        // prepare collection of state\n        final List<CloseableIterator<Integer>> iterators = new ArrayList<>();\n        for (Tuple2<Collection<Integer>, String> assertion : assertions) {\n            iterators.add(\n                    env.fromData(assertion.f0)\n                            .keyBy(v -> v)\n                            .map(new StateReader())\n                            .uid(assertion.f1)\n       ",
          "conflictNames": [
              "savepointPath",
              "assertions",
              "env",
              "iterators",
              "streamGraph",
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/02110ceb58dc6838ac965477d174c6760eff53f2^1/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/DefaultCheckpointPlan.java",
      "locators": [
          {
              "line": 196,
              "column": 29
          },
          {
              "line": 198,
              "column": 40
          },
          {
              "line": 231,
              "column": 33
          },
          {
              "line": 233,
              "column": 44
          },
          {
              "line": 240,
              "column": 33
          },
          {
              "line": 243,
              "column": 36
          },
          {
              "line": 252,
              "column": 33
          },
          {
              "line": 254,
              "column": 44
          },
          {
              "line": 263,
              "column": 37
          },
          {
              "line": 266,
              "column": 40
          }
      ],
      "old_name": "operatorID",
      "new_name": "operatorIDPair",
      "ctx": {
          "symbolName": "operatorID",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "OperatorIDPair",
          "scopeHint": "in fulfillFullyFinishedOrFinishedOnRestoreOperatorStates(...)",
          "filePath": "DefaultCheckpointPlan.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "    Map<OperatorID, OperatorState> operatorStates) {\n        // Completes the operator state for the fully finished operators\n        for (ExecutionJobVertex jobVertex : fullyFinishedOrFinishedOnRestoreVertices.values()) {\n            for (OperatorIDPair operatorID : jobVertex.getOperatorIDs()) {\n                OperatorState operatorState =\n                        operatorStates.get(operatorID.getGeneratedOperatorID());\n                checkState(\n                        operatorState == null || !op",
          "conflictNames": [
              "operatorStates",
              "operatorState"
          ]
      },
      "suggestions": [
          {
              "name": "operatorIDPair",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/02110ceb58dc6838ac965477d174c6760eff53f2^1/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java",
      "locators": [
          {
              "line": 410,
              "column": 38
          },
          {
              "line": 411,
              "column": 37
          },
          {
              "line": 411,
              "column": 50
          },
          {
              "line": 412,
              "column": 72
          },
          {
              "line": 467,
              "column": 28
          },
          {
              "line": 468,
              "column": 58
          },
          {
              "line": 473,
              "column": 29
          },
          {
              "line": 476,
              "column": 32
          },
          {
              "line": 482,
              "column": 33
          }
      ],
      "old_name": "operatorID",
      "new_name": "operatorIDPair",
      "ctx": {
          "symbolName": "operatorID",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "OperatorIDPair",
          "scopeHint": "in acknowledgeTask(...)",
          "filePath": "PendingCheckpoint.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "skStates.isTaskDeployedAsFinished()) {\n                checkpointPlan.reportTaskFinishedOnRestore(vertex);\n            } else {\n                List<OperatorIDPair> operatorIDs = vertex.getJobVertex().getOperatorIDs();\n                for (OperatorIDPair operatorID : operatorIDs) {\n                    updateOperatorState(vertex, operatorSubtaskStates, operatorID);\n                }\n\n                if (operatorSubtaskStates != null && operatorSubtaskStates.isTaskFinished()) {\n                    chec",
          "conflictNames": [
              "executionAttemptId",
              "operatorSubtaskStates",
              "metrics",
              "vertex",
              "ackTimestamp",
              "operatorIDs",
              "alignmentDurationMillis",
              "checkpointStartDelayMillis",
              "subtaskStateStats"
          ]
      },
      "suggestions": [
          {
              "name": "operatorIDPair",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/026d7ccfe1d6f4cfa26c9038dd05403c889d2e0d^1/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesLeaderElectionAndRetrievalITCase.java",
      "locators": [
          {
              "line": 90,
              "column": 54
          },
          {
              "line": 97,
              "column": 29
          },
          {
              "line": 99,
              "column": 29
          },
          {
              "line": 108,
              "column": 13
          },
          {
              "line": 109,
              "column": 24
          },
          {
              "line": 111,
              "column": 24
          }
      ],
      "old_name": "retrievalEventHandler",
      "new_name": "secondRetrievalEventHandler",
      "ctx": {
          "symbolName": "retrievalEventHandler",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestingLeaderRetrievalEventHandler",
          "scopeHint": "in testLeaderElectionAndRetrieval(...)",
          "filePath": "KubernetesLeaderElectionAndRetrievalITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testLeaderElectionAndRetrieval() throws Exception {\n        final String configMapName = LEADER_CONFIGMAP_NAME + System.currentTimeMillis();\n        KubernetesLeaderElectionDriver leaderElectionDriver = null;\n        KubernetesLeaderRetrievalDriver leaderRetrievalDriver = null;\n\n        final FlinkKubeClient flinkKubeClient = kubernetesExtension.getFlinkKubeClient();\n        final Configuration configuration = kubernetesExtension.getConfiguration();\n\n        final String clusterId = configuration.getString(KubernetesConfigOptions.CLUSTER_ID);\n        final KubernetesConfigMapSharedWatcher configMapSharedWatcher =\n                flinkKubeClient.createConfigMapSharedWatcher(\n                        KubernetesUtils.getConfigMapLabels(\n                                clusterId, LABEL_CONFIGMAP_TYPE_HIGH_AVAILABILITY));\n        final ExecutorService watchExecutorService = Executors.newCachedThreadPool();\n\n        final TestingLeaderElectionEventHandler electionEventHandler =\n                new TestingLeaderElectionEventHandler(LEADER_ADDRESS);\n\n        try {\n            leaderElectionDriver =\n                    new KubernetesLeaderElectionDriver(\n                            flinkKubeClient,\n                            configMapSharedWatcher,\n                            watchExecutorService,\n                            new KubernetesLeaderElectionConfiguration(\n                                    configMapName, UUID.randomUUID().toString(), configuration),\n                            electionEventHandler,\n                            electionEventHandler::handleError);\n            electionEventHandler.init(leaderElectionDriver);\n\n            final TestingLeaderRetrievalEventHandler retrievalEventHandler =\n                    new TestingLeaderRetrievalEventHandler();\n            leaderRetrievalDriver =\n                    new KubernetesLeaderRetrievalDriver(\n                            configMapSharedWatcher,\n                            watchExecutorService,\n                            configMapName,\n                            retrievalEventHandler,\n                            KubernetesUtils::getLeaderInformationFromConfigMap,\n                            retrievalEventHandler::handleError);\n\n            electionEventHandler.waitForLeader();\n            // Check the new leader is confirmed\n            final LeaderInformation confirmedLeaderInformation =\n                    electionEventHandler.getConfirmedLeaderInformation();\n            assertThat(confirmedLeaderInformation.getLeaderAddress()).isEqualTo(LEADER_ADDRESS);\n\n            // Check the leader retrieval driver should be notified the leader address\n            retrievalEventHandler.waitForNewLeader();\n            assertThat(retrievalEventHandler.getLeaderSessionID())\n                    .isEqualByComparingTo(confirmedLeaderInformation.getLeaderSessionID());\n            assertThat(retrievalEventHandler.getAddress())\n                    .isEqualTo(confirmedLeaderInformation.getLeaderAddress());\n        } finally {\n            electionEventHandler.close();\n            if (leaderElectionDriver != null) {\n                leaderElectionDriver.close();\n            }\n            if (leaderRetrievalDriver != null) {\n                leaderRetrievalDriver.close();\n            }\n            flinkKubeClient.deleteConfigMap(configMapName).get();\n            configMapSharedWatcher.close();\n            ExecutorUtils.gracefulShutdown(5, TimeUnit.SECONDS, watchExecutorService);\n        }\n    }",
          "conflictNames": [
              "configMapName",
              "leaderElectionDriver",
              "leaderRetrievalDriver",
              "flinkKubeClient",
              "configuration",
              "clusterId",
              "configMapSharedWatcher",
              "watchExecutorService",
              "electionEventHandler",
              "confirmedLeaderInformation"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/029860f26ce8455cdd2bd1244785f42fee0440ca^1/flink-table/flink-sql-gateway/src/test/java/org/apache/flink/table/gateway/rest/serde/ResultInfoJsonSerDeTest.java",
      "locators": [
          {
              "line": 129,
              "column": 23
          },
          {
              "line": 137,
              "column": 25
          }
      ],
      "old_name": "rowDataList",
      "new_name": "rowDatas",
      "ctx": {
          "symbolName": "rowDataList",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<RowData>",
          "scopeHint": "in serDeTest(...)",
          "filePath": "ResultInfoJsonSerDeTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void serDeTest(List<Row> rows) throws IOException {\n        List<RowData> rowDataList =\n                rows.stream().map(this::convertToInternal).collect(Collectors.toList());\n        ResolvedSchema testResolvedSchema = getTestResolvedSchema(getFields());\n        ResultInfo testResultInfo =\n                new ResultInfo(\n                        testResolvedSchema.getColumns().stream()\n                                .map(ColumnInfo::toColumnInfo)\n                                .collect(Collectors.toList()),\n                        rowDataList);\n\n        // test serialization & deserialization\n        String result = OBJECT_MAPPER.writeValueAsString(testResultInfo);\n        ResultInfo resultInfo = OBJECT_MAPPER.readValue(result, ResultInfo.class);\n\n        assertThat(resultInfo.getResultSchema().toString())\n                .isEqualTo(testResultInfo.getResultSchema().toString());\n\n        List<RowData> data = resultInfo.getData();\n        for (int i = 0; i < data.size(); i++) {\n            assertThat(convertToExternal(data.get(i), ROW(getFields()))).isEqualTo(rows.get(i));\n        }\n    }",
          "conflictNames": [
              "rows",
              "testResolvedSchema",
              "testResultInfo",
              "result",
              "resultInfo",
              "data",
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/029860f26ce8455cdd2bd1244785f42fee0440ca^1/flink-table/flink-sql-gateway/src/test/java/org/apache/flink/table/gateway/rest/SqlGatewayRestEndpointStatementITCase.java",
      "locators": [
          {
              "line": 179,
              "column": 37
          },
          {
              "line": 186,
              "column": 25
          }
      ],
      "old_name": "fetchResultsTokenParameters",
      "new_name": "fetchResultsMessageParameters",
      "ctx": {
          "symbolName": "fetchResultsTokenParameters",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "FetchResultsTokenParameters",
          "scopeHint": "in fetchResults(...)",
          "filePath": "SqlGatewayRestEndpointStatementITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "FetchResultsResponseBody fetchResults(\n            SessionHandle sessionHandle, OperationHandle operationHandle, Long token)\n            throws Exception {\n        FetchResultsTokenParameters fetchResultsTokenParameters =\n                new FetchResultsTokenParameters(sessionHandle, operationHandle, token);\n        CompletableFuture<FetchResultsResponseBody> response =\n                restClient.sendRequest(\n                        SQL_GATEWAY_REST_ENDPOINT_EXTENSION.getTargetAddress(),\n                        SQL_GATEWAY_REST_ENDPOINT_EXTENSION.getTargetPort(),\n                        fetchResultsHeaders,\n                        fetchResultsTokenParameters,\n                        EmptyRequestBody.getInstance());\n        return response.get();\n    }",
          "conflictNames": [
              "sessionHandle",
              "operationHandle",
              "token",
              "response"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/02b09eac6238fe059b6cb0ddbe791b761962dd14^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/slowtaskdetector/ExecutionTimeBasedSlowTaskDetector.java",
      "locators": [
          {
              "line": 173,
              "column": 20
          },
          {
              "line": 175,
              "column": 58
          }
      ],
      "old_name": "executionTimeMedian",
      "new_name": "weightedExecutionTimeMedian",
      "ctx": {
          "symbolName": "executionTimeMedian",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "long",
          "scopeHint": "in getBaseline(...)",
          "filePath": "ExecutionTimeBasedSlowTaskDetector.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private long getBaseline(\n            final ExecutionJobVertex executionJobVertex, final long currentTimeMillis) {\n        final long executionTimeMedian =\n                calculateFinishedTaskExecutionTimeMedian(executionJobVertex, currentTimeMillis);\n        return (long) Math.max(baselineLowerBoundMillis, executionTimeMedian * baselineMultiplier);\n    }",
          "conflictNames": [
              "executionJobVertex",
              "currentTimeMillis"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/02d89caede088d334daf13fb26103aaec6d3ac19^1/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/source/TimestampsAndWatermarks.java",
      "locators": [
          {
              "line": 96,
              "column": 46
          },
          {
              "line": 98,
              "column": 59
          },
          {
              "line": 103,
              "column": 17
          },
          {
              "line": 111,
              "column": 46
          },
          {
              "line": 113,
              "column": 59
          }
      ],
      "old_name": "context",
      "new_name": "contextProvider",
      "ctx": {
          "symbolName": "context",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TimestampsAndWatermarksContext",
          "scopeHint": "in createProgressiveEventTimeLogic(...)",
          "filePath": "TimestampsAndWatermarks.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "static <E> TimestampsAndWatermarks<E> createProgressiveEventTimeLogic(\n            WatermarkStrategy<E> watermarkStrategy,\n            MetricGroup metrics,\n            ProcessingTimeService timeService,\n            long periodicWatermarkIntervalMillis) {\n\n        final TimestampsAndWatermarksContext context = new TimestampsAndWatermarksContext(metrics);\n        final TimestampAssigner<E> timestampAssigner =\n                watermarkStrategy.createTimestampAssigner(context);\n\n        return new ProgressiveTimestampsAndWatermarks<>(\n                timestampAssigner,\n                watermarkStrategy,\n                context,\n                timeService,\n                Duration.ofMillis(periodicWatermarkIntervalMillis));\n    }",
          "conflictNames": [
              "watermarkStrategy",
              "metrics",
              "timeService",
              "periodicWatermarkIntervalMillis",
              "timestampAssigner"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/034d19c63857c34406e0753a1ce522f0f5cab0bb^1/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DefaultResourceAllocationStrategy.java",
      "locators": [
          {
              "line": 542,
              "column": 41
          },
          {
              "line": 546,
              "column": 13
          },
          {
              "line": 548,
              "column": 43
          },
          {
              "line": 550,
              "column": 25
          },
          {
              "line": 557,
              "column": 25
          }
      ],
      "old_name": "resourceInfoInUtilizationOrder",
      "new_name": "prioritizedResources",
      "ctx": {
          "symbolName": "resourceInfoInUtilizationOrder",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Queue<InternalResourceInfo>",
          "scopeHint": "in tryFulfilledRequirementWithResource(...)",
          "filePath": "DefaultResourceAllocationStrategy.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public int tryFulfilledRequirementWithResource(\n                List<InternalResourceInfo> internalResources,\n                int numUnfulfilled,\n                ResourceProfile requiredResource,\n                JobID jobId) {\n            if (internalResources.isEmpty()) {\n                return numUnfulfilled;\n            }\n\n            Queue<InternalResourceInfo> resourceInfoInUtilizationOrder =\n                    new PriorityQueue<>(\n                            internalResources.size(),\n                            Comparator.comparingDouble(i -> i.utilization));\n            resourceInfoInUtilizationOrder.addAll(internalResources);\n\n            while (numUnfulfilled > 0 && !resourceInfoInUtilizationOrder.isEmpty()) {\n                final InternalResourceInfo currentTaskManager =\n                        resourceInfoInUtilizationOrder.poll();\n\n                if (currentTaskManager.tryAllocateSlotForJob(jobId, requiredResource)) {\n                    numUnfulfilled--;\n\n                    // ignore non resource task managers to reduce the overhead of insert.\n                    if (!currentTaskManager.availableProfile.equals(ResourceProfile.ZERO)) {\n                        resourceInfoInUtilizationOrder.add(currentTaskManager);\n                    }\n                }\n            }\n            return numUnfulfilled;\n        }",
          "conflictNames": [
              "internalResources",
              "numUnfulfilled",
              "requiredResource",
              "jobId",
              "currentTaskManager"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0388b760fc66975c70f797ad07f2e073738a7171^1/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OperatorChain.java",
      "locators": [
          {
              "line": 644,
              "column": 16
          },
          {
              "line": 652,
              "column": 62
          }
      ],
      "old_name": "streamOperatorFactoryClassName",
      "new_name": "streamOperatorFactoryClass",
      "ctx": {
          "symbolName": "streamOperatorFactoryClassName",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in getOperatorRecordsOutCounter(...)",
          "filePath": "OperatorChain.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Get the numRecordsOut counter for the operator represented by the given config. And re-use\n     * the operator-level counter for the task-level numRecordsOut counter if this operator is at\n     * the end of the operator chain.\n     *\n     * <p>Return null if we should not use the numRecordsOut counter to track the records emitted by\n     * this operator.\n     */\n    @Nullable\n    private Counter getOperatorRecordsOutCounter(\n            StreamTask<?, ?> containingTask, StreamConfig operatorConfig) {\n        String streamOperatorFactoryClassName = operatorConfig.getStreamOperatorFactoryClassName();\n        // Do not use the numRecordsOut counter on output if this operator is SinkWriterOperator.\n        //\n        // Metric \"numRecordsOut\" is defined as the total number of records written to the\n        // external system in FLIP-33, but this metric is occupied in AbstractStreamOperator as the\n        // number of records sent to downstream operators, which is number of Committable batches\n        // sent to SinkCommitter. So we skip registering this metric on output and leave this metric\n        // to sink writer implementations to report.\n        if (SinkWriterOperatorFactory.class.getName().equals(streamOperatorFactoryClassName)) {\n            return null;\n        }\n\n        InternalOperatorMetricGroup operatorMetricGroup =\n                containingTask\n                        .getEnvironment()\n                        .getMetricGroup()\n                        .getOrAddOperator(\n                                operatorConfig.getOperatorID(), operatorConfig.getOperatorName());\n\n        return operatorMetricGroup.getIOMetricGroup().getNumRecordsOutCounter();\n    }",
          "conflictNames": [
              "containingTask",
              "operatorConfig",
              "operatorMetricGroup"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/04e6437dd4d06b59b3f87651e2043559f3df827e^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/operators/join/stream/keyselector/AttributeBasedJoinKeyExtractor.java",
      "locators": [
          {
              "line": 93,
              "column": 29
          },
          {
              "line": 94,
              "column": 13
          },
          {
              "line": 94,
              "column": 40
          },
          {
              "line": 98,
              "column": 42
          },
          {
              "line": 122,
              "column": 29
          },
          {
              "line": 123,
              "column": 13
          },
          {
              "line": 127,
              "column": 42
          },
          {
              "line": 132,
              "column": 29
          },
          {
              "line": 133,
              "column": 13
          },
          {
              "line": 136,
              "column": 16
          },
          {
              "line": 256,
              "column": 59
          },
          {
              "line": 257,
              "column": 58
          },
          {
              "line": 260,
              "column": 29
          },
          {
              "line": 261,
              "column": 36
          },
          {
              "line": 282,
              "column": 65
          },
          {
              "line": 284,
              "column": 56
          },
          {
              "line": 285,
              "column": 46
          },
          {
              "line": 287,
              "column": 29
          },
          {
              "line": 288,
              "column": 36
          }
      ],
      "old_name": "keyFieldIndices",
      "new_name": "keyExtractors",
      "ctx": {
          "symbolName": "keyFieldIndices",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<Integer>",
          "scopeHint": "in getJoinKey(...)",
          "filePath": "AttributeBasedJoinKeyExtractor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public RowData getJoinKey(RowData row, int inputId) {\n        if (inputId == 0) {\n            return null;\n        }\n\n        final List<ConditionAttributeRef> attributeMapping = joinAttributeMap.get(inputId);\n        if (attributeMapping == null || attributeMapping.isEmpty()) {\n            return null;\n        }\n\n        final List<Integer> keyFieldIndices = inputKeyFieldIndices.get(inputId);\n        if (keyFieldIndices == null || keyFieldIndices.isEmpty()) {\n            return null;\n        }\n\n        return buildKeyRow(row, inputId, keyFieldIndices);\n    }",
          "conflictNames": [
              "row",
              "inputId",
              "attributeMapping"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/04e6437dd4d06b59b3f87651e2043559f3df827e^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/operators/join/stream/keyselector/AttributeBasedJoinKeyExtractor.java",
      "locators": [
          {
              "line": 314,
              "column": 41
          },
          {
              "line": 322,
              "column": 32
          },
          {
              "line": 323,
              "column": 31
          },
          {
              "line": 325,
              "column": 38
          },
          {
              "line": 344,
              "column": 45
          },
          {
              "line": 348,
              "column": 13
          },
          {
              "line": 354,
              "column": 45
          },
          {
              "line": 358,
              "column": 25
          },
          {
              "line": 367,
              "column": 45
          },
          {
              "line": 370,
              "column": 50
          },
          {
              "line": 489,
              "column": 45
          },
          {
              "line": 490,
              "column": 14
          },
          {
              "line": 491,
              "column": 13
          },
          {
              "line": 491,
              "column": 47
          },
          {
              "line": 491,
              "column": 55
          },
          {
              "line": 493,
              "column": 16
          },
          {
              "line": 497,
              "column": 45
          },
          {
              "line": 501,
              "column": 47
          },
          {
              "line": 502,
              "column": 47
          },
          {
              "line": 506,
              "column": 17
          },
          {
              "line": 508,
              "column": 17
          },
          {
              "line": 510,
              "column": 17
          }
      ],
      "old_name": "parent",
      "new_name": "attributeToRoot",
      "ctx": {
          "symbolName": "parent",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Map<AttributeRef, AttributeRef>",
          "scopeHint": "in initializeCommonJoinKeyStructures(...)",
          "filePath": "AttributeBasedJoinKeyExtractor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void initializeCommonJoinKeyStructures() {\n        this.commonJoinKeyType = null;\n\n        if (this.inputTypes != null) {\n            for (int i = 0; i < this.inputTypes.size(); i++) {\n                this.commonJoinKeyExtractors.put(i, Collections.emptyList());\n            }\n        }\n\n        assert inputTypes != null;\n        if (inputTypes.isEmpty() || joinAttributeMap.isEmpty()) {\n            return;\n        }\n\n        Map<AttributeRef, AttributeRef> parent = new HashMap<>();\n        Map<AttributeRef, Integer> rank = new HashMap<>();\n        Set<AttributeRef> allAttrRefs = collectAllAttributeRefs();\n\n        if (allAttrRefs.isEmpty()) {\n            return;\n        }\n\n        initializeDisjointSets(parent, rank, allAttrRefs);\n        processJoinConditions(parent, rank);\n        Map<AttributeRef, Set<AttributeRef>> equivalenceSets =\n                buildEquivalenceSets(parent, allAttrRefs);\n        List<Set<AttributeRef>> commonConceptualAttributeSets =\n                findCommonConceptualAttributeSets(equivalenceSets);\n\n        processCommonAttributes(commonConceptualAttributeSets);\n    }",
          "conflictNames": [
              "i",
              "rank",
              "allAttrRefs",
              "equivalenceSets",
              "commonConceptualAttributeSets"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/04e6437dd4d06b59b3f87651e2043559f3df827e^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/operators/join/stream/keyselector/AttributeBasedJoinKeyExtractor.java",
      "locators": [
          {
              "line": 315,
              "column": 36
          },
          {
              "line": 322,
              "column": 40
          },
          {
              "line": 323,
              "column": 39
          },
          {
              "line": 345,
              "column": 40
          },
          {
              "line": 349,
              "column": 13
          },
          {
              "line": 354,
              "column": 80
          },
          {
              "line": 359,
              "column": 25
          },
          {
              "line": 498,
              "column": 40
          },
          {
              "line": 505,
              "column": 17
          },
          {
              "line": 505,
              "column": 35
          },
          {
              "line": 507,
              "column": 24
          },
          {
              "line": 507,
              "column": 42
          },
          {
              "line": 511,
              "column": 17
          },
          {
              "line": 511,
              "column": 33
          }
      ],
      "old_name": "rank",
      "new_name": "rootRank",
      "ctx": {
          "symbolName": "rank",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Map<AttributeRef, Integer>",
          "scopeHint": "in initializeCommonJoinKeyStructures(...)",
          "filePath": "AttributeBasedJoinKeyExtractor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void initializeCommonJoinKeyStructures() {\n        this.commonJoinKeyType = null;\n\n        if (this.inputTypes != null) {\n            for (int i = 0; i < this.inputTypes.size(); i++) {\n                this.commonJoinKeyExtractors.put(i, Collections.emptyList());\n            }\n        }\n\n        assert inputTypes != null;\n        if (inputTypes.isEmpty() || joinAttributeMap.isEmpty()) {\n            return;\n        }\n\n        Map<AttributeRef, AttributeRef> parent = new HashMap<>();\n        Map<AttributeRef, Integer> rank = new HashMap<>();\n        Set<AttributeRef> allAttrRefs = collectAllAttributeRefs();\n\n        if (allAttrRefs.isEmpty()) {\n            return;\n        }\n\n        initializeDisjointSets(parent, rank, allAttrRefs);\n        processJoinConditions(parent, rank);\n        Map<AttributeRef, Set<AttributeRef>> equivalenceSets =\n                buildEquivalenceSets(parent, allAttrRefs);\n        List<Set<AttributeRef>> commonConceptualAttributeSets =\n                findCommonConceptualAttributeSets(equivalenceSets);\n\n        processCommonAttributes(commonConceptualAttributeSets);\n    }",
          "conflictNames": [
              "i",
              "parent",
              "allAttrRefs",
              "equivalenceSets",
              "commonConceptualAttributeSets"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/04e6437dd4d06b59b3f87651e2043559f3df827e^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/operators/join/stream/keyselector/AttributeBasedJoinKeyExtractor.java",
      "locators": [
          {
              "line": 274,
              "column": 24
          },
          {
              "line": 277,
              "column": 13
          },
          {
              "line": 279,
              "column": 16
          }
      ],
      "old_name": "commonJoinKeyRow",
      "new_name": "keyRow",
      "ctx": {
          "symbolName": "commonJoinKeyRow",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "GenericRowData",
          "scopeHint": "in buildCommonJoinKey(...)",
          "filePath": "AttributeBasedJoinKeyExtractor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private RowData buildCommonJoinKey(RowData row, List<KeyExtractor> extractors) {\n        GenericRowData commonJoinKeyRow = new GenericRowData(extractors.size());\n\n        for (int i = 0; i < extractors.size(); i++) {\n            commonJoinKeyRow.setField(i, extractors.get(i).getRightSideKey(row));\n        }\n        return commonJoinKeyRow;\n    }",
          "conflictNames": [
              "row",
              "extractors",
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/05191071638236a617d769259090a0e9b41d6318^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/WrapJsonAggFunctionArgumentsRule.java",
      "locators": [
          {
              "line": 94,
              "column": 29
          },
          {
              "line": 95,
              "column": 32
          },
          {
              "line": 101,
              "column": 51
          },
          {
              "line": 102,
              "column": 26
          }
      ],
      "old_name": "newAggregate",
      "new_name": "wrappedAggregate",
      "ctx": {
          "symbolName": "newAggregate",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "LogicalAggregate",
          "scopeHint": "in onMatch(...)",
          "filePath": "WrapJsonAggFunctionArgumentsRule.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void onMatch(RelOptRuleCall call) {\n        final LogicalAggregate aggregate = call.rel(0);\n        final AggregateCall aggCall = aggregate.getAggCallList().get(0);\n\n        final RelNode aggInput = aggregate.getInput();\n        final RelBuilder relBuilder = call.builder().push(aggInput);\n\n        final List<Integer> affectedArgs = getAffectedArgs(aggCall);\n        addProjections(aggregate.getCluster(), relBuilder, affectedArgs);\n\n        final TargetMapping argsMapping =\n                getAggArgsMapping(aggInput.getRowType().getFieldCount(), affectedArgs);\n\n        final AggregateCall newAggregateCall = aggCall.transform(argsMapping);\n        final LogicalAggregate newAggregate =\n                aggregate.copy(\n                        aggregate.getTraitSet(),\n                        relBuilder.build(),\n                        aggregate.getGroupSet(),\n                        aggregate.getGroupSets(),\n                        Collections.singletonList(newAggregateCall));\n        call.transformTo(newAggregate.withHints(Collections.singletonList(MARKER_HINT)));\n    }",
          "conflictNames": [
              "call",
              "aggregate",
              "aggCall",
              "aggInput",
              "relBuilder",
              "affectedArgs",
              "argsMapping",
              "newAggregateCall"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/05191071638236a617d769259090a0e9b41d6318^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/WrapJsonAggFunctionArgumentsRule.java",
      "locators": [
          {
              "line": 149,
              "column": 19
          },
          {
              "line": 152,
              "column": 56
          },
          {
              "line": 152,
              "column": 66
          }
      ],
      "old_name": "newCount",
      "new_name": "newInputCount",
      "ctx": {
          "symbolName": "newCount",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in getAggArgsMapping(...)",
          "filePath": "WrapJsonAggFunctionArgumentsRule.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Returns a {@link TargetMapping} that defines how the arguments of the aggregation must be\n     * mapped such that the wrapped arguments are used instead.\n     */\n    private TargetMapping getAggArgsMapping(int inputCount, List<Integer> affectedArgs) {\n        final int newCount = inputCount + affectedArgs.size();\n\n        final TargetMapping argsMapping =\n                Mappings.create(MappingType.BIJECTION, newCount, newCount);\n        for (int i = 0; i < affectedArgs.size(); i++) {\n            argsMapping.set(affectedArgs.get(i), inputCount + i);\n        }\n\n        return argsMapping;\n    }",
          "conflictNames": [
              "inputCount",
              "affectedArgs",
              "argsMapping",
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0580924bf06ea93889c26cff26fcea8ddd941003^1/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/extraction/BaseMappingExtractor.java",
      "locators": [
          {
              "line": 407,
              "column": 28
          },
          {
              "line": 408,
              "column": 29
          },
          {
              "line": 413,
              "column": 13
          },
          {
              "line": 414,
              "column": 79
          },
          {
              "line": 464,
              "column": 22
          },
          {
              "line": 464,
              "column": 38
          },
          {
              "line": 464,
              "column": 62
          }
      ],
      "old_name": "argumentHint",
      "new_name": "h",
      "ctx": {
          "symbolName": "argumentHint",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ArgumentHint",
          "scopeHint": "in tryExtractInputGroupArgument(...)",
          "filePath": "BaseMappingExtractor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "static Optional<FunctionArgumentTemplate> tryExtractInputGroupArgument(\n            Method method, int paramPos) {\n        final Parameter parameter = method.getParameters()[paramPos];\n        final DataTypeHint hint = parameter.getAnnotation(DataTypeHint.class);\n        final ArgumentHint argumentHint = parameter.getAnnotation(ArgumentHint.class);\n        if (hint != null && argumentHint != null) {\n            throw extractionError(\n                    \"Argument and dataType hints cannot be declared in the same parameter at position %d.\",\n                    paramPos);\n        }\n        if (argumentHint != null) {\n            final DataTypeTemplate template = DataTypeTemplate.fromAnnotation(argumentHint, null);\n            if (template.inputGroup != null) {\n                return Optional.of(FunctionArgumentTemplate.of(template.inputGroup));\n            }\n        } else if (hint != null) {\n            final DataTypeTemplate template = DataTypeTemplate.fromAnnotation(hint, null);\n            if (template.inputGroup != null) {\n                return Optional.of(FunctionArgumentTemplate.of(template.inputGroup));\n            }\n        }\n        return Optional.empty();\n    }",
          "conflictNames": [
              "method",
              "paramPos",
              "parameter",
              "hint",
              "template"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/05cdb299e26db931a328bdc4e536dfb7effdb905^1/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/restore/RocksDBIncrementalRestoreOperation.java",
      "locators": [
          {
              "line": 226,
              "column": 39
          },
          {
              "line": 229,
              "column": 75
          },
          {
              "line": 230,
              "column": 46
          },
          {
              "line": 232,
              "column": 32
          },
          {
              "line": 281,
              "column": 49
          },
          {
              "line": 285,
              "column": 21
          },
          {
              "line": 325,
              "column": 37
          },
          {
              "line": 329,
              "column": 66
          },
          {
              "line": 348,
              "column": 38
          },
          {
              "line": 351,
              "column": 21
          },
          {
              "line": 354,
              "column": 70
          },
          {
              "line": 402,
              "column": 25
          },
          {
              "line": 404,
              "column": 36
          },
          {
              "line": 474,
              "column": 37
          },
          {
              "line": 477,
              "column": 30
          },
          {
              "line": 490,
              "column": 25
          }
      ],
      "old_name": "downloadRequest",
      "new_name": "stateHandle",
      "ctx": {
          "symbolName": "downloadRequest",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "StateHandleDownloadSpec",
          "scopeHint": "in restoreBaseDBFromRemoteState(...)",
          "filePath": "RocksDBIncrementalRestoreOperation.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void restoreBaseDBFromRemoteState(IncrementalRemoteKeyedStateHandle stateHandle)\n            throws Exception {\n        // used as restore source for IncrementalRemoteKeyedStateHandle\n        final Path tmpRestoreInstancePath =\n                instanceBasePath.getAbsoluteFile().toPath().resolve(UUID.randomUUID().toString());\n        final StateHandleDownloadSpec downloadRequest =\n                new StateHandleDownloadSpec(stateHandle, tmpRestoreInstancePath);\n        try {\n            transferRemoteStateToLocalDirectory(Collections.singletonList(downloadRequest));\n            restoreBaseDBFromDownloadedState(downloadRequest);\n        } finally {\n            cleanUpPathQuietly(downloadRequest.getDownloadDestination());\n        }\n    }",
          "conflictNames": [
              "stateHandle",
              "tmpRestoreInstancePath"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0921968bb7d38bfac0b7899ec974a9744a721b22^1/flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBPropertyTest.java",
      "locators": [
          {
              "line": 37,
              "column": 30
          },
          {
              "line": 39,
              "column": 44
          },
          {
              "line": 42,
              "column": 56
          },
          {
              "line": 42,
              "column": 70
          }
      ],
      "old_name": "property",
      "new_name": "rocksDBProperty",
      "ctx": {
          "symbolName": "property",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "RocksDBProperty",
          "scopeHint": "in testRocksDBPropertiesValid(...)",
          "filePath": "RocksDBPropertyTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": " rocksDBExtension = new RocksDBExtension();\n\n    @Test\n    void testRocksDBPropertiesValid() {\n        RocksDB db = rocksDBExtension.getRocksDB();\n        ColumnFamilyHandle handle = rocksDBExtension.getDefaultColumnFamily();\n\n        for (RocksDBProperty property : RocksDBProperty.values()) {\n            try {\n                db.getLongProperty(handle, property.getRocksDBProperty());\n            } catch (RocksDBException e) {\n                throw new AssertionError(\n                        String.",
          "conflictNames": [
              "db",
              "handle"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0a3e711ffe8c433d3881b20261446d4dd026827f^1/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/checkpointing/AlternatingCheckpointsTest.java",
      "locators": [
          {
              "line": 208,
              "column": 14
          },
          {
              "line": 221,
              "column": 78
          },
          {
              "line": 224,
              "column": 31
          },
          {
              "line": 233,
              "column": 78
          },
          {
              "line": 244,
              "column": 78
          },
          {
              "line": 925,
              "column": 14
          },
          {
              "line": 942,
              "column": 45
          },
          {
              "line": 950,
              "column": 54
          },
          {
              "line": 981,
              "column": 14
          },
          {
              "line": 997,
              "column": 45
          },
          {
              "line": 1021,
              "column": 45
          }
      ],
      "old_name": "alignmentTimeOut",
      "new_name": "alignedCheckpointTimeout",
      "ctx": {
          "symbolName": "alignmentTimeOut",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "long",
          "scopeHint": "in testAlignedAfterTimedOut(...)",
          "filePath": "AlternatingCheckpointsTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testAlignedAfterTimedOut() throws Exception {\n        int numChannels = 1;\n        ValidatingCheckpointHandler target = new ValidatingCheckpointHandler();\n        long alignmentTimeOut = 100L;\n        try (CheckpointedInputGate gate =\n                new TestCheckpointedInputGateBuilder(\n                                numChannels, getTestBarrierHandlerFactory(target))\n                        .withRemoteChannels()\n                        .withMailboxExecutor()\n                        .build()) {\n\n            Buffer barrier1 =\n                    barrier(\n                            1,\n                            clock.relativeTimeMillis(),\n                            alignedWithTimeout(\n                                    CheckpointType.CHECKPOINT, getDefault(), alignmentTimeOut));\n            ((RemoteInputChannel) gate.getChannel(0)).onBuffer(barrier1.retainBuffer(), 0, 0);\n            assertAnnouncement(gate);\n            clock.advanceTime(alignmentTimeOut + 1, TimeUnit.MILLISECONDS);\n            assertBarrier(gate);\n\n            assertEquals(1, target.getTriggeredCheckpointCounter());\n            Buffer barrier2 =\n                    barrier(\n                            2,\n                            clock.relativeTimeMillis(),\n                            alignedWithTimeout(\n                                    CheckpointType.CHECKPOINT, getDefault(), alignmentTimeOut));\n            ((RemoteInputChannel) gate.getChannel(0)).onBuffer(barrier2.retainBuffer(), 1, 0);\n            assertAnnouncement(gate);\n            assertBarrier(gate);\n\n            assertEquals(2, target.getTriggeredCheckpointCounter());\n            assertThat(\n                    target.getTriggeredCheckpointOptions(),\n                    contains(\n                            unaligned(CheckpointType.CHECKPOINT, getDefault()),\n                            alignedWithTimeout(\n                                    CheckpointType.CHECKPOINT, getDefault(), alignmentTimeOut)));\n        }\n    }",
          "conflictNames": [
              "numChannels",
              "target",
              "gate",
              "barrier1",
              "barrier2"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0a3e711ffe8c433d3881b20261446d4dd026827f^1/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/checkpointing/AlternatingCheckpointsTest.java",
      "locators": [
          {
              "line": 306,
              "column": 82
          },
          {
              "line": 308,
              "column": 48
          },
          {
              "line": 318,
              "column": 27
          },
          {
              "line": 351,
              "column": 14
          },
          {
              "line": 352,
              "column": 48
          },
          {
              "line": 364,
              "column": 27
          },
          {
              "line": 406,
              "column": 14
          },
          {
              "line": 407,
              "column": 51
          },
          {
              "line": 424,
              "column": 27
          },
          {
              "line": 426,
              "column": 44
          },
          {
              "line": 438,
              "column": 27
          },
          {
              "line": 461,
              "column": 18
          },
          {
              "line": 462,
              "column": 52
          },
          {
              "line": 472,
              "column": 54
          },
          {
              "line": 505,
              "column": 14
          },
          {
              "line": 506,
              "column": 59
          },
          {
              "line": 509,
              "column": 51
          },
          {
              "line": 522,
              "column": 27
          },
          {
              "line": 532,
              "column": 18
          },
          {
              "line": 534,
              "column": 51
          },
          {
              "line": 558,
              "column": 14
          },
          {
              "line": 559,
              "column": 48
          },
          {
              "line": 565,
              "column": 50
          },
          {
              "line": 584,
              "column": 14
          },
          {
              "line": 585,
              "column": 48
          },
          {
              "line": 589,
              "column": 27
          },
          {
              "line": 606,
              "column": 14
          },
          {
              "line": 612,
              "column": 74
          },
          {
              "line": 621,
              "column": 27
          },
          {
              "line": 646,
              "column": 14
          },
          {
              "line": 647,
              "column": 48
          },
          {
              "line": 651,
              "column": 27
          },
          {
              "line": 669,
              "column": 14
          },
          {
              "line": 670,
              "column": 48
          },
          {
              "line": 675,
              "column": 27
          },
          {
              "line": 703,
              "column": 14
          },
          {
              "line": 704,
              "column": 48
          },
          {
              "line": 708,
              "column": 45
          },
          {
              "line": 723,
              "column": 18
          },
          {
              "line": 724,
              "column": 52
          },
          {
              "line": 736,
              "column": 31
          },
          {
              "line": 760,
              "column": 18
          },
          {
              "line": 761,
              "column": 52
          },
          {
              "line": 771,
              "column": 54
          },
          {
              "line": 844,
              "column": 18
          },
          {
              "line": 845,
              "column": 52
          },
          {
              "line": 856,
              "column": 54
          },
          {
              "line": 1299,
              "column": 14
          },
          {
              "line": 1300,
              "column": 48
          },
          {
              "line": 1304,
              "column": 29
          },
          {
              "line": 1308,
              "column": 29
          }
      ],
      "old_name": "alignmentTimeout",
      "new_name": "alignedCheckpointTimeout",
      "ctx": {
          "symbolName": "alignmentTimeout",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "long",
          "scopeHint": "in testTimeoutBarrierOnTwoChannels(...)",
          "filePath": "AlternatingCheckpointsTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "kpointCounter());\n\n            testTimeoutBarrierOnTwoChannels(target, gate, Integer.MAX_VALUE);\n        }\n    }\n\n    private void testTimeoutBarrierOnTwoChannels(\n            ValidatingCheckpointHandler target, CheckpointedInputGate gate, long alignmentTimeout)\n            throws Exception {\n        Buffer checkpointBarrier = withTimeout(alignmentTimeout);\n\n        getChannel(gate, 0).onBuffer(dataBuffer(), 0, 0);\n        getChannel(gate, 0).onBuffer(dataBuffer(), 1, 0);\n        getChannel(gate,",
          "conflictNames": [
              "target",
              "gate",
              "checkpointBarrier"
          ]
      },
      "suggestions": [
          {
              "name": "alignedCheckpointTimeout",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/0a3e711ffe8c433d3881b20261446d4dd026827f^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/serialization/EventSerializer.java",
      "locators": [
          {
              "line": 323,
              "column": 20
          },
          {
              "line": 328,
              "column": 81
          }
      ],
      "old_name": "alignmentTimeout",
      "new_name": "alignedCheckpointTimeout",
      "ctx": {
          "symbolName": "alignmentTimeout",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "long",
          "scopeHint": "in deserializeCheckpointBarrier(...)",
          "filePath": "EventSerializer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static CheckpointBarrier deserializeCheckpointBarrier(ByteBuffer buffer)\n            throws IOException {\n        final long id = buffer.getLong();\n        final long timestamp = buffer.getLong();\n\n        final byte checkpointTypeCode = buffer.get();\n\n        final SnapshotType snapshotType;\n        if (checkpointTypeCode == CHECKPOINT_TYPE_CHECKPOINT) {\n            snapshotType = CheckpointType.CHECKPOINT;\n        } else if (checkpointTypeCode == CHECKPOINT_TYPE_FULL_CHECKPOINT) {\n            snapshotType = CheckpointType.FULL_CHECKPOINT;\n        } else if (checkpointTypeCode == CHECKPOINT_TYPE_SAVEPOINT\n                || checkpointTypeCode == CHECKPOINT_TYPE_SAVEPOINT_SUSPEND\n                || checkpointTypeCode == CHECKPOINT_TYPE_SAVEPOINT_TERMINATE) {\n            snapshotType = decodeSavepointType(checkpointTypeCode, buffer);\n        } else {\n            throw new IOException(\"Unknown checkpoint type code: \" + checkpointTypeCode);\n        }\n\n        final CheckpointStorageLocationReference locationRef;\n        final int locationRefLen = buffer.getInt();\n        if (locationRefLen == -1) {\n            locationRef = CheckpointStorageLocationReference.getDefault();\n        } else {\n            byte[] bytes = new byte[locationRefLen];\n            buffer.get(bytes);\n            locationRef = new CheckpointStorageLocationReference(bytes);\n        }\n        final CheckpointOptions.AlignmentType alignmentType =\n                CheckpointOptions.AlignmentType.values()[buffer.get()];\n        final long alignmentTimeout = buffer.getLong();\n\n        return new CheckpointBarrier(\n                id,\n                timestamp,\n                new CheckpointOptions(snapshotType, locationRef, alignmentType, alignmentTimeout));\n    }",
          "conflictNames": [
              "buffer",
              "id",
              "timestamp",
              "checkpointTypeCode",
              "snapshotType",
              "locationRef",
              "locationRefLen",
              "bytes",
              "alignmentType"
          ]
      },
      "suggestions": [
          {
              "name": "alignedCheckpointTimeout",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/0a7a0a30904cf0a58ead8306bbf0b5b18d3077ca^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/calcite/FlinkConvertletTable.java",
      "locators": [
          {
              "line": 14,
              "column": 57
          },
          {
              "line": 196,
              "column": 27
          },
          {
              "line": 197,
              "column": 39
          }
      ],
      "old_name": "expr",
      "new_name": "column",
      "ctx": {
          "symbolName": "expr",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RexNode",
          "scopeHint": "in getPartitionKeyIndices(...)",
          "filePath": "FlinkConvertletTable.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static int[] getPartitionKeyIndices(SqlRexContext cx, SqlNodeList partitions) {\n        final int[] result = new int[partitions.size()];\n        for (int i = 0; i < partitions.getList().size(); i++) {\n            final RexNode expr = cx.convertExpression(partitions.get(i));\n            result[i] = parseFieldIdx(expr);\n        }\n        return result;\n    }",
          "conflictNames": [
              "cx",
              "partitions",
              "result",
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0a7a0a30904cf0a58ead8306bbf0b5b18d3077ca^1/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/nodes/exec/stream/MiscTests.java",
      "locators": [
          {
              "line": 80,
              "column": 32
          },
          {
              "line": 82,
              "column": 70
          },
          {
              "line": 90,
              "column": 34
          },
          {
              "line": 97,
              "column": 32
          },
          {
              "line": 100,
              "column": 43
          }
      ],
      "old_name": "tEnv",
      "new_name": "env",
      "ctx": {
          "symbolName": "tEnv",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TableEnvironment",
          "scopeHint": "in runTests(...)",
          "filePath": "MiscTests.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@ParameterizedTest\n    @MethodSource(\"supportedPrograms\")\n    void runTests(TableTestProgram program) throws Exception {\n        final TableEnvironment tEnv =\n                TableEnvironment.create(EnvironmentSettings.inStreamingMode());\n        program.getSetupConfigOptionTestSteps().forEach(s -> s.apply(tEnv));\n\n        for (SourceTestStep sourceTestStep : program.getSetupSourceTestSteps()) {\n            final String id = TestValuesTableFactory.registerData(sourceTestStep.dataBeforeRestore);\n            final Map<String, String> options = new HashMap<>();\n            options.put(\"connector\", \"values\");\n            options.put(\"data-id\", id);\n            options.put(\"runtime-source\", \"NewSource\");\n            sourceTestStep.apply(tEnv, options);\n        }\n\n        for (SinkTestStep sinkTestStep : program.getSetupSinkTestSteps()) {\n            final Map<String, String> options = new HashMap<>();\n            options.put(\"connector\", \"values\");\n            options.put(\"sink-insert-only\", \"false\");\n            sinkTestStep.apply(tEnv, options);\n        }\n\n        program.getRunSqlTestStep().apply(tEnv).await();\n        for (SinkTestStep sinkTestStep : program.getSetupSinkTestSteps()) {\n            List<String> expectedResults = getExpectedResults(sinkTestStep, sinkTestStep.name);\n            assertThat(expectedResults)\n                    .containsExactlyInAnyOrder(\n                            sinkTestStep.getExpectedAsStrings().toArray(new String[0]));\n        }\n    }",
          "conflictNames": [
              "program",
              "id",
              "options",
              "expectedResults"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0a7a0a30904cf0a58ead8306bbf0b5b18d3077ca^1/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/nodes/exec/stream/MiscTests.java",
      "locators": [
          {
              "line": 102,
              "column": 26
          },
          {
              "line": 103,
              "column": 24
          }
      ],
      "old_name": "expectedResults",
      "new_name": "actualResults",
      "ctx": {
          "symbolName": "expectedResults",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<String>",
          "scopeHint": "in runTests(...)",
          "filePath": "MiscTests.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@ParameterizedTest\n    @MethodSource(\"supportedPrograms\")\n    void runTests(TableTestProgram program) throws Exception {\n        final TableEnvironment tEnv =\n                TableEnvironment.create(EnvironmentSettings.inStreamingMode());\n        program.getSetupConfigOptionTestSteps().forEach(s -> s.apply(tEnv));\n\n        for (SourceTestStep sourceTestStep : program.getSetupSourceTestSteps()) {\n            final String id = TestValuesTableFactory.registerData(sourceTestStep.dataBeforeRestore);\n            final Map<String, String> options = new HashMap<>();\n            options.put(\"connector\", \"values\");\n            options.put(\"data-id\", id);\n            options.put(\"runtime-source\", \"NewSource\");\n            sourceTestStep.apply(tEnv, options);\n        }\n\n        for (SinkTestStep sinkTestStep : program.getSetupSinkTestSteps()) {\n            final Map<String, String> options = new HashMap<>();\n            options.put(\"connector\", \"values\");\n            options.put(\"sink-insert-only\", \"false\");\n            sinkTestStep.apply(tEnv, options);\n        }\n\n        program.getRunSqlTestStep().apply(tEnv).await();\n        for (SinkTestStep sinkTestStep : program.getSetupSinkTestSteps()) {\n            List<String> expectedResults = getExpectedResults(sinkTestStep, sinkTestStep.name);\n            assertThat(expectedResults)\n                    .containsExactlyInAnyOrder(\n                            sinkTestStep.getExpectedAsStrings().toArray(new String[0]));\n        }\n    }",
          "conflictNames": [
              "program",
              "tEnv",
              "id",
              "options"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0a7a0a30904cf0a58ead8306bbf0b5b18d3077ca^1/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/nodes/exec/stream/MiscTests.java",
      "locators": [
          {
              "line": 84,
              "column": 29
          },
          {
              "line": 85,
              "column": 67
          },
          {
              "line": 90,
              "column": 13
          }
      ],
      "old_name": "sourceTestStep",
      "new_name": "testStep",
      "ctx": {
          "symbolName": "sourceTestStep",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "SourceTestStep",
          "scopeHint": "in runTests(...)",
          "filePath": "MiscTests.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "am program) throws Exception {\n        final TableEnvironment tEnv =\n                TableEnvironment.create(EnvironmentSettings.inStreamingMode());\n        program.getSetupConfigOptionTestSteps().forEach(s -> s.apply(tEnv));\n\n        for (SourceTestStep sourceTestStep : program.getSetupSourceTestSteps()) {\n            final String id = TestValuesTableFactory.registerData(sourceTestStep.dataBeforeRestore);\n            final Map<String, String> options = new HashMap<>();\n            options.put(\"connector",
          "conflictNames": [
              "program",
              "tEnv",
              "id",
              "options",
              "expectedResults"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0b8bba6117bf2e8fe767b03d95274bac0b33faa0^1/flink-runtime/src/test/java/org/apache/flink/runtime/leaderretrieval/ZooKeeperLeaderRetrievalTest.java",
      "locators": [
          {
              "line": 122,
              "column": 31
          },
          {
              "line": 183,
              "column": 17
          },
          {
              "line": 187,
              "column": 62
          },
          {
              "line": 211,
              "column": 21
          },
          {
              "line": 212,
              "column": 21
          }
      ],
      "old_name": "leaderElectionService",
      "new_name": "leaderElection",
      "ctx": {
          "symbolName": "leaderElectionService",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "LeaderElectionService",
          "scopeHint": "in testConnectingAddressRetrievalWithDelayedLeaderElection(...)",
          "filePath": "ZooKeeperLeaderRetrievalTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Tests that LeaderRetrievalUtils.findConnectingAddress finds the correct connecting address in\n     * case of an old leader address in ZooKeeper and a subsequent election of a new leader. The\n     * findConnectingAddress should block until the new leader has been elected and his address has\n     * been written to ZooKeeper.\n     */\n    @Test\n    void testConnectingAddressRetrievalWithDelayedLeaderElection() throws Exception {\n        Duration timeout = Duration.ofMinutes(1L);\n\n        long sleepingTime = 1000;\n\n        LeaderElectionService leaderElectionService = null;\n\n        Thread thread;\n\n        final InetAddress localHost;\n        try {\n            localHost = InetAddress.getLocalHost();\n        } catch (UnknownHostException e) {\n            // may happen if disconnected. skip test.\n            System.err.println(\"Skipping 'testNetworkInterfaceSelection' test.\");\n            return;\n        }\n\n        try (ServerSocket serverSocket = new ServerSocket(0, 50, localHost)) {\n            String wrongAddress =\n                    RPC_SYSTEM.getRpcUrl(\n                            \"1.1.1.1\",\n                            1234,\n                            \"foobar\",\n                            AddressResolution.NO_ADDRESS_RESOLUTION,\n                            config);\n\n            try {\n                InetSocketAddress correctInetSocketAddress =\n                        new InetSocketAddress(localHost, serverSocket.getLocalPort());\n\n                String correctAddress =\n                        RPC_SYSTEM.getRpcUrl(\n                                localHost.getHostName(),\n                                correctInetSocketAddress.getPort(),\n                                JobMaster.JOB_MANAGER_NAME,\n                                AddressResolution.NO_ADDRESS_RESOLUTION,\n                                config);\n\n                // create driver to simulate a separate Flink process having leadership that writes\n                // its leader information to the ZooKeeper backend and gets lost afterward\n                final ZooKeeperMultipleComponentLeaderElectionDriver externalProcessDriver =\n                        new ZooKeeperMultipleComponentLeaderElectionDriver(\n                                ZooKeeperUtils.useNamespaceAndEnsurePath(\n                                        zooKeeperExtension.getZooKeeperClient(\n                                                testingFatalErrorHandlerResource\n                                                        .getTestingFatalErrorHandler()),\n                                        ZooKeeperUtils.generateLeaderLatchPath(\"\")),\n                                new TestingLeaderElectionListener());\n                externalProcessDriver.isLeader();\n\n                externalProcessDriver.publishLeaderInformation(\n                        HighAvailabilityServices.DEFAULT_JOB_ID.toString(),\n                        LeaderInformation.known(UUID.randomUUID(), wrongAddress));\n\n                FindConnectingAddress findConnectingAddress =\n                        new FindConnectingAddress(\n                                timeout,\n                                highAvailabilityServices.getJobManagerLeaderRetriever(\n                                        HighAvailabilityServices.DEFAULT_JOB_ID,\n                                        \"unused-default-address\"));\n\n                thread = new Thread(findConnectingAddress);\n\n                thread.start();\n\n                leaderElectionService =\n                        highAvailabilityServices.getJobManagerLeaderElectionService(\n                                HighAvailabilityServices.DEFAULT_JOB_ID);\n                TestingContender correctLeaderAddressContender =\n                        new TestingContender(correctAddress, leaderElectionService);\n\n                Thread.sleep(sleepingTime);\n\n                externalProcessDriver.notLeader();\n                externalProcessDriver.close();\n\n                // leaderElection is unused right now because it doesn't need to be closed, yet.\n                // The close call will be introduced with FLINK-31785\n                correctLeaderAddressContender.startLeaderElection();\n\n                thread.join();\n\n                InetAddress result = findConnectingAddress.getInetAddress();\n\n                // check that we can connect to the localHost\n                try (Socket socket = new Socket()) {\n                    // port 0 = let the OS choose the port\n                    SocketAddress bindP = new InetSocketAddress(result, 0);\n                    // machine\n                    socket.bind(bindP);\n                    socket.connect(correctInetSocketAddress, 1000);\n                }\n            } finally {\n                if (leaderElectionService != null) {\n                    leaderElectionService.stop();\n                }\n            }\n        } catch (IOException e) {\n            // may happen in certain test setups, skip test.\n            System.err.println(\"Skipping 'testNetworkInterfaceSelection' test.\");\n        }\n    }",
          "conflictNames": [
              "timeout",
              "sleepingTime",
              "thread",
              "localHost",
              "serverSocket",
              "wrongAddress",
              "correctInetSocketAddress",
              "correctAddress",
              "externalProcessDriver",
              "findConnectingAddress",
              "correctLeaderAddressContender",
              "result",
              "socket",
              "bindP"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0ccd95ef48bcd7246f8c88c9aa7b69ffa268c865^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/SpillingBufferTest.java",
      "locators": [
          {
              "line": 114,
              "column": 23
          },
          {
              "line": 121,
              "column": 45
          },
          {
              "line": 135,
              "column": 9
          },
          {
              "line": 141,
              "column": 45
          },
          {
              "line": 183,
              "column": 23
          },
          {
              "line": 191,
              "column": 49
          },
          {
              "line": 209,
              "column": 9
          },
          {
              "line": 215,
              "column": 45
          },
          {
              "line": 259,
              "column": 23
          },
          {
              "line": 266,
              "column": 45
          },
          {
              "line": 280,
              "column": 9
          },
          {
              "line": 286,
              "column": 45
          },
          {
              "line": 328,
              "column": 23
          },
          {
              "line": 336,
              "column": 49
          },
          {
              "line": 354,
              "column": 9
          },
          {
              "line": 360,
              "column": 45
          }
      ],
      "old_name": "inView",
      "new_name": "nextInView",
      "ctx": {
          "symbolName": "inView",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "DataInputView",
          "scopeHint": "in testWriteReadInMemory(...)",
          "filePath": "SpillingBufferTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testWriteReadInMemory() throws Exception {\n        final TestData.TupleGenerator generator =\n                new TestData.TupleGenerator(\n                        SEED, KEY_MAX, VALUE_LENGTH, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);\n        final TypeSerializer<Tuple2<Integer, String>> serializer =\n                TestData.getIntStringTupleSerializer();\n\n        // create the writer output view\n        final ArrayList<MemorySegment> memory = new ArrayList<MemorySegment>(NUM_MEMORY_SEGMENTS);\n        this.memoryManager.allocatePages(this.parentTask, memory, NUM_MEMORY_SEGMENTS);\n        final SpillingBuffer outView =\n                new SpillingBuffer(\n                        this.ioManager,\n                        new ListMemorySegmentSource(memory),\n                        this.memoryManager.getPageSize());\n\n        // write a number of pairs\n        final Tuple2<Integer, String> rec = new Tuple2<>();\n        for (int i = 0; i < NUM_PAIRS_INMEM; i++) {\n            generator.next(rec);\n            serializer.serialize(rec, outView);\n        }\n\n        // create the reader input view\n        DataInputView inView = outView.flip();\n        generator.reset();\n\n        // notifyNonEmpty and re-generate all records and compare them\n        final Tuple2<Integer, String> readRec = new Tuple2<>();\n        for (int i = 0; i < NUM_PAIRS_INMEM; i++) {\n            generator.next(rec);\n            serializer.deserialize(readRec, inView);\n\n            int k1 = rec.f0;\n            String v1 = rec.f1;\n\n            int k2 = readRec.f0;\n            String v2 = readRec.f1;\n\n            Assert.assertTrue(\n                    \"The re-generated and the notifyNonEmpty record do not match.\",\n                    k1 == k2 && v1.equals(v2));\n        }\n\n        // re-notifyNonEmpty the data\n        inView = outView.flip();\n        generator.reset();\n\n        // notifyNonEmpty and re-generate all records and compare them\n        for (int i = 0; i < NUM_PAIRS_INMEM; i++) {\n            generator.next(rec);\n            serializer.deserialize(readRec, inView);\n\n            int k1 = rec.f0;\n            String v1 = rec.f1;\n\n            int k2 = readRec.f0;\n            String v2 = readRec.f1;\n\n            Assert.assertTrue(\n                    \"The re-generated and the notifyNonEmpty record do not match.\",\n                    k1 == k2 && v1.equals(v2));\n        }\n\n        this.memoryManager.release(outView.close());\n        this.memoryManager.release(memory);\n    }",
          "conflictNames": [
              "generator",
              "serializer",
              "memory",
              "outView",
              "rec",
              "i",
              "readRec",
              "k1",
              "v1",
              "k2",
              "v2"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0ccd95ef48bcd7246f8c88c9aa7b69ffa268c865^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/disk/iomanager/IOManagerTest.java",
      "locators": [
          {
              "line": 62,
              "column": 22
          },
          {
              "line": 64,
              "column": 63
          },
          {
              "line": 64,
              "column": 71
          },
          {
              "line": 65,
              "column": 79
          },
          {
              "line": 69,
              "column": 41
          },
          {
              "line": 72,
              "column": 25
          },
          {
              "line": 88,
              "column": 42
          },
          {
              "line": 89,
              "column": 19
          }
      ],
      "old_name": "path",
      "new_name": "pathFile",
      "ctx": {
          "symbolName": "path",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "File",
          "scopeHint": "in channelEnumerator(...)",
          "filePath": "IOManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void channelEnumerator() throws Exception {\n        File tempPath = temporaryFolder.newFolder();\n\n        String[] tempDirs =\n                new String[] {\n                    new File(tempPath, \"a\").getAbsolutePath(),\n                    new File(tempPath, \"b\").getAbsolutePath(),\n                    new File(tempPath, \"c\").getAbsolutePath(),\n                    new File(tempPath, \"d\").getAbsolutePath(),\n                    new File(tempPath, \"e\").getAbsolutePath(),\n                };\n\n        int[] counters = new int[tempDirs.length];\n        try (IOManager ioMan = new TestIOManager(tempDirs)) {\n            FileIOChannel.Enumerator enumerator = ioMan.createChannelEnumerator();\n\n            for (int i = 0; i < 3 * tempDirs.length; i++) {\n                FileIOChannel.ID id = enumerator.next();\n\n                File path = id.getPathFile();\n\n                assertTrue(\"Channel IDs must name an absolute path.\", path.isAbsolute());\n                assertFalse(\"Channel IDs must name a file, not a directory.\", path.isDirectory());\n\n                assertTrue(\n                        \"Path is not in the temp directory.\",\n                        tempPath.equals(path.getParentFile().getParentFile().getParentFile()));\n\n                for (int k = 0; k < tempDirs.length; k++) {\n                    if (path.getParentFile().getParent().equals(tempDirs[k])) {\n                        counters[k]++;\n                    }\n                }\n            }\n\n            for (int k = 0; k < tempDirs.length; k++) {\n                assertEquals(3, counters[k]);\n            }\n        }\n    }",
          "conflictNames": [
              "tempPath",
              "tempDirs",
              "counters",
              "ioMan",
              "enumerator",
              "i",
              "id",
              "k"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0d11103b7bc88c6eb5e4fa598008591d332d8d30^1/flink-python/src/main/java/org/apache/flink/table/runtime/typeutils/serializers/python/RowDataSerializer.java",
      "locators": [
          {
              "line": 208,
              "column": 31
          },
          {
              "line": 209,
              "column": 47
          },
          {
              "line": 216,
              "column": 37
          }
      ],
      "old_name": "newRowSerializer",
      "new_name": "oldRowDataSerializerSnapshot",
      "ctx": {
          "symbolName": "newRowSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RowDataSerializer",
          "scopeHint": "in resolveSchemaCompatibility(...)",
          "filePath": "RowDataSerializer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public TypeSerializerSchemaCompatibility<RowData> resolveSchemaCompatibility(\n                TypeSerializer<RowData> newSerializer) {\n            if (!(newSerializer instanceof RowDataSerializer)) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            }\n\n            RowDataSerializer newRowSerializer = (RowDataSerializer) newSerializer;\n            if (!Arrays.equals(previousTypes, newRowSerializer.fieldTypes)) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            }\n\n            CompositeTypeSerializerUtil.IntermediateCompatibilityResult<RowData>\n                    intermediateResult =\n                            CompositeTypeSerializerUtil.constructIntermediateCompatibilityResult(\n                                    newRowSerializer.fieldSerializers,\n                                    nestedSerializersSnapshotDelegate\n                                            .getNestedSerializerSnapshots());\n\n            if (intermediateResult.isCompatibleWithReconfiguredSerializer()) {\n                RowDataSerializer reconfiguredCompositeSerializer = restoreSerializer();\n                return TypeSerializerSchemaCompatibility.compatibleWithReconfiguredSerializer(\n                        reconfiguredCompositeSerializer);\n            }\n\n            return intermediateResult.getFinalResult();\n        }",
          "conflictNames": [
              "newSerializer",
              "intermediateResult",
              "reconfiguredCompositeSerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0d11103b7bc88c6eb5e4fa598008591d332d8d30^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/typeutils/RowDataSerializer.java",
      "locators": [
          {
              "line": 342,
              "column": 31
          },
          {
              "line": 343,
              "column": 47
          },
          {
              "line": 350,
              "column": 37
          }
      ],
      "old_name": "newRowSerializer",
      "new_name": "oldRowDataSerializerSnapshot",
      "ctx": {
          "symbolName": "newRowSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RowDataSerializer",
          "scopeHint": "in resolveSchemaCompatibility(...)",
          "filePath": "RowDataSerializer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public TypeSerializerSchemaCompatibility<RowData> resolveSchemaCompatibility(\n                TypeSerializer<RowData> newSerializer) {\n            if (!(newSerializer instanceof RowDataSerializer)) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            }\n\n            RowDataSerializer newRowSerializer = (RowDataSerializer) newSerializer;\n            if (!Arrays.equals(previousTypes, newRowSerializer.types)) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            }\n\n            CompositeTypeSerializerUtil.IntermediateCompatibilityResult<RowData>\n                    intermediateResult =\n                            CompositeTypeSerializerUtil.constructIntermediateCompatibilityResult(\n                                    newRowSerializer.fieldSerializers,\n                                    nestedSerializersSnapshotDelegate\n                                            .getNestedSerializerSnapshots());\n\n            if (intermediateResult.isCompatibleWithReconfiguredSerializer()) {\n                RowDataSerializer reconfiguredCompositeSerializer = restoreSerializer();\n                return TypeSerializerSchemaCompatibility.compatibleWithReconfiguredSerializer(\n                        reconfiguredCompositeSerializer);\n            }\n\n            return intermediateResult.getFinalResult();\n        }",
          "conflictNames": [
              "newSerializer",
              "intermediateResult",
              "reconfiguredCompositeSerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0e8b98088396a1f2cb77590b2b75c47c0258595b^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateFactory.java",
      "locators": [
          {
              "line": 174,
              "column": 20
          },
          {
              "line": 182,
              "column": 70
          },
          {
              "line": 193,
              "column": 50
          },
          {
              "line": 223,
              "column": 24
          },
          {
              "line": 232,
              "column": 74
          },
          {
              "line": 241,
              "column": 42
          },
          {
              "line": 242,
              "column": 42
          },
          {
              "line": 324,
              "column": 51
          },
          {
              "line": 326,
              "column": 50
          }
      ],
      "old_name": "subpartitionIndexRange",
      "new_name": "subpartitionIndexSet",
      "ctx": {
          "symbolName": "subpartitionIndexRange",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "IndexRange",
          "scopeHint": "in create(...)",
          "filePath": "SingleInputGateFactory.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Creates an input gate and all of its input channels. */\n    public SingleInputGate create(\n            @Nonnull ShuffleIOOwnerContext owner,\n            int gateIndex,\n            @Nonnull InputGateDeploymentDescriptor igdd,\n            @Nonnull PartitionProducerStateProvider partitionProducerStateProvider,\n            @Nonnull InputChannelMetrics metrics) {\n        GateBuffersSpec gateBuffersSpec =\n                createGateBuffersSpec(\n                        maxRequiredBuffersPerGate,\n                        configuredNetworkBuffersPerChannel,\n                        floatingNetworkBuffersPerGate,\n                        igdd.getConsumedPartitionType(),\n                        calculateNumChannels(\n                                igdd.getShuffleDescriptors().length,\n                                igdd.getConsumedSubpartitionIndexRange()),\n                        tieredStorageConfiguration != null);\n        SupplierWithException<BufferPool, IOException> bufferPoolFactory =\n                createBufferPoolFactory(\n                        networkBufferPool,\n                        gateBuffersSpec.getRequiredFloatingBuffers(),\n                        gateBuffersSpec.getTotalFloatingBuffers());\n\n        BufferDecompressor bufferDecompressor = null;\n        if (igdd.getConsumedPartitionType().supportCompression()\n                && batchShuffleCompressionEnabled) {\n            bufferDecompressor = new BufferDecompressor(networkBufferSize, compressionCodec);\n        }\n\n        final String owningTaskName = owner.getOwnerName();\n        final MetricGroup networkInputGroup = owner.getInputGroup();\n\n        IndexRange subpartitionIndexRange = igdd.getConsumedSubpartitionIndexRange();\n        SingleInputGate inputGate =\n                new SingleInputGate(\n                        owningTaskName,\n                        gateIndex,\n                        igdd.getConsumedResultId(),\n                        igdd.getConsumedPartitionType(),\n                        calculateNumChannels(\n                                igdd.getShuffleDescriptors().length, subpartitionIndexRange),\n                        partitionProducerStateProvider,\n                        bufferPoolFactory,\n                        bufferDecompressor,\n                        networkBufferPool,\n                        networkBufferSize,\n                        new ThroughputCalculator(SystemClock.getInstance()),\n                        maybeCreateBufferDebloater(\n                                owningTaskName, gateIndex, networkInputGroup.addGroup(gateIndex)));\n\n        createInputChannelsAndTieredStorageService(\n                owningTaskName, igdd, inputGate, subpartitionIndexRange, gateBuffersSpec, metrics);\n        return inputGate;\n    }",
          "conflictNames": [
              "owner",
              "gateIndex",
              "igdd",
              "partitionProducerStateProvider",
              "metrics",
              "gateBuffersSpec",
              "bufferPoolFactory",
              "bufferDecompressor",
              "owningTaskName",
              "networkInputGroup",
              "inputGate"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0e8b98088396a1f2cb77590b2b75c47c0258595b^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NettyMessage.java",
      "locators": [
          {
              "line": 517,
              "column": 19
          },
          {
              "line": 525,
              "column": 21
          },
          {
              "line": 529,
              "column": 18
          },
          {
              "line": 529,
              "column": 31
          },
          {
              "line": 541,
              "column": 37
          },
          {
              "line": 564,
              "column": 17
          },
          {
              "line": 568,
              "column": 54
          },
          {
              "line": 573,
              "column": 77
          }
      ],
      "old_name": "queueIndex",
      "new_name": "queueIndexSet",
      "ctx": {
          "symbolName": "queueIndex",
          "symbolKind": "field",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in PartitionRequest",
          "filePath": "NettyMessage.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "sts\n    // ------------------------------------------------------------------------\n\n    static class PartitionRequest extends NettyMessage {\n\n        private static final byte ID = 2;\n\n        final ResultPartitionID partitionId;\n\n        final int queueIndex;\n\n        final InputChannelID receiverId;\n\n        final int credit;\n\n        PartitionRequest(\n                ResultPartitionID partitionId,\n                int queueIndex,\n                InputChannelID receiverId,\n                int c",
          "conflictNames": [
              "ID",
              "partitionId",
              "receiverId",
              "credit"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0e8b98088396a1f2cb77590b2b75c47c0258595b^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/TestingResultPartitionProvider.java",
      "locators": [
          {
              "line": 45,
              "column": 17
          },
          {
              "line": 49,
              "column": 30
          },
          {
              "line": 55,
              "column": 17
          },
          {
              "line": 61,
              "column": 38
          },
          {
              "line": 76,
              "column": 37
          },
          {
              "line": 79,
              "column": 39
          },
          {
              "line": 116,
              "column": 21
          },
          {
              "line": 125,
              "column": 21
          }
      ],
      "old_name": "index",
      "new_name": "indexSet",
      "ctx": {
          "symbolName": "index",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in createSubpartitionView(...)",
          "filePath": "TestingResultPartitionProvider.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "Function;\n        this.releasePartitionRequestListenerConsumer = releasePartitionRequestListenerConsumer;\n    }\n\n    @Override\n    public ResultSubpartitionView createSubpartitionView(\n            ResultPartitionID partitionId,\n            int index,\n            BufferAvailabilityListener availabilityListener)\n            throws IOException {\n        return createSubpartitionViewFunction.createSubpartitionView(\n                partitionId, index, availabilityListener);\n    }\n\n    @Ove",
          "conflictNames": [
              "partitionId",
              "availabilityListener"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0ef0dbd4077161d47b29cc6130a2da3bc2a8048b^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/HsFileDataIndexCache.java",
      "locators": [
          {
              "line": 142,
              "column": 15
          },
          {
              "line": 144,
              "column": 60
          },
          {
              "line": 147,
              "column": 29
          },
          {
              "line": 147,
              "column": 46
          },
          {
              "line": 149,
              "column": 55
          },
          {
              "line": 151,
              "column": 25
          },
          {
              "line": 151,
              "column": 63
          },
          {
              "line": 201,
              "column": 25
          },
          {
              "line": 201,
              "column": 43
          }
      ],
      "old_name": "internalRegion",
      "new_name": "region",
      "ctx": {
          "symbolName": "internalRegion",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "InternalRegion",
          "scopeHint": "in put(...)",
          "filePath": "HsFileDataIndexCache.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "be cached.\n     */\n    public void put(int subpartition, List<InternalRegion> internalRegions) {\n        TreeMap<Integer, InternalRegion> treeMap =\n                subpartitionFirstBufferIndexInternalRegions.get(subpartition);\n        for (InternalRegion internalRegion : internalRegions) {\n            internalCache.put(\n                    new CachedRegionKey(subpartition, internalRegion.getFirstBufferIndex()),\n                    PLACEHOLDER);\n            treeMap.put(internalRegion.getFirstBufferIndex()",
          "conflictNames": [
              "subpartition",
              "internalRegions",
              "treeMap"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0ef0dbd4077161d47b29cc6130a2da3bc2a8048b^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/HsFileDataIndexSpilledRegionManagerImplTest.java",
      "locators": [
          {
              "line": 99,
              "column": 13
          },
          {
              "line": 101,
              "column": 44
          },
          {
              "line": 114,
              "column": 29
          },
          {
              "line": 121,
              "column": 13
          },
          {
              "line": 123,
              "column": 44
          },
          {
              "line": 127,
              "column": 57
          },
          {
              "line": 128,
              "column": 57
          },
          {
              "line": 190,
              "column": 17
          },
          {
              "line": 192,
              "column": 68
          }
      ],
      "old_name": "segmentSize",
      "new_name": "regionGroupSize",
      "ctx": {
          "symbolName": "segmentSize",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in testWriteMoreThanOneSegment(...)",
          "filePath": "HsFileDataIndexSpilledRegionManagerImplTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testWriteMoreThanOneSegment() throws Exception {\n        List<InternalRegion> regions = createAllUnreleasedRegions(0, 0L, 2, 2);\n        int segmentSize = regions.stream().mapToInt(InternalRegion::getSize).sum() + 1;\n        try (HsFileDataIndexSpilledRegionManager spilledRegionManager =\n                createSpilledRegionManager(segmentSize, (ignore1, ignore2) -> {})) {\n            spilledRegionManager.appendOrOverwriteRegion(0, regions.get(0));\n            spilledRegionManager.appendOrOverwriteRegion(0, regions.get(1));\n            // segment has no enough space, will start new segment.\n            InternalRegion regionInNewSegment = createSingleUnreleasedRegion(4, 4L, 2);\n            spilledRegionManager.appendOrOverwriteRegion(0, regionInNewSegment);\n            FileChannel indexFileChannel = FileChannel.open(indexFilePath, StandardOpenOption.READ);\n            InternalRegion readRegion =\n                    InternalRegionWriteReadUtils.readRegionFromFile(\n                            indexFileChannel,\n                            allocateAndConfigureBuffer(InternalRegion.HEADER_SIZE),\n                            // offset is segment size instead of two regions size to prove that new\n                            // segment is started.\n                            segmentSize);\n            assertRegionEquals(readRegion, regionInNewSegment);\n        }\n    }",
          "conflictNames": [
              "regions",
              "spilledRegionManager",
              "regionInNewSegment",
              "indexFileChannel",
              "readRegion"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0ef0dbd4077161d47b29cc6130a2da3bc2a8048b^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/HsFileDataIndexSpilledRegionManagerImplTest.java",
      "locators": [
          {
              "line": 105,
              "column": 28
          },
          {
              "line": 106,
              "column": 61
          },
          {
              "line": 115,
              "column": 44
          }
      ],
      "old_name": "regionInNewSegment",
      "new_name": "regionInNewRegionGroup",
      "ctx": {
          "symbolName": "regionInNewSegment",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "InternalRegion",
          "scopeHint": "in testWriteMoreThanOneSegment(...)",
          "filePath": "HsFileDataIndexSpilledRegionManagerImplTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testWriteMoreThanOneSegment() throws Exception {\n        List<InternalRegion> regions = createAllUnreleasedRegions(0, 0L, 2, 2);\n        int segmentSize = regions.stream().mapToInt(InternalRegion::getSize).sum() + 1;\n        try (HsFileDataIndexSpilledRegionManager spilledRegionManager =\n                createSpilledRegionManager(segmentSize, (ignore1, ignore2) -> {})) {\n            spilledRegionManager.appendOrOverwriteRegion(0, regions.get(0));\n            spilledRegionManager.appendOrOverwriteRegion(0, regions.get(1));\n            // segment has no enough space, will start new segment.\n            InternalRegion regionInNewSegment = createSingleUnreleasedRegion(4, 4L, 2);\n            spilledRegionManager.appendOrOverwriteRegion(0, regionInNewSegment);\n            FileChannel indexFileChannel = FileChannel.open(indexFilePath, StandardOpenOption.READ);\n            InternalRegion readRegion =\n                    InternalRegionWriteReadUtils.readRegionFromFile(\n                            indexFileChannel,\n                            allocateAndConfigureBuffer(InternalRegion.HEADER_SIZE),\n                            // offset is segment size instead of two regions size to prove that new\n                            // segment is started.\n                            segmentSize);\n            assertRegionEquals(readRegion, regionInNewSegment);\n        }\n    }",
          "conflictNames": [
              "regions",
              "segmentSize",
              "spilledRegionManager",
              "indexFileChannel",
              "readRegion"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0ef0dbd4077161d47b29cc6130a2da3bc2a8048b^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/HsFileDataIndexSpilledRegionManagerImpl.java",
      "locators": [
          {
              "line": 149,
              "column": 21
          },
          {
              "line": 150,
              "column": 13
          },
          {
              "line": 152,
              "column": 68
          },
          {
              "line": 299,
              "column": 21
          },
          {
              "line": 300,
              "column": 9
          }
      ],
      "old_name": "segmentMeta",
      "new_name": "regionGroup",
      "ctx": {
          "symbolName": "segmentMeta",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SegmentMeta",
          "scopeHint": "in findRegion(...)",
          "filePath": "HsFileDataIndexSpilledRegionManagerImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public long findRegion(int subpartition, int bufferIndex, boolean loadToCache) {\n        // first of all, find the region from current writing segment.\n        SegmentMeta segmentMeta = currentSegmentMeta[subpartition];\n        if (segmentMeta != null) {\n            long regionOffset =\n                    findRegionInSegment(subpartition, bufferIndex, segmentMeta, loadToCache);\n            if (regionOffset != -1) {\n                return regionOffset;\n            }\n        }\n\n        // next, find the region from finished segments.\n        TreeMap<Integer, SegmentMeta> subpartitionSegmentMetaTreeMap =\n                subpartitionFinishedSegmentMetas.get(subpartition);\n        // all segments with a minBufferIndex less than or equal to this target buffer index may\n        // contain the target region.\n        for (SegmentMeta meta :\n                subpartitionSegmentMetaTreeMap.headMap(bufferIndex, true).values()) {\n            long regionOffset = findRegionInSegment(subpartition, bufferIndex, meta, loadToCache);\n            if (regionOffset != -1) {\n                return regionOffset;\n            }\n        }\n        return -1;\n    }",
          "conflictNames": [
              "subpartition",
              "bufferIndex",
              "loadToCache",
              "regionOffset",
              "subpartitionSegmentMetaTreeMap"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0ef0dbd4077161d47b29cc6130a2da3bc2a8048b^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/HsFileDataIndexSpilledRegionManagerImpl.java",
      "locators": [
          {
              "line": 159,
              "column": 39
          },
          {
              "line": 164,
              "column": 17
          }
      ],
      "old_name": "subpartitionSegmentMetaTreeMap",
      "new_name": "subpartitionRegionGroupMetaTreeMap",
      "ctx": {
          "symbolName": "subpartitionSegmentMetaTreeMap",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TreeMap<Integer, SegmentMeta>",
          "scopeHint": "in findRegion(...)",
          "filePath": "HsFileDataIndexSpilledRegionManagerImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public long findRegion(int subpartition, int bufferIndex, boolean loadToCache) {\n        // first of all, find the region from current writing segment.\n        SegmentMeta segmentMeta = currentSegmentMeta[subpartition];\n        if (segmentMeta != null) {\n            long regionOffset =\n                    findRegionInSegment(subpartition, bufferIndex, segmentMeta, loadToCache);\n            if (regionOffset != -1) {\n                return regionOffset;\n            }\n        }\n\n        // next, find the region from finished segments.\n        TreeMap<Integer, SegmentMeta> subpartitionSegmentMetaTreeMap =\n                subpartitionFinishedSegmentMetas.get(subpartition);\n        // all segments with a minBufferIndex less than or equal to this target buffer index may\n        // contain the target region.\n        for (SegmentMeta meta :\n                subpartitionSegmentMetaTreeMap.headMap(bufferIndex, true).values()) {\n            long regionOffset = findRegionInSegment(subpartition, bufferIndex, meta, loadToCache);\n            if (regionOffset != -1) {\n                return regionOffset;\n            }\n        }\n        return -1;\n    }",
          "conflictNames": [
              "subpartition",
              "bufferIndex",
              "loadToCache",
              "segmentMeta",
              "regionOffset"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/0ef0dbd4077161d47b29cc6130a2da3bc2a8048b^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/HsFileDataIndexSpilledRegionManagerImpl.java",
      "locators": [
          {
              "line": 282,
              "column": 21
          },
          {
              "line": 287,
              "column": 13
          },
          {
              "line": 291,
              "column": 26
          },
          {
              "line": 291,
              "column": 57
          }
      ],
      "old_name": "oldSegmentMeta",
      "new_name": "oldRegionGroup",
      "ctx": {
          "symbolName": "oldSegmentMeta",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SegmentMeta",
          "scopeHint": "in startNewSegment(...)",
          "filePath": "HsFileDataIndexSpilledRegionManagerImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void startNewSegment(int subpartition, int newSegmentSize) {\n        SegmentMeta oldSegmentMeta = currentSegmentMeta[subpartition];\n        currentSegmentMeta[subpartition] = new SegmentMeta(nextSegmentOffset);\n        subpartitionCurrentOffset[subpartition] = nextSegmentOffset;\n        nextSegmentOffset += newSegmentSize;\n        subpartitionFreeSpaceInBytes[subpartition] = newSegmentSize;\n        if (oldSegmentMeta != null) {\n            // put the finished segment to subpartitionFinishedSegmentMetas.\n            subpartitionFinishedSegmentMetas\n                    .get(subpartition)\n                    .put(oldSegmentMeta.minBufferIndex, oldSegmentMeta);\n        }\n    }",
          "conflictNames": [
              "subpartition",
              "newSegmentSize"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/1070c6e9e0f9f00991bdeb34f0757e4f0597931e^1/flink-table/flink-table-planner/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java",
      "locators": [
          {
              "line": 6091,
              "column": 32
          },
          {
              "line": 6093,
              "column": 42
          },
          {
              "line": 6095,
              "column": 50
          }
      ],
      "old_name": "sqlCallBinding",
      "new_name": "binding",
      "ctx": {
          "symbolName": "sqlCallBinding",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SqlCallBinding",
          "scopeHint": "in translateAgg(...)",
          "filePath": "SqlToRelConverter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void translateAgg(\n                SqlCall call,\n                @Nullable SqlNode filter,\n                @Nullable SqlNodeList distinctList,\n                @Nullable SqlNodeList orderList,\n                boolean ignoreNulls,\n                SqlCall outerCall) {\n            assert bb.agg == this;\n            assert outerCall != null;\n            final List<SqlNode> operands = call.getOperandList();\n            final SqlParserPos pos = call.getParserPosition();\n            final SqlCall call2;\n            switch (call.getKind()) {\n                case FILTER:\n                    assert filter == null;\n                    translateAgg(\n                            call.operand(0),\n                            call.operand(1),\n                            distinctList,\n                            orderList,\n                            ignoreNulls,\n                            outerCall);\n                    return;\n                case WITHIN_DISTINCT:\n                    assert orderList == null;\n                    translateAgg(\n                            call.operand(0),\n                            filter,\n                            call.operand(1),\n                            orderList,\n                            ignoreNulls,\n                            outerCall);\n                    return;\n                case WITHIN_GROUP:\n                    assert orderList == null;\n                    translateAgg(\n                            call.operand(0),\n                            filter,\n                            distinctList,\n                            call.operand(1),\n                            ignoreNulls,\n                            outerCall);\n                    return;\n                case IGNORE_NULLS:\n                    ignoreNulls = true;\n                    // fall through\n                case RESPECT_NULLS:\n                    translateAgg(\n                            call.operand(0),\n                            filter,\n                            distinctList,\n                            orderList,\n                            ignoreNulls,\n                            outerCall);\n                    return;\n\n                case COUNTIF:\n                    // COUNTIF(b)  ==> COUNT(*) FILTER (WHERE b)\n                    // COUNTIF(b) FILTER (WHERE b2)  ==> COUNT(*) FILTER (WHERE b2 AND b)\n                    call2 = SqlStdOperatorTable.COUNT.createCall(pos, SqlIdentifier.star(pos));\n                    final SqlNode filter2 = SqlUtil.andExpressions(filter, call.operand(0));\n                    translateAgg(call2, filter2, distinctList, orderList, ignoreNulls, outerCall);\n                    return;\n\n                case STRING_AGG:\n                    // Translate \"STRING_AGG(s, sep ORDER BY x, y)\"\n                    // as if it were \"LISTAGG(s, sep) WITHIN GROUP (ORDER BY x, y)\";\n                    // and \"STRING_AGG(s, sep)\" as \"LISTAGG(s, sep)\".\n                    final List<SqlNode> operands2;\n                    if (!operands.isEmpty() && Util.last(operands) instanceof SqlNodeList) {\n                        orderList = (SqlNodeList) Util.last(operands);\n                        operands2 = Util.skipLast(operands);\n                    } else {\n                        operands2 = operands;\n                    }\n                    call2 =\n                            SqlStdOperatorTable.LISTAGG.createCall(\n                                    call.getFunctionQuantifier(), pos, operands2);\n                    translateAgg(call2, filter, distinctList, orderList, ignoreNulls, outerCall);\n                    return;\n\n                case GROUP_CONCAT:\n                    // Translate \"GROUP_CONCAT(s ORDER BY x, y SEPARATOR ',')\"\n                    // as if it were \"LISTAGG(s, ',') WITHIN GROUP (ORDER BY x, y)\".\n                    // To do this, build a list of operands without ORDER BY with with sep.\n                    operands2 = new ArrayList<>(operands);\n                    final SqlNode separator;\n                    if (!operands2.isEmpty()\n                            && Util.last(operands2).getKind() == SqlKind.SEPARATOR) {\n                        final SqlCall sepCall = (SqlCall) operands2.remove(operands.size() - 1);\n                        separator = sepCall.operand(0);\n                    } else {\n                        separator = null;\n                    }\n\n                    if (!operands2.isEmpty() && Util.last(operands2) instanceof SqlNodeList) {\n                        orderList = (SqlNodeList) operands2.remove(operands2.size() - 1);\n                    }\n\n                    if (separator != null) {\n                        operands2.add(separator);\n                    }\n\n                    call2 =\n                            SqlStdOperatorTable.LISTAGG.createCall(\n                                    call.getFunctionQuantifier(), pos, operands2);\n                    translateAgg(call2, filter, distinctList, orderList, ignoreNulls, outerCall);\n                    return;\n\n                case ARRAY_AGG:\n                case ARRAY_CONCAT_AGG:\n                    // Translate \"ARRAY_AGG(s ORDER BY x, y)\"\n                    // as if it were \"ARRAY_AGG(s) WITHIN GROUP (ORDER BY x, y)\";\n                    // similarly \"ARRAY_CONCAT_AGG\".\n                    if (!operands.isEmpty() && Util.last(operands) instanceof SqlNodeList) {\n                        orderList = (SqlNodeList) Util.last(operands);\n                        call2 =\n                                call.getOperator()\n                                        .createCall(\n                                                call.getFunctionQuantifier(),\n                                                pos,\n                                                Util.skipLast(operands));\n                        translateAgg(\n                                call2, filter, distinctList, orderList, ignoreNulls, outerCall);\n                        return;\n                    }\n                    // \"ARRAY_AGG\" and \"ARRAY_CONCAT_AGG\" without \"ORDER BY\"\n                    // are handled normally; fall through.\n\n                default:\n                    break;\n            }\n            final List<Integer> args = new ArrayList<>();\n            int filterArg = -1;\n            final ImmutableBitSet distinctKeys;\n            try {\n                // switch out of agg mode\n                bb.agg = null;\n                // ----- FLINK MODIFICATION BEGIN -----\n                SqlCallBinding sqlCallBinding =\n                        new SqlCallBinding(validator(), aggregatingSelectScope, call);\n                List<SqlNode> sqlNodes = sqlCallBinding.operands();\n                FlinkOperatorBinding flinkOperatorBinding =\n                        new FlinkOperatorBinding(sqlCallBinding);\n                for (int i = 0; i < sqlNodes.size(); i++) {\n                    SqlNode operand = sqlNodes.get(i);\n                    // special case for COUNT(*):  delete the *\n                    if (operand instanceof SqlIdentifier) {\n                        SqlIdentifier id = (SqlIdentifier) operand;\n                        if (id.isStar()) {\n                            assert call.operandCount() == 1;\n                            assert args.isEmpty();\n                            break;\n                        }\n                    }\n                    RexNode convertedExpr = bb.convertExpression(operand);\n                    if (convertedExpr.getKind() == SqlKind.DEFAULT) {\n                        RelDataType relDataType = flinkOperatorBinding.getOperandType(i);\n                        convertedExpr =\n                                ((RexCall) convertedExpr)\n                                        .clone(relDataType, ((RexCall) convertedExpr).operands);\n                    }\n                    args.add(lookupOrCreateGroupExpr(convertedExpr));\n                }\n                // ----- FLINK MODIFICATION END -----\n\n                if (filter != null) {\n                    RexNode convertedExpr = bb.convertExpression(filter);\n                    if (convertedExpr.getType().isNullable()) {\n                        convertedExpr =\n                                rexBuilder.makeCall(SqlStdOperatorTable.IS_TRUE, convertedExpr);\n                    }\n                    filterArg = lookupOrCreateGroupExpr(convertedExpr);\n                }\n\n                if (distinctList == null) {\n                    distinctKeys = null;\n                } else {\n                    final ImmutableBitSet.Builder distinctBuilder = ImmutableBitSet.builder();\n                    for (SqlNode distinct : distinctList) {\n                        RexNode e = bb.convertExpression(distinct);\n                        assert e != null;\n                        distinctBuilder.set(lookupOrCreateGroupExpr(e));\n                    }\n                    distinctKeys = distinctBuilder.build();\n                }\n            } finally {\n                // switch back into agg mode\n                bb.agg = this;\n            }\n\n            SqlAggFunction aggFunction = (SqlAggFunction) call.getOperator();\n            final RelDataType type = validator().deriveType(bb.scope(), call);\n            boolean distinct = false;\n            SqlLiteral quantifier = call.getFunctionQuantifier();\n            if ((null != quantifier) && (quantifier.getValue() == SqlSelectKeyword.DISTINCT)) {\n                distinct = true;\n            }\n            boolean approximate = false;\n            if (aggFunction == SqlStdOperatorTable.APPROX_COUNT_DISTINCT) {\n                aggFunction = SqlStdOperatorTable.COUNT;\n                distinct = true;\n                approximate = true;\n            }\n            final RelCollation collation;\n            if (orderList == null || orderList.size() == 0) {\n                collation = RelCollations.EMPTY;\n            } else {\n                try {\n                    // switch out of agg mode\n                    bb.agg = null;\n                    collation =\n                            RelCollations.of(\n                                    orderList.stream()\n                                            .map(\n                                                    order ->\n                                                            bb.convertSortExpression(\n                                                                    order,\n                                                                    RelFieldCollation.Direction\n                                                                            .ASCENDING,\n                                                                    RelFieldCollation.NullDirection\n                                                                            .UNSPECIFIED,\n                                                                    this::sortToFieldCollation))\n                                            .collect(Collectors.toList()));\n                } finally {\n                    // switch back into agg mode\n                    bb.agg = this;\n                }\n            }\n            final AggregateCall aggCall =\n                    AggregateCall.create(\n                            aggFunction,\n                            distinct,\n                            approximate,\n                            ignoreNulls,\n                            args,\n                            filterArg,\n                            distinctKeys,\n                            collation,\n                            type,\n                            nameMap.get(outerCall.toString()));\n            RexNode rex =\n                    rexBuilder.addAggCall(\n                            aggCall,\n                            groupExprs.size(),\n                            aggCalls,\n                            aggCallMapping,\n                            i -> convertedInputExprs.get(i).left.getType().isNullable());\n            aggMapping.put(outerCall, rex);\n        }",
          "conflictNames": [
              "call",
              "filter",
              "distinctList",
              "orderList",
              "ignoreNulls",
              "outerCall",
              "operands",
              "pos",
              "call2",
              "filter2",
              "operands2",
              "separator",
              "sepCall",
              "args",
              "filterArg",
              "distinctKeys",
              "sqlNodes",
              "flinkOperatorBinding",
              "i",
              "operand",
              "id",
              "convertedExpr",
              "relDataType",
              "distinctBuilder",
              "e",
              "aggFunction",
              "type",
              "distinct",
              "quantifier",
              "approximate",
              "collation",
              "aggCall",
              "rex"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/128b0c4442a7c8e8efd5f7f3151523fca394f91c^1/flink-table/flink-sql-client/src/test/java/org/apache/flink/table/client/cli/CliTableauResultViewTest.java",
      "locators": [
          {
              "line": 193,
              "column": 25
          },
          {
              "line": 204,
              "column": 52
          },
          {
              "line": 236,
              "column": 20
          },
          {
              "line": 247,
              "column": 25
          },
          {
              "line": 255,
              "column": 52
          },
          {
              "line": 262,
              "column": 23
          },
          {
              "line": 273,
              "column": 20
          },
          {
              "line": 275,
              "column": 20
          },
          {
              "line": 288,
              "column": 25
          },
          {
              "line": 298,
              "column": 52
          },
          {
              "line": 304,
              "column": 20
          },
          {
              "line": 315,
              "column": 25
          },
          {
              "line": 325,
              "column": 52
          },
          {
              "line": 335,
              "column": 20
          },
          {
              "line": 346,
              "column": 25
          },
          {
              "line": 361,
              "column": 52
          },
          {
              "line": 398,
              "column": 20
          },
          {
              "line": 409,
              "column": 25
          },
          {
              "line": 415,
              "column": 52
          },
          {
              "line": 430,
              "column": 20
          },
          {
              "line": 441,
              "column": 25
          },
          {
              "line": 451,
              "column": 52
          },
          {
              "line": 458,
              "column": 23
          },
          {
              "line": 484,
              "column": 20
          },
          {
              "line": 495,
              "column": 25
          },
          {
              "line": 507,
              "column": 52
          },
          {
              "line": 533,
              "column": 20
          }
      ],
      "old_name": "mockExecutor",
      "new_name": "collectResult",
      "ctx": {
          "symbolName": "mockExecutor",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestingExecutor",
          "scopeHint": "in testBatchResult(...)",
          "filePath": "CliTableauResultViewTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testBatchResult() {\n        final Configuration testConfig = new Configuration();\n        testConfig.set(EXECUTION_RESULT_MODE, ResultMode.TABLEAU);\n        testConfig.set(RUNTIME_MODE, RuntimeExecutionMode.BATCH);\n        ResultDescriptor resultDescriptor =\n                new ResultDescriptor(\"\", schema, true, testConfig, rowDataToStringConverter);\n\n        TestingExecutor mockExecutor =\n                new TestingExecutorBuilder()\n                        .setResultChangesSupplier(\n                                () -> TypedResult.payload(data.subList(0, data.size() / 2)),\n                                () ->\n                                        TypedResult.payload(\n                                                data.subList(data.size() / 2, data.size())),\n                                TypedResult::endOfStream)\n                        .build();\n\n        CliTableauResultView view =\n                new CliTableauResultView(terminal, mockExecutor, resultDescriptor);\n\n        view.displayResults();\n        view.close();\n        assertThat(terminalOutput)\n                .hasToString(\n                        \"+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+---------------------+\"\n                                + System.lineSeparator()\n                                + \"| boolean |         int |               bigint |                        varchar | decimal(10, 5) |                  timestamp |              binary |\"\n                                + System.lineSeparator()\n                                + \"+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+---------------------+\"\n                                + System.lineSeparator()\n                                + \"|  <NULL> |           1 |                    2 |                            abc |        1.23000 | 2020-03-01 18:39:14.000000 | x'32333485365d737e' |\"\n                                + System.lineSeparator()\n                                + \"|   FALSE |      <NULL> |                    0 |                                |        1.00000 | 2020-03-01 18:39:14.100000 |       x'649e207983' |\"\n                                + System.lineSeparator()\n                                + \"|    TRUE |  2147483647 |               <NULL> |                        abcdefg |    12345.00000 | 2020-03-01 18:39:14.120000 |         x'92e90102' |\"\n                                + System.lineSeparator()\n                                + \"|   FALSE | -2147483648 |  9223372036854775807 |                         <NULL> |    12345.06789 | 2020-03-01 18:39:14.123000 | x'32333485365d737e' |\"\n                                + System.lineSeparator()\n                                + \"|    TRUE |         100 | -9223372036854775808 |                     abcdefg111 |         <NULL> | 2020-03-01 18:39:14.123456 |         x'6e17fffe' |\"\n                                + System.lineSeparator()\n                                + \"|  <NULL> |          -1 |                   -1 |     abcdefghijklmnopqrstuvwxyz |   -12345.06789 |                     <NULL> |              <NULL> |\"\n                                + System.lineSeparator()\n                                + \"|  <NULL> |          -1 |                   -1 |                    |   -12345.06789 | 2020-03-04 18:39:14.000000 |   x'fdfeff00010203' |\"\n                                + System.lineSeparator()\n                                + \"|  <NULL> |          -1 |                   -1 |  ... |   -12345.06789 | 2020-03-04 18:39:14.000000 |   x'fdfeff00010203' |\"\n                                + System.lineSeparator()\n                                + \"+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+---------------------+\"\n                                + System.lineSeparator()\n                                + \"8 rows in set\"\n                                + System.lineSeparator());\n        assertThat(mockExecutor.getNumCancelCalls()).isZero();\n    }",
          "conflictNames": [
              "testConfig",
              "resultDescriptor",
              "view"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/128b0c4442a7c8e8efd5f7f3151523fca394f91c^1/flink-table/flink-sql-client/src/test/java/org/apache/flink/table/client/cli/CliTableauResultViewTest.java",
      "locators": [
          {
              "line": 193,
              "column": 25
          },
          {
              "line": 204,
              "column": 52
          },
          {
              "line": 236,
              "column": 20
          },
          {
              "line": 247,
              "column": 25
          },
          {
              "line": 255,
              "column": 52
          },
          {
              "line": 262,
              "column": 23
          },
          {
              "line": 273,
              "column": 20
          },
          {
              "line": 275,
              "column": 20
          },
          {
              "line": 288,
              "column": 25
          },
          {
              "line": 298,
              "column": 52
          },
          {
              "line": 304,
              "column": 20
          },
          {
              "line": 315,
              "column": 25
          },
          {
              "line": 325,
              "column": 52
          },
          {
              "line": 335,
              "column": 20
          },
          {
              "line": 346,
              "column": 25
          },
          {
              "line": 361,
              "column": 52
          },
          {
              "line": 398,
              "column": 20
          },
          {
              "line": 409,
              "column": 25
          },
          {
              "line": 415,
              "column": 52
          },
          {
              "line": 430,
              "column": 20
          },
          {
              "line": 441,
              "column": 25
          },
          {
              "line": 451,
              "column": 52
          },
          {
              "line": 458,
              "column": 23
          },
          {
              "line": 484,
              "column": 20
          },
          {
              "line": 495,
              "column": 25
          },
          {
              "line": 507,
              "column": 52
          },
          {
              "line": 533,
              "column": 20
          }
      ],
      "old_name": "mockExecutor",
      "new_name": "testChangelogResult",
      "ctx": {
          "symbolName": "mockExecutor",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestingExecutor",
          "scopeHint": "in testBatchResult(...)",
          "filePath": "CliTableauResultViewTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testBatchResult() {\n        final Configuration testConfig = new Configuration();\n        testConfig.set(EXECUTION_RESULT_MODE, ResultMode.TABLEAU);\n        testConfig.set(RUNTIME_MODE, RuntimeExecutionMode.BATCH);\n        ResultDescriptor resultDescriptor =\n                new ResultDescriptor(\"\", schema, true, testConfig, rowDataToStringConverter);\n\n        TestingExecutor mockExecutor =\n                new TestingExecutorBuilder()\n                        .setResultChangesSupplier(\n                                () -> TypedResult.payload(data.subList(0, data.size() / 2)),\n                                () ->\n                                        TypedResult.payload(\n                                                data.subList(data.size() / 2, data.size())),\n                                TypedResult::endOfStream)\n                        .build();\n\n        CliTableauResultView view =\n                new CliTableauResultView(terminal, mockExecutor, resultDescriptor);\n\n        view.displayResults();\n        view.close();\n        assertThat(terminalOutput)\n                .hasToString(\n                        \"+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+---------------------+\"\n                                + System.lineSeparator()\n                                + \"| boolean |         int |               bigint |                        varchar | decimal(10, 5) |                  timestamp |              binary |\"\n                                + System.lineSeparator()\n                                + \"+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+---------------------+\"\n                                + System.lineSeparator()\n                                + \"|  <NULL> |           1 |                    2 |                            abc |        1.23000 | 2020-03-01 18:39:14.000000 | x'32333485365d737e' |\"\n                                + System.lineSeparator()\n                                + \"|   FALSE |      <NULL> |                    0 |                                |        1.00000 | 2020-03-01 18:39:14.100000 |       x'649e207983' |\"\n                                + System.lineSeparator()\n                                + \"|    TRUE |  2147483647 |               <NULL> |                        abcdefg |    12345.00000 | 2020-03-01 18:39:14.120000 |         x'92e90102' |\"\n                                + System.lineSeparator()\n                                + \"|   FALSE | -2147483648 |  9223372036854775807 |                         <NULL> |    12345.06789 | 2020-03-01 18:39:14.123000 | x'32333485365d737e' |\"\n                                + System.lineSeparator()\n                                + \"|    TRUE |         100 | -9223372036854775808 |                     abcdefg111 |         <NULL> | 2020-03-01 18:39:14.123456 |         x'6e17fffe' |\"\n                                + System.lineSeparator()\n                                + \"|  <NULL> |          -1 |                   -1 |     abcdefghijklmnopqrstuvwxyz |   -12345.06789 |                     <NULL> |              <NULL> |\"\n                                + System.lineSeparator()\n                                + \"|  <NULL> |          -1 |                   -1 |                    |   -12345.06789 | 2020-03-04 18:39:14.000000 |   x'fdfeff00010203' |\"\n                                + System.lineSeparator()\n                                + \"|  <NULL> |          -1 |                   -1 |  ... |   -12345.06789 | 2020-03-04 18:39:14.000000 |   x'fdfeff00010203' |\"\n                                + System.lineSeparator()\n                                + \"+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+---------------------+\"\n                                + System.lineSeparator()\n                                + \"8 rows in set\"\n                                + System.lineSeparator());\n        assertThat(mockExecutor.getNumCancelCalls()).isZero();\n    }",
          "conflictNames": [
              "testConfig",
              "resultDescriptor",
              "view"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/128b0c4442a7c8e8efd5f7f3151523fca394f91c^1/flink-table/flink-sql-client/src/test/java/org/apache/flink/table/client/cli/CliTableauResultViewTest.java",
      "locators": [
          {
              "line": 193,
              "column": 25
          },
          {
              "line": 204,
              "column": 52
          },
          {
              "line": 236,
              "column": 20
          },
          {
              "line": 247,
              "column": 25
          },
          {
              "line": 255,
              "column": 52
          },
          {
              "line": 262,
              "column": 23
          },
          {
              "line": 273,
              "column": 20
          },
          {
              "line": 275,
              "column": 20
          },
          {
              "line": 288,
              "column": 25
          },
          {
              "line": 298,
              "column": 52
          },
          {
              "line": 304,
              "column": 20
          },
          {
              "line": 315,
              "column": 25
          },
          {
              "line": 325,
              "column": 52
          },
          {
              "line": 335,
              "column": 20
          },
          {
              "line": 346,
              "column": 25
          },
          {
              "line": 361,
              "column": 52
          },
          {
              "line": 398,
              "column": 20
          },
          {
              "line": 409,
              "column": 25
          },
          {
              "line": 415,
              "column": 52
          },
          {
              "line": 430,
              "column": 20
          },
          {
              "line": 441,
              "column": 25
          },
          {
              "line": 451,
              "column": 52
          },
          {
              "line": 458,
              "column": 23
          },
          {
              "line": 484,
              "column": 20
          },
          {
              "line": 495,
              "column": 25
          },
          {
              "line": 507,
              "column": 52
          },
          {
              "line": 533,
              "column": 20
          }
      ],
      "old_name": "mockExecutor",
      "new_name": "changelogResult",
      "ctx": {
          "symbolName": "mockExecutor",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestingExecutor",
          "scopeHint": "in testBatchResult(...)",
          "filePath": "CliTableauResultViewTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testBatchResult() {\n        final Configuration testConfig = new Configuration();\n        testConfig.set(EXECUTION_RESULT_MODE, ResultMode.TABLEAU);\n        testConfig.set(RUNTIME_MODE, RuntimeExecutionMode.BATCH);\n        ResultDescriptor resultDescriptor =\n                new ResultDescriptor(\"\", schema, true, testConfig, rowDataToStringConverter);\n\n        TestingExecutor mockExecutor =\n                new TestingExecutorBuilder()\n                        .setResultChangesSupplier(\n                                () -> TypedResult.payload(data.subList(0, data.size() / 2)),\n                                () ->\n                                        TypedResult.payload(\n                                                data.subList(data.size() / 2, data.size())),\n                                TypedResult::endOfStream)\n                        .build();\n\n        CliTableauResultView view =\n                new CliTableauResultView(terminal, mockExecutor, resultDescriptor);\n\n        view.displayResults();\n        view.close();\n        assertThat(terminalOutput)\n                .hasToString(\n                        \"+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+---------------------+\"\n                                + System.lineSeparator()\n                                + \"| boolean |         int |               bigint |                        varchar | decimal(10, 5) |                  timestamp |              binary |\"\n                                + System.lineSeparator()\n                                + \"+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+---------------------+\"\n                                + System.lineSeparator()\n                                + \"|  <NULL> |           1 |                    2 |                            abc |        1.23000 | 2020-03-01 18:39:14.000000 | x'32333485365d737e' |\"\n                                + System.lineSeparator()\n                                + \"|   FALSE |      <NULL> |                    0 |                                |        1.00000 | 2020-03-01 18:39:14.100000 |       x'649e207983' |\"\n                                + System.lineSeparator()\n                                + \"|    TRUE |  2147483647 |               <NULL> |                        abcdefg |    12345.00000 | 2020-03-01 18:39:14.120000 |         x'92e90102' |\"\n                                + System.lineSeparator()\n                                + \"|   FALSE | -2147483648 |  9223372036854775807 |                         <NULL> |    12345.06789 | 2020-03-01 18:39:14.123000 | x'32333485365d737e' |\"\n                                + System.lineSeparator()\n                                + \"|    TRUE |         100 | -9223372036854775808 |                     abcdefg111 |         <NULL> | 2020-03-01 18:39:14.123456 |         x'6e17fffe' |\"\n                                + System.lineSeparator()\n                                + \"|  <NULL> |          -1 |                   -1 |     abcdefghijklmnopqrstuvwxyz |   -12345.06789 |                     <NULL> |              <NULL> |\"\n                                + System.lineSeparator()\n                                + \"|  <NULL> |          -1 |                   -1 |                    |   -12345.06789 | 2020-03-04 18:39:14.000000 |   x'fdfeff00010203' |\"\n                                + System.lineSeparator()\n                                + \"|  <NULL> |          -1 |                   -1 |  ... |   -12345.06789 | 2020-03-04 18:39:14.000000 |   x'fdfeff00010203' |\"\n                                + System.lineSeparator()\n                                + \"+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+---------------------+\"\n                                + System.lineSeparator()\n                                + \"8 rows in set\"\n                                + System.lineSeparator());\n        assertThat(mockExecutor.getNumCancelCalls()).isZero();\n    }",
          "conflictNames": [
              "testConfig",
              "resultDescriptor",
              "view"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/12ee2993707e01fa665eaa35795f25c62c946d11^1/flink-runtime/src/test/java/org/apache/flink/runtime/asyncprocessing/operators/AbstractAsyncStateStreamOperatorTest.java",
      "locators": [
          {
              "line": 102,
              "column": 29
          },
          {
              "line": 104,
              "column": 13
          },
          {
              "line": 118,
              "column": 13
          },
          {
              "line": 132,
              "column": 29
          },
          {
              "line": 134,
              "column": 13
          },
          {
              "line": 150,
              "column": 13
          },
          {
              "line": 174,
              "column": 29
          },
          {
              "line": 176,
              "column": 13
          },
          {
              "line": 192,
              "column": 13
          },
          {
              "line": 258,
              "column": 29
          },
          {
              "line": 259,
              "column": 13
          },
          {
              "line": 277,
              "column": 13
          },
          {
              "line": 292,
              "column": 29
          },
          {
              "line": 293,
              "column": 13
          },
          {
              "line": 313,
              "column": 13
          }
      ],
      "old_name": "anotherThread",
      "new_name": "executorService",
      "ctx": {
          "symbolName": "anotherThread",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ExecutorService",
          "scopeHint": "in testRecordProcessorWithFirstStateOrder(...)",
          "filePath": "AbstractAsyncStateStreamOperatorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testRecordProcessorWithFirstStateOrder() throws Exception {\n        try (KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String>\n                testHarness = createTestHarness(128, 1, 0, ElementOrder.FIRST_STATE_ORDER)) {\n            testHarness.open();\n            TestOperator testOperator = (TestOperator) testHarness.getOperator();\n            ThrowingConsumer<StreamRecord<Tuple2<Integer, String>>, Exception> processor =\n                    RecordProcessorUtils.getRecordProcessor(testOperator);\n            ExecutorService anotherThread = Executors.newSingleThreadExecutor();\n            // Trigger the processor\n            anotherThread.execute(\n                    () -> {\n                        try {\n                            processor.accept(new StreamRecord<>(Tuple2.of(5, \"5\")));\n                        } catch (Exception e) {\n                        }\n                    });\n\n            Thread.sleep(1000);\n            assertThat(testOperator.getProcessed()).isEqualTo(1);\n            assertThat(testOperator.getCurrentProcessingContext().getReferenceCount()).isEqualTo(1);\n\n            // Proceed processing\n            testOperator.proceed();\n            anotherThread.shutdown();\n            Thread.sleep(1000);\n            assertThat(testOperator.getCurrentProcessingContext().getReferenceCount()).isEqualTo(0);\n        }\n    }",
          "conflictNames": [
              "testHarness",
              "testOperator",
              "processor"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/133ffab4f19b91d5a5fba58684e2a30a6b8b31c7^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/HsFullSpillingStrategy.java",
      "locators": [
          {
              "line": 131,
              "column": 13
          },
          {
              "line": 133,
              "column": 39
          }
      ],
      "old_name": "survivedNum",
      "new_name": "releaseNum",
      "ctx": {
          "symbolName": "survivedNum",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in checkRelease(...)",
          "filePath": "HsFullSpillingStrategy.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Release subpartition's spilled buffer from head. Each subpartition fairly retains a fixed\n     * number of buffers, and all the remaining buffers are released. If this subpartition does not\n     * have so many qualified buffers, all of them will be retained.\n     */\n    private void checkRelease(\n            HsSpillingInfoProvider spillingInfoProvider, int poolSize, Decision.Builder builder) {\n        if (spillingInfoProvider.getNumTotalRequestedBuffers() < poolSize * releaseThreshold) {\n            // In case situation changed since onMemoryUsageChanged() returns Optional#empty()\n            return;\n        }\n\n        int survivedNum = (int) (poolSize - poolSize * releaseBufferRatio);\n        int numSubpartitions = spillingInfoProvider.getNumSubpartitions();\n        int subpartitionSurvivedNum = survivedNum / numSubpartitions;\n\n        TreeMap<Integer, Deque<BufferIndexAndChannel>> bufferToRelease = new TreeMap<>();\n\n        for (int subpartitionId = 0; subpartitionId < numSubpartitions; subpartitionId++) {\n            Deque<BufferIndexAndChannel> buffersInOrder =\n                    spillingInfoProvider.getBuffersInOrder(\n                            subpartitionId, SpillStatus.SPILL, ConsumeStatusWithId.ALL_ANY);\n            // if the number of subpartition buffers less than survived buffers, reserved all of\n            // them.\n            int releaseNum = Math.max(0, buffersInOrder.size() - subpartitionSurvivedNum);\n            while (releaseNum-- != 0) {\n                buffersInOrder.pollLast();\n            }\n            bufferToRelease.put(subpartitionId, buffersInOrder);\n        }\n\n        // collect results in order\n        for (int i = 0; i < numSubpartitions; i++) {\n            builder.addBufferToRelease(i, bufferToRelease.getOrDefault(i, new ArrayDeque<>()));\n        }\n    }",
          "conflictNames": [
              "spillingInfoProvider",
              "poolSize",
              "builder",
              "numSubpartitions",
              "subpartitionSurvivedNum",
              "bufferToRelease",
              "subpartitionId",
              "buffersInOrder",
              "releaseNum",
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/133ffab4f19b91d5a5fba58684e2a30a6b8b31c7^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/HsFullSpillingStrategy.java",
      "locators": [
          {
              "line": 143,
              "column": 17
          },
          {
              "line": 144,
              "column": 20
          }
      ],
      "old_name": "releaseNum",
      "new_name": "subpartitionSurvivedNum",
      "ctx": {
          "symbolName": "releaseNum",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in checkRelease(...)",
          "filePath": "HsFullSpillingStrategy.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Release subpartition's spilled buffer from head. Each subpartition fairly retains a fixed\n     * number of buffers, and all the remaining buffers are released. If this subpartition does not\n     * have so many qualified buffers, all of them will be retained.\n     */\n    private void checkRelease(\n            HsSpillingInfoProvider spillingInfoProvider, int poolSize, Decision.Builder builder) {\n        if (spillingInfoProvider.getNumTotalRequestedBuffers() < poolSize * releaseThreshold) {\n            // In case situation changed since onMemoryUsageChanged() returns Optional#empty()\n            return;\n        }\n\n        int survivedNum = (int) (poolSize - poolSize * releaseBufferRatio);\n        int numSubpartitions = spillingInfoProvider.getNumSubpartitions();\n        int subpartitionSurvivedNum = survivedNum / numSubpartitions;\n\n        TreeMap<Integer, Deque<BufferIndexAndChannel>> bufferToRelease = new TreeMap<>();\n\n        for (int subpartitionId = 0; subpartitionId < numSubpartitions; subpartitionId++) {\n            Deque<BufferIndexAndChannel> buffersInOrder =\n                    spillingInfoProvider.getBuffersInOrder(\n                            subpartitionId, SpillStatus.SPILL, ConsumeStatusWithId.ALL_ANY);\n            // if the number of subpartition buffers less than survived buffers, reserved all of\n            // them.\n            int releaseNum = Math.max(0, buffersInOrder.size() - subpartitionSurvivedNum);\n            while (releaseNum-- != 0) {\n                buffersInOrder.pollLast();\n            }\n            bufferToRelease.put(subpartitionId, buffersInOrder);\n        }\n\n        // collect results in order\n        for (int i = 0; i < numSubpartitions; i++) {\n            builder.addBufferToRelease(i, bufferToRelease.getOrDefault(i, new ArrayDeque<>()));\n        }\n    }",
          "conflictNames": [
              "spillingInfoProvider",
              "poolSize",
              "builder",
              "survivedNum",
              "numSubpartitions",
              "subpartitionSurvivedNum",
              "bufferToRelease",
              "subpartitionId",
              "buffersInOrder",
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/1389856a6412eca4fd738e4cd37c6ef157e4dee1^1/flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializerSnapshot.java",
      "locators": [
          {
              "line": 99,
              "column": 27
          },
          {
              "line": 100,
              "column": 13
          },
          {
              "line": 103,
              "column": 43
          }
      ],
      "old_name": "kryoSerializer",
      "new_name": "oldKryoSerializerSnapshot",
      "ctx": {
          "symbolName": "kryoSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "KryoSerializer<T>",
          "scopeHint": "in resolveSchemaCompatibility(...)",
          "filePath": "KryoSerializerSnapshot.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(\n            TypeSerializer<T> newSerializer) {\n        if (!(newSerializer instanceof KryoSerializer)) {\n            return TypeSerializerSchemaCompatibility.incompatible();\n        }\n        KryoSerializer<T> kryoSerializer = (KryoSerializer<T>) newSerializer;\n        if (kryoSerializer.getType() != snapshotData.getTypeClass()) {\n            return TypeSerializerSchemaCompatibility.incompatible();\n        }\n        return resolveSchemaCompatibility(kryoSerializer);\n    }",
          "conflictNames": [
              "newSerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/1420ee7ed69a3ce72eab8027570cc3af9fa828a3^1/flink-connectors/flink-connector-files/src/main/java/org/apache/flink/connector/file/table/FileSystemOutputFormat.java",
      "locators": [
          {
              "line": 144,
              "column": 40
          },
          {
              "line": 152,
              "column": 37
          }
      ],
      "old_name": "context",
      "new_name": "writerContext",
      "ctx": {
          "symbolName": "context",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Context<T>",
          "scopeHint": "in open(...)",
          "filePath": "FileSystemOutputFormat.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void open(int taskNumber, int numTasks) throws IOException {\n        try {\n            PartitionTempFileManager fileManager =\n                    new PartitionTempFileManager(fsFactory, tmpPath, taskNumber, outputFileConfig);\n            PartitionWriter.Context<T> context =\n                    new PartitionWriter.Context<>(parameters, formatFactory);\n            writer =\n                    PartitionWriterFactory.<T>get(\n                                    partitionColumns.length - staticPartitions.size() > 0,\n                                    dynamicGrouped,\n                                    staticPartitions)\n                            .create(\n                                    context,\n                                    fileManager,\n                                    computer,\n                                    new PartitionWriter.DefaultPartitionWriterListener());\n        } catch (Exception e) {\n            throw new TableException(\"Exception in open\", e);\n        }\n    }",
          "conflictNames": [
              "taskNumber",
              "numTasks",
              "fileManager"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/14fdd13b632ac2dc54194d7496390021277f8991^1/flink-core/src/test/java/org/apache/flink/core/fs/RefCountedFileWithStreamTest.java",
      "locators": [
          {
              "line": 45,
              "column": 40
          },
          {
              "line": 46,
              "column": 27
          },
          {
              "line": 59,
              "column": 40
          },
          {
              "line": 62,
              "column": 9
          },
          {
              "line": 67,
              "column": 40
          },
          {
              "line": 69,
              "column": 9
          },
          {
              "line": 91,
              "column": 40
          },
          {
              "line": 94,
              "column": 9
          },
          {
              "line": 96,
              "column": 9
          },
          {
              "line": 97,
              "column": 16
          }
      ],
      "old_name": "fileUnderTest",
      "new_name": "fileUnderTest1",
      "ctx": {
          "symbolName": "fileUnderTest",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RefCountedFileWithStream",
          "scopeHint": "in writeShouldSucceed(...)",
          "filePath": "RefCountedFileWithStreamTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void writeShouldSucceed() throws IOException {\n        byte[] content = bytesOf(\"hello world\");\n\n        final RefCountedFileWithStream fileUnderTest = getClosedRefCountedFileWithContent(content);\n        long fileLength = fileUnderTest.getLength();\n\n        Assert.assertEquals(content.length, fileLength);\n    }",
          "conflictNames": [
              "content",
              "fileLength"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/1534ea751613772d93699e1916e38f3af3dac7f9^1/flink-table/flink-sql-client/src/test/java/org/apache/flink/table/client/gateway/local/LocalExecutorITCase.java",
      "locators": [
          {
              "line": 420,
              "column": 23
          },
          {
              "line": 421,
              "column": 27
          },
          {
              "line": 427,
              "column": 29
          }
      ],
      "old_name": "jobClient",
      "new_name": "jobID",
      "ctx": {
          "symbolName": "jobClient",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobClient",
          "scopeHint": "in testStopJob(...)",
          "filePath": "LocalExecutorITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testStopJob() throws Exception {\n        final Map<String, String> configMap = new HashMap<>();\n        configMap.put(EXECUTION_RESULT_MODE.key(), ResultMode.TABLE.name());\n        configMap.put(RUNTIME_MODE.key(), RuntimeExecutionMode.STREAMING.name());\n        configMap.put(TableConfigOptions.TABLE_DML_SYNC.key(), \"false\");\n\n        final LocalExecutor executor =\n                createLocalExecutor(\n                        Collections.singletonList(udfDependency), Configuration.fromMap(configMap));\n        executor.openSession(\"test-session\");\n\n        final String srcDdl = \"CREATE TABLE src (a STRING) WITH ('connector' = 'datagen')\";\n        final String snkDdl = \"CREATE TABLE snk (a STRING) WITH ('connector' = 'blackhole')\";\n        final String insert = \"INSERT INTO snk SELECT a FROM src;\";\n\n        try {\n            executor.executeOperation(executor.parseStatement(srcDdl));\n            executor.executeOperation(executor.parseStatement(snkDdl));\n            TableResult result = executor.executeOperation(executor.parseStatement(insert));\n            JobClient jobClient = result.getJobClient().get();\n            JobID jobId = jobClient.getJobID();\n\n            // wait till the job turns into running status or the test times out\n            JobStatus jobStatus;\n            do {\n                Thread.sleep(2_000L);\n                jobStatus = jobClient.getJobStatus().get();\n            } while (jobStatus != JobStatus.RUNNING);\n\n            Optional<String> savepoint = executor.stopJob(jobId.toString(), true, true);\n            assertThat(savepoint).isPresent();\n        } finally {\n            executor.closeSession();\n        }\n    }",
          "conflictNames": [
              "configMap",
              "executor",
              "srcDdl",
              "snkDdl",
              "insert",
              "result",
              "jobId",
              "jobStatus",
              "savepoint"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/161014149e803bfd1d3653badb230b2ed36ce3cb^1/flink-formats/flink-parquet/src/main/java/org/apache/flink/formats/parquet/vector/ParquetSplitReaderUtil.java",
      "locators": [
          {
              "line": 366,
              "column": 35
          },
          {
              "line": 380,
              "column": 44
          }
      ],
      "old_name": "keyReader",
      "new_name": "mapKeyReader",
      "ctx": {
          "symbolName": "keyReader",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ArrayColumnReader",
          "scopeHint": "in createColumnReader(...)",
          "filePath": "ParquetSplitReaderUtil.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static ColumnReader createColumnReader(\n            boolean isUtcTimestamp,\n            LogicalType fieldType,\n            Type type,\n            List<ColumnDescriptor> columnDescriptors,\n            PageReadStore pages,\n            int depth)\n            throws IOException {\n        List<ColumnDescriptor> descriptors =\n                getAllColumnDescriptorByType(depth, type, columnDescriptors);\n        switch (fieldType.getTypeRoot()) {\n            case BOOLEAN:\n                return new BooleanColumnReader(\n                        descriptors.get(0), pages.getPageReader(descriptors.get(0)));\n            case TINYINT:\n                return new ByteColumnReader(\n                        descriptors.get(0), pages.getPageReader(descriptors.get(0)));\n            case DOUBLE:\n                return new DoubleColumnReader(\n                        descriptors.get(0), pages.getPageReader(descriptors.get(0)));\n            case FLOAT:\n                return new FloatColumnReader(\n                        descriptors.get(0), pages.getPageReader(descriptors.get(0)));\n            case INTEGER:\n            case DATE:\n            case TIME_WITHOUT_TIME_ZONE:\n                return new IntColumnReader(\n                        descriptors.get(0), pages.getPageReader(descriptors.get(0)));\n            case BIGINT:\n                return new LongColumnReader(\n                        descriptors.get(0), pages.getPageReader(descriptors.get(0)));\n            case SMALLINT:\n                return new ShortColumnReader(\n                        descriptors.get(0), pages.getPageReader(descriptors.get(0)));\n            case CHAR:\n            case VARCHAR:\n            case BINARY:\n            case VARBINARY:\n                return new BytesColumnReader(\n                        descriptors.get(0), pages.getPageReader(descriptors.get(0)));\n            case TIMESTAMP_WITHOUT_TIME_ZONE:\n            case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n                return new TimestampColumnReader(\n                        isUtcTimestamp,\n                        descriptors.get(0),\n                        pages.getPageReader(descriptors.get(0)));\n            case DECIMAL:\n                switch (descriptors.get(0).getPrimitiveType().getPrimitiveTypeName()) {\n                    case INT32:\n                        return new IntColumnReader(\n                                descriptors.get(0), pages.getPageReader(descriptors.get(0)));\n                    case INT64:\n                        return new LongColumnReader(\n                                descriptors.get(0), pages.getPageReader(descriptors.get(0)));\n                    case BINARY:\n                        return new BytesColumnReader(\n                                descriptors.get(0), pages.getPageReader(descriptors.get(0)));\n                    case FIXED_LEN_BYTE_ARRAY:\n                        return new FixedLenBytesColumnReader(\n                                descriptors.get(0),\n                                pages.getPageReader(descriptors.get(0)),\n                                ((DecimalType) fieldType).getPrecision());\n                }\n            case ARRAY:\n                return new ArrayColumnReader(\n                        descriptors.get(0),\n                        pages.getPageReader(descriptors.get(0)),\n                        isUtcTimestamp,\n                        descriptors.get(0).getPrimitiveType(),\n                        fieldType);\n            case MAP:\n                MapType mapType = (MapType) fieldType;\n                ArrayColumnReader keyReader =\n                        new ArrayColumnReader(\n                                descriptors.get(0),\n                                pages.getPageReader(descriptors.get(0)),\n                                isUtcTimestamp,\n                                descriptors.get(0).getPrimitiveType(),\n                                new ArrayType(mapType.getKeyType()));\n                ArrayColumnReader valueReader =\n                        new ArrayColumnReader(\n                                descriptors.get(1),\n                                pages.getPageReader(descriptors.get(1)),\n                                isUtcTimestamp,\n                                descriptors.get(1).getPrimitiveType(),\n                                new ArrayType(mapType.getValueType()));\n                return new MapColumnReader(keyReader, valueReader);\n            case ROW:\n                RowType rowType = (RowType) fieldType;\n                GroupType groupType = type.asGroupType();\n                List<ColumnReader> fieldReaders = new ArrayList<>();\n                for (int i = 0; i < rowType.getFieldCount(); i++) {\n                    fieldReaders.add(\n                            createColumnReader(\n                                    isUtcTimestamp,\n                                    rowType.getTypeAt(i),\n                                    groupType.getType(i),\n                                    descriptors,\n                                    pages,\n                                    depth + 1));\n                }\n                return new RowColumnReader(fieldReaders);\n            default:\n                throw new UnsupportedOperationException(fieldType + \" is not supported now.\");\n        }\n    }",
          "conflictNames": [
              "isUtcTimestamp",
              "fieldType",
              "type",
              "columnDescriptors",
              "pages",
              "depth",
              "descriptors",
              "mapType",
              "valueReader",
              "rowType",
              "groupType",
              "fieldReaders",
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/161014149e803bfd1d3653badb230b2ed36ce3cb^1/flink-formats/flink-parquet/src/main/java/org/apache/flink/formats/parquet/vector/ParquetSplitReaderUtil.java",
      "locators": [
          {
              "line": 373,
              "column": 35
          },
          {
              "line": 380,
              "column": 55
          }
      ],
      "old_name": "valueReader",
      "new_name": "mapValueReader",
      "ctx": {
          "symbolName": "valueReader",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ArrayColumnReader",
          "scopeHint": "in createColumnReader(...)",
          "filePath": "ParquetSplitReaderUtil.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static ColumnReader createColumnReader(\n            boolean isUtcTimestamp,\n            LogicalType fieldType,\n            Type type,\n            List<ColumnDescriptor> columnDescriptors,\n            PageReadStore pages,\n            int depth)\n            throws IOException {\n        List<ColumnDescriptor> descriptors =\n                getAllColumnDescriptorByType(depth, type, columnDescriptors);\n        switch (fieldType.getTypeRoot()) {\n            case BOOLEAN:\n                return new BooleanColumnReader(\n                        descriptors.get(0), pages.getPageReader(descriptors.get(0)));\n            case TINYINT:\n                return new ByteColumnReader(\n                        descriptors.get(0), pages.getPageReader(descriptors.get(0)));\n            case DOUBLE:\n                return new DoubleColumnReader(\n                        descriptors.get(0), pages.getPageReader(descriptors.get(0)));\n            case FLOAT:\n                return new FloatColumnReader(\n                        descriptors.get(0), pages.getPageReader(descriptors.get(0)));\n            case INTEGER:\n            case DATE:\n            case TIME_WITHOUT_TIME_ZONE:\n                return new IntColumnReader(\n                        descriptors.get(0), pages.getPageReader(descriptors.get(0)));\n            case BIGINT:\n                return new LongColumnReader(\n                        descriptors.get(0), pages.getPageReader(descriptors.get(0)));\n            case SMALLINT:\n                return new ShortColumnReader(\n                        descriptors.get(0), pages.getPageReader(descriptors.get(0)));\n            case CHAR:\n            case VARCHAR:\n            case BINARY:\n            case VARBINARY:\n                return new BytesColumnReader(\n                        descriptors.get(0), pages.getPageReader(descriptors.get(0)));\n            case TIMESTAMP_WITHOUT_TIME_ZONE:\n            case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n                return new TimestampColumnReader(\n                        isUtcTimestamp,\n                        descriptors.get(0),\n                        pages.getPageReader(descriptors.get(0)));\n            case DECIMAL:\n                switch (descriptors.get(0).getPrimitiveType().getPrimitiveTypeName()) {\n                    case INT32:\n                        return new IntColumnReader(\n                                descriptors.get(0), pages.getPageReader(descriptors.get(0)));\n                    case INT64:\n                        return new LongColumnReader(\n                                descriptors.get(0), pages.getPageReader(descriptors.get(0)));\n                    case BINARY:\n                        return new BytesColumnReader(\n                                descriptors.get(0), pages.getPageReader(descriptors.get(0)));\n                    case FIXED_LEN_BYTE_ARRAY:\n                        return new FixedLenBytesColumnReader(\n                                descriptors.get(0),\n                                pages.getPageReader(descriptors.get(0)),\n                                ((DecimalType) fieldType).getPrecision());\n                }\n            case ARRAY:\n                return new ArrayColumnReader(\n                        descriptors.get(0),\n                        pages.getPageReader(descriptors.get(0)),\n                        isUtcTimestamp,\n                        descriptors.get(0).getPrimitiveType(),\n                        fieldType);\n            case MAP:\n                MapType mapType = (MapType) fieldType;\n                ArrayColumnReader keyReader =\n                        new ArrayColumnReader(\n                                descriptors.get(0),\n                                pages.getPageReader(descriptors.get(0)),\n                                isUtcTimestamp,\n                                descriptors.get(0).getPrimitiveType(),\n                                new ArrayType(mapType.getKeyType()));\n                ArrayColumnReader valueReader =\n                        new ArrayColumnReader(\n                                descriptors.get(1),\n                                pages.getPageReader(descriptors.get(1)),\n                                isUtcTimestamp,\n                                descriptors.get(1).getPrimitiveType(),\n                                new ArrayType(mapType.getValueType()));\n                return new MapColumnReader(keyReader, valueReader);\n            case ROW:\n                RowType rowType = (RowType) fieldType;\n                GroupType groupType = type.asGroupType();\n                List<ColumnReader> fieldReaders = new ArrayList<>();\n                for (int i = 0; i < rowType.getFieldCount(); i++) {\n                    fieldReaders.add(\n                            createColumnReader(\n                                    isUtcTimestamp,\n                                    rowType.getTypeAt(i),\n                                    groupType.getType(i),\n                                    descriptors,\n                                    pages,\n                                    depth + 1));\n                }\n                return new RowColumnReader(fieldReaders);\n            default:\n                throw new UnsupportedOperationException(fieldType + \" is not supported now.\");\n        }\n    }",
          "conflictNames": [
              "isUtcTimestamp",
              "fieldType",
              "type",
              "columnDescriptors",
              "pages",
              "depth",
              "descriptors",
              "mapType",
              "keyReader",
              "rowType",
              "groupType",
              "fieldReaders",
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/161014149e803bfd1d3653badb230b2ed36ce3cb^1/flink-formats/flink-parquet/src/main/java/org/apache/flink/formats/parquet/vector/ParquetSplitReaderUtil.java",
      "locators": [
          {
              "line": 511,
              "column": 27
          },
          {
              "line": 517,
              "column": 33
          },
          {
              "line": 523,
              "column": 33
          }
      ],
      "old_name": "repeatedType",
      "new_name": "mapRepeatedType",
      "ctx": {
          "symbolName": "repeatedType",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "GroupType",
          "scopeHint": "in createWritableColumnVector(...)",
          "filePath": "ParquetSplitReaderUtil.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static WritableColumnVector createWritableColumnVector(\n            int batchSize,\n            LogicalType fieldType,\n            Type type,\n            List<ColumnDescriptor> columnDescriptors,\n            int depth) {\n        List<ColumnDescriptor> descriptors =\n                getAllColumnDescriptorByType(depth, type, columnDescriptors);\n        PrimitiveType primitiveType = descriptors.get(0).getPrimitiveType();\n        PrimitiveType.PrimitiveTypeName typeName = primitiveType.getPrimitiveTypeName();\n        switch (fieldType.getTypeRoot()) {\n            case BOOLEAN:\n                checkArgument(\n                        typeName == PrimitiveType.PrimitiveTypeName.BOOLEAN,\n                        \"Unexpected type: %s\",\n                        typeName);\n                return new HeapBooleanVector(batchSize);\n            case TINYINT:\n                checkArgument(\n                        typeName == PrimitiveType.PrimitiveTypeName.INT32,\n                        \"Unexpected type: %s\",\n                        typeName);\n                return new HeapByteVector(batchSize);\n            case DOUBLE:\n                checkArgument(\n                        typeName == PrimitiveType.PrimitiveTypeName.DOUBLE,\n                        \"Unexpected type: %s\",\n                        typeName);\n                return new HeapDoubleVector(batchSize);\n            case FLOAT:\n                checkArgument(\n                        typeName == PrimitiveType.PrimitiveTypeName.FLOAT,\n                        \"Unexpected type: %s\",\n                        typeName);\n                return new HeapFloatVector(batchSize);\n            case INTEGER:\n            case DATE:\n            case TIME_WITHOUT_TIME_ZONE:\n                checkArgument(\n                        typeName == PrimitiveType.PrimitiveTypeName.INT32,\n                        \"Unexpected type: %s\",\n                        typeName);\n                return new HeapIntVector(batchSize);\n            case BIGINT:\n                checkArgument(\n                        typeName == PrimitiveType.PrimitiveTypeName.INT64,\n                        \"Unexpected type: %s\",\n                        typeName);\n                return new HeapLongVector(batchSize);\n            case SMALLINT:\n                checkArgument(\n                        typeName == PrimitiveType.PrimitiveTypeName.INT32,\n                        \"Unexpected type: %s\",\n                        typeName);\n                return new HeapShortVector(batchSize);\n            case CHAR:\n            case VARCHAR:\n            case BINARY:\n            case VARBINARY:\n                checkArgument(\n                        typeName == PrimitiveType.PrimitiveTypeName.BINARY,\n                        \"Unexpected type: %s\",\n                        typeName);\n                return new HeapBytesVector(batchSize);\n            case TIMESTAMP_WITHOUT_TIME_ZONE:\n            case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n                checkArgument(\n                        typeName == PrimitiveType.PrimitiveTypeName.INT96,\n                        \"Unexpected type: %s\",\n                        typeName);\n                return new HeapTimestampVector(batchSize);\n            case DECIMAL:\n                DecimalType decimalType = (DecimalType) fieldType;\n                if (ParquetSchemaConverter.is32BitDecimal(decimalType.getPrecision())) {\n                    checkArgument(\n                            (typeName == PrimitiveType.PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY\n                                            || typeName == PrimitiveType.PrimitiveTypeName.INT32)\n                                    && primitiveType.getOriginalType() == OriginalType.DECIMAL,\n                            \"Unexpected type: %s\",\n                            typeName);\n                    return new HeapIntVector(batchSize);\n                } else if (ParquetSchemaConverter.is64BitDecimal(decimalType.getPrecision())) {\n                    checkArgument(\n                            (typeName == PrimitiveType.PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY\n                                            || typeName == PrimitiveType.PrimitiveTypeName.INT64)\n                                    && primitiveType.getOriginalType() == OriginalType.DECIMAL,\n                            \"Unexpected type: %s\",\n                            typeName);\n                    return new HeapLongVector(batchSize);\n                } else {\n                    checkArgument(\n                            (typeName == PrimitiveType.PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY\n                                            || typeName == PrimitiveType.PrimitiveTypeName.BINARY)\n                                    && primitiveType.getOriginalType() == OriginalType.DECIMAL,\n                            \"Unexpected type: %s\",\n                            typeName);\n                    return new HeapBytesVector(batchSize);\n                }\n            case ARRAY:\n                ArrayType arrayType = (ArrayType) fieldType;\n                return new HeapArrayVector(\n                        batchSize,\n                        createWritableColumnVector(\n                                batchSize,\n                                arrayType.getElementType(),\n                                type,\n                                columnDescriptors,\n                                depth));\n            case MAP:\n                MapType mapType = (MapType) fieldType;\n                GroupType repeatedType = type.asGroupType().getType(0).asGroupType();\n                return new HeapMapVector(\n                        batchSize,\n                        createWritableColumnVector(\n                                batchSize,\n                                mapType.getKeyType(),\n                                repeatedType.getType(0),\n                                descriptors,\n                                depth + 2),\n                        createWritableColumnVector(\n                                batchSize,\n                                mapType.getValueType(),\n                                repeatedType.getType(1),\n                                descriptors,\n                                depth + 2));\n            case ROW:\n                RowType rowType = (RowType) fieldType;\n                GroupType groupType = type.asGroupType();\n                WritableColumnVector[] columnVectors =\n                        new WritableColumnVector[rowType.getFieldCount()];\n                for (int i = 0; i < columnVectors.length; i++) {\n                    columnVectors[i] =\n                            createWritableColumnVector(\n                                    batchSize,\n                                    rowType.getTypeAt(i),\n                                    groupType.getType(i),\n                                    descriptors,\n                                    depth + 1);\n                }\n                return new HeapRowVector(batchSize, columnVectors);\n            default:\n                throw new UnsupportedOperationException(fieldType + \" is not supported now.\");\n        }\n    }",
          "conflictNames": [
              "batchSize",
              "fieldType",
              "type",
              "columnDescriptors",
              "depth",
              "descriptors",
              "primitiveType",
              "typeName",
              "decimalType",
              "arrayType",
              "mapType",
              "rowType",
              "groupType",
              "columnVectors",
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/18c03f2e6c593a772f64cdb5c089e2911d3cbc89^1/flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/LatencyMarkerITCase.java",
      "locators": [
          {
              "line": 63,
              "column": 28
          },
          {
              "line": 73,
              "column": 17
          }
      ],
      "old_name": "streamWithoutData",
      "new_name": "dataStream",
      "ctx": {
          "symbolName": "streamWithoutData",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "DataStream<String>",
          "scopeHint": "in testBroadcast(...)",
          "filePath": "LatencyMarkerITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "\n    /**\n     * FLINK-17780: Tests that streams are not corrupted/records lost when using latency markers\n     * with broadcast.\n     */\n    @Test\n    public void testBroadcast() throws Exception {\n        int inputCount = 100000;\n        int parallelism = 4;\n\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.setParallelism(parallelism);\n        env.getConfig().setLatencyTrackingInterval(2000);\n        env.setRestartStrategy(RestartStrategies.noRestart());\n\n        List<Integer> broadcastData =\n                IntStream.range(0, inputCount).boxed().collect(Collectors.toList());\n        DataStream<Integer> broadcastDataStream =\n                env.fromCollection(broadcastData).setParallelism(1);\n\n        // broadcast the configurations and create the broadcast state\n\n        DataStream<String> streamWithoutData =\n                env.fromCollection(Collections.emptyList(), TypeInformation.of(String.class));\n\n        MapStateDescriptor<String, Integer> stateDescriptor =\n                new MapStateDescriptor<>(\n                        \"BroadcastState\",\n                        BasicTypeInfo.STRING_TYPE_INFO,\n                        BasicTypeInfo.INT_TYPE_INFO);\n\n        SingleOutputStreamOperator<Integer> processor =\n                streamWithoutData\n                        .connect(broadcastDataStream.broadcast(stateDescriptor))\n                        .process(\n                                new BroadcastProcessFunction<String, Integer, Integer>() {\n                                    int expected = 0;\n\n                                    public void processElement(\n                                            String value,\n                                            ReadOnlyContext ctx,\n                                            Collector<Integer> out) {}\n\n                                    public void processBroadcastElement(\n                                            Integer value, Context ctx, Collector<Integer> out) {\n                                        if (value != expected++) {\n                                            throw new AssertionError(\n                                                    String.format(\n                                                            \"Value was supposed to be: '%s', but was: '%s'\",\n                                                            expected - 1, value));\n                                        }\n                                        out.collect(value);\n                                    }\n                                });\n\n        processor.addSink(new AccumulatorCountingSink<>()).setParallelism(1);\n\n        JobExecutionResult executionResult = env.execute();\n\n        Integer count =\n                executionResult.getAccumulatorResult(\n                        AccumulatorCountingSink.NUM_ELEMENTS_ACCUMULATOR);\n        Assert.assertEquals(inputCount * parallelism, count.intValue());\n    }",
          "conflictNames": [
              "inputCount",
              "parallelism",
              "env",
              "broadcastData",
              "broadcastDataStream",
              "stateDescriptor",
              "processor",
              "executionResult",
              "count"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/19577b0da7f42fe569084f0207bce93a9be08f57^1/flink-state-backends/flink-statebackend-forst/src/test/java/org/apache/flink/state/forst/ForStStateBackendConfigTest.java",
      "locators": [
          {
              "line": 266,
              "column": 14
          },
          {
              "line": 269,
              "column": 27
          }
      ],
      "old_name": "instanceRocksDBPath",
      "new_name": "localForStPath",
      "ctx": {
          "symbolName": "instanceRocksDBPath",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "File",
          "scopeHint": "in testCleanRelocatedDbLogs(...)",
          "filePath": "ForStStateBackendConfigTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    @Timeout(value = 60)\n    public void testCleanRelocatedDbLogs() throws Exception {\n        final File folder = tempFolder.newFolder();\n        final File relocatedDBLogDir = tempFolder.newFolder(\"db_logs\");\n        final File logFile = new File(relocatedDBLogDir, \"taskManager.log\");\n        Files.createFile(logFile.toPath());\n        System.setProperty(\"log.file\", logFile.getAbsolutePath());\n\n        Configuration conf = new Configuration();\n        conf.set(ForStConfigurableOptions.LOG_LEVEL, InfoLogLevel.DEBUG_LEVEL);\n        conf.set(ForStConfigurableOptions.LOG_FILE_NUM, 4);\n        conf.set(ForStConfigurableOptions.LOG_MAX_FILE_SIZE, MemorySize.parse(\"1kb\"));\n        final ForStStateBackend rocksDbBackend =\n                new ForStStateBackend().configure(conf, getClass().getClassLoader());\n        final String dbStoragePath = new Path(folder.toURI().toString()).toString();\n        rocksDbBackend.setLocalDbStoragePath(dbStoragePath);\n\n        final MockEnvironment env = getMockEnvironment(tempFolder.newFolder());\n        ForStKeyedStateBackend<Integer> keyedBackend =\n                createKeyedStateBackend(rocksDbBackend, env, IntSerializer.INSTANCE);\n\n        File instanceBasePath = keyedBackend.getInstanceBasePath();\n        File instanceRocksDBPath = new File(instanceBasePath, \"db\");\n\n        // avoid tests without relocate.\n        Assume.assumeTrue(instanceRocksDBPath.getAbsolutePath().length() <= 255 - \"_LOG\".length());\n\n        java.nio.file.Path[] relocatedDbLogs;\n        try {\n            relocatedDbLogs = FileUtils.listDirectory(relocatedDBLogDir.toPath());\n            while (relocatedDbLogs.length <= 2) {\n                // If the default number of log files in rocksdb is not enough, add more logs.\n                try (FlushOptions flushOptions = new FlushOptions()) {\n                    keyedBackend.db.put(RandomUtils.nextBytes(32), RandomUtils.nextBytes(512));\n                    keyedBackend.db.flush(flushOptions);\n                }\n                relocatedDbLogs = FileUtils.listDirectory(relocatedDBLogDir.toPath());\n            }\n        } finally {\n            keyedBackend.dispose();\n            env.close();\n        }\n\n        relocatedDbLogs = FileUtils.listDirectory(relocatedDBLogDir.toPath());\n        assertEquals(1, relocatedDbLogs.length);\n        assertEquals(\"taskManager.log\", relocatedDbLogs[0].toFile().getName());\n    }",
          "conflictNames": [
              "folder",
              "relocatedDBLogDir",
              "logFile",
              "conf",
              "rocksDbBackend",
              "dbStoragePath",
              "env",
              "keyedBackend",
              "instanceBasePath",
              "relocatedDbLogs",
              "flushOptions"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/19577b0da7f42fe569084f0207bce93a9be08f57^1/flink-state-backends/flink-statebackend-forst/src/test/java/org/apache/flink/state/forst/ForStStateBackendConfigTest.java",
      "locators": [
          {
              "line": 256,
              "column": 33
          },
          {
              "line": 259,
              "column": 9
          },
          {
              "line": 263,
              "column": 41
          }
      ],
      "old_name": "rocksDbBackend",
      "new_name": "forStBackend",
      "ctx": {
          "symbolName": "rocksDbBackend",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ForStStateBackend",
          "scopeHint": "in testCleanRelocatedDbLogs(...)",
          "filePath": "ForStStateBackendConfigTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    @Timeout(value = 60)\n    public void testCleanRelocatedDbLogs() throws Exception {\n        final File folder = tempFolder.newFolder();\n        final File relocatedDBLogDir = tempFolder.newFolder(\"db_logs\");\n        final File logFile = new File(relocatedDBLogDir, \"taskManager.log\");\n        Files.createFile(logFile.toPath());\n        System.setProperty(\"log.file\", logFile.getAbsolutePath());\n\n        Configuration conf = new Configuration();\n        conf.set(ForStConfigurableOptions.LOG_LEVEL, InfoLogLevel.DEBUG_LEVEL);\n        conf.set(ForStConfigurableOptions.LOG_FILE_NUM, 4);\n        conf.set(ForStConfigurableOptions.LOG_MAX_FILE_SIZE, MemorySize.parse(\"1kb\"));\n        final ForStStateBackend rocksDbBackend =\n                new ForStStateBackend().configure(conf, getClass().getClassLoader());\n        final String dbStoragePath = new Path(folder.toURI().toString()).toString();\n        rocksDbBackend.setLocalDbStoragePath(dbStoragePath);\n\n        final MockEnvironment env = getMockEnvironment(tempFolder.newFolder());\n        ForStKeyedStateBackend<Integer> keyedBackend =\n                createKeyedStateBackend(rocksDbBackend, env, IntSerializer.INSTANCE);\n\n        File instanceBasePath = keyedBackend.getInstanceBasePath();\n        File instanceRocksDBPath = new File(instanceBasePath, \"db\");\n\n        // avoid tests without relocate.\n        Assume.assumeTrue(instanceRocksDBPath.getAbsolutePath().length() <= 255 - \"_LOG\".length());\n\n        java.nio.file.Path[] relocatedDbLogs;\n        try {\n            relocatedDbLogs = FileUtils.listDirectory(relocatedDBLogDir.toPath());\n            while (relocatedDbLogs.length <= 2) {\n                // If the default number of log files in rocksdb is not enough, add more logs.\n                try (FlushOptions flushOptions = new FlushOptions()) {\n                    keyedBackend.db.put(RandomUtils.nextBytes(32), RandomUtils.nextBytes(512));\n                    keyedBackend.db.flush(flushOptions);\n                }\n                relocatedDbLogs = FileUtils.listDirectory(relocatedDBLogDir.toPath());\n            }\n        } finally {\n            keyedBackend.dispose();\n            env.close();\n        }\n\n        relocatedDbLogs = FileUtils.listDirectory(relocatedDBLogDir.toPath());\n        assertEquals(1, relocatedDbLogs.length);\n        assertEquals(\"taskManager.log\", relocatedDbLogs[0].toFile().getName());\n    }",
          "conflictNames": [
              "folder",
              "relocatedDBLogDir",
              "logFile",
              "conf",
              "dbStoragePath",
              "env",
              "keyedBackend",
              "instanceBasePath",
              "instanceRocksDBPath",
              "relocatedDbLogs",
              "flushOptions"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/19577b0da7f42fe569084f0207bce93a9be08f57^1/flink-state-backends/flink-statebackend-forst/src/test/java/org/apache/flink/state/forst/ForStStateBackendConfigTest.java",
      "locators": [
          {
              "line": 147,
              "column": 18
          },
          {
              "line": 149,
              "column": 21
          },
          {
              "line": 210,
              "column": 18
          },
          {
              "line": 212,
              "column": 21
          },
          {
              "line": 265,
              "column": 14
          },
          {
              "line": 266,
              "column": 45
          },
          {
              "line": 329,
              "column": 18
          },
          {
              "line": 330,
              "column": 24
          }
      ],
      "old_name": "instanceBasePath",
      "new_name": "localBasePath",
      "ctx": {
          "symbolName": "instanceBasePath",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "File",
          "scopeHint": "in testSetDbPath(...)",
          "filePath": "ForStStateBackendConfigTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** This test checks the behavior for basic setting of local DB directories. */\n    @Test\n    public void testSetDbPath() throws Exception {\n        final ForStStateBackend forStStateBackend = new ForStStateBackend();\n\n        final String testDir1 = tempFolder.newFolder().getAbsolutePath();\n        final String testDir2 = tempFolder.newFolder().getAbsolutePath();\n\n        assertNull(forStStateBackend.getLocalDbStoragePaths());\n\n        forStStateBackend.setLocalDbStoragePath(testDir1);\n        assertArrayEquals(new String[] {testDir1}, forStStateBackend.getLocalDbStoragePaths());\n\n        forStStateBackend.setLocalDbStoragePath(null);\n        assertNull(forStStateBackend.getLocalDbStoragePaths());\n\n        forStStateBackend.setLocalDbStoragePaths(testDir1, testDir2);\n        assertArrayEquals(\n                new String[] {testDir1, testDir2}, forStStateBackend.getLocalDbStoragePaths());\n\n        final MockEnvironment env = getMockEnvironment(tempFolder.newFolder());\n        final ForStKeyedStateBackend<Integer> keyedBackend =\n                createKeyedStateBackend(forStStateBackend, env, IntSerializer.INSTANCE);\n\n        try {\n            File instanceBasePath = keyedBackend.getInstanceBasePath();\n            assertThat(\n                    instanceBasePath.getAbsolutePath(),\n                    anyOf(startsWith(testDir1), startsWith(testDir2)));\n\n            //noinspection NullArgumentToVariableArgMethod\n            forStStateBackend.setLocalDbStoragePaths(null);\n            assertNull(forStStateBackend.getLocalDbStoragePaths());\n        } finally {\n            keyedBackend.dispose();\n            env.close();\n        }\n    }",
          "conflictNames": [
              "forStStateBackend",
              "testDir1",
              "testDir2",
              "env",
              "keyedBackend"
          ]
      },
      "suggestions": [
          {
              "name": "childPath",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/19577b0da7f42fe569084f0207bce93a9be08f57^1/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/ForStStateBackend.java",
      "locators": [
          {
              "line": 282,
              "column": 14
          },
          {
              "line": 305,
              "column": 25
          },
          {
              "line": 537,
              "column": 77
          },
          {
              "line": 538,
              "column": 56
          },
          {
              "line": 544,
              "column": 28
          },
          {
              "line": 551,
              "column": 17
          }
      ],
      "old_name": "instanceBasePath",
      "new_name": "childPath",
      "ctx": {
          "symbolName": "instanceBasePath",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "File",
          "scopeHint": "in createForStKeyedStateBackend(...)",
          "filePath": "ForStStateBackend.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public <K> ForStKeyedStateBackend<K> createForStKeyedStateBackend(\n            KeyedStateBackendParameters<K> parameters) throws IOException {\n        Environment env = parameters.getEnv();\n\n        // first, make sure that the ForSt JNI library is loaded\n        // we do this explicitly here to have better error handling\n        String tempDir = env.getTaskManagerInfo().getTmpWorkingDirectory().getAbsolutePath();\n        ensureForStIsLoaded(tempDir);\n\n        // replace all characters that are not legal for filenames with underscore\n        String fileCompatibleIdentifier =\n                parameters.getOperatorIdentifier().replaceAll(\"[^a-zA-Z0-9\\\\-]\", \"_\");\n\n        lazyInitializeForJob(env, fileCompatibleIdentifier);\n\n        File instanceBasePath =\n                new File(\n                        getNextStoragePath(),\n                        \"job_\"\n                                + jobId\n                                + \"_op_\"\n                                + fileCompatibleIdentifier\n                                + \"_uuid_\"\n                                + UUID.randomUUID());\n\n        final OpaqueMemoryResource<ForStSharedResources> sharedResources =\n                ForStOperationUtils.allocateSharedCachesIfConfigured(\n                        memoryConfiguration,\n                        env,\n                        parameters.getManagedMemoryFraction(),\n                        LOG,\n                        forStMemoryFactory);\n        if (sharedResources != null) {\n            LOG.info(\"Obtained shared ForSt cache of size {} bytes\", sharedResources.getSize());\n        }\n        final ForStResourceContainer resourceContainer =\n                createOptionsAndResourceContainer(\n                        sharedResources,\n                        instanceBasePath,\n                        nativeMetricOptions.isStatisticsEnabled());\n\n        ForStKeyedStateBackendBuilder<K> builder =\n                new ForStKeyedStateBackendBuilder<>(\n                                resourceContainer,\n                                stateName -> resourceContainer.getColumnOptions(),\n                                parameters.getKeySerializer(),\n                                parameters.getMetricGroup(),\n                                parameters.getStateHandles())\n                        .setNativeMetricOptions(\n                                resourceContainer.getMemoryWatcherOptions(nativeMetricOptions));\n        return builder.build();\n    }",
          "conflictNames": [
              "parameters",
              "env",
              "tempDir",
              "fileCompatibleIdentifier",
              "sharedResources",
              "resourceContainer",
              "builder"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/1986cfe1cb3606fc00fd13735f7ba901b806f56f^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/expressions/converter/OverConvertRule.java",
      "locators": [
          {
              "line": 114,
              "column": 21
          },
          {
              "line": 133,
              "column": 37
          }
      ],
      "old_name": "isPhysical",
      "new_name": "isRows",
      "ctx": {
          "symbolName": "isPhysical",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "boolean",
          "scopeHint": "in convert(...)",
          "filePath": "OverConvertRule.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public Optional<RexNode> convert(CallExpression call, ConvertContext context) {\n        List<Expression> children = call.getChildren();\n        if (call.getFunctionDefinition() == BuiltInFunctionDefinitions.OVER) {\n            FlinkTypeFactory typeFactory = context.getTypeFactory();\n            Expression agg = children.get(0);\n            FunctionDefinition def = ((CallExpression) agg).getFunctionDefinition();\n            boolean isDistinct = BuiltInFunctionDefinitions.DISTINCT == def;\n\n            SqlAggFunction aggFunc = agg.accept(new SqlAggFunctionVisitor(context.getRelBuilder()));\n            RelDataType aggResultType =\n                    typeFactory.createFieldTypeFromLogicalType(\n                            fromDataTypeToLogicalType(\n                                    ((ResolvedExpression) agg).getOutputDataType()));\n\n            // assemble exprs by agg children\n            List<RexNode> aggExprs =\n                    agg.getChildren().stream()\n                            .map(\n                                    child -> {\n                                        if (isDistinct) {\n                                            return context.toRexNode(child.getChildren().get(0));\n                                        } else {\n                                            return context.toRexNode(child);\n                                        }\n                                    })\n                            .collect(Collectors.toList());\n\n            // assemble order by key\n            Expression orderKeyExpr = children.get(1);\n            Set<SqlKind> kinds = new HashSet<>();\n            RexNode collationRexNode =\n                    createCollation(\n                            context.toRexNode(orderKeyExpr),\n                            RelFieldCollation.Direction.ASCENDING,\n                            null,\n                            kinds);\n            ImmutableList<RexFieldCollation> orderKey =\n                    ImmutableList.of(new RexFieldCollation(collationRexNode, kinds));\n\n            // assemble partition by keys\n            List<RexNode> partitionKeys =\n                    children.subList(4, children.size()).stream()\n                            .map(context::toRexNode)\n                            .collect(Collectors.toList());\n            // assemble bounds\n            Expression preceding = children.get(2);\n            boolean isPhysical =\n                    fromDataTypeToLogicalType(((ResolvedExpression) preceding).getOutputDataType())\n                            .is(LogicalTypeRoot.BIGINT);\n            Expression following = children.get(3);\n            RexWindowBound lowerBound = createBound(context, preceding, SqlKind.PRECEDING);\n            RexWindowBound upperBound = createBound(context, following, SqlKind.FOLLOWING);\n\n            // build RexOver\n            return Optional.of(\n                    context.getRelBuilder()\n                            .getRexBuilder()\n                            .makeOver(\n                                    aggResultType,\n                                    aggFunc,\n                                    aggExprs,\n                                    partitionKeys,\n                                    orderKey,\n                                    lowerBound,\n                                    upperBound,\n                                    isPhysical,\n                                    true,\n                                    false,\n                                    isDistinct,\n                                    false));\n        }\n        return Optional.empty();\n    }",
          "conflictNames": [
              "call",
              "context",
              "children",
              "typeFactory",
              "agg",
              "def",
              "isDistinct",
              "aggFunc",
              "aggResultType",
              "aggExprs",
              "orderKeyExpr",
              "kinds",
              "collationRexNode",
              "orderKey",
              "partitionKeys",
              "preceding",
              "following",
              "lowerBound",
              "upperBound"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/1986cfe1cb3606fc00fd13735f7ba901b806f56f^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/expressions/converter/OverConvertRule.java",
      "locators": [
          {
              "line": 218,
              "column": 36
          },
          {
              "line": 220,
              "column": 21
          },
          {
              "line": 225,
              "column": 67
          }
      ],
      "old_name": "literalExpr",
      "new_name": "literal",
      "ctx": {
          "symbolName": "literalExpr",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ValueLiteralExpression",
          "scopeHint": "in createBound(...)",
          "filePath": "OverConvertRule.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private RexWindowBound createBound(ConvertContext context, Expression bound, SqlKind sqlKind) {\n        if (bound instanceof CallExpression) {\n            CallExpression callExpr = (CallExpression) bound;\n            FunctionDefinition func = callExpr.getFunctionDefinition();\n            if (BuiltInFunctionDefinitions.UNBOUNDED_ROW.equals(func)\n                    || BuiltInFunctionDefinitions.UNBOUNDED_RANGE.equals(func)) {\n                SqlNode unbounded =\n                        sqlKind.equals(SqlKind.PRECEDING)\n                                ? SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO)\n                                : SqlWindow.createUnboundedFollowing(SqlParserPos.ZERO);\n                return RexWindowBounds.create(unbounded, null);\n            } else if (BuiltInFunctionDefinitions.CURRENT_ROW.equals(func)\n                    || BuiltInFunctionDefinitions.CURRENT_RANGE.equals(func)) {\n                SqlNode currentRow = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n                return RexWindowBounds.create(currentRow, null);\n            } else {\n                throw new IllegalArgumentException(\"Unexpected expression: \" + bound);\n            }\n        } else if (bound instanceof ValueLiteralExpression) {\n            RelDataType returnType =\n                    context.getTypeFactory()\n                            .createFieldTypeFromLogicalType(new DecimalType(true, 19, 0));\n            SqlOperator sqlOperator =\n                    new SqlPostfixOperator(\n                            sqlKind.name(),\n                            sqlKind,\n                            2,\n                            new OrdinalReturnTypeInference(0),\n                            null,\n                            null);\n            SqlNode[] operands =\n                    new SqlNode[] {SqlLiteral.createExactNumeric(\"1\", SqlParserPos.ZERO)};\n            SqlNode node = new SqlBasicCall(sqlOperator, operands, SqlParserPos.ZERO);\n\n            ValueLiteralExpression literalExpr = (ValueLiteralExpression) bound;\n            RexNode literalRexNode =\n                    literalExpr\n                            .getValueAs(BigDecimal.class)\n                            .map(v -> context.getRelBuilder().literal(v))\n                            .orElse(\n                                    context.getRelBuilder()\n                                            .literal(extractValue(literalExpr, Object.class)));\n\n            List<RexNode> expressions = new ArrayList<>();\n            expressions.add(literalRexNode);\n            RexNode rexNode =\n                    context.getRelBuilder()\n                            .getRexBuilder()\n                            .makeCall(returnType, sqlOperator, expressions);\n            return RexWindowBounds.create(node, rexNode);\n        } else {\n            throw new TableException(\"Unexpected expression: \" + bound);\n        }\n    }",
          "conflictNames": [
              "context",
              "bound",
              "sqlKind",
              "callExpr",
              "func",
              "unbounded",
              "currentRow",
              "returnType",
              "sqlOperator",
              "operands",
              "node",
              "literalRexNode",
              "expressions",
              "rexNode"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/19cb9de5c54b9535be15ca850f5e1ebd2e21c244^1/flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestClient.java",
      "locators": [
          {
              "line": 647,
              "column": 46
          },
          {
              "line": 655,
              "column": 25
          }
      ],
      "old_name": "jpe2",
      "new_name": "ex",
      "ctx": {
          "symbolName": "jpe2",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "JsonProcessingException",
          "scopeHint": "in parseResponse(...)",
          "filePath": "RestClient.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "esponseBody.class);\n                responseFuture.completeExceptionally(\n                        new RestClientException(\n                                error.errors.toString(), rawResponse.getHttpResponseStatus()));\n            } catch (JsonProcessingException jpe2) {\n                // if this fails it is either the expected type or response type was wrong, most\n                // likely caused\n                // by a client/search MessageHeaders mismatch\n                LOG.error(\n                 ",
          "conflictNames": [
              "rawResponse",
              "responseType",
              "responseFuture",
              "jsonParser",
              "response",
              "error"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/1a274ab2f150ad290771a08c5bd8bff465cae675^1/flink-runtime/src/test/java/org/apache/flink/runtime/metrics/filter/DefaultMetricFilterTest.java",
      "locators": [
          {
              "line": 98,
              "column": 28
          },
          {
              "line": 100,
              "column": 20
          },
          {
              "line": 101,
              "column": 20
          },
          {
              "line": 102,
              "column": 20
          },
          {
              "line": 103,
              "column": 20
          },
          {
              "line": 112,
              "column": 28
          },
          {
              "line": 114,
              "column": 20
          },
          {
              "line": 115,
              "column": 20
          },
          {
              "line": 124,
              "column": 28
          },
          {
              "line": 126,
              "column": 20
          },
          {
              "line": 127,
              "column": 20
          },
          {
              "line": 136,
              "column": 28
          },
          {
              "line": 138,
              "column": 20
          },
          {
              "line": 139,
              "column": 20
          },
          {
              "line": 140,
              "column": 20
          },
          {
              "line": 141,
              "column": 20
          },
          {
              "line": 150,
              "column": 28
          },
          {
              "line": 152,
              "column": 20
          },
          {
              "line": 153,
              "column": 20
          },
          {
              "line": 154,
              "column": 20
          },
          {
              "line": 155,
              "column": 20
          },
          {
              "line": 164,
              "column": 28
          },
          {
              "line": 166,
              "column": 20
          },
          {
              "line": 167,
              "column": 20
          },
          {
              "line": 175,
              "column": 28
          },
          {
              "line": 177,
              "column": 20
          },
          {
              "line": 178,
              "column": 20
          },
          {
              "line": 186,
              "column": 28
          },
          {
              "line": 188,
              "column": 20
          },
          {
              "line": 195,
              "column": 28
          },
          {
              "line": 197,
              "column": 20
          },
          {
              "line": 198,
              "column": 20
          },
          {
              "line": 209,
              "column": 28
          },
          {
              "line": 211,
              "column": 20
          },
          {
              "line": 212,
              "column": 20
          },
          {
              "line": 213,
              "column": 20
          }
      ],
      "old_name": "metricFilter",
      "new_name": "reporterFilter",
      "ctx": {
          "symbolName": "metricFilter",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "MetricFilter",
          "scopeHint": "in testFromConfigurationIncludeByScope(...)",
          "filePath": "DefaultMetricFilterTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testFromConfigurationIncludeByScope() {\n        Configuration configuration = new Configuration();\n        configuration.set(\n                MetricOptions.REPORTER_INCLUDES, Arrays.asList(\"include1:*:*\", \"include2.*:*:*\"));\n        configuration.set(MetricOptions.REPORTER_EXCLUDES, Collections.emptyList());\n\n        final MetricFilter metricFilter = DefaultMetricFilter.fromConfiguration(configuration);\n\n        assertThat(metricFilter.filter(COUNTER, \"name\", \"include1\")).isTrue();\n        assertThat(metricFilter.filter(COUNTER, \"name\", \"include1.bar\")).isFalse();\n        assertThat(metricFilter.filter(COUNTER, \"name\", \"include2\")).isFalse();\n        assertThat(metricFilter.filter(COUNTER, \"name\", \"include2.bar\")).isTrue();\n    }",
          "conflictNames": [
              "configuration"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/1b21e37d7c0848cf088be71815ecffb182c2915a^1/flink-metrics/flink-metrics-otel/src/main/java/org/apache/flink/events/otel/OpenTelemetryEventReporter.java",
      "locators": [
          {
              "line": 63,
              "column": 42
          },
          {
              "line": 63,
              "column": 78
          },
          {
              "line": 64,
              "column": 44
          },
          {
              "line": 65,
              "column": 43
          },
          {
              "line": 67,
              "column": 29
          },
          {
              "line": 68,
              "column": 54
          },
          {
              "line": 70,
              "column": 35
          }
      ],
      "old_name": "builder",
      "new_name": "grpcBuilder",
      "ctx": {
          "symbolName": "builder",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "OtlpGrpcLogRecordExporterBuilder",
          "scopeHint": "in open(...)",
          "filePath": "OpenTelemetryEventReporter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void open(MetricConfig metricConfig) {\n        LOG.info(\"Starting OpenTelemetryEventReporter\");\n        OtlpGrpcLogRecordExporterBuilder builder = OtlpGrpcLogRecordExporter.builder();\n        tryConfigureEndpoint(metricConfig, builder::setEndpoint);\n        tryConfigureTimeout(metricConfig, builder::setTimeout);\n\n        logRecordExporter = builder.build();\n        logRecordProcessor = BatchLogRecordProcessor.builder(logRecordExporter).build();\n        loggerProvider =\n                SdkLoggerProvider.builder()\n                        .addLogRecordProcessor(logRecordProcessor)\n                        .setResource(resource)\n                        .build();\n    }",
          "conflictNames": [
              "metricConfig"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/1b21e37d7c0848cf088be71815ecffb182c2915a^1/flink-metrics/flink-metrics-otel/src/main/java/org/apache/flink/metrics/otel/OpenTelemetryMetricReporter.java",
      "locators": [
          {
              "line": 95,
              "column": 39
          },
          {
              "line": 95,
              "column": 72
          },
          {
              "line": 96,
              "column": 44
          },
          {
              "line": 97,
              "column": 43
          },
          {
              "line": 98,
              "column": 20
          }
      ],
      "old_name": "builder",
      "new_name": "grpcBuilder",
      "ctx": {
          "symbolName": "builder",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "OtlpGrpcMetricExporterBuilder",
          "scopeHint": "in open(...)",
          "filePath": "OpenTelemetryMetricReporter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void open(MetricConfig metricConfig) {\n        LOG.info(\"Starting OpenTelemetryMetricReporter\");\n        super.open(metricConfig);\n        OtlpGrpcMetricExporterBuilder builder = OtlpGrpcMetricExporter.builder();\n        tryConfigureEndpoint(metricConfig, builder::setEndpoint);\n        tryConfigureTimeout(metricConfig, builder::setTimeout);\n        exporter = builder.build();\n    }",
          "conflictNames": [
              "metricConfig"
          ]
      },
      "suggestions": [
          {
              "name": "grpcBuilder",
              "confidence": 0.8
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/1b21e37d7c0848cf088be71815ecffb182c2915a^1/flink-metrics/flink-metrics-otel/src/main/java/org/apache/flink/traces/otel/OpenTelemetryTraceReporter.java",
      "locators": [
          {
              "line": 59,
              "column": 37
          },
          {
              "line": 59,
              "column": 68
          },
          {
              "line": 60,
              "column": 44
          },
          {
              "line": 61,
              "column": 43
          },
          {
              "line": 62,
              "column": 24
          },
          {
              "line": 63,
              "column": 44
          },
          {
              "line": 65,
              "column": 35
          }
      ],
      "old_name": "builder",
      "new_name": "grpcBuilder",
      "ctx": {
          "symbolName": "builder",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "OtlpGrpcSpanExporterBuilder",
          "scopeHint": "in open(...)",
          "filePath": "OpenTelemetryTraceReporter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void open(MetricConfig metricConfig) {\n        LOG.info(\"Starting OpenTelemetryTraceReporter\");\n        super.open(metricConfig);\n        OtlpGrpcSpanExporterBuilder builder = OtlpGrpcSpanExporter.builder();\n        tryConfigureEndpoint(metricConfig, builder::setEndpoint);\n        tryConfigureTimeout(metricConfig, builder::setTimeout);\n        spanExporter = builder.build();\n        spanProcessor = BatchSpanProcessor.builder(spanExporter).build();\n        tracerProvider =\n                SdkTracerProvider.builder()\n                        .addSpanProcessor(spanProcessor)\n                        .setResource(resource)\n                        .build();\n    }",
          "conflictNames": [
              "metricConfig"
          ]
      },
      "suggestions": [
          {
              "name": "grpcBuilder",
              "confidence": 0.8
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/1d1247d4ae6d4313f7d952c4b2d66351314c9432^1/flink-yarn/src/main/java/org/apache/flink/yarn/YarnLocalResourceDescriptor.java",
      "locators": [
          {
              "line": 3,
              "column": 7
          },
          {
              "line": 3,
              "column": 37
          },
          {
              "line": 4,
              "column": 51
          },
          {
              "line": 7,
              "column": 20
          },
          {
              "line": 7,
              "column": 54
          },
          {
              "line": 8,
              "column": 27
          },
          {
              "line": 14,
              "column": 69
          },
          {
              "line": 15,
              "column": 59
          },
          {
              "line": 16,
              "column": 6
          },
          {
              "line": 21,
              "column": 2
          },
          {
              "line": 23,
              "column": 2
          },
          {
              "line": 24,
              "column": 2
          },
          {
              "line": 25,
              "column": 2
          },
          {
              "line": 26,
              "column": 2
          },
          {
              "line": 27,
              "column": 2
          },
          {
              "line": 29,
              "column": 2
          },
          {
              "line": 30,
              "column": 2
          },
          {
              "line": 31,
              "column": 2
          },
          {
              "line": 33,
              "column": 2
          },
          {
              "line": 37,
              "column": 11
          },
          {
              "line": 37,
              "column": 23
          },
          {
              "line": 37,
              "column": 90
          },
          {
              "line": 44,
              "column": 50
          },
          {
              "line": 44,
              "column": 64
          },
          {
              "line": 46,
              "column": 23
          },
          {
              "line": 48,
              "column": 72
          },
          {
              "line": 48,
              "column": 86
          },
          {
              "line": 53,
              "column": 24
          },
          {
              "line": 53,
              "column": 38
          },
          {
              "line": 61,
              "column": 18
          },
          {
              "line": 61,
              "column": 32
          },
          {
              "line": 67,
              "column": 14
          },
          {
              "line": 67,
              "column": 28
          },
          {
              "line": 67,
              "column": 33
          },
          {
              "line": 67,
              "column": 47
          },
          {
              "line": 88,
              "column": 27
          },
          {
              "line": 89,
              "column": 16
          },
          {
              "line": 89,
              "column": 30
          },
          {
              "line": 100,
              "column": 43
          },
          {
              "line": 101,
              "column": 17
          },
          {
              "line": 101,
              "column": 48
          },
          {
              "line": 102,
              "column": 17
          },
          {
              "line": 102,
              "column": 23
          },
          {
              "line": 103,
              "column": 13
          },
          {
              "line": 105,
              "column": 21
          },
          {
              "line": 106,
              "column": 30
          },
          {
              "line": 107,
              "column": 36
          },
          {
              "line": 108,
              "column": 36
          },
          {
              "line": 109,
              "column": 53
          },
          {
              "line": 110,
              "column": 47
          },
          {
              "line": 112,
              "column": 85
          },
          {
              "line": 116,
              "column": 43
          },
          {
              "line": 128,
              "column": 45
          },
          {
              "line": 135,
              "column": 26
          },
          {
              "line": 140,
              "column": 17
          },
          {
              "line": 140,
              "column": 31
          },
          {
              "line": 150,
              "column": 49
          },
          {
              "line": 150,
              "column": 63
          },
          {
              "line": 165,
              "column": 39
          },
          {
              "line": 165,
              "column": 53
          },
          {
              "line": 165,
              "column": 62
          },
          {
              "line": 165,
              "column": 76
          },
          {
              "line": 173,
              "column": 16
          },
          {
              "line": 178,
              "column": 56
          },
          {
              "line": 178,
              "column": 70
          }
      ],
      "old_name": "m",
      "new_name": "node",
      "ctx": {
          "symbolName": "m",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Matcher",
          "scopeHint": "in fromString(...)",
          "filePath": "YarnLocalResourceDescriptor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "static YarnLocalResourceDescriptor fromString(String desc) throws Exception {\n        Matcher m = LOCAL_RESOURCE_DESC_FORMAT.matcher(desc);\n        boolean mat = m.find();\n        if (mat) {\n            return new YarnLocalResourceDescriptor(\n                    m.group(1),\n                    new Path(m.group(2)),\n                    Long.parseLong(m.group(3)),\n                    Long.parseLong(m.group(4)),\n                    LocalResourceVisibility.valueOf(m.group(5)),\n                    LocalResourceType.valueOf(m.group(6)));\n        } else {\n            throw new FlinkException(\"Error to parse YarnLocalResourceDescriptor from \" + desc);\n        }\n    }",
          "conflictNames": [
              "desc",
              "mat"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/1d433fb4b72d74b1aa0cfa8ac7a9f7fed22bce32^1/flink-runtime/src/main/java/org/apache/flink/runtime/deployment/TaskDeploymentDescriptorFactory.java",
      "locators": [
          {
              "line": 135,
              "column": 24
          },
          {
              "line": 148,
              "column": 29
          }
      ],
      "old_name": "consumedSubpartitionRange",
      "new_name": "subpartitionRange",
      "ctx": {
          "symbolName": "consumedSubpartitionRange",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "IndexRange",
          "scopeHint": "in createInputGateDeploymentDescriptors(...)",
          "filePath": "TaskDeploymentDescriptorFactory.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private List<InputGateDeploymentDescriptor> createInputGateDeploymentDescriptors()\n            throws IOException {\n        List<InputGateDeploymentDescriptor> inputGates =\n                new ArrayList<>(consumedPartitionGroups.size());\n\n        for (ConsumedPartitionGroup consumedPartitionGroup : consumedPartitionGroups) {\n            // If the produced partition has multiple consumers registered, we\n            // need to request the one matching our sub task index.\n            // TODO Refactor after removing the consumers from the intermediate result partitions\n            IntermediateResultPartition resultPartition =\n                    resultPartitionRetriever.apply(consumedPartitionGroup.getFirst());\n\n            IntermediateResult consumedIntermediateResult = resultPartition.getIntermediateResult();\n            IndexRange consumedSubpartitionRange =\n                    computeConsumedSubpartitionRange(\n                            consumedPartitionGroup.getNumConsumers(),\n                            resultPartition,\n                            executionId.getSubtaskIndex());\n\n            IntermediateDataSetID resultId = consumedIntermediateResult.getId();\n            ResultPartitionType partitionType = consumedIntermediateResult.getResultType();\n\n            inputGates.add(\n                    new InputGateDeploymentDescriptor(\n                            resultId,\n                            partitionType,\n                            consumedSubpartitionRange,\n                            getConsumedPartitionShuffleDescriptors(\n                                    consumedIntermediateResult, consumedPartitionGroup)));\n        }\n\n        for (Map.Entry<IntermediateDataSetID, ShuffleDescriptor[]> entry :\n                consumedClusterPartitionShuffleDescriptors.entrySet()) {\n            // For FLIP-205, the JobGraph generating side ensure that the cluster partition is\n            // produced with only one subpartition. Therefore, we always consume the partition with\n            // subpartition index of 0.\n            inputGates.add(\n                    new InputGateDeploymentDescriptor(\n                            entry.getKey(),\n                            ResultPartitionType.BLOCKING_PERSISTENT,\n                            0,\n                            entry.getValue()));\n        }\n\n        return inputGates;\n    }",
          "conflictNames": [
              "inputGates",
              "resultPartition",
              "consumedIntermediateResult",
              "resultId",
              "partitionType"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/1d433fb4b72d74b1aa0cfa8ac7a9f7fed22bce32^1/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/EdgeManagerBuildUtil.java",
      "locators": [
          {
              "line": 170,
              "column": 41
          },
          {
              "line": 176,
              "column": 21
          },
          {
              "line": 181,
              "column": 33
          }
      ],
      "old_name": "consumers",
      "new_name": "taskVertices",
      "ctx": {
          "symbolName": "consumers",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<ExecutionVertexID>",
          "scopeHint": "in connectPointwise(...)",
          "filePath": "EdgeManagerBuildUtil.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void connectPointwise(\n            ExecutionVertex[] taskVertices, IntermediateResult intermediateResult) {\n\n        final int sourceCount = intermediateResult.getPartitions().length;\n        final int targetCount = taskVertices.length;\n\n        if (sourceCount == targetCount) {\n            for (int i = 0; i < sourceCount; i++) {\n                ExecutionVertex executionVertex = taskVertices[i];\n                IntermediateResultPartition partition = intermediateResult.getPartitions()[i];\n\n                ConsumerVertexGroup consumerVertexGroup =\n                        ConsumerVertexGroup.fromSingleVertex(\n                                executionVertex.getID(), intermediateResult.getResultType());\n                partition.addConsumers(consumerVertexGroup);\n\n                ConsumedPartitionGroup consumedPartitionGroup =\n                        createAndRegisterConsumedPartitionGroupToEdgeManager(\n                                consumerVertexGroup.size(),\n                                partition.getPartitionId(),\n                                intermediateResult);\n                executionVertex.addConsumedPartitionGroup(consumedPartitionGroup);\n            }\n        } else if (sourceCount > targetCount) {\n            for (int index = 0; index < targetCount; index++) {\n\n                ExecutionVertex executionVertex = taskVertices[index];\n                ConsumerVertexGroup consumerVertexGroup =\n                        ConsumerVertexGroup.fromSingleVertex(\n                                executionVertex.getID(), intermediateResult.getResultType());\n\n                int start = index * sourceCount / targetCount;\n                int end = (index + 1) * sourceCount / targetCount;\n\n                List<IntermediateResultPartitionID> consumedPartitions =\n                        new ArrayList<>(end - start);\n\n                for (int i = start; i < end; i++) {\n                    IntermediateResultPartition partition = intermediateResult.getPartitions()[i];\n                    partition.addConsumers(consumerVertexGroup);\n\n                    consumedPartitions.add(partition.getPartitionId());\n                }\n\n                ConsumedPartitionGroup consumedPartitionGroup =\n                        createAndRegisterConsumedPartitionGroupToEdgeManager(\n                                consumerVertexGroup.size(), consumedPartitions, intermediateResult);\n                executionVertex.addConsumedPartitionGroup(consumedPartitionGroup);\n            }\n        } else {\n            for (int partitionNum = 0; partitionNum < sourceCount; partitionNum++) {\n                int start = (partitionNum * targetCount + sourceCount - 1) / sourceCount;\n                int end = ((partitionNum + 1) * targetCount + sourceCount - 1) / sourceCount;\n\n                IntermediateResultPartition partition =\n                        intermediateResult.getPartitions()[partitionNum];\n                ConsumedPartitionGroup consumedPartitionGroup =\n                        createAndRegisterConsumedPartitionGroupToEdgeManager(\n                                end - start, partition.getPartitionId(), intermediateResult);\n\n                List<ExecutionVertexID> consumers = new ArrayList<>(end - start);\n\n                for (int i = start; i < end; i++) {\n                    ExecutionVertex executionVertex = taskVertices[i];\n                    executionVertex.addConsumedPartitionGroup(consumedPartitionGroup);\n\n                    consumers.add(executionVertex.getID());\n                }\n\n                ConsumerVertexGroup consumerVertexGroup =\n                        ConsumerVertexGroup.fromMultipleVertices(\n                                consumers, intermediateResult.getResultType());\n                partition.addConsumers(consumerVertexGroup);\n            }\n        }\n    }",
          "conflictNames": [
              "taskVertices",
              "intermediateResult",
              "sourceCount",
              "targetCount",
              "i",
              "executionVertex",
              "partition",
              "consumerVertexGroup",
              "consumedPartitionGroup",
              "index",
              "start",
              "end",
              "consumedPartitions",
              "partitionNum"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/1d433fb4b72d74b1aa0cfa8ac7a9f7fed22bce32^1/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/EdgeManagerBuildUtil.java",
      "locators": [
          {
              "line": 87,
              "column": 45
          },
          {
              "line": 93,
              "column": 46
          },
          {
              "line": 144,
              "column": 53
          },
          {
              "line": 151,
              "column": 21
          },
          {
              "line": 156,
              "column": 61
          },
          {
              "line": 204,
              "column": 49
          },
          {
              "line": 208,
              "column": 39
          },
          {
              "line": 210,
              "column": 37
          }
      ],
      "old_name": "consumedPartitions",
      "new_name": "partitions",
      "ctx": {
          "symbolName": "consumedPartitions",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<IntermediateResultPartitionID>",
          "scopeHint": "in connectAllToAll(...)",
          "filePath": "EdgeManagerBuildUtil.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void connectAllToAll(\n            ExecutionVertex[] taskVertices, IntermediateResult intermediateResult) {\n\n        List<IntermediateResultPartitionID> consumedPartitions =\n                Arrays.stream(intermediateResult.getPartitions())\n                        .map(IntermediateResultPartition::getPartitionId)\n                        .collect(Collectors.toList());\n        ConsumedPartitionGroup consumedPartitionGroup =\n                createAndRegisterConsumedPartitionGroupToEdgeManager(\n                        taskVertices.length, consumedPartitions, intermediateResult);\n        for (ExecutionVertex ev : taskVertices) {\n            ev.addConsumedPartitionGroup(consumedPartitionGroup);\n        }\n\n        List<ExecutionVertexID> consumerVertices =\n                Arrays.stream(taskVertices)\n                        .map(ExecutionVertex::getID)\n                        .collect(Collectors.toList());\n        ConsumerVertexGroup consumerVertexGroup =\n                ConsumerVertexGroup.fromMultipleVertices(\n                        consumerVertices, intermediateResult.getResultType());\n        for (IntermediateResultPartition partition : intermediateResult.getPartitions()) {\n            partition.addConsumers(consumerVertexGroup);\n        }\n    }",
          "conflictNames": [
              "taskVertices",
              "intermediateResult",
              "consumedPartitionGroup",
              "consumerVertices",
              "consumerVertexGroup"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/1d433fb4b72d74b1aa0cfa8ac7a9f7fed22bce32^1/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/EdgeManagerBuildUtil.java",
      "locators": [
          {
              "line": 189,
              "column": 43
          },
          {
              "line": 193,
              "column": 39
          },
          {
              "line": 196,
              "column": 43
          },
          {
              "line": 217,
              "column": 49
          },
          {
              "line": 219,
              "column": 44
          },
          {
              "line": 219,
              "column": 66
          },
          {
              "line": 222,
              "column": 53
          }
      ],
      "old_name": "consumedPartitionId",
      "new_name": "partition",
      "ctx": {
          "symbolName": "consumedPartitionId",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "IntermediateResultPartitionID",
          "scopeHint": "in createAndRegisterConsumedPartitionGroupToEdgeManager(...)",
          "filePath": "EdgeManagerBuildUtil.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "tType());\n                partition.addConsumers(consumerVertexGroup);\n            }\n        }\n    }\n\n    private static ConsumedPartitionGroup createAndRegisterConsumedPartitionGroupToEdgeManager(\n            int numConsumers,\n            IntermediateResultPartitionID consumedPartitionId,\n            IntermediateResult intermediateResult) {\n        ConsumedPartitionGroup consumedPartitionGroup =\n                ConsumedPartitionGroup.fromSinglePartition(\n                        numConsumers, consumedPartitionId, intermedia",
          "conflictNames": [
              "numConsumers",
              "intermediateResult",
              "consumedPartitionGroup"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/1e2787a1eb29ccc8ba2a30d454658c091f7213e0^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptivebatch/AdaptiveExecutionPlanSchedulingContextTest.java",
      "locators": [
          {
              "line": 50,
              "column": 13
          },
          {
              "line": 51,
              "column": 13
          },
          {
              "line": 54,
              "column": 52
          },
          {
              "line": 54,
              "column": 69
          },
          {
              "line": 63,
              "column": 28
          },
          {
              "line": 65,
              "column": 28
          },
          {
              "line": 67,
              "column": 45
          },
          {
              "line": 78,
              "column": 13
          },
          {
              "line": 79,
              "column": 13
          },
          {
              "line": 83,
              "column": 52
          },
          {
              "line": 83,
              "column": 69
          },
          {
              "line": 94,
              "column": 53
          },
          {
              "line": 99,
              "column": 13
          },
          {
              "line": 100,
              "column": 13
          },
          {
              "line": 104,
              "column": 52
          },
          {
              "line": 104,
              "column": 69
          },
          {
              "line": 140,
              "column": 17
          },
          {
              "line": 140,
              "column": 38
          },
          {
              "line": 148,
              "column": 20
          },
          {
              "line": 150,
              "column": 9
          },
          {
              "line": 150,
              "column": 29
          },
          {
              "line": 152,
              "column": 13
          },
          {
              "line": 153,
              "column": 13
          },
          {
              "line": 153,
              "column": 36
          }
      ],
      "old_name": "sink",
      "new_name": "streamNode",
      "ctx": {
          "symbolName": "sink",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "StreamNode",
          "scopeHint": "in getDefaultAdaptiveExecutionHandler(...)",
          "filePath": "AdaptiveExecutionPlanSchedulingContextTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static DefaultAdaptiveExecutionHandler getDefaultAdaptiveExecutionHandler(\n            int sinkParallelism, int sinkMaxParallelism) {\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.fromSequence(0L, 1L).disableChaining().print();\n        StreamGraph streamGraph = env.getStreamGraph();\n\n        Iterator<StreamNode> iterator = streamGraph.getStreamNodes().iterator();\n\n        iterator.next();\n        StreamNode sink = iterator.next();\n\n        sink.setParallelism(sinkParallelism);\n\n        if (sinkMaxParallelism > 0) {\n            sink.setMaxParallelism(sinkMaxParallelism);\n        }\n\n        return new DefaultAdaptiveExecutionHandler(\n                Thread.currentThread().getContextClassLoader(),\n                streamGraph,\n                EXECUTOR_RESOURCE.getExecutor());\n    }",
          "conflictNames": [
              "sinkParallelism",
              "sinkMaxParallelism",
              "env",
              "streamGraph",
              "iterator"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/1f062a38f43cdc9fdbaab3c68e1ec1c1ffdb88b5^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/input/InputSelectionHandler.java",
      "locators": [
          {
              "line": 40,
              "column": 35
          },
          {
              "line": 47,
              "column": 50
          },
          {
              "line": 48,
              "column": 14
          },
          {
              "line": 48,
              "column": 27
          },
          {
              "line": 49,
              "column": 30
          },
          {
              "line": 79,
              "column": 24
          },
          {
              "line": 79,
              "column": 36
          },
          {
              "line": 82,
              "column": 29
          },
          {
              "line": 83,
              "column": 26
          }
      ],
      "old_name": "inputSpec",
      "new_name": "inputSelectionSpecs",
      "ctx": {
          "symbolName": "inputSpec",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "InputSpec",
          "scopeHint": "in buildSortedAvailableInputs(...)",
          "filePath": "InputSelectionHandler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "       inputSelection = buildInputSelection(inputIds);\n        }\n    }\n\n    private List<List<Integer>> buildSortedAvailableInputs() {\n        final SortedMap<Integer, List<Integer>> orderedAvailableInputIds = new TreeMap<>();\n        for (InputSpec inputSpec : inputSpecs) {\n            List<Integer> inputIds =\n                    orderedAvailableInputIds.computeIfAbsent(\n                            inputSpec.getReadOrder(), k -> new LinkedList<>());\n            inputIds.add(inputSpec.getMultip",
          "conflictNames": [
              "orderedAvailableInputIds",
              "inputIds"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/1f303a218f47aa1a8eaf1323fc2a5debe914762d^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/DefaultStateTransitionManagerTest.java",
      "locators": [
          {
              "line": 55,
              "column": 24
          },
          {
              "line": 60,
              "column": 77
          },
          {
              "line": 72,
              "column": 33
          },
          {
              "line": 72,
              "column": 60
          }
      ],
      "old_name": "cooldownTimeout",
      "new_name": "scalingIntervalMin",
      "ctx": {
          "symbolName": "cooldownTimeout",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Duration",
          "scopeHint": "in testProperConfiguration(...)",
          "filePath": "DefaultStateTransitionManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testProperConfiguration() throws ConfigurationException {\n        final Duration cooldownTimeout = Duration.ofMillis(1337);\n        final Duration resourceStabilizationTimeout = Duration.ofMillis(7331);\n        final Duration maximumDelayForRescaleTrigger = Duration.ofMillis(4242);\n\n        final Configuration configuration = new Configuration();\n        configuration.set(JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MIN, cooldownTimeout);\n        configuration.set(\n                JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MAX, resourceStabilizationTimeout);\n        configuration.set(\n                JobManagerOptions.MAXIMUM_DELAY_FOR_SCALE_TRIGGER, maximumDelayForRescaleTrigger);\n\n        final DefaultStateTransitionManager testInstance =\n                DefaultStateTransitionManager.Factory.fromSettings(\n                                AdaptiveScheduler.Settings.of(configuration))\n                        .create(\n                                TestingStateTransitionManagerContext.stableContext(),\n                                Instant.now());\n        assertThat(testInstance.cooldownTimeout).isEqualTo(cooldownTimeout);\n        assertThat(testInstance.resourceStabilizationTimeout)\n                .isEqualTo(resourceStabilizationTimeout);\n        assertThat(testInstance.maxTriggerDelay).isEqualTo(maximumDelayForRescaleTrigger);\n    }",
          "conflictNames": [
              "resourceStabilizationTimeout",
              "maximumDelayForRescaleTrigger",
              "configuration",
              "testInstance"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/1f303a218f47aa1a8eaf1323fc2a5debe914762d^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/DefaultStateTransitionManagerTest.java",
      "locators": [
          {
              "line": 56,
              "column": 24
          },
          {
              "line": 62,
              "column": 67
          },
          {
              "line": 73,
              "column": 33
          },
          {
              "line": 74,
              "column": 28
          },
          {
              "line": 623,
              "column": 36
          },
          {
              "line": 631,
              "column": 29
          }
      ],
      "old_name": "resourceStabilizationTimeout",
      "new_name": "scalingIntervalMax",
      "ctx": {
          "symbolName": "resourceStabilizationTimeout",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Duration",
          "scopeHint": "in testProperConfiguration(...)",
          "filePath": "DefaultStateTransitionManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testProperConfiguration() throws ConfigurationException {\n        final Duration cooldownTimeout = Duration.ofMillis(1337);\n        final Duration resourceStabilizationTimeout = Duration.ofMillis(7331);\n        final Duration maximumDelayForRescaleTrigger = Duration.ofMillis(4242);\n\n        final Configuration configuration = new Configuration();\n        configuration.set(JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MIN, cooldownTimeout);\n        configuration.set(\n                JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MAX, resourceStabilizationTimeout);\n        configuration.set(\n                JobManagerOptions.MAXIMUM_DELAY_FOR_SCALE_TRIGGER, maximumDelayForRescaleTrigger);\n\n        final DefaultStateTransitionManager testInstance =\n                DefaultStateTransitionManager.Factory.fromSettings(\n                                AdaptiveScheduler.Settings.of(configuration))\n                        .create(\n                                TestingStateTransitionManagerContext.stableContext(),\n                                Instant.now());\n        assertThat(testInstance.cooldownTimeout).isEqualTo(cooldownTimeout);\n        assertThat(testInstance.resourceStabilizationTimeout)\n                .isEqualTo(resourceStabilizationTimeout);\n        assertThat(testInstance.maxTriggerDelay).isEqualTo(maximumDelayForRescaleTrigger);\n    }",
          "conflictNames": [
              "cooldownTimeout",
              "maximumDelayForRescaleTrigger",
              "configuration",
              "testInstance"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/1f303a218f47aa1a8eaf1323fc2a5debe914762d^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/DefaultStateTransitionManagerTest.java",
      "locators": [
          {
              "line": 57,
              "column": 24
          },
          {
              "line": 64,
              "column": 68
          },
          {
              "line": 75,
              "column": 60
          }
      ],
      "old_name": "maximumDelayForRescaleTrigger",
      "new_name": "maxDelayForTrigger",
      "ctx": {
          "symbolName": "maximumDelayForRescaleTrigger",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Duration",
          "scopeHint": "in testProperConfiguration(...)",
          "filePath": "DefaultStateTransitionManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testProperConfiguration() throws ConfigurationException {\n        final Duration cooldownTimeout = Duration.ofMillis(1337);\n        final Duration resourceStabilizationTimeout = Duration.ofMillis(7331);\n        final Duration maximumDelayForRescaleTrigger = Duration.ofMillis(4242);\n\n        final Configuration configuration = new Configuration();\n        configuration.set(JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MIN, cooldownTimeout);\n        configuration.set(\n                JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MAX, resourceStabilizationTimeout);\n        configuration.set(\n                JobManagerOptions.MAXIMUM_DELAY_FOR_SCALE_TRIGGER, maximumDelayForRescaleTrigger);\n\n        final DefaultStateTransitionManager testInstance =\n                DefaultStateTransitionManager.Factory.fromSettings(\n                                AdaptiveScheduler.Settings.of(configuration))\n                        .create(\n                                TestingStateTransitionManagerContext.stableContext(),\n                                Instant.now());\n        assertThat(testInstance.cooldownTimeout).isEqualTo(cooldownTimeout);\n        assertThat(testInstance.resourceStabilizationTimeout)\n                .isEqualTo(resourceStabilizationTimeout);\n        assertThat(testInstance.maxTriggerDelay).isEqualTo(maximumDelayForRescaleTrigger);\n    }",
          "conflictNames": [
              "cooldownTimeout",
              "resourceStabilizationTimeout",
              "configuration",
              "testInstance"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/1f303a218f47aa1a8eaf1323fc2a5debe914762d^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/DefaultStateTransitionManagerTest.java",
      "locators": [
          {
              "line": 66,
              "column": 45
          },
          {
              "line": 72,
              "column": 20
          },
          {
              "line": 73,
              "column": 20
          },
          {
              "line": 75,
              "column": 20
          },
          {
              "line": 82,
              "column": 45
          },
          {
              "line": 83,
              "column": 38
          },
          {
              "line": 90,
              "column": 45
          },
          {
              "line": 92,
              "column": 38
          },
          {
              "line": 99,
              "column": 45
          },
          {
              "line": 101,
              "column": 38
          },
          {
              "line": 108,
              "column": 45
          },
          {
              "line": 110,
              "column": 37
          },
          {
              "line": 112,
              "column": 38
          },
          {
              "line": 116,
              "column": 48
          },
          {
              "line": 118,
              "column": 9
          },
          {
              "line": 122,
              "column": 48
          },
          {
              "line": 124,
              "column": 9
          },
          {
              "line": 126,
              "column": 49
          },
          {
              "line": 133,
              "column": 45
          },
          {
              "line": 135,
              "column": 37
          },
          {
              "line": 137,
              "column": 38
          },
          {
              "line": 141,
              "column": 48
          },
          {
              "line": 143,
              "column": 9
          },
          {
              "line": 145,
              "column": 49
          },
          {
              "line": 152,
              "column": 45
          },
          {
              "line": 155,
              "column": 48
          },
          {
              "line": 157,
              "column": 9
          },
          {
              "line": 159,
              "column": 48
          },
          {
              "line": 161,
              "column": 9
          },
          {
              "line": 163,
              "column": 49
          },
          {
              "line": 170,
              "column": 45
          },
          {
              "line": 173,
              "column": 48
          },
          {
              "line": 175,
              "column": 32
          },
          {
              "line": 177,
              "column": 48
          },
          {
              "line": 179,
              "column": 9
          },
          {
              "line": 181,
              "column": 49
          },
          {
              "line": 188,
              "column": 45
          },
          {
              "line": 195,
              "column": 48
          },
          {
              "line": 199,
              "column": 32
          },
          {
              "line": 201,
              "column": 48
          },
          {
              "line": 205,
              "column": 49
          },
          {
              "line": 212,
              "column": 45
          },
          {
              "line": 214,
              "column": 37
          },
          {
              "line": 216,
              "column": 38
          },
          {
              "line": 220,
              "column": 48
          },
          {
              "line": 227,
              "column": 45
          },
          {
              "line": 230,
              "column": 37
          },
          {
              "line": 232,
              "column": 38
          },
          {
              "line": 239,
              "column": 45
          },
          {
              "line": 246,
              "column": 48
          },
          {
              "line": 250,
              "column": 48
          },
          {
              "line": 257,
              "column": 45
          },
          {
              "line": 260,
              "column": 48
          },
          {
              "line": 264,
              "column": 49
          },
          {
              "line": 271,
              "column": 45
          },
          {
              "line": 273,
              "column": 37
          },
          {
              "line": 275,
              "column": 38
          },
          {
              "line": 279,
              "column": 38
          },
          {
              "line": 283,
              "column": 9
          },
          {
              "line": 285,
              "column": 49
          },
          {
              "line": 292,
              "column": 45
          },
          {
              "line": 295,
              "column": 48
          },
          {
              "line": 297,
              "column": 9
          },
          {
              "line": 299,
              "column": 38
          },
          {
              "line": 303,
              "column": 9
          },
          {
              "line": 305,
              "column": 49
          },
          {
              "line": 312,
              "column": 45
          },
          {
              "line": 315,
              "column": 48
          },
          {
              "line": 317,
              "column": 9
          },
          {
              "line": 319,
              "column": 49
          },
          {
              "line": 326,
              "column": 45
          },
          {
              "line": 329,
              "column": 48
          },
          {
              "line": 331,
              "column": 9
          },
          {
              "line": 333,
              "column": 38
          },
          {
              "line": 335,
              "column": 32
          },
          {
              "line": 337,
              "column": 48
          },
          {
              "line": 339,
              "column": 9
          },
          {
              "line": 341,
              "column": 49
          },
          {
              "line": 348,
              "column": 45
          },
          {
              "line": 351,
              "column": 48
          },
          {
              "line": 353,
              "column": 9
          },
          {
              "line": 355,
              "column": 38
          },
          {
              "line": 359,
              "column": 37
          },
          {
              "line": 361,
              "column": 38
          },
          {
              "line": 365,
              "column": 48
          },
          {
              "line": 367,
              "column": 35
          },
          {
              "line": 369,
              "column": 48
          },
          {
              "line": 371,
              "column": 9
          },
          {
              "line": 373,
              "column": 49
          },
          {
              "line": 380,
              "column": 45
          },
          {
              "line": 383,
              "column": 48
          },
          {
              "line": 387,
              "column": 9
          },
          {
              "line": 389,
              "column": 48
          },
          {
              "line": 396,
              "column": 45
          },
          {
              "line": 400,
              "column": 9
          },
          {
              "line": 415,
              "column": 43
          },
          {
              "line": 418,
              "column": 20
          },
          {
              "line": 422,
              "column": 85
          },
          {
              "line": 424,
              "column": 20
          },
          {
              "line": 429,
              "column": 43
          },
          {
              "line": 431,
              "column": 48
          },
          {
              "line": 433,
              "column": 9
          },
          {
              "line": 435,
              "column": 48
          },
          {
              "line": 440,
              "column": 43
          },
          {
              "line": 443,
              "column": 48
          },
          {
              "line": 445,
              "column": 9
          },
          {
              "line": 447,
              "column": 48
          },
          {
              "line": 451,
              "column": 85
          },
          {
              "line": 454,
              "column": 9
          },
          {
              "line": 458,
              "column": 85
          },
          {
              "line": 461,
              "column": 9
          },
          {
              "line": 624,
              "column": 49
          },
          {
              "line": 652,
              "column": 29
          },
          {
              "line": 653,
              "column": 20
          }
      ],
      "old_name": "testInstance",
      "new_name": "factory",
      "ctx": {
          "symbolName": "testInstance",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "DefaultStateTransitionManager",
          "scopeHint": "in testProperConfiguration(...)",
          "filePath": "DefaultStateTransitionManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testProperConfiguration() throws ConfigurationException {\n        final Duration cooldownTimeout = Duration.ofMillis(1337);\n        final Duration resourceStabilizationTimeout = Duration.ofMillis(7331);\n        final Duration maximumDelayForRescaleTrigger = Duration.ofMillis(4242);\n\n        final Configuration configuration = new Configuration();\n        configuration.set(JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MIN, cooldownTimeout);\n        configuration.set(\n                JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MAX, resourceStabilizationTimeout);\n        configuration.set(\n                JobManagerOptions.MAXIMUM_DELAY_FOR_SCALE_TRIGGER, maximumDelayForRescaleTrigger);\n\n        final DefaultStateTransitionManager testInstance =\n                DefaultStateTransitionManager.Factory.fromSettings(\n                                AdaptiveScheduler.Settings.of(configuration))\n                        .create(\n                                TestingStateTransitionManagerContext.stableContext(),\n                                Instant.now());\n        assertThat(testInstance.cooldownTimeout).isEqualTo(cooldownTimeout);\n        assertThat(testInstance.resourceStabilizationTimeout)\n                .isEqualTo(resourceStabilizationTimeout);\n        assertThat(testInstance.maxTriggerDelay).isEqualTo(maximumDelayForRescaleTrigger);\n    }",
          "conflictNames": [
              "cooldownTimeout",
              "resourceStabilizationTimeout",
              "maximumDelayForRescaleTrigger",
              "configuration"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/1f7622d4d23bfcb76f466469ec36585054864f04^1/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/kubeclient/decorators/FlinkConfMountDecorator.java",
      "locators": [
          {
              "line": 139,
              "column": 35
          },
          {
              "line": 141,
              "column": 79
          },
          {
              "line": 170,
              "column": 49
          },
          {
              "line": 173,
              "column": 13
          }
      ],
      "old_name": "propertiesMap",
      "new_name": "confData",
      "ctx": {
          "symbolName": "propertiesMap",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Map<String, String>",
          "scopeHint": "in buildAccompanyingKubernetesResources(...)",
          "filePath": "FlinkConfMountDecorator.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public List<HasMetadata> buildAccompanyingKubernetesResources() throws IOException {\n        final String clusterId = kubernetesComponentConf.getClusterId();\n\n        final Map<String, String> data = new HashMap<>();\n\n        final List<File> localLogFiles = getLocalLogConfFiles();\n        for (File file : localLogFiles) {\n            data.put(file.getName(), Files.toString(file, StandardCharsets.UTF_8));\n        }\n\n        final Map<String, String> propertiesMap =\n                getClusterSidePropertiesMap(kubernetesComponentConf.getFlinkConfiguration());\n        data.put(GlobalConfiguration.getFlinkConfFilename(), getFlinkConfData(propertiesMap));\n\n        final ConfigMap flinkConfConfigMap =\n                new ConfigMapBuilder()\n                        .withApiVersion(Constants.API_VERSION)\n                        .withNewMetadata()\n                        .withName(getFlinkConfConfigMapName(clusterId))\n                        .withLabels(kubernetesComponentConf.getCommonLabels())\n                        .endMetadata()\n                        .addToData(data)\n                        .build();\n\n        return Collections.singletonList(flinkConfConfigMap);\n    }",
          "conflictNames": [
              "clusterId",
              "data",
              "localLogFiles",
              "flinkConfConfigMap"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/1f7622d4d23bfcb76f466469ec36585054864f04^1/flink-runtime/src/main/java/org/apache/flink/runtime/clusterframework/BootstrapTools.java",
      "locators": [
          {
              "line": 26,
              "column": 33
          },
          {
              "line": 75,
              "column": 44
          },
          {
              "line": 75,
              "column": 76
          },
          {
              "line": 76,
              "column": 27
          },
          {
              "line": 78,
              "column": 29
          }
      ],
      "old_name": "entry",
      "new_name": "s",
      "ctx": {
          "symbolName": "entry",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Entry<String, String>",
          "scopeHint": "in writeConfiguration(...)",
          "filePath": "BootstrapTools.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "Exception\n     */\n    public static void writeConfiguration(Configuration cfg, File file) throws IOException {\n        try (FileWriter fwrt = new FileWriter(file);\n                PrintWriter out = new PrintWriter(fwrt)) {\n            for (Map.Entry<String, String> entry : cfg.toFileWritableMap().entrySet()) {\n                out.print(entry.getKey());\n                out.print(\": \");\n                out.println(entry.getValue());\n            }\n        }\n    }\n\n    /**\n     * Sets the value of a new config",
          "conflictNames": [
              "cfg",
              "file",
              "fwrt",
              "out"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/203acadb44dc5a8bba80c277124042f656353bca^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/allocator/StateLocalitySlotAssigner.java",
      "locators": [
          {
              "line": 127,
              "column": 65
          },
          {
              "line": 128,
              "column": 59
          },
          {
              "line": 186,
              "column": 38
          },
          {
              "line": 191,
              "column": 37
          },
          {
              "line": 192,
              "column": 79
          }
      ],
      "old_name": "value",
      "new_name": "numberOfKeyGroups",
      "ctx": {
          "symbolName": "value",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "long",
          "scopeHint": "in calculateScore(...)",
          "filePath": "StateLocalitySlotAssigner.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public Collection<AllocationScore> calculateScore(\n            ExecutionSlotSharingGroup group,\n            Map<JobVertexID, Integer> parallelism,\n            JobInformation jobInformation,\n            JobAllocationsInformation previousAllocations) {\n        final Map<AllocationID, Long> score = new HashMap<>();\n        for (ExecutionVertexID evi : group.getContainedExecutionVertices()) {\n            final KeyGroupRange kgr =\n                    KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(\n                            jobInformation\n                                    .getVertexInformation(evi.getJobVertexId())\n                                    .getMaxParallelism(),\n                            parallelism.get(evi.getJobVertexId()),\n                            evi.getSubtaskIndex());\n            previousAllocations\n                    .getAllocations(evi.getJobVertexId())\n                    .forEach(\n                            allocation -> {\n                                long value =\n                                        allocation\n                                                .getKeyGroupRange()\n                                                .getIntersection(kgr)\n                                                .getNumberOfKeyGroups();\n                                if (value > 0) {\n                                    score.merge(allocation.getAllocationID(), value, Long::sum);\n                                }\n                            });\n        }\n\n        return score.entrySet().stream()\n                .map(e -> new AllocationScore(group.getId(), e.getKey(), e.getValue()))\n                .collect(Collectors.toList());\n    }",
          "conflictNames": [
              "group",
              "parallelism",
              "jobInformation",
              "previousAllocations",
              "score",
              "kgr"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/20e9826f7701f91eedfbf599afb33822128145e6^1/flink-metrics/flink-metrics-prometheus/src/main/java/org/apache/flink/metrics/prometheus/PrometheusReporterFactory.java",
      "locators": [
          {
              "line": 36,
              "column": 16
          },
          {
              "line": 37,
              "column": 27
          },
          {
              "line": 37,
              "column": 67
          },
          {
              "line": 39,
              "column": 39
          }
      ],
      "old_name": "ports",
      "new_name": "portRange",
      "ctx": {
          "symbolName": "ports",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Iterator<Integer>",
          "scopeHint": "in createMetricReporter(...)",
          "filePath": "PrometheusReporterFactory.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public PrometheusReporter createMetricReporter(Properties properties) {\n        MetricConfig metricConfig = (MetricConfig) properties;\n        String portsConfig = metricConfig.getString(ARG_PORT, DEFAULT_PORT);\n        Iterator<Integer> ports = NetUtils.getPortRangeFromString(portsConfig);\n\n        return new PrometheusReporter(ports);\n    }",
          "conflictNames": [
              "properties",
              "metricConfig",
              "portsConfig"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/21403e31f4761bdddf5e4e802e0e5eb9b4533202^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/exec/StateMetadata.java",
      "locators": [
          {
              "line": 117,
              "column": 18
          },
          {
              "line": 120,
              "column": 48
          }
      ],
      "old_name": "stateRetentionTime",
      "new_name": "ttlFromTableConf",
      "ctx": {
          "symbolName": "stateRetentionTime",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Duration",
          "scopeHint": "in getMultiInputOperatorDefaultMeta(...)",
          "filePath": "StateMetadata.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static List<StateMetadata> getMultiInputOperatorDefaultMeta(\n            ReadableConfig tableConfig, String... stateNameList) {\n        Duration stateRetentionTime = tableConfig.get(ExecutionConfigOptions.IDLE_STATE_RETENTION);\n        return IntStream.range(0, stateNameList.length)\n                .boxed()\n                .map(i -> new StateMetadata(i, stateRetentionTime, stateNameList[i]))\n                .collect(Collectors.toList());\n    }",
          "conflictNames": [
              "tableConfig",
              "stateNameList"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/21403e31f4761bdddf5e4e802e0e5eb9b4533202^1/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/optimize/ClearQueryBlockAliasResolverTest.java",
      "locators": [
          {
              "line": 98,
              "column": 27
          },
          {
              "line": 99,
              "column": 20
          }
      ],
      "old_name": "joinHintResolver",
      "new_name": "queryHintsResolver",
      "ctx": {
          "symbolName": "joinHintResolver",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JoinHintsResolver",
          "scopeHint": "in clearQueryBlockAlias(...)",
          "filePath": "ClearQueryBlockAliasResolverTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private List<RelNode> clearQueryBlockAlias(List<RelNode> relNodes) {\n        JoinHintsResolver joinHintResolver = new JoinHintsResolver();\n        relNodes = joinHintResolver.resolve(relNodes);\n        ClearQueryBlockAliasResolver clearQueryBlockAliasResolver =\n                new ClearQueryBlockAliasResolver();\n        return clearQueryBlockAliasResolver.resolve(relNodes);\n    }",
          "conflictNames": [
              "relNodes",
              "clearQueryBlockAliasResolver"
          ]
      },
      "suggestions": [
          {
              "name": "resolver",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/21403e31f4761bdddf5e4e802e0e5eb9b4533202^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/hint/ClearJoinHintsOnUnmatchedNodesShuttle.java",
      "locators": [
          {
              "line": 60,
              "column": 27
          },
          {
              "line": 66,
              "column": 35
          },
          {
              "line": 72,
              "column": 67
          },
          {
              "line": 73,
              "column": 41
          }
      ],
      "old_name": "joinHints",
      "new_name": "queryHints",
      "ctx": {
          "symbolName": "joinHints",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<RelHint>",
          "scopeHint": "in visit(...)",
          "filePath": "ClearJoinHintsOnUnmatchedNodesShuttle.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public RelNode visit(RelNode other) {\n        if (FlinkRelOptUtil.containsSubQuery(other)) {\n            other = resolveSubQuery(other, relNode -> relNode.accept(this));\n        }\n\n        if (other instanceof Hintable) {\n            List<RelHint> originHints = ((Hintable) other).getHints();\n            // 1. classify the hints and separate out the join hints\n            List<RelHint> joinHints =\n                    originHints.stream()\n                            .filter(h -> JoinStrategy.isJoinStrategy(h.hintName))\n                            .collect(Collectors.toList());\n\n            List<RelHint> remainHints = new ArrayList<>(originHints);\n            remainHints.removeAll(joinHints);\n\n            // 2. use hintStrategyTable#apply to determine whether the join hint can be attached\n            // to the current node\n            // If it cannot be attached, it means that the join hint on the current node needs to\n            // be removed.\n            List<RelHint> hintsCanApply = hintStrategyTable.apply(joinHints, other);\n            if (hintsCanApply.size() != joinHints.size()) {\n                hintsCanApply.addAll(remainHints);\n                // As a result, the remaining hints will be attached.\n                other = ((Hintable) other).withHints(hintsCanApply);\n            }\n        }\n\n        return super.visit(other);\n    }",
          "conflictNames": [
              "other",
              "originHints",
              "remainHints",
              "hintsCanApply"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/21403e31f4761bdddf5e4e802e0e5eb9b4533202^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/hint/ClearJoinHintsWithInvalidPropagationShuttle.java",
      "locators": [
          {
              "line": 72,
              "column": 23
          },
          {
              "line": 84,
              "column": 13
          },
          {
              "line": 91,
              "column": 38
          }
      ],
      "old_name": "joinHintsFromOuterQueryBlock",
      "new_name": "queryHintsFromOuterQueryBlock",
      "ctx": {
          "symbolName": "joinHintsFromOuterQueryBlock",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<RelHint>",
          "scopeHint": "in visitBiRel(...)",
          "filePath": "ClearJoinHintsWithInvalidPropagationShuttle.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    protected RelNode visitBiRel(BiRel biRel) {\n        List<RelHint> hints = ((Hintable) biRel).getHints();\n\n        Set<String> allHintNames =\n                hints.stream().map(hint -> hint.hintName).collect(Collectors.toSet());\n\n        // there are no join hints on this Join/Correlate node\n        if (allHintNames.stream().noneMatch(JoinStrategy::isJoinStrategy)) {\n            return super.visit(biRel);\n        }\n\n        Optional<RelHint> firstAliasHint =\n                hints.stream()\n                        .filter(hint -> FlinkHints.HINT_ALIAS.equals(hint.hintName))\n                        .findFirst();\n\n        // there are no alias hints on this Join/Correlate node\n        if (!firstAliasHint.isPresent()) {\n            return super.visit(biRel);\n        }\n\n        List<RelHint> joinHintsFromOuterQueryBlock =\n                hints.stream()\n                        .filter(\n                                hint ->\n                                        JoinStrategy.isJoinStrategy(hint.hintName)\n                                                // if the size of inheritPath is bigger than 0, it\n                                                // means that this join hint is propagated from its\n                                                // parent\n                                                && hint.inheritPath.size()\n                                                        > firstAliasHint.get().inheritPath.size())\n                        .collect(Collectors.toList());\n\n        if (joinHintsFromOuterQueryBlock.isEmpty()) {\n            return super.visit(biRel);\n        }\n\n        RelNode newJoin = biRel;\n        ClearOuterJoinHintShuttle clearOuterJoinHintShuttle;\n\n        for (RelHint outerJoinHint : joinHintsFromOuterQueryBlock) {\n            clearOuterJoinHintShuttle = new ClearOuterJoinHintShuttle(outerJoinHint);\n            newJoin = newJoin.accept(clearOuterJoinHintShuttle);\n        }\n\n        return super.visit(newJoin);\n    }",
          "conflictNames": [
              "biRel",
              "hints",
              "allHintNames",
              "firstAliasHint",
              "newJoin",
              "clearOuterJoinHintShuttle"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/21403e31f4761bdddf5e4e802e0e5eb9b4533202^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/hint/ClearJoinHintsWithInvalidPropagationShuttle.java",
      "locators": [
          {
              "line": 88,
              "column": 17
          },
          {
              "line": 93,
              "column": 13
          },
          {
              "line": 93,
              "column": 23
          },
          {
              "line": 96,
              "column": 28
          }
      ],
      "old_name": "newJoin",
      "new_name": "newRelNode",
      "ctx": {
          "symbolName": "newJoin",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RelNode",
          "scopeHint": "in visitBiRel(...)",
          "filePath": "ClearJoinHintsWithInvalidPropagationShuttle.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    protected RelNode visitBiRel(BiRel biRel) {\n        List<RelHint> hints = ((Hintable) biRel).getHints();\n\n        Set<String> allHintNames =\n                hints.stream().map(hint -> hint.hintName).collect(Collectors.toSet());\n\n        // there are no join hints on this Join/Correlate node\n        if (allHintNames.stream().noneMatch(JoinStrategy::isJoinStrategy)) {\n            return super.visit(biRel);\n        }\n\n        Optional<RelHint> firstAliasHint =\n                hints.stream()\n                        .filter(hint -> FlinkHints.HINT_ALIAS.equals(hint.hintName))\n                        .findFirst();\n\n        // there are no alias hints on this Join/Correlate node\n        if (!firstAliasHint.isPresent()) {\n            return super.visit(biRel);\n        }\n\n        List<RelHint> joinHintsFromOuterQueryBlock =\n                hints.stream()\n                        .filter(\n                                hint ->\n                                        JoinStrategy.isJoinStrategy(hint.hintName)\n                                                // if the size of inheritPath is bigger than 0, it\n                                                // means that this join hint is propagated from its\n                                                // parent\n                                                && hint.inheritPath.size()\n                                                        > firstAliasHint.get().inheritPath.size())\n                        .collect(Collectors.toList());\n\n        if (joinHintsFromOuterQueryBlock.isEmpty()) {\n            return super.visit(biRel);\n        }\n\n        RelNode newJoin = biRel;\n        ClearOuterJoinHintShuttle clearOuterJoinHintShuttle;\n\n        for (RelHint outerJoinHint : joinHintsFromOuterQueryBlock) {\n            clearOuterJoinHintShuttle = new ClearOuterJoinHintShuttle(outerJoinHint);\n            newJoin = newJoin.accept(clearOuterJoinHintShuttle);\n        }\n\n        return super.visit(newJoin);\n    }",
          "conflictNames": [
              "biRel",
              "hints",
              "allHintNames",
              "firstAliasHint",
              "joinHintsFromOuterQueryBlock",
              "clearOuterJoinHintShuttle"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/21403e31f4761bdddf5e4e802e0e5eb9b4533202^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/hint/ClearJoinHintsWithInvalidPropagationShuttle.java",
      "locators": [
          {
              "line": 89,
              "column": 35
          },
          {
              "line": 92,
              "column": 13
          },
          {
              "line": 93,
              "column": 38
          }
      ],
      "old_name": "clearOuterJoinHintShuttle",
      "new_name": "clearOuterQueryHintShuttle",
      "ctx": {
          "symbolName": "clearOuterJoinHintShuttle",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ClearOuterJoinHintShuttle",
          "scopeHint": "in visitBiRel(...)",
          "filePath": "ClearJoinHintsWithInvalidPropagationShuttle.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    protected RelNode visitBiRel(BiRel biRel) {\n        List<RelHint> hints = ((Hintable) biRel).getHints();\n\n        Set<String> allHintNames =\n                hints.stream().map(hint -> hint.hintName).collect(Collectors.toSet());\n\n        // there are no join hints on this Join/Correlate node\n        if (allHintNames.stream().noneMatch(JoinStrategy::isJoinStrategy)) {\n            return super.visit(biRel);\n        }\n\n        Optional<RelHint> firstAliasHint =\n                hints.stream()\n                        .filter(hint -> FlinkHints.HINT_ALIAS.equals(hint.hintName))\n                        .findFirst();\n\n        // there are no alias hints on this Join/Correlate node\n        if (!firstAliasHint.isPresent()) {\n            return super.visit(biRel);\n        }\n\n        List<RelHint> joinHintsFromOuterQueryBlock =\n                hints.stream()\n                        .filter(\n                                hint ->\n                                        JoinStrategy.isJoinStrategy(hint.hintName)\n                                                // if the size of inheritPath is bigger than 0, it\n                                                // means that this join hint is propagated from its\n                                                // parent\n                                                && hint.inheritPath.size()\n                                                        > firstAliasHint.get().inheritPath.size())\n                        .collect(Collectors.toList());\n\n        if (joinHintsFromOuterQueryBlock.isEmpty()) {\n            return super.visit(biRel);\n        }\n\n        RelNode newJoin = biRel;\n        ClearOuterJoinHintShuttle clearOuterJoinHintShuttle;\n\n        for (RelHint outerJoinHint : joinHintsFromOuterQueryBlock) {\n            clearOuterJoinHintShuttle = new ClearOuterJoinHintShuttle(outerJoinHint);\n            newJoin = newJoin.accept(clearOuterJoinHintShuttle);\n        }\n\n        return super.visit(newJoin);\n    }",
          "conflictNames": [
              "biRel",
              "hints",
              "allHintNames",
              "firstAliasHint",
              "joinHintsFromOuterQueryBlock",
              "newJoin"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/21403e31f4761bdddf5e4e802e0e5eb9b4533202^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/hint/ClearJoinHintsWithInvalidPropagationShuttle.java",
      "locators": [
          {
              "line": 91,
              "column": 22
          },
          {
              "line": 92,
              "column": 71
          }
      ],
      "old_name": "outerJoinHint",
      "new_name": "outerQueryHint",
      "ctx": {
          "symbolName": "outerJoinHint",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "RelHint",
          "scopeHint": "in visitBiRel(...)",
          "filePath": "ClearJoinHintsWithInvalidPropagationShuttle.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "lect(Collectors.toList());\n\n        if (joinHintsFromOuterQueryBlock.isEmpty()) {\n            return super.visit(biRel);\n        }\n\n        RelNode newJoin = biRel;\n        ClearOuterJoinHintShuttle clearOuterJoinHintShuttle;\n\n        for (RelHint outerJoinHint : joinHintsFromOuterQueryBlock) {\n            clearOuterJoinHintShuttle = new ClearOuterJoinHintShuttle(outerJoinHint);\n            newJoin = newJoin.accept(clearOuterJoinHintShuttle);\n        }\n\n        return super.visit(newJoin);\n    }\n",
          "conflictNames": [
              "biRel",
              "hints",
              "allHintNames",
              "firstAliasHint",
              "joinHintsFromOuterQueryBlock",
              "newJoin",
              "clearOuterJoinHintShuttle"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/21403e31f4761bdddf5e4e802e0e5eb9b4533202^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/hint/ClearJoinHintsWithInvalidPropagationShuttle.java",
      "locators": [
          {
              "line": 137,
              "column": 31
          },
          {
              "line": 140,
              "column": 17
          },
          {
              "line": 141,
              "column": 30
          }
      ],
      "old_name": "invalidJoinHint",
      "new_name": "invalidQueryHint",
      "ctx": {
          "symbolName": "invalidJoinHint",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Optional<RelHint>",
          "scopeHint": "in visitBiRel(...)",
          "filePath": "ClearJoinHintsWithInvalidPropagationShuttle.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private RelNode visitBiRel(BiRel biRel) {\n            Hintable hBiRel = (Hintable) biRel;\n            List<RelHint> hints = new ArrayList<>(hBiRel.getHints());\n            Optional<RelHint> invalidJoinHint = getInvalidJoinHint(hints);\n\n            // if this join node contains the join hint that needs to be removed\n            if (invalidJoinHint.isPresent()) {\n                hints.remove(invalidJoinHint.get());\n                return super.visit(hBiRel.withHints(hints));\n            }\n\n            return super.visit(biRel);\n        }",
          "conflictNames": [
              "biRel",
              "hBiRel",
              "hints"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/21403e31f4761bdddf5e4e802e0e5eb9b4533202^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/optimize/JoinHintsResolver.java",
      "locators": [
          {
              "line": 137,
              "column": 23
          },
          {
              "line": 138,
              "column": 14
          }
      ],
      "old_name": "oldJoinHints",
      "new_name": "oldQueryHints",
      "ctx": {
          "symbolName": "oldJoinHints",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<RelHint>",
          "scopeHint": "in visitBiRel(...)",
          "filePath": "JoinHintsResolver.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    protected RelNode visitBiRel(BiRel biRel) {\n        Optional<String> leftName = extractAliasOrTableName(biRel.getLeft());\n        Optional<String> rightName = extractAliasOrTableName(biRel.getRight());\n\n        Set<RelHint> existentKVHints = new HashSet<>();\n\n        List<RelHint> oldHints = ((Hintable) biRel).getHints();\n        List<RelHint> newHints = new ArrayList<>();\n\n        for (RelHint hint : oldHints) {\n            if (JoinStrategy.isLookupHint(hint.hintName)) {\n                allHints.add(trimInheritPath(hint));\n                Configuration conf = Configuration.fromMap(hint.kvOptions);\n                // hint option checker has done the validation\n                String lookupTable = conf.get(LOOKUP_TABLE);\n\n                // add options about this hint for finally checking\n                initOptionInfoAboutJoinHintsForCheck(\n                        hint.hintName, Collections.singletonList(lookupTable));\n\n                assert null != lookupTable;\n                if (rightName.isPresent() && matchIdentifier(lookupTable, rightName.get())) {\n                    validHints.add(trimInheritPath(hint));\n                    updateInfoForOptionCheck(hint.hintName, rightName);\n                    newHints.add(hint);\n                }\n            } else if (JoinStrategy.isJoinStrategy(hint.hintName)) {\n                allHints.add(trimInheritPath(hint));\n                // add options about this hint for finally checking\n                initOptionInfoAboutJoinHintsForCheck(hint.hintName, hint.listOptions);\n\n                // the declared table name or query block name is replaced by\n                // JoinStrategy#LEFT_INPUT or JoinStrategy#RIGHT_INPUT\n                List<String> newOptions =\n                        getNewJoinHintOptions(leftName, rightName, hint.listOptions, hint.hintName);\n\n                // check whether the join hints options are valid\n                boolean isValidOption = JoinStrategy.validOptions(hint.hintName, newOptions);\n                if (isValidOption) {\n                    validHints.add(trimInheritPath(hint));\n                    // if the hint defines more than one args, only\n                    // retain the first one\n                    newHints.add(\n                            RelHint.builder(hint.hintName)\n                                    .hintOptions(singletonList(newOptions.get(0)))\n                                    .build());\n                }\n            } else {\n                if (!existentKVHints.contains(hint)) {\n                    existentKVHints.add(hint);\n                    newHints.add(hint);\n                }\n            }\n        }\n\n        RelNode newNode = super.visitChildren(biRel);\n\n        List<RelHint> oldJoinHints = FlinkHints.getAllJoinHints(oldHints);\n        if (!oldJoinHints.isEmpty()) {\n            // replace the table name as LEFT or RIGHT\n            return ((Hintable) newNode).withHints(newHints);\n        }\n        // has no hints, return original node directly.\n        return newNode;\n    }",
          "conflictNames": [
              "biRel",
              "leftName",
              "rightName",
              "existentKVHints",
              "oldHints",
              "newHints",
              "conf",
              "lookupTable",
              "newOptions",
              "isValidOption",
              "newNode"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/21403e31f4761bdddf5e4e802e0e5eb9b4533202^1/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/optimize/JoinHintResolverTest.java",
      "locators": [
          {
              "line": 98,
              "column": 27
          },
          {
              "line": 99,
              "column": 16
          }
      ],
      "old_name": "joinHintResolver",
      "new_name": "resolver",
      "ctx": {
          "symbolName": "joinHintResolver",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JoinHintsResolver",
          "scopeHint": "in resolveJoinHint(...)",
          "filePath": "JoinHintResolverTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private List<RelNode> resolveJoinHint(List<RelNode> relNodes) {\n        JoinHintsResolver joinHintResolver = new JoinHintsResolver();\n        return joinHintResolver.resolve(relNodes);\n    }",
          "conflictNames": [
              "relNodes"
          ]
      },
      "suggestions": [
          {
              "name": "queryHintsResolver",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/21b22c0829463136e556b1b4cf312d602d227d09^1/flink-core/src/test/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializerSnapshotTest.java",
      "locators": [
          {
              "line": 118,
              "column": 48
          },
          {
              "line": 121,
              "column": 61
          },
          {
              "line": 141,
              "column": 48
          },
          {
              "line": 148,
              "column": 61
          },
          {
              "line": 167,
              "column": 48
          },
          {
              "line": 170,
              "column": 61
          },
          {
              "line": 190,
              "column": 48
          },
          {
              "line": 197,
              "column": 17
          },
          {
              "line": 204,
              "column": 48
          },
          {
              "line": 215,
              "column": 17
          },
          {
              "line": 222,
              "column": 48
          },
          {
              "line": 229,
              "column": 17
          },
          {
              "line": 236,
              "column": 48
          },
          {
              "line": 243,
              "column": 17
          },
          {
              "line": 250,
              "column": 48
          },
          {
              "line": 269,
              "column": 17
          },
          {
              "line": 276,
              "column": 48
          },
          {
              "line": 295,
              "column": 17
          },
          {
              "line": 302,
              "column": 48
          },
          {
              "line": 321,
              "column": 17
          }
      ],
      "old_name": "testSnapshot",
      "new_name": "newSnapshot",
      "ctx": {
          "symbolName": "testSnapshot",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "PojoSerializerSnapshot<TestPojo>",
          "scopeHint": "in testRestoreSerializerWithSameFields(...)",
          "filePath": "PojoSerializerSnapshotTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testRestoreSerializerWithSameFields() {\n        final PojoSerializerSnapshot<TestPojo> testSnapshot =\n                buildTestSnapshot(Arrays.asList(ID_FIELD, NAME_FIELD, HEIGHT_FIELD));\n\n        final TypeSerializer<TestPojo> restoredSerializer = testSnapshot.restoreSerializer();\n        assertSame(restoredSerializer.getClass(), PojoSerializer.class);\n        final PojoSerializer<TestPojo> restoredPojoSerializer =\n                (PojoSerializer<TestPojo>) restoredSerializer;\n\n        final Field[] restoredFields = restoredPojoSerializer.getFields();\n        assertArrayEquals(\n                new Field[] {ID_FIELD.field, NAME_FIELD.field, HEIGHT_FIELD.field}, restoredFields);\n\n        final TypeSerializer<?>[] restoredFieldSerializers =\n                restoredPojoSerializer.getFieldSerializers();\n        assertArrayEquals(\n                new TypeSerializer[] {\n                    IntSerializer.INSTANCE, StringSerializer.INSTANCE, DoubleSerializer.INSTANCE\n                },\n                restoredFieldSerializers);\n    }",
          "conflictNames": [
              "restoredSerializer",
              "restoredPojoSerializer",
              "restoredFields",
              "restoredFieldSerializers"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/21b22c0829463136e556b1b4cf312d602d227d09^1/flink-core/src/test/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializerSnapshotTest.java",
      "locators": [
          {
              "line": 193,
              "column": 40
          },
          {
              "line": 197,
              "column": 57
          },
          {
              "line": 211,
              "column": 40
          },
          {
              "line": 215,
              "column": 57
          },
          {
              "line": 225,
              "column": 40
          },
          {
              "line": 229,
              "column": 57
          },
          {
              "line": 239,
              "column": 40
          },
          {
              "line": 243,
              "column": 57
          },
          {
              "line": 260,
              "column": 40
          },
          {
              "line": 269,
              "column": 57
          },
          {
              "line": 286,
              "column": 40
          },
          {
              "line": 295,
              "column": 57
          },
          {
              "line": 312,
              "column": 40
          },
          {
              "line": 321,
              "column": 57
          }
      ],
      "old_name": "newPojoSerializer",
      "new_name": "oldSnapshot",
      "ctx": {
          "symbolName": "newPojoSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "PojoSerializer<TestPojo>",
          "scopeHint": "in testResolveSchemaCompatibilityWithSameFields(...)",
          "filePath": "PojoSerializerSnapshotTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testResolveSchemaCompatibilityWithSameFields() {\n        final PojoSerializerSnapshot<TestPojo> testSnapshot =\n                buildTestSnapshot(Arrays.asList(ID_FIELD, NAME_FIELD, HEIGHT_FIELD));\n\n        final PojoSerializer<TestPojo> newPojoSerializer =\n                buildTestNewPojoSerializer(Arrays.asList(ID_FIELD, NAME_FIELD, HEIGHT_FIELD));\n\n        final TypeSerializerSchemaCompatibility<TestPojo> resultCompatibility =\n                testSnapshot.resolveSchemaCompatibility(newPojoSerializer);\n\n        assertTrue(resultCompatibility.isCompatibleAsIs());\n    }",
          "conflictNames": [
              "testSnapshot",
              "resultCompatibility"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/21b22c0829463136e556b1b4cf312d602d227d09^1/flink-core/src/test/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializerSnapshotTest.java",
      "locators": [
          {
              "line": 118,
              "column": 48
          },
          {
              "line": 121,
              "column": 61
          },
          {
              "line": 141,
              "column": 48
          },
          {
              "line": 148,
              "column": 61
          },
          {
              "line": 167,
              "column": 48
          },
          {
              "line": 170,
              "column": 61
          },
          {
              "line": 190,
              "column": 48
          },
          {
              "line": 197,
              "column": 17
          },
          {
              "line": 204,
              "column": 48
          },
          {
              "line": 215,
              "column": 17
          },
          {
              "line": 222,
              "column": 48
          },
          {
              "line": 229,
              "column": 17
          },
          {
              "line": 236,
              "column": 48
          },
          {
              "line": 243,
              "column": 17
          },
          {
              "line": 250,
              "column": 48
          },
          {
              "line": 269,
              "column": 17
          },
          {
              "line": 276,
              "column": 48
          },
          {
              "line": 295,
              "column": 17
          },
          {
              "line": 302,
              "column": 48
          },
          {
              "line": 321,
              "column": 17
          }
      ],
      "old_name": "testSnapshot",
      "new_name": "oldSnapshot",
      "ctx": {
          "symbolName": "testSnapshot",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "PojoSerializerSnapshot<TestPojo>",
          "scopeHint": "in testRestoreSerializerWithSameFields(...)",
          "filePath": "PojoSerializerSnapshotTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testRestoreSerializerWithSameFields() {\n        final PojoSerializerSnapshot<TestPojo> testSnapshot =\n                buildTestSnapshot(Arrays.asList(ID_FIELD, NAME_FIELD, HEIGHT_FIELD));\n\n        final TypeSerializer<TestPojo> restoredSerializer = testSnapshot.restoreSerializer();\n        assertSame(restoredSerializer.getClass(), PojoSerializer.class);\n        final PojoSerializer<TestPojo> restoredPojoSerializer =\n                (PojoSerializer<TestPojo>) restoredSerializer;\n\n        final Field[] restoredFields = restoredPojoSerializer.getFields();\n        assertArrayEquals(\n                new Field[] {ID_FIELD.field, NAME_FIELD.field, HEIGHT_FIELD.field}, restoredFields);\n\n        final TypeSerializer<?>[] restoredFieldSerializers =\n                restoredPojoSerializer.getFieldSerializers();\n        assertArrayEquals(\n                new TypeSerializer[] {\n                    IntSerializer.INSTANCE, StringSerializer.INSTANCE, DoubleSerializer.INSTANCE\n                },\n                restoredFieldSerializers);\n    }",
          "conflictNames": [
              "restoredSerializer",
              "restoredPojoSerializer",
              "restoredFields",
              "restoredFieldSerializers"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/21b22c0829463136e556b1b4cf312d602d227d09^1/flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializerSnapshot.java",
      "locators": [
          {
              "line": 307,
              "column": 44
          },
          {
              "line": 321,
              "column": 13
          },
          {
              "line": 325,
              "column": 17
          },
          {
              "line": 326,
              "column": 47
          }
      ],
      "old_name": "associatedNewFieldSerializers",
      "new_name": "associatedNewFieldSerializerSnapshots",
      "ctx": {
          "symbolName": "associatedNewFieldSerializers",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ArrayList<TypeSerializer<?>>",
          "scopeHint": "in getCompatibilityOfPreExistingFields(...)",
          "filePath": "PojoSerializerSnapshot.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Finds which Pojo fields exists both in the new {@link PojoSerializer} as well as in the\n     * previous one (represented by this snapshot), and returns an {@link\n     * IntermediateCompatibilityResult} of the serializers of those preexisting fields.\n     */\n    private static <T> IntermediateCompatibilityResult<T> getCompatibilityOfPreExistingFields(\n            PojoSerializer<T> newPojoSerializer,\n            LinkedOptionalMap<Field, TypeSerializerSnapshot<?>> fieldSerializerSnapshots) {\n\n        // the present entries dictates the preexisting fields, because removed fields would be\n        // represented as absent keys in the optional map.\n        final Set<LinkedOptionalMap.KeyValue<Field, TypeSerializerSnapshot<?>>>\n                presentFieldSnapshots = fieldSerializerSnapshots.getPresentEntries();\n\n        final ArrayList<TypeSerializerSnapshot<?>> associatedFieldSerializerSnapshots =\n                new ArrayList<>(presentFieldSnapshots.size());\n        final ArrayList<TypeSerializer<?>> associatedNewFieldSerializers =\n                new ArrayList<>(presentFieldSnapshots.size());\n\n        final Map<Field, TypeSerializer<?>> newFieldSerializersIndex =\n                buildNewFieldSerializersIndex(newPojoSerializer);\n        for (LinkedOptionalMap.KeyValue<Field, TypeSerializerSnapshot<?>> presentFieldEntry :\n                presentFieldSnapshots) {\n            TypeSerializer<?> associatedNewFieldSerializer =\n                    newFieldSerializersIndex.get(presentFieldEntry.getKey());\n            checkState(\n                    associatedNewFieldSerializer != null,\n                    \"a present field should have its associated new field serializer available.\");\n\n            associatedFieldSerializerSnapshots.add(presentFieldEntry.getValue());\n            associatedNewFieldSerializers.add(associatedNewFieldSerializer);\n        }\n\n        return CompositeTypeSerializerUtil.constructIntermediateCompatibilityResult(\n                associatedNewFieldSerializers.toArray(\n                        new TypeSerializer<?>[associatedNewFieldSerializers.size()]),\n                associatedFieldSerializerSnapshots.toArray(\n                        new TypeSerializerSnapshot<?>[associatedFieldSerializerSnapshots.size()]));\n    }",
          "conflictNames": [
              "newPojoSerializer",
              "fieldSerializerSnapshots",
              "presentFieldSnapshots",
              "associatedFieldSerializerSnapshots",
              "newFieldSerializersIndex",
              "associatedNewFieldSerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/21b22c0829463136e556b1b4cf312d602d227d09^1/flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializerSnapshot.java",
      "locators": [
          {
              "line": 310,
              "column": 45
          },
          {
              "line": 315,
              "column": 21
          }
      ],
      "old_name": "newFieldSerializersIndex",
      "new_name": "newFieldSerializerSnapshots",
      "ctx": {
          "symbolName": "newFieldSerializersIndex",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Map<Field, TypeSerializer<?>>",
          "scopeHint": "in getCompatibilityOfPreExistingFields(...)",
          "filePath": "PojoSerializerSnapshot.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Finds which Pojo fields exists both in the new {@link PojoSerializer} as well as in the\n     * previous one (represented by this snapshot), and returns an {@link\n     * IntermediateCompatibilityResult} of the serializers of those preexisting fields.\n     */\n    private static <T> IntermediateCompatibilityResult<T> getCompatibilityOfPreExistingFields(\n            PojoSerializer<T> newPojoSerializer,\n            LinkedOptionalMap<Field, TypeSerializerSnapshot<?>> fieldSerializerSnapshots) {\n\n        // the present entries dictates the preexisting fields, because removed fields would be\n        // represented as absent keys in the optional map.\n        final Set<LinkedOptionalMap.KeyValue<Field, TypeSerializerSnapshot<?>>>\n                presentFieldSnapshots = fieldSerializerSnapshots.getPresentEntries();\n\n        final ArrayList<TypeSerializerSnapshot<?>> associatedFieldSerializerSnapshots =\n                new ArrayList<>(presentFieldSnapshots.size());\n        final ArrayList<TypeSerializer<?>> associatedNewFieldSerializers =\n                new ArrayList<>(presentFieldSnapshots.size());\n\n        final Map<Field, TypeSerializer<?>> newFieldSerializersIndex =\n                buildNewFieldSerializersIndex(newPojoSerializer);\n        for (LinkedOptionalMap.KeyValue<Field, TypeSerializerSnapshot<?>> presentFieldEntry :\n                presentFieldSnapshots) {\n            TypeSerializer<?> associatedNewFieldSerializer =\n                    newFieldSerializersIndex.get(presentFieldEntry.getKey());\n            checkState(\n                    associatedNewFieldSerializer != null,\n                    \"a present field should have its associated new field serializer available.\");\n\n            associatedFieldSerializerSnapshots.add(presentFieldEntry.getValue());\n            associatedNewFieldSerializers.add(associatedNewFieldSerializer);\n        }\n\n        return CompositeTypeSerializerUtil.constructIntermediateCompatibilityResult(\n                associatedNewFieldSerializers.toArray(\n                        new TypeSerializer<?>[associatedNewFieldSerializers.size()]),\n                associatedFieldSerializerSnapshots.toArray(\n                        new TypeSerializerSnapshot<?>[associatedFieldSerializerSnapshots.size()]));\n    }",
          "conflictNames": [
              "newPojoSerializer",
              "fieldSerializerSnapshots",
              "presentFieldSnapshots",
              "associatedFieldSerializerSnapshots",
              "associatedNewFieldSerializers",
              "associatedNewFieldSerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/21b22c0829463136e556b1b4cf312d602d227d09^1/flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializerSnapshot.java",
      "locators": [
          {
              "line": 369,
              "column": 44
          },
          {
              "line": 380,
              "column": 17
          },
          {
              "line": 385,
              "column": 17
          },
          {
              "line": 386,
              "column": 47
          }
      ],
      "old_name": "associatedNewSubclassSerializers",
      "new_name": "associatedNewSubclassSerializerSnapshots",
      "ctx": {
          "symbolName": "associatedNewSubclassSerializers",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ArrayList<TypeSerializer<?>>",
          "scopeHint": "in getCompatibilityOfPreExistingRegisteredSubclasses(...)",
          "filePath": "PojoSerializerSnapshot.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Finds which registered subclasses exists both in the new {@link PojoSerializer} as well as in\n     * the previous one (represented by this snapshot), and returns an {@link\n     * IntermediateCompatibilityResult} of the serializers of this preexisting registered\n     * subclasses.\n     */\n    private static <T>\n            IntermediateCompatibilityResult<T> getCompatibilityOfPreExistingRegisteredSubclasses(\n                    PojoSerializer<T> newPojoSerializer,\n                    LinkedOptionalMap<Class<?>, TypeSerializerSnapshot<?>>\n                            registeredSubclassSerializerSnapshots) {\n\n        final LinkedHashMap<Class<?>, TypeSerializerSnapshot<?>> unwrappedSerializerSnapshots =\n                registeredSubclassSerializerSnapshots.unwrapOptionals();\n\n        final ArrayList<TypeSerializerSnapshot<?>> associatedSubclassSerializerSnapshots =\n                new ArrayList<>();\n        final ArrayList<TypeSerializer<?>> associatedNewSubclassSerializers = new ArrayList<>();\n\n        final LinkedHashMap<Class<?>, TypeSerializer<?>> newSubclassSerializerRegistry =\n                newPojoSerializer.getBundledSubclassSerializerRegistry();\n\n        for (Map.Entry<Class<?>, TypeSerializerSnapshot<?>> entry :\n                unwrappedSerializerSnapshots.entrySet()) {\n            TypeSerializer<?> newRegisteredSerializer =\n                    newSubclassSerializerRegistry.get(entry.getKey());\n            if (newRegisteredSerializer != null) {\n                associatedSubclassSerializerSnapshots.add(entry.getValue());\n                associatedNewSubclassSerializers.add(newRegisteredSerializer);\n            }\n        }\n\n        return CompositeTypeSerializerUtil.constructIntermediateCompatibilityResult(\n                associatedNewSubclassSerializers.toArray(\n                        new TypeSerializer<?>[associatedNewSubclassSerializers.size()]),\n                associatedSubclassSerializerSnapshots.toArray(\n                        new TypeSerializerSnapshot<?>\n                                [associatedSubclassSerializerSnapshots.size()]));\n    }",
          "conflictNames": [
              "newPojoSerializer",
              "registeredSubclassSerializerSnapshots",
              "unwrappedSerializerSnapshots",
              "associatedSubclassSerializerSnapshots",
              "newSubclassSerializerRegistry",
              "newRegisteredSerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/21b22c0829463136e556b1b4cf312d602d227d09^1/flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializerSnapshot.java",
      "locators": [
          {
              "line": 376,
              "column": 31
          },
          {
              "line": 378,
              "column": 17
          },
          {
              "line": 380,
              "column": 54
          }
      ],
      "old_name": "newRegisteredSerializer",
      "new_name": "newRegisteredSerializerSnapshot",
      "ctx": {
          "symbolName": "newRegisteredSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TypeSerializer<?>",
          "scopeHint": "in getCompatibilityOfPreExistingRegisteredSubclasses(...)",
          "filePath": "PojoSerializerSnapshot.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Finds which registered subclasses exists both in the new {@link PojoSerializer} as well as in\n     * the previous one (represented by this snapshot), and returns an {@link\n     * IntermediateCompatibilityResult} of the serializers of this preexisting registered\n     * subclasses.\n     */\n    private static <T>\n            IntermediateCompatibilityResult<T> getCompatibilityOfPreExistingRegisteredSubclasses(\n                    PojoSerializer<T> newPojoSerializer,\n                    LinkedOptionalMap<Class<?>, TypeSerializerSnapshot<?>>\n                            registeredSubclassSerializerSnapshots) {\n\n        final LinkedHashMap<Class<?>, TypeSerializerSnapshot<?>> unwrappedSerializerSnapshots =\n                registeredSubclassSerializerSnapshots.unwrapOptionals();\n\n        final ArrayList<TypeSerializerSnapshot<?>> associatedSubclassSerializerSnapshots =\n                new ArrayList<>();\n        final ArrayList<TypeSerializer<?>> associatedNewSubclassSerializers = new ArrayList<>();\n\n        final LinkedHashMap<Class<?>, TypeSerializer<?>> newSubclassSerializerRegistry =\n                newPojoSerializer.getBundledSubclassSerializerRegistry();\n\n        for (Map.Entry<Class<?>, TypeSerializerSnapshot<?>> entry :\n                unwrappedSerializerSnapshots.entrySet()) {\n            TypeSerializer<?> newRegisteredSerializer =\n                    newSubclassSerializerRegistry.get(entry.getKey());\n            if (newRegisteredSerializer != null) {\n                associatedSubclassSerializerSnapshots.add(entry.getValue());\n                associatedNewSubclassSerializers.add(newRegisteredSerializer);\n            }\n        }\n\n        return CompositeTypeSerializerUtil.constructIntermediateCompatibilityResult(\n                associatedNewSubclassSerializers.toArray(\n                        new TypeSerializer<?>[associatedNewSubclassSerializers.size()]),\n                associatedSubclassSerializerSnapshots.toArray(\n                        new TypeSerializerSnapshot<?>\n                                [associatedSubclassSerializerSnapshots.size()]));\n    }",
          "conflictNames": [
              "newPojoSerializer",
              "registeredSubclassSerializerSnapshots",
              "unwrappedSerializerSnapshots",
              "associatedSubclassSerializerSnapshots",
              "associatedNewSubclassSerializers",
              "newSubclassSerializerRegistry"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/23272f03f2925abaee3b37a6b33ea9f62ea5c8e1^1/flink-runtime/src/test/java/org/apache/flink/runtime/deployment/TaskDeploymentDescriptorFactoryTest.java",
      "locators": [
          {
              "line": 82,
              "column": 34
          },
          {
              "line": 84,
              "column": 38
          },
          {
              "line": 88,
              "column": 51
          },
          {
              "line": 113,
              "column": 34
          },
          {
              "line": 115,
              "column": 38
          }
      ],
      "old_name": "ejv",
      "new_name": "executionJobVertices",
      "ctx": {
          "symbolName": "ejv",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ExecutionJobVertex",
          "scopeHint": "in testCacheShuffleDescriptor(...)",
          "filePath": "TaskDeploymentDescriptorFactoryTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void testCacheShuffleDescriptor(TestingBlobWriter blobWriter) throws Exception {\n        final JobID jobId = new JobID();\n\n        final ExecutionJobVertex ejv = setupExecutionGraphAndGetVertex(jobId, blobWriter);\n\n        final ExecutionVertex ev21 = ejv.getTaskVertices()[0];\n        createTaskDeploymentDescriptor(ev21);\n\n        // The ShuffleDescriptors should be cached\n        final IntermediateResult consumedResult = ejv.getInputs().get(0);\n        final MaybeOffloaded<ShuffleDescriptor[]> maybeOffloaded =\n                consumedResult.getCachedShuffleDescriptors(ev21.getConsumedPartitionGroup(0));\n\n        final ShuffleDescriptor[] cachedShuffleDescriptors =\n                deserializeShuffleDescriptors(maybeOffloaded, jobId, blobWriter);\n\n        // Check if the ShuffleDescriptors are cached correctly\n        assertEquals(ev21.getConsumedPartitionGroup(0).size(), cachedShuffleDescriptors.length);\n\n        int idx = 0;\n        for (IntermediateResultPartitionID consumedPartitionId :\n                ev21.getConsumedPartitionGroup(0)) {\n            assertEquals(\n                    consumedPartitionId,\n                    cachedShuffleDescriptors[idx++].getResultPartitionID().getPartitionId());\n        }\n    }",
          "conflictNames": [
              "blobWriter",
              "jobId",
              "ev21",
              "consumedResult",
              "maybeOffloaded",
              "cachedShuffleDescriptors",
              "idx"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/23272f03f2925abaee3b37a6b33ea9f62ea5c8e1^1/flink-runtime/src/main/java/org/apache/flink/runtime/deployment/TaskDeploymentDescriptorFactory.java",
      "locators": [
          {
              "line": 176,
              "column": 45
          },
          {
              "line": 178,
              "column": 13
          },
          {
              "line": 179,
              "column": 13
          },
          {
              "line": 182,
              "column": 45
          },
          {
              "line": 184,
              "column": 16
          }
      ],
      "old_name": "serializedShuffleDescriptors",
      "new_name": "cachedShuffleDescriptors",
      "ctx": {
          "symbolName": "serializedShuffleDescriptors",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "MaybeOffloaded<ShuffleDescriptor[]>",
          "scopeHint": "in getConsumedPartitionShuffleDescriptors(...)",
          "filePath": "TaskDeploymentDescriptorFactory.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private MaybeOffloaded<ShuffleDescriptor[]> getConsumedPartitionShuffleDescriptors(\n            IntermediateResult intermediateResult, ConsumedPartitionGroup consumedPartitionGroup)\n            throws IOException {\n        MaybeOffloaded<ShuffleDescriptor[]> serializedShuffleDescriptors =\n                intermediateResult.getCachedShuffleDescriptors(consumedPartitionGroup);\n        if (serializedShuffleDescriptors == null) {\n            serializedShuffleDescriptors =\n                    computeConsumedPartitionShuffleDescriptors(consumedPartitionGroup);\n            intermediateResult.cacheShuffleDescriptors(\n                    consumedPartitionGroup, serializedShuffleDescriptors);\n        }\n        return serializedShuffleDescriptors;\n    }",
          "conflictNames": [
              "intermediateResult",
              "consumedPartitionGroup"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2385cc05e311797d209e85ce9b9e668a7dd3c51c^1/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/catalog/CatalogManager.java",
      "locators": [
          {
              "line": 350,
              "column": 37
          },
          {
              "line": 352,
              "column": 51
          },
          {
              "line": 353,
              "column": 34
          }
      ],
      "old_name": "oldCatalogDescriptor",
      "new_name": "oldDescriptorOpt",
      "ctx": {
          "symbolName": "oldCatalogDescriptor",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Optional<CatalogDescriptor>",
          "scopeHint": "in alterCatalog(...)",
          "filePath": "CatalogManager.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Alters a catalog under the given name. The catalog name must be unique.\n     *\n     * @param catalogName the given catalog name under which to alter the given catalog\n     * @param catalogUpdater catalog configuration updater to alter catalog\n     * @throws CatalogException If the catalog neither exists in the catalog store nor in the\n     *     initialized catalogs, or if an error occurs while creating the catalog or storing the\n     *     {@link CatalogDescriptor}\n     */\n    public void alterCatalog(String catalogName, Consumer<Configuration> catalogUpdater)\n            throws CatalogException {\n        checkArgument(\n                !StringUtils.isNullOrWhitespaceOnly(catalogName),\n                \"Catalog name cannot be null or empty.\");\n        checkNotNull(catalogUpdater, \"Catalog configuration updater cannot be null.\");\n\n        CatalogStore catalogStore = catalogStoreHolder.catalogStore();\n        Optional<CatalogDescriptor> oldCatalogDescriptor = getCatalogDescriptor(catalogName);\n\n        if (catalogStore.contains(catalogName) && oldCatalogDescriptor.isPresent()) {\n            Configuration conf = oldCatalogDescriptor.get().getConfiguration();\n            catalogUpdater.accept(conf);\n            CatalogDescriptor newCatalogDescriptor = CatalogDescriptor.of(catalogName, conf);\n            Catalog newCatalog = initCatalog(catalogName, newCatalogDescriptor);\n            catalogStore.removeCatalog(catalogName, false);\n            if (catalogs.containsKey(catalogName)) {\n                catalogs.get(catalogName).close();\n            }\n            newCatalog.open();\n            catalogs.put(catalogName, newCatalog);\n            catalogStoreHolder.catalogStore().storeCatalog(catalogName, newCatalogDescriptor);\n        } else {\n            throw new CatalogException(\n                    String.format(\"Catalog %s does not exist in the catalog store.\", catalogName));\n        }\n    }",
          "conflictNames": [
              "catalogName",
              "catalogUpdater",
              "catalogStore",
              "conf",
              "newCatalogDescriptor",
              "newCatalog"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2385cc05e311797d209e85ce9b9e668a7dd3c51c^1/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/catalog/CatalogManager.java",
      "locators": [
          {
              "line": 355,
              "column": 31
          },
          {
              "line": 356,
              "column": 59
          },
          {
              "line": 363,
              "column": 73
          }
      ],
      "old_name": "newCatalogDescriptor",
      "new_name": "newDescriptor",
      "ctx": {
          "symbolName": "newCatalogDescriptor",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CatalogDescriptor",
          "scopeHint": "in alterCatalog(...)",
          "filePath": "CatalogManager.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Alters a catalog under the given name. The catalog name must be unique.\n     *\n     * @param catalogName the given catalog name under which to alter the given catalog\n     * @param catalogUpdater catalog configuration updater to alter catalog\n     * @throws CatalogException If the catalog neither exists in the catalog store nor in the\n     *     initialized catalogs, or if an error occurs while creating the catalog or storing the\n     *     {@link CatalogDescriptor}\n     */\n    public void alterCatalog(String catalogName, Consumer<Configuration> catalogUpdater)\n            throws CatalogException {\n        checkArgument(\n                !StringUtils.isNullOrWhitespaceOnly(catalogName),\n                \"Catalog name cannot be null or empty.\");\n        checkNotNull(catalogUpdater, \"Catalog configuration updater cannot be null.\");\n\n        CatalogStore catalogStore = catalogStoreHolder.catalogStore();\n        Optional<CatalogDescriptor> oldCatalogDescriptor = getCatalogDescriptor(catalogName);\n\n        if (catalogStore.contains(catalogName) && oldCatalogDescriptor.isPresent()) {\n            Configuration conf = oldCatalogDescriptor.get().getConfiguration();\n            catalogUpdater.accept(conf);\n            CatalogDescriptor newCatalogDescriptor = CatalogDescriptor.of(catalogName, conf);\n            Catalog newCatalog = initCatalog(catalogName, newCatalogDescriptor);\n            catalogStore.removeCatalog(catalogName, false);\n            if (catalogs.containsKey(catalogName)) {\n                catalogs.get(catalogName).close();\n            }\n            newCatalog.open();\n            catalogs.put(catalogName, newCatalog);\n            catalogStoreHolder.catalogStore().storeCatalog(catalogName, newCatalogDescriptor);\n        } else {\n            throw new CatalogException(\n                    String.format(\"Catalog %s does not exist in the catalog store.\", catalogName));\n        }\n    }",
          "conflictNames": [
              "catalogName",
              "catalogUpdater",
              "catalogStore",
              "oldCatalogDescriptor",
              "conf",
              "newCatalog"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2432e5c7c9aa085d846e47cb7771e45a5dea3710^1/flink-table/flink-table-planner/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java",
      "locators": [
          {
              "line": 417,
              "column": 13
          },
          {
              "line": 418,
              "column": 23
          }
      ],
      "old_name": "numCursors",
      "new_name": "cursorCount",
      "ctx": {
          "symbolName": "numCursors",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in declareCursor(...)",
          "filePath": "SqlValidatorImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "// implement SqlValidator\n    @Override\n    public void declareCursor(SqlSelect select, SqlValidatorScope parentScope) {\n        cursorSet.add(select);\n\n        // add the cursor to a map that maps the cursor to its select based on\n        // the position of the cursor relative to other cursors in that call\n        FunctionParamInfo funcParamInfo = requireNonNull(functionCallStack.peek(), \"functionCall\");\n        Map<Integer, SqlSelect> cursorMap = funcParamInfo.cursorPosToSelectMap;\n        int numCursors = cursorMap.size();\n        cursorMap.put(numCursors, select);\n\n        // create a namespace associated with the result of the select\n        // that is the argument to the cursor constructor; register it\n        // with a scope corresponding to the cursor\n        SelectScope cursorScope = new SelectScope(parentScope, null, select);\n        clauseScopes.put(IdPair.of(select, Clause.CURSOR), cursorScope);\n        final SelectNamespace selectNs = createSelectNamespace(select, select);\n        final String alias = SqlValidatorUtil.alias(select, nextGeneratedId++);\n        registerNamespace(cursorScope, alias, selectNs, false);\n    }",
          "conflictNames": [
              "select",
              "parentScope",
              "funcParamInfo",
              "cursorMap",
              "cursorScope",
              "selectNs",
              "alias"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2432e5c7c9aa085d846e47cb7771e45a5dea3710^1/flink-table/flink-table-planner/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java",
      "locators": [
          {
              "line": 217,
              "column": 95
          },
          {
              "line": 549,
              "column": 48
          },
          {
              "line": 597,
              "column": 23
          },
          {
              "line": 598,
              "column": 15
          },
          {
              "line": 605,
              "column": 57
          },
          {
              "line": 610,
              "column": 45
          },
          {
              "line": 637,
              "column": 50
          },
          {
              "line": 678,
              "column": 39
          },
          {
              "line": 679,
              "column": 53
          },
          {
              "line": 679,
              "column": 82
          },
          {
              "line": 680,
              "column": 53
          },
          {
              "line": 719,
              "column": 29
          },
          {
              "line": 723,
              "column": 33
          },
          {
              "line": 734,
              "column": 43
          },
          {
              "line": 735,
              "column": 39
          },
          {
              "line": 850,
              "column": 21
          },
          {
              "line": 851,
              "column": 37
          },
          {
              "line": 852,
              "column": 29
          },
          {
              "line": 852,
              "column": 39
          },
          {
              "line": 873,
              "column": 71
          },
          {
              "line": 1552,
              "column": 16
          },
          {
              "line": 1606,
              "column": 25
          },
          {
              "line": 1802,
              "column": 44
          },
          {
              "line": 1862,
              "column": 88
          },
          {
              "line": 2292,
              "column": 52
          },
          {
              "line": 2359,
              "column": 50
          },
          {
              "line": 2803,
              "column": 31
          },
          {
              "line": 2804,
              "column": 21
          },
          {
              "line": 2810,
              "column": 37
          },
          {
              "line": 2811,
              "column": 37
          },
          {
              "line": 2816,
              "column": 36
          },
          {
              "line": 3674,
              "column": 21
          },
          {
              "line": 3685,
              "column": 21
          },
          {
              "line": 3691,
              "column": 27
          },
          {
              "line": 3692,
              "column": 75
          },
          {
              "line": 3693,
              "column": 40
          },
          {
              "line": 3704,
              "column": 38
          },
          {
              "line": 3709,
              "column": 30
          },
          {
              "line": 3717,
              "column": 44
          },
          {
              "line": 3717,
              "column": 54
          },
          {
              "line": 3945,
              "column": 67
          },
          {
              "line": 3946,
              "column": 13
          },
          {
              "line": 3947,
              "column": 36
          },
          {
              "line": 4126,
              "column": 75
          },
          {
              "line": 4628,
              "column": 42
          },
          {
              "line": 4630,
              "column": 31
          },
          {
              "line": 4741,
              "column": 12
          },
          {
              "line": 4800,
              "column": 32
          },
          {
              "line": 4896,
              "column": 96
          },
          {
              "line": 5890,
              "column": 76
          },
          {
              "line": 5894,
              "column": 25
          },
          {
              "line": 6250,
              "column": 51
          },
          {
              "line": 6709,
              "column": 51
          },
          {
              "line": 6757,
              "column": 48
          },
          {
              "line": 7295,
              "column": 25
          },
          {
              "line": 7296,
              "column": 21
          },
          {
              "line": 7298,
              "column": 52
          },
          {
              "line": 7345,
              "column": 52
          }
      ],
      "old_name": "from",
      "new_name": "from2",
      "ctx": {
          "symbolName": "from",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SqlNode",
          "scopeHint": "in expandCommonColumn(...)",
          "filePath": "SqlValidatorImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static SqlNode expandCommonColumn(\n            SqlSelect sqlSelect,\n            SqlNode selectItem,\n            @Nullable SelectScope scope,\n            SqlValidatorImpl validator) {\n        if (!(selectItem instanceof SqlIdentifier)) {\n            return selectItem;\n        }\n\n        final SqlNode from = sqlSelect.getFrom();\n        if (!(from instanceof SqlJoin)) {\n            return selectItem;\n        }\n\n        final SqlIdentifier identifier = (SqlIdentifier) selectItem;\n        if (!identifier.isSimple()) {\n            if (!validator.config().conformance().allowQualifyingCommonColumn()) {\n                validateQualifiedCommonColumn((SqlJoin) from, identifier, scope, validator);\n            }\n            return selectItem;\n        }\n\n        return expandExprFromJoin((SqlJoin) from, identifier, scope);\n    }",
          "conflictNames": [
              "sqlSelect",
              "selectItem",
              "scope",
              "validator",
              "identifier"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2432e5c7c9aa085d846e47cb7771e45a5dea3710^1/flink-table/flink-table-planner/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java",
      "locators": [
          {
              "line": 3593,
              "column": 22
          },
          {
              "line": 3593,
              "column": 36
          },
          {
              "line": 3594,
              "column": 39
          },
          {
              "line": 3639,
              "column": 61
          },
          {
              "line": 3656,
              "column": 61
          },
          {
              "line": 3733,
              "column": 8
          },
          {
              "line": 5752,
              "column": 28
          },
          {
              "line": 5928,
              "column": 14
          },
          {
              "line": 5941,
              "column": 35
          },
          {
              "line": 5948,
              "column": 77
          },
          {
              "line": 6006,
              "column": 31
          },
          {
              "line": 6007,
              "column": 13
          },
          {
              "line": 6383,
              "column": 29
          },
          {
              "line": 6421,
              "column": 33
          },
          {
              "line": 6422,
              "column": 25
          },
          {
              "line": 6422,
              "column": 37
          },
          {
              "line": 6423,
              "column": 37
          }
      ],
      "old_name": "groupExpr",
      "new_name": "e",
      "ctx": {
          "symbolName": "groupExpr",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "SqlNode",
          "scopeHint": "in createAggImpl(...)",
          "filePath": "SqlToRelConverter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "ant, but hey.\n\n        final AggregatingSelectScope scope =\n                requireNonNull(aggConverter.aggregatingSelectScope, \"aggregatingSelectScope\");\n        final AggregatingSelectScope.Resolved r = scope.resolved.get();\n        for (SqlNode groupExpr : r.groupExprList) {\n            aggConverter.addGroupExpr(groupExpr);\n        }\n\n        final RexNode havingExpr;\n        final List<Pair<RexNode, String>> projects = new ArrayList<>();\n\n        try {\n            checkArgument(bb.agg == ",
          "conflictNames": [
              "bb",
              "aggConverter",
              "selectList",
              "groupList",
              "having",
              "orderExprList",
              "aggregateFinder",
              "scope",
              "r",
              "havingExpr",
              "projects",
              "preExprs",
              "zero",
              "inputRel",
              "newHaving",
              "k",
              "selectScope",
              "selectNamespace",
              "names",
              "sysFieldCount"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/24685395ccf19344e9331201ae0cd600b7722a89^1/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OperatorChain.java",
      "locators": [
          {
              "line": 750,
              "column": 39
          },
          {
              "line": 752,
              "column": 17
          },
          {
              "line": 759,
              "column": 83
          },
          {
              "line": 761,
              "column": 76
          }
      ],
      "old_name": "asArray",
      "new_name": "allOutputsArray",
      "ctx": {
          "symbolName": "asArray",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Output<StreamRecord<T>>[]",
          "scopeHint": "in createOutputCollector(...)",
          "filePath": "OperatorChain.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private <T> WatermarkGaugeExposingOutput<StreamRecord<T>> createOutputCollector(\n            StreamTask<?, ?> containingTask,\n            StreamConfig operatorConfig,\n            Map<Integer, StreamConfig> chainedConfigs,\n            ClassLoader userCodeClassloader,\n            Map<IntermediateDataSetID, RecordWriterOutput<?>> recordWriterOutputs,\n            List<StreamOperatorWrapper<?, ?>> allOperatorWrappers,\n            MailboxExecutorFactory mailboxExecutorFactory,\n            boolean shouldAddMetric) {\n        List<WatermarkGaugeExposingOutput<StreamRecord<T>>> allOutputs = new ArrayList<>(4);\n\n        // create collectors for the network outputs\n        for (NonChainedOutput streamOutput :\n                operatorConfig.getOperatorNonChainedOutputs(userCodeClassloader)) {\n            @SuppressWarnings(\"unchecked\")\n            RecordWriterOutput<T> recordWriterOutput =\n                    (RecordWriterOutput<T>) recordWriterOutputs.get(streamOutput.getDataSetId());\n\n            allOutputs.add(recordWriterOutput);\n        }\n\n        // Create collectors for the chained outputs\n        for (StreamEdge outputEdge : operatorConfig.getChainedOutputs(userCodeClassloader)) {\n            int outputId = outputEdge.getTargetId();\n            StreamConfig chainedOpConfig = chainedConfigs.get(outputId);\n\n            WatermarkGaugeExposingOutput<StreamRecord<T>> output =\n                    createOperatorChain(\n                            containingTask,\n                            operatorConfig,\n                            chainedOpConfig,\n                            chainedConfigs,\n                            userCodeClassloader,\n                            recordWriterOutputs,\n                            allOperatorWrappers,\n                            outputEdge.getOutputTag(),\n                            mailboxExecutorFactory,\n                            shouldAddMetric);\n            allOutputs.add(output);\n            // If the operator has multiple downstream chained operators, only one of them should\n            // increment the recordsOutCounter for this operator. Set shouldAddMetric to false\n            // so that we would skip adding the counter to other downstream operators.\n            shouldAddMetric = false;\n        }\n\n        WatermarkGaugeExposingOutput<StreamRecord<T>> result;\n\n        if (allOutputs.size() == 1) {\n            result = allOutputs.get(0);\n        } else {\n            // send to N outputs. Note that this includes the special case\n            // of sending to zero outputs\n            @SuppressWarnings({\"unchecked\"})\n            Output<StreamRecord<T>>[] asArray = new Output[allOutputs.size()];\n            for (int i = 0; i < allOutputs.size(); i++) {\n                asArray[i] = allOutputs.get(i);\n            }\n\n            // This is the inverse of creating the normal ChainingOutput.\n            // If the chaining output does not copy we need to copy in the broadcast output,\n            // otherwise multi-chaining would not work correctly.\n            if (containingTask.getExecutionConfig().isObjectReuseEnabled()) {\n                result = closer.register(new CopyingBroadcastingOutputCollector<>(asArray));\n            } else {\n                result = closer.register(new BroadcastingOutputCollector<>(asArray));\n            }\n        }\n\n        if (shouldAddMetric) {\n            // Create a CountingOutput to increment the recordsOutCounter for this operator\n            // if we have not added the counter to any downstream chained operator.\n            Counter recordsOutCounter =\n                    getOperatorRecordsOutCounter(containingTask, operatorConfig);\n            if (recordsOutCounter != null) {\n                result = new CountingOutput<>(result, recordsOutCounter);\n            }\n        }\n        return result;\n    }",
          "conflictNames": [
              "containingTask",
              "operatorConfig",
              "chainedConfigs",
              "userCodeClassloader",
              "recordWriterOutputs",
              "allOperatorWrappers",
              "mailboxExecutorFactory",
              "shouldAddMetric",
              "allOutputs",
              "recordWriterOutput",
              "outputId",
              "chainedOpConfig",
              "output",
              "result",
              "i",
              "recordsOutCounter"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/24f18975c7205ec3b58e2fb8dca048fa2b6a4721^1/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/inference/TypeInferenceUtil.java",
      "locators": [
          {
              "line": 387,
              "column": 24
          },
          {
              "line": 393,
              "column": 70
          },
          {
              "line": 480,
              "column": 36
          },
          {
              "line": 488,
              "column": 13
          },
          {
              "line": 492,
              "column": 17
          },
          {
              "line": 497,
              "column": 24
          },
          {
              "line": 499,
              "column": 23
          },
          {
              "line": 504,
              "column": 16
          }
      ],
      "old_name": "accumulatorType",
      "new_name": "stateInfos",
      "ctx": {
          "symbolName": "accumulatorType",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "DataType",
          "scopeHint": "in runTypeInferenceInternal(...)",
          "filePath": "TypeInferenceUtil.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static Result runTypeInferenceInternal(\n            TypeInference typeInference,\n            CallContext callContext,\n            @Nullable SurroundingInfo surroundingInfo) {\n        try {\n            validateArgumentCount(\n                    typeInference.getInputTypeStrategy().getArgumentCount(),\n                    callContext.getArgumentDataTypes().size(),\n                    true);\n        } catch (ValidationException e) {\n            throw createInvalidInputException(typeInference, callContext, e);\n        }\n\n        final CallContext adaptedCallContext;\n        try {\n            // use information of surrounding call to determine output type of this call\n            final DataType outputType;\n            if (surroundingInfo != null) {\n                outputType =\n                        surroundingInfo\n                                .inferOutputType(callContext.getDataTypeFactory())\n                                .orElse(null);\n            } else {\n                outputType = null;\n            }\n\n            adaptedCallContext = adaptArguments(typeInference, callContext, outputType);\n        } catch (ValidationException e) {\n            throw createInvalidInputException(typeInference, callContext, e);\n        }\n\n        // infer output type first for better error message\n        // (logically an accumulator type should be inferred first)\n        final DataType outputType =\n                inferOutputType(adaptedCallContext, typeInference.getOutputTypeStrategy());\n\n        final DataType accumulatorType =\n                inferAccumulatorType(\n                        adaptedCallContext,\n                        outputType,\n                        typeInference.getAccumulatorTypeStrategy().orElse(null));\n\n        return new Result(adaptedCallContext.getArgumentDataTypes(), accumulatorType, outputType);\n    }",
          "conflictNames": [
              "typeInference",
              "callContext",
              "surroundingInfo",
              "adaptedCallContext",
              "outputType"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/24f18975c7205ec3b58e2fb8dca048fa2b6a4721^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/exec/stream/StreamExecProcessTableFunction.java",
      "locators": [
          {
              "line": 159,
              "column": 43
          },
          {
              "line": 177,
              "column": 13
          },
          {
              "line": 181,
              "column": 36
          }
      ],
      "old_name": "tableSemantics",
      "new_name": "runtimeTableSemantics",
      "ctx": {
          "symbolName": "tableSemantics",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<RuntimeTableSemantics>",
          "scopeHint": "in translateToPlanInternal(...)",
          "filePath": "StreamExecProcessTableFunction.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    @SuppressWarnings(\"unchecked\")\n    protected Transformation<RowData> translateToPlanInternal(\n            PlannerBase planner, ExecNodeConfig config) {\n        final List<Transformation<RowData>> inputTransforms =\n                getInputEdges().stream()\n                        .map(e -> (Transformation<RowData>) e.translateToPlan(planner))\n                        .collect(Collectors.toList());\n        if (inputTransforms.size() != 1) {\n            throw new TableException(\"Process table function only supports exactly one input.\");\n        }\n        final Transformation<RowData> inputTransform = inputTransforms.get(0);\n\n        final List<Ord<StaticArgument>> providedInputArgs =\n                StreamPhysicalProcessTableFunction.getProvidedInputArgs(invocation);\n        final List<RexNode> operands = invocation.getOperands();\n        final List<RuntimeTableSemantics> tableSemantics =\n                providedInputArgs.stream()\n                        .map(\n                                providedInputArg -> {\n                                    final RexTableArgCall tableArgCall =\n                                            (RexTableArgCall) operands.get(providedInputArg.i);\n                                    final StaticArgument tabledArg = providedInputArg.e;\n                                    return createTableSemantics(tabledArg, tableArgCall);\n                                })\n                        .collect(Collectors.toList());\n\n        final CodeGeneratorContext ctx =\n                new CodeGeneratorContext(config, planner.getFlinkContext().getClassLoader());\n\n        final GeneratedProcessTableRunner generatedRunner =\n                ProcessTableRunnerGenerator.generate(ctx, invocation, inputChangelogModes);\n\n        final RuntimeTableSemantics singleTableSemantics;\n        if (tableSemantics.isEmpty()) {\n            // For constant function calls\n            singleTableSemantics = null;\n        } else {\n            singleTableSemantics = tableSemantics.get(0);\n        }\n\n        final ProcessTableOperatorFactory operatorFactory =\n                new ProcessTableOperatorFactory(singleTableSemantics, generatedRunner);\n\n        final String effectiveUid =\n                uid != null ? uid : createTransformationUid(PROCESS_TRANSFORMATION, config);\n\n        final TransformationMetadata metadata =\n                new TransformationMetadata(\n                        effectiveUid,\n                        createTransformationName(config),\n                        createTransformationDescription(config));\n\n        final OneInputTransformation<RowData, RowData> transform =\n                ExecNodeUtil.createOneInputTransformation(\n                        inputTransform,\n                        metadata,\n                        operatorFactory,\n                        InternalTypeInfo.of(getOutputType()),\n                        inputTransform.getParallelism(),\n                        false);\n\n        // For one input (but non-constant) functions with set semantics\n        if (singleTableSemantics != null && singleTableSemantics.hasSetSemantics()) {\n            final RowDataKeySelector selector =\n                    KeySelectorUtil.getRowDataSelector(\n                            planner.getFlinkContext().getClassLoader(),\n                            singleTableSemantics.partitionByColumns(),\n                            (InternalTypeInfo<RowData>) inputTransform.getOutputType());\n            transform.setStateKeySelector(selector);\n            transform.setStateKeyType(selector.getProducedType());\n        }\n\n        if (inputsContainSingleton()) {\n            transform.setParallelism(1);\n            transform.setMaxParallelism(1);\n        }\n\n        return transform;\n    }",
          "conflictNames": [
              "planner",
              "config",
              "inputTransforms",
              "inputTransform",
              "providedInputArgs",
              "operands",
              "tableArgCall",
              "tabledArg",
              "ctx",
              "generatedRunner",
              "singleTableSemantics",
              "operatorFactory",
              "effectiveUid",
              "metadata",
              "transform",
              "selector"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/24f18975c7205ec3b58e2fb8dca048fa2b6a4721^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/exec/stream/StreamExecProcessTableFunction.java",
      "locators": [
          {
              "line": 173,
              "column": 43
          },
          {
              "line": 185,
              "column": 71
          }
      ],
      "old_name": "generatedRunner",
      "new_name": "generated",
      "ctx": {
          "symbolName": "generatedRunner",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "GeneratedProcessTableRunner",
          "scopeHint": "in translateToPlanInternal(...)",
          "filePath": "StreamExecProcessTableFunction.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    @SuppressWarnings(\"unchecked\")\n    protected Transformation<RowData> translateToPlanInternal(\n            PlannerBase planner, ExecNodeConfig config) {\n        final List<Transformation<RowData>> inputTransforms =\n                getInputEdges().stream()\n                        .map(e -> (Transformation<RowData>) e.translateToPlan(planner))\n                        .collect(Collectors.toList());\n        if (inputTransforms.size() != 1) {\n            throw new TableException(\"Process table function only supports exactly one input.\");\n        }\n        final Transformation<RowData> inputTransform = inputTransforms.get(0);\n\n        final List<Ord<StaticArgument>> providedInputArgs =\n                StreamPhysicalProcessTableFunction.getProvidedInputArgs(invocation);\n        final List<RexNode> operands = invocation.getOperands();\n        final List<RuntimeTableSemantics> tableSemantics =\n                providedInputArgs.stream()\n                        .map(\n                                providedInputArg -> {\n                                    final RexTableArgCall tableArgCall =\n                                            (RexTableArgCall) operands.get(providedInputArg.i);\n                                    final StaticArgument tabledArg = providedInputArg.e;\n                                    return createTableSemantics(tabledArg, tableArgCall);\n                                })\n                        .collect(Collectors.toList());\n\n        final CodeGeneratorContext ctx =\n                new CodeGeneratorContext(config, planner.getFlinkContext().getClassLoader());\n\n        final GeneratedProcessTableRunner generatedRunner =\n                ProcessTableRunnerGenerator.generate(ctx, invocation, inputChangelogModes);\n\n        final RuntimeTableSemantics singleTableSemantics;\n        if (tableSemantics.isEmpty()) {\n            // For constant function calls\n            singleTableSemantics = null;\n        } else {\n            singleTableSemantics = tableSemantics.get(0);\n        }\n\n        final ProcessTableOperatorFactory operatorFactory =\n                new ProcessTableOperatorFactory(singleTableSemantics, generatedRunner);\n\n        final String effectiveUid =\n                uid != null ? uid : createTransformationUid(PROCESS_TRANSFORMATION, config);\n\n        final TransformationMetadata metadata =\n                new TransformationMetadata(\n                        effectiveUid,\n                        createTransformationName(config),\n                        createTransformationDescription(config));\n\n        final OneInputTransformation<RowData, RowData> transform =\n                ExecNodeUtil.createOneInputTransformation(\n                        inputTransform,\n                        metadata,\n                        operatorFactory,\n                        InternalTypeInfo.of(getOutputType()),\n                        inputTransform.getParallelism(),\n                        false);\n\n        // For one input (but non-constant) functions with set semantics\n        if (singleTableSemantics != null && singleTableSemantics.hasSetSemantics()) {\n            final RowDataKeySelector selector =\n                    KeySelectorUtil.getRowDataSelector(\n                            planner.getFlinkContext().getClassLoader(),\n                            singleTableSemantics.partitionByColumns(),\n                            (InternalTypeInfo<RowData>) inputTransform.getOutputType());\n            transform.setStateKeySelector(selector);\n            transform.setStateKeyType(selector.getProducedType());\n        }\n\n        if (inputsContainSingleton()) {\n            transform.setParallelism(1);\n            transform.setMaxParallelism(1);\n        }\n\n        return transform;\n    }",
          "conflictNames": [
              "planner",
              "config",
              "inputTransforms",
              "inputTransform",
              "providedInputArgs",
              "operands",
              "tableSemantics",
              "tableArgCall",
              "tabledArg",
              "ctx",
              "singleTableSemantics",
              "operatorFactory",
              "effectiveUid",
              "metadata",
              "transform",
              "selector"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/25926d1f90df59d013d9ada3d2613c8d778c42d1^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPoolTest.java",
      "locators": [
          {
              "line": 161,
              "column": 40
          },
          {
              "line": 164,
              "column": 17
          },
          {
              "line": 172,
              "column": 25
          },
          {
              "line": 497,
              "column": 40
          },
          {
              "line": 498,
              "column": 63
          },
          {
              "line": 735,
              "column": 50
          },
          {
              "line": 738,
              "column": 54
          },
          {
              "line": 777,
              "column": 40
          },
          {
              "line": 780,
              "column": 13
          },
          {
              "line": 782,
              "column": 16
          }
      ],
      "old_name": "newSlots",
      "new_name": "newSlotsById",
      "ctx": {
          "symbolName": "newSlots",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Collection<PhysicalSlot>",
          "scopeHint": "in testOfferSlots(...)",
          "filePath": "DefaultDeclarativeSlotPoolTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testOfferSlots() throws InterruptedException {\n        final NewSlotsService notifyNewSlots = new NewSlotsService();\n        final DefaultDeclarativeSlotPool slotPool =\n                createDefaultDeclarativeSlotPoolWithNewSlotsListener(notifyNewSlots);\n\n        final ResourceCounter resourceRequirements = createResourceRequirements();\n\n        slotPool.increaseResourceRequirementsBy(resourceRequirements);\n\n        Collection<SlotOffer> slotOffers =\n                createSlotOffersForResourceRequirements(resourceRequirements);\n\n        final Collection<SlotOffer> acceptedSlots =\n                SlotPoolTestUtils.offerSlots(slotPool, slotOffers);\n\n        assertThat(acceptedSlots, containsInAnyOrder(slotOffers.toArray()));\n\n        final Collection<PhysicalSlot> newSlots = drainNewSlotService(notifyNewSlots);\n\n        assertThat(\n                newSlots,\n                containsInAnyOrder(\n                        slotOffers.stream()\n                                .map(DefaultDeclarativeSlotPoolTest::matchesSlotOffer)\n                                .collect(Collectors.toList())));\n        assertThat(\n                slotPool.getAllSlotsInformation(),\n                containsInAnyOrder(\n                        newSlots.stream()\n                                .map(DefaultAllocatedSlotPoolTest::matchesPhysicalSlot)\n                                .collect(Collectors.toList())));\n    }",
          "conflictNames": [
              "notifyNewSlots",
              "slotPool",
              "resourceRequirements",
              "slotOffers",
              "acceptedSlots"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/25d34b996aaecb35d552d1525d54215e826fcfaf^1/flink-state-backends/flink-statebackend-forst/src/test/java/org/apache/flink/state/forst/fs/ForStFlinkFileSystemTest.java",
      "locators": [
          {
              "line": 285,
              "column": 24
          },
          {
              "line": 286,
              "column": 20
          },
          {
              "line": 287,
              "column": 20
          },
          {
              "line": 293,
              "column": 20
          },
          {
              "line": 294,
              "column": 20
          },
          {
              "line": 311,
              "column": 20
          }
      ],
      "old_name": "cacheEntry",
      "new_name": "cacheEntry1",
      "ctx": {
          "symbolName": "cacheEntry",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "FileCacheEntry",
          "scopeHint": "in testSstFileInCache(...)",
          "filePath": "ForStFlinkFileSystemTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testSstFileInCache() throws IOException {\n        final Map<String, Gauge<?>> registeredGauges = new HashMap<>();\n        final Map<String, Counter> registeredCounters = new HashMap<>();\n        org.apache.flink.core.fs.Path remotePath =\n                new org.apache.flink.core.fs.Path(tempDir.toString() + \"/remote\");\n        org.apache.flink.core.fs.Path localPath =\n                new org.apache.flink.core.fs.Path(tempDir.toString() + \"/local\");\n        org.apache.flink.core.fs.Path cachePath =\n                new org.apache.flink.core.fs.Path(tempDir.toString() + \"/tmp-cache\");\n        BundledCacheLimitPolicy cacheLimitPolicy =\n                new BundledCacheLimitPolicy(\n                        new SpaceBasedCacheLimitPolicy(new File(cachePath.toString()), 0, 0),\n                        new SizeBasedCacheLimitPolicy(250));\n        UnregisteredMetricsGroup metricsGroup =\n                new UnregisteredMetricsGroup() {\n                    @Override\n                    public <C extends Counter> C counter(String name, C counter) {\n                        registeredCounters.put(name, counter);\n                        return counter;\n                    }\n\n                    @Override\n                    public <T, G extends Gauge<T>> G gauge(String name, G gauge) {\n                        registeredGauges.put(name, gauge);\n                        return gauge;\n                    }\n                };\n        FileBasedCache cache =\n                new FileBasedCache(\n                        250,\n                        cacheLimitPolicy,\n                        FileSystem.getLocalFileSystem(),\n                        cachePath,\n                        metricsGroup);\n        ForStFlinkFileSystem fileSystem =\n                new ForStFlinkFileSystem(\n                        new ByteBufferReadableLocalFileSystem(),\n                        remotePath.toString(),\n                        localPath.toString(),\n                        cache);\n        fileSystem.mkdirs(remotePath);\n        fileSystem.mkdirs(localPath);\n        byte[] tmpBytes = new byte[233];\n        ByteBufferWritableFSDataOutputStream os =\n                fileSystem.create(new org.apache.flink.core.fs.Path(remotePath, \"1.sst\"));\n        os.write(tmpBytes);\n        os.write(89);\n        os.sync();\n        os.close();\n        assertThat(fileSystem.exists(new org.apache.flink.core.fs.Path(remotePath, \"1.sst\")))\n                .isTrue();\n        assertThat(\n                        cachePath\n                                .getFileSystem()\n                                .exists(new org.apache.flink.core.fs.Path(cachePath, \"1.sst\")))\n                .isTrue();\n        assertThat(registeredGauges.get(\"forst.fileCache.usedBytes\").getValue()).isEqualTo(234L);\n        assertThat(registeredCounters.get(\"forst.fileCache.hit\").getCount()).isEqualTo(0L);\n        assertThat(registeredCounters.get(\"forst.fileCache.miss\").getCount()).isEqualTo(0L);\n        FileCacheEntry cacheEntry = cache.get(cachePath.getPath() + \"/1.sst\");\n        assertThat(cacheEntry).isNotNull();\n        assertThat(cacheEntry.getReferenceCount()).isEqualTo(1);\n\n        ByteBufferReadableFSDataInputStream is =\n                fileSystem.open(new org.apache.flink.core.fs.Path(remotePath, \"1.sst\"));\n\n        assertThat(is.read(tmpBytes)).isEqualTo(233);\n        assertThat(cacheEntry.getReferenceCount()).isEqualTo(1);\n        assertThat(cacheEntry.getReferenceCount()).isEqualTo(1);\n        assertThat(registeredCounters.get(\"forst.fileCache.hit\").getCount()).isEqualTo(2L);\n        // evict\n        ByteBufferWritableFSDataOutputStream os1 =\n                fileSystem.create(new org.apache.flink.core.fs.Path(remotePath, \"2.sst\"));\n        os1.write(tmpBytes);\n        os1.sync();\n        os1.close();\n        assertThat(fileSystem.exists(new org.apache.flink.core.fs.Path(remotePath, \"1.sst\")))\n                .isTrue();\n        assertThat(fileSystem.exists(new org.apache.flink.core.fs.Path(cachePath, \"1.sst\")))\n                .isFalse();\n        assertThat(\n                        cachePath\n                                .getFileSystem()\n                                .exists(new org.apache.flink.core.fs.Path(cachePath, \"2.sst\")))\n                .isTrue();\n        assertThat(cacheEntry.getReferenceCount()).isEqualTo(0);\n        assertThat(registeredGauges.get(\"forst.fileCache.usedBytes\").getValue()).isEqualTo(233L);\n        // read after evict\n        assertThat(is.read()).isEqualTo(89);\n        is.close();\n    }",
          "conflictNames": [
              "registeredGauges",
              "registeredCounters",
              "remotePath",
              "localPath",
              "cachePath",
              "cacheLimitPolicy",
              "metricsGroup",
              "cache",
              "fileSystem",
              "tmpBytes",
              "os",
              "is",
              "os1"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/25d34b996aaecb35d552d1525d54215e826fcfaf^1/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/fs/ForStFlinkFileSystem.java",
      "locators": [
          {
              "line": 147,
              "column": 37
          },
          {
              "line": 148,
              "column": 13
          },
          {
              "line": 150,
              "column": 36
          },
          {
              "line": 163,
              "column": 37
          },
          {
              "line": 163,
              "column": 67
          },
          {
              "line": 164,
              "column": 36
          },
          {
              "line": 165,
              "column": 13
          },
          {
              "line": 167,
              "column": 40
          },
          {
              "line": 169,
              "column": 43
          },
          {
              "line": 171,
              "column": 60
          },
          {
              "line": 174,
              "column": 69
          },
          {
              "line": 178,
              "column": 59
          },
          {
              "line": 187,
              "column": 37
          },
          {
              "line": 187,
              "column": 67
          },
          {
              "line": 188,
              "column": 36
          },
          {
              "line": 189,
              "column": 13
          },
          {
              "line": 191,
              "column": 40
          },
          {
              "line": 193,
              "column": 43
          },
          {
              "line": 195,
              "column": 60
          },
          {
              "line": 198,
              "column": 69
          },
          {
              "line": 202,
              "column": 59
          },
          {
              "line": 231,
              "column": 37
          },
          {
              "line": 231,
              "column": 67
          },
          {
              "line": 232,
              "column": 13
          },
          {
              "line": 237,
              "column": 13
          },
          {
              "line": 238,
              "column": 38
          },
          {
              "line": 243,
              "column": 40
          },
          {
              "line": 250,
              "column": 37
          },
          {
              "line": 250,
              "column": 67
          },
          {
              "line": 251,
              "column": 36
          },
          {
              "line": 252,
              "column": 13
          },
          {
              "line": 253,
              "column": 42
          },
          {
              "line": 255,
              "column": 41
          },
          {
              "line": 262,
              "column": 37
          },
          {
              "line": 262,
              "column": 67
          },
          {
              "line": 263,
              "column": 36
          },
          {
              "line": 264,
              "column": 13
          },
          {
              "line": 265,
              "column": 58
          }
      ],
      "old_name": "realPath",
      "new_name": "mappingEntry",
      "ctx": {
          "symbolName": "realPath",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RealPath",
          "scopeHint": "in create(...)",
          "filePath": "ForStFlinkFileSystem.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public synchronized ByteBufferWritableFSDataOutputStream create(\n            Path path, WriteMode overwriteMode) throws IOException {\n        FileMappingManager.RealPath realPath = fileMappingManager.createFile(path);\n        if (realPath.isLocal) {\n            return new ByteBufferWritableFSDataOutputStream(\n                    localFS.create(realPath.path, overwriteMode));\n        }\n\n        FSDataOutputStream originalOutputStream = delegateFS.create(path, overwriteMode);\n        CachedDataOutputStream cachedDataOutputStream =\n                fileBasedCache == null ? null : fileBasedCache.create(originalOutputStream, path);\n        return new ByteBufferWritableFSDataOutputStream(\n                cachedDataOutputStream == null ? originalOutputStream : cachedDataOutputStream);\n    }",
          "conflictNames": [
              "path",
              "overwriteMode",
              "originalOutputStream",
              "cachedDataOutputStream"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/25d34b996aaecb35d552d1525d54215e826fcfaf^1/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/fs/ForStFlinkFileSystem.java",
      "locators": [
          {
              "line": 132,
              "column": 66
          },
          {
              "line": 135,
              "column": 15
          },
          {
              "line": 135,
              "column": 29
          },
          {
              "line": 136,
              "column": 57
          },
          {
              "line": 138,
              "column": 40
          },
          {
              "line": 140,
              "column": 61
          },
          {
              "line": 141,
              "column": 23
          },
          {
              "line": 146,
              "column": 18
          },
          {
              "line": 147,
              "column": 78
          },
          {
              "line": 150,
              "column": 45
          },
          {
              "line": 153,
              "column": 69
          },
          {
              "line": 155,
              "column": 93
          },
          {
              "line": 161,
              "column": 71
          },
          {
              "line": 163,
              "column": 76
          },
          {
              "line": 167,
              "column": 49
          },
          {
              "line": 169,
              "column": 52
          },
          {
              "line": 171,
              "column": 69
          },
          {
              "line": 174,
              "column": 78
          },
          {
              "line": 178,
              "column": 68
          },
          {
              "line": 186,
              "column": 71
          },
          {
              "line": 187,
              "column": 76
          },
          {
              "line": 191,
              "column": 49
          },
          {
              "line": 193,
              "column": 52
          },
          {
              "line": 195,
              "column": 69
          },
          {
              "line": 198,
              "column": 78
          },
          {
              "line": 202,
              "column": 68
          },
          {
              "line": 238,
              "column": 47
          },
          {
              "line": 243,
              "column": 49
          },
          {
              "line": 249,
              "column": 55
          },
          {
              "line": 250,
              "column": 76
          },
          {
              "line": 253,
              "column": 51
          },
          {
              "line": 255,
              "column": 50
          },
          {
              "line": 261,
              "column": 14
          },
          {
              "line": 262,
              "column": 76
          },
          {
              "line": 265,
              "column": 67
          },
          {
              "line": 272,
              "column": 54
          },
          {
              "line": 275,
              "column": 16
          },
          {
              "line": 275,
              "column": 26
          },
          {
              "line": 276,
              "column": 14
          },
          {
              "line": 277,
              "column": 13
          },
          {
              "line": 279,
              "column": 69
          },
          {
              "line": 281,
              "column": 57
          },
          {
              "line": 291,
              "column": 45
          },
          {
              "line": 292,
              "column": 57
          },
          {
              "line": 295,
              "column": 35
          },
          {
              "line": 301,
              "column": 45
          },
          {
              "line": 302,
              "column": 34
          }
      ],
      "old_name": "path",
      "new_name": "sourcePath",
      "ctx": {
          "symbolName": "path",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Path",
          "scopeHint": "in create(...)",
          "filePath": "ForStFlinkFileSystem.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "on Thrown, if the stream could not be opened because of an I/O, or because a\n     *     file already exists at that path and the write mode indicates to not overwrite the file.\n     */\n    public ByteBufferWritableFSDataOutputStream create(Path path) throws IOException {\n        return create(path, WriteMode.OVERWRITE);\n    }\n\n    @Override\n    public synchronized ByteBufferWritableFSDataOutputStream create(\n            Path path, WriteMode overwriteMode) throws IOException {\n        "
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/263555c9adcca0abe194e9a6c1d85ec591c304e4^1/flink-connectors/flink-connector-hive/src/test/java/org/apache/flink/connectors/hive/HiveDialectAggITCase.java",
      "locators": [
          {
              "line": 100,
              "column": 19
          },
          {
              "line": 103,
              "column": 20
          },
          {
              "line": 183,
              "column": 19
          },
          {
              "line": 186,
              "column": 20
          },
          {
              "line": 247,
              "column": 19
          },
          {
              "line": 250,
              "column": 20
          },
          {
              "line": 311,
              "column": 19
          },
          {
              "line": 314,
              "column": 20
          },
          {
              "line": 416,
              "column": 19
          },
          {
              "line": 419,
              "column": 20
          }
      ],
      "old_name": "result3",
      "new_name": "result4",
      "ctx": {
          "symbolName": "result3",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<Row>",
          "scopeHint": "in testSimpleSumAggFunction(...)",
          "filePath": "HiveDialectAggITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testSimpleSumAggFunction() throws Exception {\n        tableEnv.executeSql(\n                \"create table test_sum(x string, y string, z int, d decimal(10,5), e float, f double, ts timestamp)\");\n        tableEnv.executeSql(\n                        \"insert into test_sum values (NULL, '2', 1, 1.11, 1.2, 1.3, '2021-08-04 16:26:33.4'), \"\n                                + \"(NULL, 'b', 2, 2.22, 2.3, 2.4, '2021-08-07 16:26:33.4'), \"\n                                + \"(NULL, '4', 3, 3.33, 3.5, 3.6, '2021-08-08 16:26:33.4'), \"\n                                + \"(NULL, NULL, 4, 4.45, 4.7, 4.8, '2021-08-09 16:26:33.4')\")\n                .await();\n\n        // test sum with all elements are null\n        List<Row> result =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(x) from test_sum\").collect());\n        assertThat(result.toString()).isEqualTo(\"[+I[null]]\");\n\n        // test sum string type with partial element can't convert to double, result type is double\n        List<Row> result2 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(y) from test_sum\").collect());\n        assertThat(result2.toString()).isEqualTo(\"[+I[6.0]]\");\n\n        // test decimal type\n        List<Row> result3 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(d) from test_sum\").collect());\n        assertThat(result3.toString()).isEqualTo(\"[+I[11.11000]]\");\n\n        // test sum int, result type is bigint\n        List<Row> result4 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(z) from test_sum\").collect());\n        assertThat(result4.toString()).isEqualTo(\"[+I[10]]\");\n\n        // test float type\n        List<Row> result5 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(e) from test_sum\").collect());\n        float actualFloatValue = ((Double) result5.get(0).getField(0)).floatValue();\n        assertThat(actualFloatValue).isEqualTo(11.7f);\n\n        // test double type\n        List<Row> result6 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(f) from test_sum\").collect());\n        actualFloatValue = ((Double) result6.get(0).getField(0)).floatValue();\n        assertThat(actualFloatValue).isEqualTo(12.1f);\n\n        // test sum string&int type simultaneously\n        List<Row> result7 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(y), sum(z) from test_sum\").collect());\n        assertThat(result7.toString()).isEqualTo(\"[+I[6.0, 10]]\");\n\n        // test unsupported timestamp type\n        String expectedMessage =\n                \"Native hive sum aggregate function does not support type: TIMESTAMP(9). \"\n                        + \"Please set option 'table.exec.hive.native-agg-function.enabled' to false to fall back to Hive's own sum function.\";\n        assertSqlException(\"select sum(ts) from test_sum\", TableException.class, expectedMessage);\n\n        tableEnv.executeSql(\"drop table test_sum\");\n    }",
          "conflictNames": [
              "result",
              "result2",
              "result4",
              "result5",
              "actualFloatValue",
              "result6",
              "result7",
              "expectedMessage"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/263555c9adcca0abe194e9a6c1d85ec591c304e4^1/flink-connectors/flink-connector-hive/src/test/java/org/apache/flink/connectors/hive/HiveDialectAggITCase.java",
      "locators": [
          {
              "line": 106,
              "column": 19
          },
          {
              "line": 109,
              "column": 20
          },
          {
              "line": 189,
              "column": 19
          },
          {
              "line": 192,
              "column": 20
          },
          {
              "line": 253,
              "column": 19
          },
          {
              "line": 256,
              "column": 20
          },
          {
              "line": 317,
              "column": 19
          },
          {
              "line": 320,
              "column": 20
          },
          {
              "line": 422,
              "column": 19
          },
          {
              "line": 425,
              "column": 20
          }
      ],
      "old_name": "result4",
      "new_name": "result5",
      "ctx": {
          "symbolName": "result4",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<Row>",
          "scopeHint": "in testSimpleSumAggFunction(...)",
          "filePath": "HiveDialectAggITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testSimpleSumAggFunction() throws Exception {\n        tableEnv.executeSql(\n                \"create table test_sum(x string, y string, z int, d decimal(10,5), e float, f double, ts timestamp)\");\n        tableEnv.executeSql(\n                        \"insert into test_sum values (NULL, '2', 1, 1.11, 1.2, 1.3, '2021-08-04 16:26:33.4'), \"\n                                + \"(NULL, 'b', 2, 2.22, 2.3, 2.4, '2021-08-07 16:26:33.4'), \"\n                                + \"(NULL, '4', 3, 3.33, 3.5, 3.6, '2021-08-08 16:26:33.4'), \"\n                                + \"(NULL, NULL, 4, 4.45, 4.7, 4.8, '2021-08-09 16:26:33.4')\")\n                .await();\n\n        // test sum with all elements are null\n        List<Row> result =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(x) from test_sum\").collect());\n        assertThat(result.toString()).isEqualTo(\"[+I[null]]\");\n\n        // test sum string type with partial element can't convert to double, result type is double\n        List<Row> result2 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(y) from test_sum\").collect());\n        assertThat(result2.toString()).isEqualTo(\"[+I[6.0]]\");\n\n        // test decimal type\n        List<Row> result3 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(d) from test_sum\").collect());\n        assertThat(result3.toString()).isEqualTo(\"[+I[11.11000]]\");\n\n        // test sum int, result type is bigint\n        List<Row> result4 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(z) from test_sum\").collect());\n        assertThat(result4.toString()).isEqualTo(\"[+I[10]]\");\n\n        // test float type\n        List<Row> result5 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(e) from test_sum\").collect());\n        float actualFloatValue = ((Double) result5.get(0).getField(0)).floatValue();\n        assertThat(actualFloatValue).isEqualTo(11.7f);\n\n        // test double type\n        List<Row> result6 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(f) from test_sum\").collect());\n        actualFloatValue = ((Double) result6.get(0).getField(0)).floatValue();\n        assertThat(actualFloatValue).isEqualTo(12.1f);\n\n        // test sum string&int type simultaneously\n        List<Row> result7 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(y), sum(z) from test_sum\").collect());\n        assertThat(result7.toString()).isEqualTo(\"[+I[6.0, 10]]\");\n\n        // test unsupported timestamp type\n        String expectedMessage =\n                \"Native hive sum aggregate function does not support type: TIMESTAMP(9). \"\n                        + \"Please set option 'table.exec.hive.native-agg-function.enabled' to false to fall back to Hive's own sum function.\";\n        assertSqlException(\"select sum(ts) from test_sum\", TableException.class, expectedMessage);\n\n        tableEnv.executeSql(\"drop table test_sum\");\n    }",
          "conflictNames": [
              "result",
              "result2",
              "result3",
              "result5",
              "actualFloatValue",
              "result6",
              "result7",
              "expectedMessage"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/263555c9adcca0abe194e9a6c1d85ec591c304e4^1/flink-connectors/flink-connector-hive/src/test/java/org/apache/flink/connectors/hive/HiveDialectAggITCase.java",
      "locators": [
          {
              "line": 112,
              "column": 19
          },
          {
              "line": 115,
              "column": 44
          },
          {
              "line": 195,
              "column": 19
          },
          {
              "line": 199,
              "column": 20
          },
          {
              "line": 259,
              "column": 19
          },
          {
              "line": 262,
              "column": 20
          },
          {
              "line": 323,
              "column": 19
          },
          {
              "line": 326,
              "column": 20
          },
          {
              "line": 428,
              "column": 19
          },
          {
              "line": 431,
              "column": 20
          }
      ],
      "old_name": "result5",
      "new_name": "result6",
      "ctx": {
          "symbolName": "result5",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<Row>",
          "scopeHint": "in testSimpleSumAggFunction(...)",
          "filePath": "HiveDialectAggITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testSimpleSumAggFunction() throws Exception {\n        tableEnv.executeSql(\n                \"create table test_sum(x string, y string, z int, d decimal(10,5), e float, f double, ts timestamp)\");\n        tableEnv.executeSql(\n                        \"insert into test_sum values (NULL, '2', 1, 1.11, 1.2, 1.3, '2021-08-04 16:26:33.4'), \"\n                                + \"(NULL, 'b', 2, 2.22, 2.3, 2.4, '2021-08-07 16:26:33.4'), \"\n                                + \"(NULL, '4', 3, 3.33, 3.5, 3.6, '2021-08-08 16:26:33.4'), \"\n                                + \"(NULL, NULL, 4, 4.45, 4.7, 4.8, '2021-08-09 16:26:33.4')\")\n                .await();\n\n        // test sum with all elements are null\n        List<Row> result =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(x) from test_sum\").collect());\n        assertThat(result.toString()).isEqualTo(\"[+I[null]]\");\n\n        // test sum string type with partial element can't convert to double, result type is double\n        List<Row> result2 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(y) from test_sum\").collect());\n        assertThat(result2.toString()).isEqualTo(\"[+I[6.0]]\");\n\n        // test decimal type\n        List<Row> result3 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(d) from test_sum\").collect());\n        assertThat(result3.toString()).isEqualTo(\"[+I[11.11000]]\");\n\n        // test sum int, result type is bigint\n        List<Row> result4 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(z) from test_sum\").collect());\n        assertThat(result4.toString()).isEqualTo(\"[+I[10]]\");\n\n        // test float type\n        List<Row> result5 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(e) from test_sum\").collect());\n        float actualFloatValue = ((Double) result5.get(0).getField(0)).floatValue();\n        assertThat(actualFloatValue).isEqualTo(11.7f);\n\n        // test double type\n        List<Row> result6 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(f) from test_sum\").collect());\n        actualFloatValue = ((Double) result6.get(0).getField(0)).floatValue();\n        assertThat(actualFloatValue).isEqualTo(12.1f);\n\n        // test sum string&int type simultaneously\n        List<Row> result7 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(y), sum(z) from test_sum\").collect());\n        assertThat(result7.toString()).isEqualTo(\"[+I[6.0, 10]]\");\n\n        // test unsupported timestamp type\n        String expectedMessage =\n                \"Native hive sum aggregate function does not support type: TIMESTAMP(9). \"\n                        + \"Please set option 'table.exec.hive.native-agg-function.enabled' to false to fall back to Hive's own sum function.\";\n        assertSqlException(\"select sum(ts) from test_sum\", TableException.class, expectedMessage);\n\n        tableEnv.executeSql(\"drop table test_sum\");\n    }",
          "conflictNames": [
              "result",
              "result2",
              "result3",
              "result4",
              "actualFloatValue",
              "result6",
              "result7",
              "expectedMessage"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/263555c9adcca0abe194e9a6c1d85ec591c304e4^1/flink-connectors/flink-connector-hive/src/test/java/org/apache/flink/connectors/hive/HiveDialectAggITCase.java",
      "locators": [
          {
              "line": 119,
              "column": 19
          },
          {
              "line": 122,
              "column": 38
          },
          {
              "line": 265,
              "column": 19
          },
          {
              "line": 268,
              "column": 20
          },
          {
              "line": 329,
              "column": 19
          },
          {
              "line": 332,
              "column": 20
          },
          {
              "line": 434,
              "column": 19
          },
          {
              "line": 437,
              "column": 20
          }
      ],
      "old_name": "result6",
      "new_name": "result7",
      "ctx": {
          "symbolName": "result6",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<Row>",
          "scopeHint": "in testSimpleSumAggFunction(...)",
          "filePath": "HiveDialectAggITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testSimpleSumAggFunction() throws Exception {\n        tableEnv.executeSql(\n                \"create table test_sum(x string, y string, z int, d decimal(10,5), e float, f double, ts timestamp)\");\n        tableEnv.executeSql(\n                        \"insert into test_sum values (NULL, '2', 1, 1.11, 1.2, 1.3, '2021-08-04 16:26:33.4'), \"\n                                + \"(NULL, 'b', 2, 2.22, 2.3, 2.4, '2021-08-07 16:26:33.4'), \"\n                                + \"(NULL, '4', 3, 3.33, 3.5, 3.6, '2021-08-08 16:26:33.4'), \"\n                                + \"(NULL, NULL, 4, 4.45, 4.7, 4.8, '2021-08-09 16:26:33.4')\")\n                .await();\n\n        // test sum with all elements are null\n        List<Row> result =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(x) from test_sum\").collect());\n        assertThat(result.toString()).isEqualTo(\"[+I[null]]\");\n\n        // test sum string type with partial element can't convert to double, result type is double\n        List<Row> result2 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(y) from test_sum\").collect());\n        assertThat(result2.toString()).isEqualTo(\"[+I[6.0]]\");\n\n        // test decimal type\n        List<Row> result3 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(d) from test_sum\").collect());\n        assertThat(result3.toString()).isEqualTo(\"[+I[11.11000]]\");\n\n        // test sum int, result type is bigint\n        List<Row> result4 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(z) from test_sum\").collect());\n        assertThat(result4.toString()).isEqualTo(\"[+I[10]]\");\n\n        // test float type\n        List<Row> result5 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(e) from test_sum\").collect());\n        float actualFloatValue = ((Double) result5.get(0).getField(0)).floatValue();\n        assertThat(actualFloatValue).isEqualTo(11.7f);\n\n        // test double type\n        List<Row> result6 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(f) from test_sum\").collect());\n        actualFloatValue = ((Double) result6.get(0).getField(0)).floatValue();\n        assertThat(actualFloatValue).isEqualTo(12.1f);\n\n        // test sum string&int type simultaneously\n        List<Row> result7 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(y), sum(z) from test_sum\").collect());\n        assertThat(result7.toString()).isEqualTo(\"[+I[6.0, 10]]\");\n\n        // test unsupported timestamp type\n        String expectedMessage =\n                \"Native hive sum aggregate function does not support type: TIMESTAMP(9). \"\n                        + \"Please set option 'table.exec.hive.native-agg-function.enabled' to false to fall back to Hive's own sum function.\";\n        assertSqlException(\"select sum(ts) from test_sum\", TableException.class, expectedMessage);\n\n        tableEnv.executeSql(\"drop table test_sum\");\n    }",
          "conflictNames": [
              "result",
              "result2",
              "result3",
              "result4",
              "result5",
              "actualFloatValue",
              "result7",
              "expectedMessage"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/263555c9adcca0abe194e9a6c1d85ec591c304e4^1/flink-connectors/flink-connector-hive/src/test/java/org/apache/flink/connectors/hive/HiveDialectAggITCase.java",
      "locators": [
          {
              "line": 126,
              "column": 19
          },
          {
              "line": 129,
              "column": 20
          },
          {
              "line": 271,
              "column": 19
          },
          {
              "line": 276,
              "column": 20
          },
          {
              "line": 335,
              "column": 19
          },
          {
              "line": 338,
              "column": 20
          },
          {
              "line": 440,
              "column": 19
          },
          {
              "line": 443,
              "column": 20
          }
      ],
      "old_name": "result7",
      "new_name": "result8",
      "ctx": {
          "symbolName": "result7",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<Row>",
          "scopeHint": "in testSimpleSumAggFunction(...)",
          "filePath": "HiveDialectAggITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testSimpleSumAggFunction() throws Exception {\n        tableEnv.executeSql(\n                \"create table test_sum(x string, y string, z int, d decimal(10,5), e float, f double, ts timestamp)\");\n        tableEnv.executeSql(\n                        \"insert into test_sum values (NULL, '2', 1, 1.11, 1.2, 1.3, '2021-08-04 16:26:33.4'), \"\n                                + \"(NULL, 'b', 2, 2.22, 2.3, 2.4, '2021-08-07 16:26:33.4'), \"\n                                + \"(NULL, '4', 3, 3.33, 3.5, 3.6, '2021-08-08 16:26:33.4'), \"\n                                + \"(NULL, NULL, 4, 4.45, 4.7, 4.8, '2021-08-09 16:26:33.4')\")\n                .await();\n\n        // test sum with all elements are null\n        List<Row> result =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(x) from test_sum\").collect());\n        assertThat(result.toString()).isEqualTo(\"[+I[null]]\");\n\n        // test sum string type with partial element can't convert to double, result type is double\n        List<Row> result2 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(y) from test_sum\").collect());\n        assertThat(result2.toString()).isEqualTo(\"[+I[6.0]]\");\n\n        // test decimal type\n        List<Row> result3 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(d) from test_sum\").collect());\n        assertThat(result3.toString()).isEqualTo(\"[+I[11.11000]]\");\n\n        // test sum int, result type is bigint\n        List<Row> result4 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(z) from test_sum\").collect());\n        assertThat(result4.toString()).isEqualTo(\"[+I[10]]\");\n\n        // test float type\n        List<Row> result5 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(e) from test_sum\").collect());\n        float actualFloatValue = ((Double) result5.get(0).getField(0)).floatValue();\n        assertThat(actualFloatValue).isEqualTo(11.7f);\n\n        // test double type\n        List<Row> result6 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(f) from test_sum\").collect());\n        actualFloatValue = ((Double) result6.get(0).getField(0)).floatValue();\n        assertThat(actualFloatValue).isEqualTo(12.1f);\n\n        // test sum string&int type simultaneously\n        List<Row> result7 =\n                CollectionUtil.iteratorToList(\n                        tableEnv.executeSql(\"select sum(y), sum(z) from test_sum\").collect());\n        assertThat(result7.toString()).isEqualTo(\"[+I[6.0, 10]]\");\n\n        // test unsupported timestamp type\n        String expectedMessage =\n                \"Native hive sum aggregate function does not support type: TIMESTAMP(9). \"\n                        + \"Please set option 'table.exec.hive.native-agg-function.enabled' to false to fall back to Hive's own sum function.\";\n        assertSqlException(\"select sum(ts) from test_sum\", TableException.class, expectedMessage);\n\n        tableEnv.executeSql(\"drop table test_sum\");\n    }",
          "conflictNames": [
              "result",
              "result2",
              "result3",
              "result4",
              "result5",
              "actualFloatValue",
              "result6",
              "expectedMessage"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/268144c30fab7704e713ccfcda0c3e6be3857660^1/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/nodes/exec/testutils/BatchRestoreTestBase.java",
      "locators": [
          {
              "line": 231,
              "column": 26
          },
          {
              "line": 232,
              "column": 24
          }
      ],
      "old_name": "expectedResults",
      "new_name": "actualResults",
      "ctx": {
          "symbolName": "expectedResults",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<String>",
          "scopeHint": "in loadAndRunCompiledPlan(...)",
          "filePath": "BatchRestoreTestBase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@ParameterizedTest\n    @MethodSource(\"createSpecs\")\n    @Order(1)\n    void loadAndRunCompiledPlan(TableTestProgram program, ExecNodeMetadata metadata)\n            throws Exception {\n        final EnvironmentSettings settings = EnvironmentSettings.inBatchMode();\n        final TableEnvironment tEnv = TableEnvironment.create(settings);\n        tEnv.getConfig()\n                .set(\n                        TableConfigOptions.PLAN_RESTORE_CATALOG_OBJECTS,\n                        TableConfigOptions.CatalogPlanRestore.IDENTIFIER);\n\n        program.getSetupConfigOptionTestSteps().forEach(s -> s.apply(tEnv));\n\n        for (SourceTestStep sourceTestStep : program.getSetupSourceTestSteps()) {\n\n            List<Row> data = new ArrayList<>();\n            data.addAll(sourceTestStep.dataBeforeRestore);\n            data.addAll(sourceTestStep.dataAfterRestore);\n            final String id = TestValuesTableFactory.registerData(data);\n            final Map<String, String> options = new HashMap<>();\n            options.put(\"connector\", \"values\");\n            options.put(\"data-id\", id);\n            options.put(\"runtime-source\", \"NewSource\");\n            options.put(\"terminating\", \"true\");\n            options.put(\"bounded\", \"true\");\n            sourceTestStep.apply(tEnv, options);\n        }\n\n        for (SinkTestStep sinkTestStep : program.getSetupSinkTestSteps()) {\n            final Map<String, String> options = new HashMap<>();\n            options.put(\"connector\", \"values\");\n            options.put(\"disable-lookup\", \"true\");\n            options.put(\"sink-insert-only\", \"false\");\n            sinkTestStep.apply(tEnv, options);\n        }\n\n        program.getSetupFunctionTestSteps().forEach(s -> s.apply(tEnv));\n\n        final CompiledPlan compiledPlan =\n                tEnv.loadPlan(PlanReference.fromFile(getPlanPath(program, metadata)));\n\n        compiledPlan.execute().await();\n        for (SinkTestStep sinkTestStep : program.getSetupSinkTestSteps()) {\n            List<String> expectedResults = getExpectedResults(sinkTestStep, sinkTestStep.name);\n            assertThat(expectedResults)\n                    .containsExactlyInAnyOrder(\n                            sinkTestStep.getExpectedAsStrings().toArray(new String[0]));\n        }\n    }",
          "conflictNames": [
              "program",
              "metadata",
              "settings",
              "tEnv",
              "data",
              "id",
              "options",
              "compiledPlan"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/26d342601a545293b6d9f447a033c0559ba86d14^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/operators/deduplicate/RowTimeDeduplicateFunction.java",
      "locators": [
          {
              "line": 84,
              "column": 17
          },
          {
              "line": 86,
              "column": 25
          },
          {
              "line": 87,
              "column": 75
          }
      ],
      "old_name": "preRow",
      "new_name": "prevRow",
      "ctx": {
          "symbolName": "preRow",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RowData",
          "scopeHint": "in deduplicateOnRowTime(...)",
          "filePath": "RowTimeDeduplicateFunction.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Processes element to deduplicate on keys with row time semantic, sends current element if it\n     * is last or first row, retracts previous element if needed.\n     *\n     * @param state state of function\n     * @param currentRow latest row received by deduplicate function\n     * @param out underlying collector\n     * @param generateUpdateBefore flag to generate UPDATE_BEFORE message or not\n     * @param generateInsert flag to gennerate INSERT message or not\n     * @param rowtimeIndex the index of rowtime field\n     * @param keepLastRow flag to keep last row or keep first row\n     */\n    public static void deduplicateOnRowTime(\n            ValueState<RowData> state,\n            RowData currentRow,\n            Collector<RowData> out,\n            boolean generateUpdateBefore,\n            boolean generateInsert,\n            int rowtimeIndex,\n            boolean keepLastRow)\n            throws Exception {\n        checkInsertOnly(currentRow);\n        RowData preRow = state.value();\n\n        if (isDuplicate(preRow, currentRow, rowtimeIndex, keepLastRow)) {\n            updateDeduplicateResult(generateUpdateBefore, generateInsert, preRow, currentRow, out);\n            state.update(currentRow);\n        }\n    }",
          "conflictNames": [
              "state",
              "currentRow",
              "out",
              "generateUpdateBefore",
              "generateInsert",
              "rowtimeIndex",
              "keepLastRow"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/277706d8cb2d446c2d74cb5170158ecc97859acf^1/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/ForStStateRequestClassifier.java",
      "locators": [
          {
              "line": 78,
              "column": 50
          },
          {
              "line": 80,
              "column": 43
          }
      ],
      "old_name": "forStValueState",
      "new_name": "forStMapState",
      "ctx": {
          "symbolName": "forStValueState",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ForStValueState<?, ?, ?>",
          "scopeHint": "in convertStateRequestsToForStDBRequests(...)",
          "filePath": "ForStStateRequestClassifier.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@SuppressWarnings(\"ConstantConditions\")\n    private void convertStateRequestsToForStDBRequests(StateRequest<?, ?, ?> stateRequest) {\n        StateRequestType stateRequestType = stateRequest.getRequestType();\n        switch (stateRequestType) {\n            case VALUE_GET:\n            case LIST_GET:\n                {\n                    ForStInnerTable<?, ?, ?> innerTable =\n                            (ForStInnerTable<?, ?, ?>) stateRequest.getState();\n                    dbGetRequests.add(innerTable.buildDBGetRequest(stateRequest));\n                    return;\n                }\n            case VALUE_UPDATE:\n            case LIST_UPDATE:\n            case LIST_ADD:\n            case LIST_ADD_ALL:\n                {\n                    ForStInnerTable<?, ?, ?> innerTable =\n                            (ForStInnerTable<?, ?, ?>) stateRequest.getState();\n                    dbPutRequests.add(innerTable.buildDBPutRequest(stateRequest));\n                    return;\n                }\n            case CLEAR:\n                {\n                    if (stateRequest.getState() instanceof ForStValueState) {\n                        ForStValueState<?, ?, ?> forStValueState =\n                                (ForStValueState<?, ?, ?>) stateRequest.getState();\n                        dbPutRequests.add(forStValueState.buildDBPutRequest(stateRequest));\n                        return;\n                    } else {\n                        throw new UnsupportedOperationException(\n                                \"The State \"\n                                        + stateRequest.getState().getClass()\n                                        + \" doesn't yet support the clear method.\");\n                    }\n                }\n            default:\n                throw new UnsupportedOperationException(\n                        \"Unsupported state request type:\" + stateRequestType);\n        }\n    }",
          "conflictNames": [
              "stateRequest",
              "stateRequestType",
              "innerTable"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2839d06559ccf2a0b63a7f61276d7bb546abca3d^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/writer/ChannelSelectorRecordWriter.java",
      "locators": [
          {
              "line": 66,
              "column": 18
          },
          {
              "line": 66,
              "column": 36
          },
          {
              "line": 66,
              "column": 69
          },
          {
              "line": 68,
              "column": 36
          }
      ],
      "old_name": "channelIndex",
      "new_name": "subpartitionIndex",
      "ctx": {
          "symbolName": "channelIndex",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in broadcastEmit(...)",
          "filePath": "ChannelSelectorRecordWriter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void broadcastEmit(T record) throws IOException {\n        checkErroneous();\n\n        // Emitting to all channels in a for loop can be better than calling\n        // ResultPartitionWriter#broadcastRecord because the broadcastRecord\n        // method incurs extra overhead.\n        ByteBuffer serializedRecord = serializeRecord(serializer, record);\n        for (int channelIndex = 0; channelIndex < numberOfChannels; channelIndex++) {\n            serializedRecord.rewind();\n            emit(serializedRecord, channelIndex);\n        }\n\n        if (flushAlways) {\n            flushAll();\n        }\n    }",
          "conflictNames": [
              "record",
              "serializedRecord"
          ]
      },
      "suggestions": [
          {
              "name": "subpartition",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/2839d06559ccf2a0b63a7f61276d7bb546abca3d^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/api/writer/BroadcastRecordWriterTest.java",
      "locators": [
          {
              "line": 59,
              "column": 19
          },
          {
              "line": 63,
              "column": 77
          },
          {
              "line": 75,
              "column": 29
          },
          {
              "line": 83,
              "column": 43
          },
          {
              "line": 88,
              "column": 33
          },
          {
              "line": 99,
              "column": 29
          },
          {
              "line": 103,
              "column": 67
          },
          {
              "line": 105,
              "column": 39
          },
          {
              "line": 124,
              "column": 13
          },
          {
              "line": 126,
              "column": 75
          }
      ],
      "old_name": "numberOfChannels",
      "new_name": "numberOfSubpartitions",
      "ctx": {
          "symbolName": "numberOfChannels",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in testBroadcastMixedRandomEmitRecord(...)",
          "filePath": "BroadcastRecordWriterTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Tests the number of requested buffers and results are correct in the case of switching modes\n     * between {@link BroadcastRecordWriter#broadcastEmit(IOReadableWritable)} and {@link\n     * BroadcastRecordWriter#randomEmit(IOReadableWritable)}.\n     */\n    @Test\n    void testBroadcastMixedRandomEmitRecord(@TempDir Path tempPath) throws Exception {\n        final int numberOfChannels = 8;\n        final int numberOfRecords = 8;\n        final int bufferSize = 32;\n\n        final ResultPartition partition = createResultPartition(bufferSize, numberOfChannels);\n        final BroadcastRecordWriter<SerializationTestType> writer =\n                new BroadcastRecordWriter<>(partition, -1, \"test\");\n        final RecordDeserializer<SerializationTestType> deserializer =\n                new SpillingAdaptiveSpanningRecordDeserializer<>(\n                        new String[] {tempPath.toString()});\n\n        // generate the configured number of int values as global record set\n        final Iterable<SerializationTestType> records =\n                Util.randomRecords(numberOfRecords, SerializationTestTypeFactory.INT);\n        // restore the corresponding record set for every input channel\n        final Map<Integer, ArrayDeque<SerializationTestType>> serializedRecords = new HashMap<>();\n        for (int i = 0; i < numberOfChannels; i++) {\n            serializedRecords.put(i, new ArrayDeque<>());\n        }\n\n        // every record in global set would both emit into one random channel and broadcast to all\n        // the channels\n        int index = 0;\n        for (SerializationTestType record : records) {\n            int randomChannel = index++ % numberOfChannels;\n            writer.emit(record, randomChannel);\n            serializedRecords.get(randomChannel).add(record);\n\n            writer.broadcastEmit(record);\n            for (int i = 0; i < numberOfChannels; i++) {\n                serializedRecords.get(i).add(record);\n            }\n        }\n\n        final int numberOfCreatedBuffers =\n                partition.getBufferPool().bestEffortGetNumOfUsedBuffers();\n        // verify the expected number of requested buffers, and it would always request a new buffer\n        // while random emitting\n        assertThat(2 * numberOfRecords).isEqualTo(numberOfCreatedBuffers);\n\n        for (int i = 0; i < numberOfChannels; i++) {\n            // every channel would queue the number of above crated buffers\n            assertThat(partition.getNumberOfQueuedBuffers(i)).isEqualTo(numberOfRecords + 1);\n\n            final int excessRandomRecords = i < numberOfRecords % numberOfChannels ? 1 : 0;\n            final int numberOfRandomRecords =\n                    numberOfRecords / numberOfChannels + excessRandomRecords;\n            final int numberOfTotalRecords = numberOfRecords + numberOfRandomRecords;\n            // verify the data correctness in every channel queue\n            verifyDeserializationResults(\n                    partition.createSubpartitionView(i, new NoOpBufferAvailablityListener()),\n                    deserializer,\n                    serializedRecords.get(i),\n                    numberOfRecords + 1,\n                    numberOfTotalRecords);\n        }\n    }",
          "conflictNames": [
              "tempPath",
              "numberOfRecords",
              "bufferSize",
              "partition",
              "writer",
              "deserializer",
              "records",
              "serializedRecords",
              "i",
              "index",
              "randomChannel",
              "numberOfCreatedBuffers",
              "excessRandomRecords",
              "numberOfRandomRecords",
              "numberOfTotalRecords"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2839d06559ccf2a0b63a7f61276d7bb546abca3d^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/api/writer/BroadcastRecordWriterTest.java",
      "locators": [
          {
              "line": 83,
              "column": 17
          },
          {
              "line": 84,
              "column": 33
          },
          {
              "line": 85,
              "column": 35
          }
      ],
      "old_name": "randomChannel",
      "new_name": "randomSubpartition",
      "ctx": {
          "symbolName": "randomChannel",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in testBroadcastMixedRandomEmitRecord(...)",
          "filePath": "BroadcastRecordWriterTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Tests the number of requested buffers and results are correct in the case of switching modes\n     * between {@link BroadcastRecordWriter#broadcastEmit(IOReadableWritable)} and {@link\n     * BroadcastRecordWriter#randomEmit(IOReadableWritable)}.\n     */\n    @Test\n    void testBroadcastMixedRandomEmitRecord(@TempDir Path tempPath) throws Exception {\n        final int numberOfChannels = 8;\n        final int numberOfRecords = 8;\n        final int bufferSize = 32;\n\n        final ResultPartition partition = createResultPartition(bufferSize, numberOfChannels);\n        final BroadcastRecordWriter<SerializationTestType> writer =\n                new BroadcastRecordWriter<>(partition, -1, \"test\");\n        final RecordDeserializer<SerializationTestType> deserializer =\n                new SpillingAdaptiveSpanningRecordDeserializer<>(\n                        new String[] {tempPath.toString()});\n\n        // generate the configured number of int values as global record set\n        final Iterable<SerializationTestType> records =\n                Util.randomRecords(numberOfRecords, SerializationTestTypeFactory.INT);\n        // restore the corresponding record set for every input channel\n        final Map<Integer, ArrayDeque<SerializationTestType>> serializedRecords = new HashMap<>();\n        for (int i = 0; i < numberOfChannels; i++) {\n            serializedRecords.put(i, new ArrayDeque<>());\n        }\n\n        // every record in global set would both emit into one random channel and broadcast to all\n        // the channels\n        int index = 0;\n        for (SerializationTestType record : records) {\n            int randomChannel = index++ % numberOfChannels;\n            writer.emit(record, randomChannel);\n            serializedRecords.get(randomChannel).add(record);\n\n            writer.broadcastEmit(record);\n            for (int i = 0; i < numberOfChannels; i++) {\n                serializedRecords.get(i).add(record);\n            }\n        }\n\n        final int numberOfCreatedBuffers =\n                partition.getBufferPool().bestEffortGetNumOfUsedBuffers();\n        // verify the expected number of requested buffers, and it would always request a new buffer\n        // while random emitting\n        assertThat(2 * numberOfRecords).isEqualTo(numberOfCreatedBuffers);\n\n        for (int i = 0; i < numberOfChannels; i++) {\n            // every channel would queue the number of above crated buffers\n            assertThat(partition.getNumberOfQueuedBuffers(i)).isEqualTo(numberOfRecords + 1);\n\n            final int excessRandomRecords = i < numberOfRecords % numberOfChannels ? 1 : 0;\n            final int numberOfRandomRecords =\n                    numberOfRecords / numberOfChannels + excessRandomRecords;\n            final int numberOfTotalRecords = numberOfRecords + numberOfRandomRecords;\n            // verify the data correctness in every channel queue\n            verifyDeserializationResults(\n                    partition.createSubpartitionView(i, new NoOpBufferAvailablityListener()),\n                    deserializer,\n                    serializedRecords.get(i),\n                    numberOfRecords + 1,\n                    numberOfTotalRecords);\n        }\n    }",
          "conflictNames": [
              "tempPath",
              "numberOfChannels",
              "numberOfRecords",
              "bufferSize",
              "partition",
              "writer",
              "deserializer",
              "records",
              "serializedRecords",
              "i",
              "index",
              "numberOfCreatedBuffers",
              "excessRandomRecords",
              "numberOfRandomRecords",
              "numberOfTotalRecords"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2839d06559ccf2a0b63a7f61276d7bb546abca3d^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BufferWritingResultPartition.java",
      "locators": [
          {
              "line": 464,
              "column": 18
          },
          {
              "line": 464,
              "column": 36
          },
          {
              "line": 464,
              "column": 69
          },
          {
              "line": 465,
              "column": 40
          }
      ],
      "old_name": "channelIndex",
      "new_name": "subpartition",
      "ctx": {
          "symbolName": "channelIndex",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in finishUnicastBufferBuilders(...)",
          "filePath": "BufferWritingResultPartition.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void finishUnicastBufferBuilders() {\n        for (int channelIndex = 0; channelIndex < numSubpartitions; channelIndex++) {\n            finishUnicastBufferBuilder(channelIndex);\n        }\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2839d06559ccf2a0b63a7f61276d7bb546abca3d^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/HashBasedDataBuffer.java",
      "locators": [
          {
              "line": 86,
              "column": 54
          },
          {
              "line": 96,
              "column": 45
          },
          {
              "line": 122,
              "column": 18
          },
          {
              "line": 122,
              "column": 31
          },
          {
              "line": 122,
              "column": 61
          },
          {
              "line": 123,
              "column": 26
          },
          {
              "line": 131,
              "column": 22
          },
          {
              "line": 131,
              "column": 35
          },
          {
              "line": 131,
              "column": 65
          },
          {
              "line": 132,
              "column": 44
          },
          {
              "line": 132,
              "column": 55
          },
          {
              "line": 257,
              "column": 18
          },
          {
              "line": 257,
              "column": 31
          },
          {
              "line": 257,
              "column": 60
          },
          {
              "line": 258,
              "column": 46
          },
          {
              "line": 262,
              "column": 26
          },
          {
              "line": 279,
              "column": 18
          },
          {
              "line": 279,
              "column": 31
          },
          {
              "line": 279,
              "column": 60
          },
          {
              "line": 280,
              "column": 46
          },
          {
              "line": 283,
              "column": 26
          }
      ],
      "old_name": "channel",
      "new_name": "subpartition",
      "ctx": {
          "symbolName": "channel",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in HashBasedDataBuffer(...)",
          "filePath": "HashBasedDataBuffer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public HashBasedDataBuffer(\n            LinkedList<MemorySegment> freeSegments,\n            BufferRecycler bufferRecycler,\n            int numSubpartitions,\n            int bufferSize,\n            int numGuaranteedBuffers,\n            @Nullable int[] customReadOrder) {\n        checkArgument(numGuaranteedBuffers > 0, \"No guaranteed buffers for sort.\");\n\n        this.freeSegments = checkNotNull(freeSegments);\n        this.bufferRecycler = checkNotNull(bufferRecycler);\n        this.bufferSize = bufferSize;\n        this.numGuaranteedBuffers = numGuaranteedBuffers;\n        checkState(numGuaranteedBuffers <= freeSegments.size(), \"Wrong number of free segments.\");\n\n        this.builders = new BufferBuilder[numSubpartitions];\n        this.buffers = new ArrayDeque[numSubpartitions];\n        for (int channel = 0; channel < numSubpartitions; ++channel) {\n            this.buffers[channel] = new ArrayDeque<>();\n        }\n\n        this.subpartitionReadOrder = new int[numSubpartitions];\n        if (customReadOrder != null) {\n            checkArgument(customReadOrder.length == numSubpartitions, \"Illegal data read order.\");\n            System.arraycopy(customReadOrder, 0, this.subpartitionReadOrder, 0, numSubpartitions);\n        } else {\n            for (int channel = 0; channel < numSubpartitions; ++channel) {\n                this.subpartitionReadOrder[channel] = channel;\n            }\n        }\n    }",
          "conflictNames": [
              "freeSegments",
              "bufferRecycler",
              "numSubpartitions",
              "bufferSize",
              "numGuaranteedBuffers",
              "customReadOrder",
              "channel"
          ]
      },
      "suggestions": [
          {
              "name": "subpartition",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/2839d06559ccf2a0b63a7f61276d7bb546abca3d^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/HashBasedDataBuffer.java",
      "locators": [
          {
              "line": 143,
              "column": 50
          },
          {
              "line": 151,
              "column": 33
          },
          {
              "line": 153,
              "column": 32
          },
          {
              "line": 164,
              "column": 52
          },
          {
              "line": 165,
              "column": 42
          },
          {
              "line": 169,
              "column": 22
          },
          {
              "line": 179,
              "column": 17
          },
          {
              "line": 182,
              "column": 53
          },
          {
              "line": 183,
              "column": 42
          },
          {
              "line": 194,
              "column": 25
          },
          {
              "line": 196,
              "column": 26
          },
          {
              "line": 203,
              "column": 26
          },
          {
              "line": 219,
              "column": 13
          },
          {
              "line": 221,
              "column": 47
          },
          {
              "line": 223,
              "column": 66
          },
          {
              "line": 231,
              "column": 17
          }
      ],
      "old_name": "targetChannel",
      "new_name": "targetSubpartition",
      "ctx": {
          "symbolName": "targetChannel",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in append(...)",
          "filePath": "HashBasedDataBuffer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "BasedDataBuffer} is full.\n     * The remaining data of the target record will be written to the next data region (a new data\n     * buffer or this data buffer after reset).\n     */\n    @Override\n    public boolean append(ByteBuffer source, int targetChannel, Buffer.DataType dataType)\n            throws IOException {\n        checkArgument(source.hasRemaining(), \"Cannot append empty data.\");\n        checkState(!isFinished, \"Sort buffer is already finished.\");\n        checkState(!isReleased, \"So",
          "conflictNames": [
              "source",
              "dataType",
              "totalBytes"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2839d06559ccf2a0b63a7f61276d7bb546abca3d^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PartitionedFileWriter.java",
      "locators": [
          {
              "line": 31,
              "column": 17
          },
          {
              "line": 51,
              "column": 19
          },
          {
              "line": 54,
              "column": 26
          },
          {
              "line": 57,
              "column": 27
          },
          {
              "line": 133,
              "column": 42
          },
          {
              "line": 196,
              "column": 22
          },
          {
              "line": 196,
              "column": 35
          },
          {
              "line": 196,
              "column": 65
          },
          {
              "line": 197,
              "column": 53
          },
          {
              "line": 197,
              "column": 81
          },
          {
              "line": 252,
              "column": 54
          },
          {
              "line": 268,
              "column": 39
          },
          {
              "line": 299,
              "column": 75
          }
      ],
      "old_name": "channel",
      "new_name": "subpartition",
      "ctx": {
          "symbolName": "channel",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in writeRegionIndex(...)",
          "filePath": "PartitionedFileWriter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void writeRegionIndex() throws IOException {\n        if (Arrays.stream(subpartitionBytes).sum() > 0) {\n            for (int channel = 0; channel < numSubpartitions; ++channel) {\n                writeIndexEntry(subpartitionOffsets[channel], subpartitionBytes[channel]);\n            }\n\n            currentSubpartition = -1;\n            ++numRegions;\n            Arrays.fill(subpartitionBytes, 0);\n        }\n    }"
      },
      "suggestions": [
          {
              "name": "subpartition",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/2839d06559ccf2a0b63a7f61276d7bb546abca3d^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SortBasedDataBuffer.java",
      "locators": [
          {
              "line": 69,
              "column": 13
          },
          {
              "line": 105,
              "column": 70
          },
          {
              "line": 116,
              "column": 46
          }
      ],
      "old_name": "channelIndex",
      "new_name": "subpartitionIndex",
      "ctx": {
          "symbolName": "channelIndex",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in getNextBuffer(...)",
          "filePath": "SortBasedDataBuffer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public BufferWithChannel getNextBuffer(MemorySegment transitBuffer) {\n        checkState(isFinished, \"Sort buffer is not ready to be read.\");\n        checkState(!isReleased, \"Sort buffer is already released.\");\n\n        if (!hasRemaining()) {\n            return null;\n        }\n\n        int numBytesCopied = 0;\n        DataType bufferDataType = DataType.DATA_BUFFER;\n        int channelIndex = subpartitionReadOrder[readOrderIndex];\n\n        do {\n            int sourceSegmentIndex = getSegmentIndexFromPointer(readIndexEntryAddress);\n            int sourceSegmentOffset = getSegmentOffsetFromPointer(readIndexEntryAddress);\n            MemorySegment sourceSegment = segments.get(sourceSegmentIndex);\n\n            long lengthAndDataType = sourceSegment.getLong(sourceSegmentOffset);\n            int length = getSegmentIndexFromPointer(lengthAndDataType);\n            DataType dataType = DataType.values()[getSegmentOffsetFromPointer(lengthAndDataType)];\n\n            // return the data read directly if the next to read is an event\n            if (dataType.isEvent() && numBytesCopied > 0) {\n                break;\n            }\n            bufferDataType = dataType;\n\n            // get the next index entry address and move the read position forward\n            long nextReadIndexEntryAddress = sourceSegment.getLong(sourceSegmentOffset + 8);\n            sourceSegmentOffset += INDEX_ENTRY_SIZE;\n\n            // allocate a temp buffer for the event if the target buffer is not big enough\n            if (bufferDataType.isEvent() && transitBuffer.size() < length) {\n                transitBuffer = MemorySegmentFactory.allocateUnpooledSegment(length);\n            }\n\n            numBytesCopied +=\n                    copyRecordOrEvent(\n                            transitBuffer,\n                            numBytesCopied,\n                            sourceSegmentIndex,\n                            sourceSegmentOffset,\n                            length);\n\n            if (recordRemainingBytes == 0) {\n                // move to next channel if the current channel has been finished\n                if (readIndexEntryAddress == lastIndexEntryAddresses[channelIndex]) {\n                    updateReadChannelAndIndexEntryAddress();\n                    break;\n                }\n                readIndexEntryAddress = nextReadIndexEntryAddress;\n            }\n        } while (numBytesCopied < transitBuffer.size() && bufferDataType.isBuffer());\n\n        numTotalBytesRead += numBytesCopied;\n        Buffer buffer =\n                new NetworkBuffer(transitBuffer, (buf) -> {}, bufferDataType, numBytesCopied);\n        return new BufferWithChannel(buffer, channelIndex);\n    }",
          "conflictNames": [
              "transitBuffer",
              "numBytesCopied",
              "bufferDataType",
              "sourceSegmentIndex",
              "sourceSegmentOffset",
              "sourceSegment",
              "lengthAndDataType",
              "length",
              "dataType",
              "nextReadIndexEntryAddress",
              "buffer"
          ]
      },
      "suggestions": [
          {
              "name": "subpartition",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/2839d06559ccf2a0b63a7f61276d7bb546abca3d^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SortBuffer.java",
      "locators": [
          {
              "line": 45,
              "column": 67
          },
          {
              "line": 123,
              "column": 45
          },
          {
              "line": 144,
              "column": 56
          },
          {
              "line": 153,
              "column": 22
          },
          {
              "line": 153,
              "column": 35
          },
          {
              "line": 153,
              "column": 65
          },
          {
              "line": 154,
              "column": 44
          },
          {
              "line": 154,
              "column": 55
          },
          {
              "line": 187,
              "column": 33
          },
          {
              "line": 196,
              "column": 62
          },
          {
              "line": 197,
              "column": 33
          },
          {
              "line": 200,
              "column": 59
          },
          {
              "line": 205,
              "column": 38
          },
          {
              "line": 319,
              "column": 21
          },
          {
              "line": 321,
              "column": 17
          },
          {
              "line": 322,
              "column": 67
          }
      ],
      "old_name": "channel",
      "new_name": "subpartition",
      "ctx": {
          "symbolName": "channel",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in SortBuffer(...)",
          "filePath": "SortBuffer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "protected SortBuffer(\n            LinkedList<MemorySegment> freeSegments,\n            BufferRecycler bufferRecycler,\n            int numSubpartitions,\n            int bufferSize,\n            int numGuaranteedBuffers,\n            @Nullable int[] customReadOrder) {\n        checkArgument(bufferSize > INDEX_ENTRY_SIZE, \"Buffer size is too small.\");\n        checkArgument(numGuaranteedBuffers > 0, \"No guaranteed buffers for sort.\");\n\n        this.freeSegments = checkNotNull(freeSegments);\n        this.bufferRecycler = checkNotNull(bufferRecycler);\n        this.bufferSize = bufferSize;\n        this.numGuaranteedBuffers = numGuaranteedBuffers;\n        checkState(numGuaranteedBuffers <= freeSegments.size(), \"Wrong number of free segments.\");\n        this.firstIndexEntryAddresses = new long[numSubpartitions];\n        this.lastIndexEntryAddresses = new long[numSubpartitions];\n\n        // initialized with -1 means the corresponding channel has no data\n        Arrays.fill(firstIndexEntryAddresses, -1L);\n        Arrays.fill(lastIndexEntryAddresses, -1L);\n\n        this.subpartitionReadOrder = new int[numSubpartitions];\n        if (customReadOrder != null) {\n            checkArgument(customReadOrder.length == numSubpartitions, \"Illegal data read order.\");\n            System.arraycopy(customReadOrder, 0, this.subpartitionReadOrder, 0, numSubpartitions);\n        } else {\n            for (int channel = 0; channel < numSubpartitions; ++channel) {\n                this.subpartitionReadOrder[channel] = channel;\n            }\n        }\n    }",
          "conflictNames": [
              "freeSegments",
              "bufferRecycler",
              "numSubpartitions",
              "bufferSize",
              "numGuaranteedBuffers",
              "customReadOrder"
          ]
      },
      "suggestions": [
          {
              "name": "subpartition",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/2839d06559ccf2a0b63a7f61276d7bb546abca3d^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SortBuffer.java",
      "locators": [
          {
              "line": 187,
              "column": 33
          },
          {
              "line": 196,
              "column": 62
          },
          {
              "line": 197,
              "column": 33
          },
          {
              "line": 205,
              "column": 38
          },
          {
              "line": 321,
              "column": 17
          },
          {
              "line": 322,
              "column": 67
          }
      ],
      "old_name": "channelIndex",
      "new_name": "subpartitionIndex",
      "ctx": {
          "symbolName": "channelIndex",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in writeIndex(...)",
          "filePath": "SortBuffer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "entry and record or event data\n        writeIndex(targetChannel, totalBytes, dataType);\n        writeRecord(source);\n\n        ++numTotalRecords;\n        numTotalBytes += totalBytes;\n\n        return false;\n    }\n\n    private void writeIndex(int channelIndex, int numRecordBytes, Buffer.DataType dataType) {\n        MemorySegment segment = segments.get(writeSegmentIndex);\n\n        // record length takes the high 32 bits and data type takes the low 32 bits\n        segment.putLong(writeSegmentOffs",
          "conflictNames": [
              "numRecordBytes",
              "dataType",
              "segment",
              "indexEntryAddress",
              "lastIndexEntryAddress"
          ]
      },
      "suggestions": [
          {
              "name": "subpartition",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/2839d06559ccf2a0b63a7f61276d7bb546abca3d^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SortMergeResultPartition.java",
      "locators": [
          {
              "line": 398,
              "column": 31
          },
          {
              "line": 399,
              "column": 17
          },
          {
              "line": 404,
              "column": 30
          },
          {
              "line": 405,
              "column": 50
          },
          {
              "line": 427,
              "column": 74
          },
          {
              "line": 428,
              "column": 25
          },
          {
              "line": 430,
              "column": 20
          },
          {
              "line": 434,
              "column": 46
          },
          {
              "line": 437,
              "column": 53
          },
          {
              "line": 439,
              "column": 30
          },
          {
              "line": 443,
              "column": 38
          },
          {
              "line": 472,
              "column": 31
          },
          {
              "line": 473,
              "column": 30
          },
          {
              "line": 474,
              "column": 50
          }
      ],
      "old_name": "bufferWithChannel",
      "new_name": "bufferWithSubpartition",
      "ctx": {
          "symbolName": "bufferWithChannel",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "BufferWithChannel",
          "scopeHint": "in flushDataBuffer(...)",
          "filePath": "SortMergeResultPartition.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void flushDataBuffer(DataBuffer dataBuffer, boolean isBroadcast) throws IOException {\n        if (dataBuffer == null || dataBuffer.isReleased() || !dataBuffer.hasRemaining()) {\n            return;\n        }\n        dataBuffer.finish();\n\n        Queue<MemorySegment> segments = new ArrayDeque<>(freeSegments);\n        int numBuffersToWrite =\n                useHashBuffer\n                        ? EXPECTED_WRITE_BATCH_SIZE\n                        : Math.min(EXPECTED_WRITE_BATCH_SIZE, segments.size());\n        List<BufferWithChannel> toWrite = new ArrayList<>(numBuffersToWrite);\n\n        fileWriter.startNewRegion(isBroadcast);\n        do {\n            if (toWrite.size() >= numBuffersToWrite) {\n                writeBuffers(toWrite);\n                segments = new ArrayDeque<>(freeSegments);\n            }\n\n            BufferWithChannel bufferWithChannel = dataBuffer.getNextBuffer(segments.poll());\n            if (bufferWithChannel == null) {\n                writeBuffers(toWrite);\n                break;\n            }\n\n            updateStatistics(bufferWithChannel, isBroadcast);\n            toWrite.add(compressBufferIfPossible(bufferWithChannel));\n        } while (true);\n\n        releaseFreeBuffers();\n    }",
          "conflictNames": [
              "dataBuffer",
              "isBroadcast",
              "segments",
              "numBuffersToWrite",
              "toWrite"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2839d06559ccf2a0b63a7f61276d7bb546abca3d^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SortMergeResultPartition.java",
      "locators": [
          {
              "line": 579,
              "column": 18
          },
          {
              "line": 579,
              "column": 31
          },
          {
              "line": 579,
              "column": 61
          },
          {
              "line": 580,
              "column": 20
          },
          {
              "line": 580,
              "column": 59
          }
      ],
      "old_name": "channel",
      "new_name": "subpartition",
      "ctx": {
          "symbolName": "channel",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in getRandomSubpartitionOrder(...)",
          "filePath": "SortMergeResultPartition.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private int[] getRandomSubpartitionOrder(int numSubpartitions) {\n        int[] order = new int[numSubpartitions];\n        Random random = new Random();\n        int shift = random.nextInt(numSubpartitions);\n        for (int channel = 0; channel < numSubpartitions; ++channel) {\n            order[(channel + shift) % numSubpartitions] = channel;\n        }\n        return order;\n    }",
          "conflictNames": [
              "numSubpartitions",
              "order",
              "random",
              "shift"
          ]
      },
      "suggestions": [
          {
              "name": "subpartition",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/2839d06559ccf2a0b63a7f61276d7bb546abca3d^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/HsResultPartitionTest.java",
      "locators": [
          {
              "line": 237,
              "column": 19
          },
          {
              "line": 245,
              "column": 52
          },
          {
              "line": 251,
              "column": 65
          }
      ],
      "old_name": "targetChannel",
      "new_name": "targetSubpartition",
      "ctx": {
          "symbolName": "targetChannel",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in testMultipleConsumer(...)",
          "filePath": "HsResultPartitionTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Test write and read data from single subpartition with multiple consumer. */\n    @Test\n    void testMultipleConsumer() throws Exception {\n        final int numBuffers = 10;\n        final int numRecords = 10;\n        final int numConsumers = 2;\n        final int targetChannel = 0;\n        final Random random = new Random();\n\n        BufferPool bufferPool = globalPool.createBufferPool(numBuffers, numBuffers);\n        try (HsResultPartition resultPartition = createHsResultPartition(2, bufferPool)) {\n            List<ByteBuffer> dataWritten = new ArrayList<>();\n            for (int i = 0; i < numRecords; i++) {\n                ByteBuffer record = generateRandomData(bufferSize, random);\n                resultPartition.emitRecord(record, targetChannel);\n                dataWritten.add(record);\n            }\n            resultPartition.finish();\n\n            Tuple2[] viewAndListeners =\n                    createMultipleConsumerView(resultPartition, targetChannel, 2);\n\n            List<List<Buffer>> dataRead = new ArrayList<>();\n            for (int i = 0; i < numConsumers; i++) {\n                dataRead.add(new ArrayList<>());\n            }\n            readData(\n                    viewAndListeners,\n                    (buffer, subpartition) -> {\n                        int numBytes = buffer.readableBytes();\n                        if (buffer.isBuffer()) {\n                            MemorySegment segment =\n                                    MemorySegmentFactory.allocateUnpooledSegment(numBytes);\n                            segment.put(0, buffer.getNioBufferReadable(), numBytes);\n                            dataRead.get(subpartition)\n                                    .add(\n                                            new NetworkBuffer(\n                                                    segment,\n                                                    (buf) -> {},\n                                                    buffer.getDataType(),\n                                                    numBytes));\n                        }\n                    });\n\n            for (int i = 0; i < numConsumers; i++) {\n                assertThat(dataWritten).hasSameSizeAs(dataRead.get(i));\n                List<Buffer> readBufferList = dataRead.get(i);\n                for (int j = 0; j < dataWritten.size(); j++) {\n                    ByteBuffer bufferWritten = dataWritten.get(j);\n                    bufferWritten.rewind();\n                    Buffer bufferRead = readBufferList.get(j);\n                    assertThat(bufferRead.getNioBufferReadable()).isEqualTo(bufferWritten);\n                }\n            }\n        }\n    }",
          "conflictNames": [
              "numBuffers",
              "numRecords",
              "numConsumers",
              "random",
              "bufferPool",
              "resultPartition",
              "dataWritten",
              "i",
              "record",
              "viewAndListeners",
              "dataRead",
              "numBytes",
              "segment",
              "readBufferList",
              "j",
              "bufferWritten",
              "bufferRead"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2839d06559ccf2a0b63a7f61276d7bb546abca3d^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/storage/SortBufferAccumulator.java",
      "locators": [
          {
              "line": 201,
              "column": 31
          },
          {
              "line": 202,
              "column": 17
          },
          {
              "line": 205,
              "column": 25
          },
          {
              "line": 245,
              "column": 48
          },
          {
              "line": 248,
              "column": 57
          },
          {
              "line": 249,
              "column": 51
          }
      ],
      "old_name": "bufferWithChannel",
      "new_name": "bufferWithSubpartition",
      "ctx": {
          "symbolName": "bufferWithChannel",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "BufferWithChannel",
          "scopeHint": "in flushDataBuffer(...)",
          "filePath": "SortBufferAccumulator.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void flushDataBuffer() {\n        if (currentDataBuffer == null\n                || currentDataBuffer.isReleased()\n                || !currentDataBuffer.hasRemaining()) {\n            return;\n        }\n        currentDataBuffer.finish();\n\n        do {\n            MemorySegment freeSegment = getFreeSegment();\n            BufferWithChannel bufferWithChannel = currentDataBuffer.getNextBuffer(freeSegment);\n            if (bufferWithChannel == null) {\n                break;\n            }\n            flushBuffer(bufferWithChannel);\n        } while (true);\n\n        releaseFreeBuffers();\n        currentDataBuffer.release();\n    }",
          "conflictNames": [
              "freeSegment"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2839d06559ccf2a0b63a7f61276d7bb546abca3d^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/storage/TieredStorageSortBufferTest.java",
      "locators": [
          {
              "line": 177,
              "column": 27
          },
          {
              "line": 178,
              "column": 20
          },
          {
              "line": 179,
              "column": 20
          },
          {
              "line": 180,
              "column": 9
          },
          {
              "line": 183,
              "column": 9
          },
          {
              "line": 184,
              "column": 20
          },
          {
              "line": 185,
              "column": 20
          }
      ],
      "old_name": "bufferWithChannel",
      "new_name": "bufferWithSubpartition",
      "ctx": {
          "symbolName": "bufferWithChannel",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "BufferWithChannel",
          "scopeHint": "in testBufferIsRecycledWhenGetEvent(...)",
          "filePath": "TieredStorageSortBufferTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testBufferIsRecycledWhenGetEvent() throws Exception {\n        int numSubpartitions = 10;\n        int bufferPoolSize = 512;\n        int bufferSizeBytes = 1024;\n        int numBuffersForSort = 20;\n        int subpartitionId = 0;\n        Random random = new Random(1234);\n\n        NetworkBufferPool globalPool = new NetworkBufferPool(bufferPoolSize, bufferSizeBytes);\n        BufferPool bufferPool = globalPool.createBufferPool(bufferPoolSize, bufferPoolSize);\n\n        LinkedList<MemorySegment> segments = new LinkedList<>();\n        for (int i = 0; i < numBuffersForSort; ++i) {\n            segments.add(bufferPool.requestMemorySegmentBlocking());\n        }\n        TieredStorageSortBuffer sortBuffer =\n                new TieredStorageSortBuffer(\n                        segments, bufferPool, numSubpartitions, bufferSizeBytes, numBuffersForSort);\n\n        byte[] bytes = new byte[1];\n        random.nextBytes(bytes);\n        ByteBuffer dataRecord = ByteBuffer.wrap(bytes);\n        sortBuffer.append(dataRecord, subpartitionId, Buffer.DataType.DATA_BUFFER);\n        ByteBuffer eventRecord = ByteBuffer.wrap(bytes);\n        sortBuffer.append(eventRecord, subpartitionId, Buffer.DataType.EVENT_BUFFER);\n        sortBuffer.finish();\n\n        MemorySegment memorySegment = bufferPool.requestMemorySegmentBlocking();\n        BufferWithChannel bufferWithChannel = sortBuffer.getNextBuffer(memorySegment);\n        assertThat(bufferWithChannel.getBuffer().isBuffer()).isTrue();\n        assertThat(bufferWithChannel.getChannelIndex()).isEqualTo(subpartitionId);\n        bufferWithChannel.getBuffer().recycleBuffer();\n        assertThat(bufferPool.bestEffortGetNumOfUsedBuffers()).isEqualTo(numBuffersForSort);\n\n        bufferWithChannel = sortBuffer.getNextBuffer(memorySegment);\n        assertThat(bufferWithChannel.getBuffer().isBuffer()).isFalse();\n        assertThat(bufferWithChannel.getChannelIndex()).isEqualTo(subpartitionId);\n        assertThat(bufferPool.bestEffortGetNumOfUsedBuffers()).isEqualTo(numBuffersForSort);\n    }",
          "conflictNames": [
              "numSubpartitions",
              "bufferPoolSize",
              "bufferSizeBytes",
              "numBuffersForSort",
              "subpartitionId",
              "random",
              "globalPool",
              "bufferPool",
              "segments",
              "i",
              "sortBuffer",
              "bytes",
              "dataRecord",
              "eventRecord",
              "memorySegment"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2839d06559ccf2a0b63a7f61276d7bb546abca3d^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/storage/TieredStorageSortBufferTest.java",
      "locators": [
          {
              "line": 196,
              "column": 13
          },
          {
              "line": 198,
              "column": 21
          },
          {
              "line": 204,
              "column": 22
          }
      ],
      "old_name": "channel",
      "new_name": "subpartition",
      "ctx": {
          "symbolName": "channel",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in addBufferRead(...)",
          "filePath": "TieredStorageSortBufferTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void addBufferRead(\n            BufferWithChannel bufferAndChannel, Queue<Buffer>[] buffersRead, int[] numBytesRead) {\n        int channel = bufferAndChannel.getChannelIndex();\n        Buffer buffer = bufferAndChannel.getBuffer();\n        buffersRead[channel].add(\n                new NetworkBuffer(\n                        buffer.getMemorySegment(),\n                        MemorySegment::free,\n                        buffer.getDataType(),\n                        buffer.getSize()));\n        numBytesRead[channel] += buffer.getSize();\n    }",
          "conflictNames": [
              "bufferAndChannel",
              "buffersRead",
              "numBytesRead",
              "buffer"
          ]
      },
      "suggestions": [
          {
              "name": "subpartition",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/2839d06559ccf2a0b63a7f61276d7bb546abca3d^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/api/writer/RecordWriterTest.java",
      "locators": [
          {
              "line": 89,
              "column": 13
          },
          {
              "line": 92,
              "column": 71
          },
          {
              "line": 105,
              "column": 29
          },
          {
              "line": 120,
              "column": 13
          },
          {
              "line": 124,
              "column": 71
          },
          {
              "line": 160,
              "column": 33
          },
          {
              "line": 195,
              "column": 33
          },
          {
              "line": 256,
              "column": 19
          },
          {
              "line": 261,
              "column": 77
          },
          {
              "line": 281,
              "column": 53
          },
          {
              "line": 284,
              "column": 29
          }
      ],
      "old_name": "numberOfChannels",
      "new_name": "numberOfSubpartitions",
      "ctx": {
          "symbolName": "numberOfChannels",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in testBroadcastEventNoRecords(...)",
          "filePath": "RecordWriterTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Tests broadcasting events when no records have been emitted yet. */\n    @TestTemplate\n    void testBroadcastEventNoRecords() throws Exception {\n        int numberOfChannels = 4;\n        int bufferSize = 32;\n\n        ResultPartition partition = createResultPartition(bufferSize, numberOfChannels);\n        RecordWriter<ByteArrayIO> writer = createRecordWriter(partition);\n        CheckpointBarrier barrier =\n                new CheckpointBarrier(\n                        Integer.MAX_VALUE + 919192L,\n                        Integer.MAX_VALUE + 18828228L,\n                        CheckpointOptions.forCheckpointWithDefaultLocation());\n\n        // No records emitted yet, broadcast should not request a buffer\n        writer.broadcastEvent(barrier);\n\n        assertThat(partition.getBufferPool().bestEffortGetNumOfUsedBuffers()).isZero();\n\n        for (int i = 0; i < numberOfChannels; i++) {\n            assertThat(partition.getNumberOfQueuedBuffers(i)).isOne();\n            ResultSubpartitionView view =\n                    partition.createSubpartitionView(i, new NoOpBufferAvailablityListener());\n            BufferOrEvent boe = parseBuffer(view.getNextBuffer().buffer(), i);\n            assertThat(boe.isEvent()).isTrue();\n            assertThat(boe.getEvent()).isEqualTo(barrier);\n            assertThat(view.getAvailabilityAndBacklog(Integer.MAX_VALUE).isAvailable()).isFalse();\n        }\n    }",
          "conflictNames": [
              "bufferSize",
              "partition",
              "writer",
              "barrier",
              "i",
              "view",
              "boe"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2839d06559ccf2a0b63a7f61276d7bb546abca3d^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/DataBufferTest.java",
      "locators": [
          {
              "line": 257,
              "column": 27
          },
          {
              "line": 258,
              "column": 20
          },
          {
              "line": 259,
              "column": 20
          }
      ],
      "old_name": "bufferWithChannel",
      "new_name": "bufferWithSubpartition",
      "ctx": {
          "symbolName": "bufferWithChannel",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "BufferWithChannel",
          "scopeHint": "in checkReadResult(...)",
          "filePath": "DataBufferTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void checkReadResult(\n            DataBuffer dataBuffer, ByteBuffer expectedBuffer, int expectedChannel, int bufferSize) {\n        MemorySegment segment = MemorySegmentFactory.allocateUnpooledSegment(bufferSize);\n        BufferWithChannel bufferWithChannel = dataBuffer.getNextBuffer(segment);\n        assertThat(bufferWithChannel.getChannelIndex()).isEqualTo(expectedChannel);\n        assertThat(bufferWithChannel.getBuffer().getNioBufferReadable()).isEqualTo(expectedBuffer);\n    }",
          "conflictNames": [
              "dataBuffer",
              "expectedBuffer",
              "expectedChannel",
              "bufferSize",
              "segment"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2839d06559ccf2a0b63a7f61276d7bb546abca3d^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/DataBufferTest.java",
      "locators": [
          {
              "line": 167,
              "column": 13
          },
          {
              "line": 168,
              "column": 21
          },
          {
              "line": 169,
              "column": 22
          }
      ],
      "old_name": "channel",
      "new_name": "subpartition",
      "ctx": {
          "symbolName": "channel",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in addBufferRead(...)",
          "filePath": "DataBufferTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void addBufferRead(\n            BufferWithChannel buffer, Queue<Buffer>[] buffersRead, int[] numBytesRead) {\n        int channel = buffer.getChannelIndex();\n        buffersRead[channel].add(buffer.getBuffer());\n        numBytesRead[channel] += buffer.getBuffer().readableBytes();\n    }",
          "conflictNames": [
              "buffer",
              "buffersRead",
              "numBytesRead"
          ]
      },
      "suggestions": [
          {
              "name": "subpartition",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/2839d06559ccf2a0b63a7f61276d7bb546abca3d^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PartitionedFileWriteReadTest.java",
      "locators": [
          {
              "line": 128,
              "column": 39
          },
          {
              "line": 130,
              "column": 17
          },
          {
              "line": 138,
              "column": 25
          },
          {
              "line": 144,
              "column": 21
          },
          {
              "line": 152,
              "column": 41
          },
          {
              "line": 153,
              "column": 49
          },
          {
              "line": 169,
              "column": 63
          },
          {
              "line": 171,
              "column": 52
          }
      ],
      "old_name": "bufferWithChannels",
      "new_name": "bufferWithSubpartitions",
      "ctx": {
          "symbolName": "bufferWithChannels",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<BufferWithChannel>[]",
          "scopeHint": "in createPartitionedFile(...)",
          "filePath": "PartitionedFileWriteReadTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private PartitionedFile createPartitionedFile(\n            int numSubpartitions,\n            int bufferSize,\n            int numBuffers,\n            int numRegions,\n            List<Buffer>[] buffersWritten,\n            List<Tuple2<Long, Long>>[] regionStat,\n            PartitionedFileWriter fileWriter)\n            throws IOException {\n        Random random = new Random(1111);\n        long currentOffset = 0L;\n        for (int region = 0; region < numRegions; ++region) {\n            boolean isBroadcastRegion = random.nextBoolean();\n            fileWriter.startNewRegion(isBroadcastRegion);\n            List<BufferWithChannel>[] bufferWithChannels = new List[numSubpartitions];\n            for (int i = 0; i < numSubpartitions; i++) {\n                bufferWithChannels[i] = new ArrayList<>();\n            }\n\n            for (int i = 0; i < numBuffers; ++i) {\n                Buffer buffer = createBuffer(random, bufferSize);\n                if (isBroadcastRegion) {\n                    for (int subpartition = 0; subpartition < numSubpartitions; ++subpartition) {\n                        buffersWritten[subpartition].add(buffer);\n                        bufferWithChannels[subpartition].add(\n                                new BufferWithChannel(buffer, subpartition));\n                    }\n                } else {\n                    int subpartition = random.nextInt(numSubpartitions);\n                    buffersWritten[subpartition].add(buffer);\n                    bufferWithChannels[subpartition].add(\n                            new BufferWithChannel(buffer, subpartition));\n                }\n            }\n\n            int[] writeOrder = DataBufferTest.getRandomSubpartitionOrder(numSubpartitions);\n            for (int index = 0; index < numSubpartitions; ++index) {\n                int subpartition = writeOrder[index];\n                fileWriter.writeBuffers(bufferWithChannels[subpartition]);\n                long totalBytes = getTotalBytes(bufferWithChannels[subpartition]);\n                if (isBroadcastRegion) {\n                    for (int j = 0; j < numSubpartitions; j++) {\n                        regionStat[j].add(Tuple2.of(currentOffset, totalBytes));\n                    }\n                    currentOffset += totalBytes;\n                    break;\n                } else {\n                    regionStat[subpartition].add(Tuple2.of(currentOffset, totalBytes));\n                    currentOffset += totalBytes;\n                }\n            }\n        }\n        return fileWriter.finish();\n    }",
          "conflictNames": [
              "numSubpartitions",
              "bufferSize",
              "numBuffers",
              "numRegions",
              "buffersWritten",
              "regionStat",
              "fileWriter",
              "random",
              "currentOffset",
              "region",
              "isBroadcastRegion",
              "i",
              "buffer",
              "subpartition",
              "writeOrder",
              "index",
              "totalBytes",
              "j"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2839d06559ccf2a0b63a7f61276d7bb546abca3d^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PartitionedFileWriteReadTest.java",
      "locators": [
          {
              "line": 128,
              "column": 39
          },
          {
              "line": 130,
              "column": 17
          },
          {
              "line": 138,
              "column": 25
          },
          {
              "line": 144,
              "column": 21
          },
          {
              "line": 152,
              "column": 41
          },
          {
              "line": 153,
              "column": 49
          },
          {
              "line": 169,
              "column": 63
          },
          {
              "line": 171,
              "column": 32
          },
          {
              "line": 171,
              "column": 52
          },
          {
              "line": 173,
              "column": 21
          }
      ],
      "old_name": "bufferWithChannel",
      "new_name": "bufferWithSubpartition",
      "ctx": {
          "symbolName": "bufferWithChannel",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "BufferWithChannel",
          "scopeHint": "in getTotalBytes(...)",
          "filePath": "PartitionedFileWriteReadTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "urrentOffset += totalBytes;\n                }\n            }\n        }\n        return fileWriter.finish();\n    }\n\n    private static long getTotalBytes(List<BufferWithChannel> bufferWithChannels) {\n        long totalBytes = 0L;\n        for (BufferWithChannel bufferWithChannel : bufferWithChannels) {\n            totalBytes +=\n                    bufferWithChannel.getBuffer().readableBytes()\n                            + BufferReaderWriterUtil.HEADER_LENGTH;\n        }\n        return totalBytes;\n    }\n\n    private",
          "conflictNames": [
              "bufferWithChannels",
              "totalBytes"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherCleanupITCase.java",
      "locators": [
          {
              "line": 142,
              "column": 29
          },
          {
              "line": 157,
              "column": 9
          },
          {
              "line": 158,
              "column": 37
          },
          {
              "line": 265,
              "column": 29
          },
          {
              "line": 284,
              "column": 9
          },
          {
              "line": 285,
              "column": 37
          }
      ],
      "old_name": "jobGraphStore",
      "new_name": "executionPlanStore",
      "ctx": {
          "symbolName": "jobGraphStore",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraphStore",
          "scopeHint": "in testCleanupThroughRetries(...)",
          "filePath": "DispatcherCleanupITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testCleanupThroughRetries() throws Exception {\n        final JobGraph jobGraph = createJobGraph();\n        final JobID jobId = jobGraph.getJobID();\n\n        // JobGraphStore\n        final AtomicInteger actualGlobalCleanupCallCount = new AtomicInteger();\n        final OneShotLatch successfulCleanupLatch = new OneShotLatch();\n        final int numberOfErrors = 5;\n        final RuntimeException temporaryError =\n                new RuntimeException(\"Expected RuntimeException: Unable to remove job graph.\");\n        final AtomicInteger failureCount = new AtomicInteger(numberOfErrors);\n        final JobGraphStore jobGraphStore =\n                TestingJobGraphStore.newBuilder()\n                        .setGlobalCleanupFunction(\n                                (ignoredJobId, ignoredExecutor) -> {\n                                    actualGlobalCleanupCallCount.incrementAndGet();\n\n                                    if (failureCount.getAndDecrement() > 0) {\n                                        return FutureUtils.completedExceptionally(temporaryError);\n                                    }\n\n                                    successfulCleanupLatch.trigger();\n                                    return FutureUtils.completedVoidFuture();\n                                })\n                        .build();\n\n        jobGraphStore.start(NoOpJobGraphListener.INSTANCE);\n        haServices.setJobGraphStore(jobGraphStore);\n\n        // Construct leader election.\n        final TestingLeaderElection leaderElection = new TestingLeaderElection();\n        haServices.setJobMasterLeaderElection(jobId, leaderElection);\n\n        // start the dispatcher with enough retries on cleanup\n        final JobManagerRunnerRegistry jobManagerRunnerRegistry =\n                new DefaultJobManagerRunnerRegistry(2);\n        final Dispatcher dispatcher =\n                createTestingDispatcherBuilder()\n                        .setResourceCleanerFactory(\n                                new DispatcherResourceCleanerFactory(\n                                        ForkJoinPool.commonPool(),\n                                        TestingRetryStrategies.createWithNumberOfRetries(\n                                                numberOfErrors),\n                                        jobManagerRunnerRegistry,\n                                        haServices.getJobGraphStore(),\n                                        blobServer,\n                                        haServices,\n                                        UnregisteredMetricGroups\n                                                .createUnregisteredJobManagerMetricGroup()))\n                        .build(rpcService);\n        dispatcher.start();\n\n        toTerminate.add(dispatcher);\n        final CompletableFuture<LeaderInformation> confirmedLeaderInformation =\n                leaderElection.isLeader(UUID.randomUUID());\n        final DispatcherGateway dispatcherGateway =\n                dispatcher.getSelfGateway(DispatcherGateway.class);\n        dispatcherGateway.submitJob(jobGraph, TIMEOUT).get();\n\n        waitForJobToFinish(confirmedLeaderInformation, dispatcherGateway, jobId);\n\n        successfulCleanupLatch.await();\n\n        assertThat(actualGlobalCleanupCallCount.get(), equalTo(numberOfErrors + 1));\n\n        assertThat(\n                \"The JobGraph should be removed from JobGraphStore.\",\n                haServices.getJobGraphStore().getJobIds(),\n                IsEmptyCollection.empty());\n\n        CommonTestUtils.waitUntilCondition(\n                () -> haServices.getJobResultStore().hasJobResultEntryAsync(jobId).get());\n    }",
          "conflictNames": [
              "jobGraph",
              "jobId",
              "actualGlobalCleanupCallCount",
              "successfulCleanupLatch",
              "numberOfErrors",
              "temporaryError",
              "failureCount",
              "leaderElection",
              "jobManagerRunnerRegistry",
              "dispatcher",
              "confirmedLeaderInformation",
              "dispatcherGateway"
          ]
      },
      "suggestions": [
          {
              "name": "executionPlanStore",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/JobDispatcherFactory.java",
      "locators": [
          {
              "line": 49,
              "column": 24
          },
          {
              "line": 54,
              "column": 17
          },
          {
              "line": 70,
              "column": 17
          }
      ],
      "old_name": "recoveredJobGraph",
      "new_name": "recoveredExecutionPlan",
      "ctx": {
          "symbolName": "recoveredJobGraph",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraph",
          "scopeHint": "in createDispatcher(...)",
          "filePath": "JobDispatcherFactory.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public MiniDispatcher createDispatcher(\n            RpcService rpcService,\n            DispatcherId fencingToken,\n            Collection<JobGraph> recoveredJobs,\n            Collection<JobResult> recoveredDirtyJobResults,\n            DispatcherBootstrapFactory dispatcherBootstrapFactory,\n            PartialDispatcherServicesWithJobPersistenceComponents\n                    partialDispatcherServicesWithJobPersistenceComponents)\n            throws Exception {\n        final JobGraph recoveredJobGraph = Iterables.getOnlyElement(recoveredJobs, null);\n        final JobResult recoveredDirtyJob =\n                Iterables.getOnlyElement(recoveredDirtyJobResults, null);\n\n        Preconditions.checkArgument(\n                recoveredJobGraph == null ^ recoveredDirtyJob == null,\n                \"Either the JobGraph or the recovered JobResult needs to be specified.\");\n\n        final Configuration configuration =\n                partialDispatcherServicesWithJobPersistenceComponents.getConfiguration();\n        final String executionModeValue = configuration.get(INTERNAL_CLUSTER_EXECUTION_MODE);\n        final ClusterEntrypoint.ExecutionMode executionMode =\n                ClusterEntrypoint.ExecutionMode.valueOf(executionModeValue);\n\n        return new MiniDispatcher(\n                rpcService,\n                fencingToken,\n                DispatcherServices.from(\n                        partialDispatcherServicesWithJobPersistenceComponents,\n                        JobMasterServiceLeadershipRunnerFactory.INSTANCE,\n                        CheckpointResourcesCleanupRunnerFactory.INSTANCE),\n                recoveredJobGraph,\n                recoveredDirtyJob,\n                dispatcherBootstrapFactory,\n                executionMode);\n    }",
          "conflictNames": [
              "rpcService",
              "fencingToken",
              "recoveredJobs",
              "recoveredDirtyJobResults",
              "dispatcherBootstrapFactory",
              "partialDispatcherServicesWithJobPersistenceComponents",
              "recoveredDirtyJob",
              "configuration",
              "executionModeValue",
              "executionMode"
          ]
      },
      "suggestions": [
          {
              "name": "recoveredExecutionPlan",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/cleanup/DispatcherResourceCleanerFactoryTest.java",
      "locators": [
          {
              "line": 109,
              "column": 36
          },
          {
              "line": 122,
              "column": 9
          },
          {
              "line": 124,
              "column": 16
          }
      ],
      "old_name": "jobGraphStore",
      "new_name": "executionPlanStore",
      "ctx": {
          "symbolName": "jobGraphStore",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestingJobGraphStore",
          "scopeHint": "in createJobGraphWriter(...)",
          "filePath": "DispatcherResourceCleanerFactoryTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private JobGraphWriter createJobGraphWriter() throws Exception {\n        jobGraphWriterLocalCleanupFuture = new CompletableFuture<>();\n        jobGraphWriterGlobalCleanupFuture = new CompletableFuture<>();\n        final TestingJobGraphStore jobGraphStore =\n                TestingJobGraphStore.newBuilder()\n                        .setGlobalCleanupFunction(\n                                (jobId, executor) -> {\n                                    jobGraphWriterGlobalCleanupFuture.complete(jobId);\n                                    return FutureUtils.completedVoidFuture();\n                                })\n                        .setLocalCleanupFunction(\n                                (jobId, ignoredExecutor) -> {\n                                    jobGraphWriterLocalCleanupFuture.complete(jobId);\n                                    return FutureUtils.completedVoidFuture();\n                                })\n                        .build();\n        jobGraphStore.start(null);\n\n        return jobGraphStore;\n    }"
      },
      "suggestions": [
          {
              "name": "executionPlanStore",
              "confidence": 0.8
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/JobDispatcherLeaderProcessFactoryFactoryTest.java",
      "locators": [
          {
              "line": 120,
              "column": 29
          },
          {
              "line": 122,
              "column": 59
          },
          {
              "line": 128,
              "column": 59
          }
      ],
      "old_name": "jobGraphStore",
      "new_name": "executionPlanStore",
      "ctx": {
          "symbolName": "jobGraphStore",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraphStore",
          "scopeHint": "in createDispatcherLeaderProcessFactoryFromTestInstance(...)",
          "filePath": "JobDispatcherLeaderProcessFactoryFactoryTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static JobDispatcherLeaderProcessFactory\n            createDispatcherLeaderProcessFactoryFromTestInstance(\n                    @Nullable JobGraph jobGraph,\n                    @Nullable JobResult dirtyJobResult,\n                    Path storageDir)\n                    throws IOException {\n        final JobDispatcherLeaderProcessFactoryFactory testInstance =\n                new JobDispatcherLeaderProcessFactoryFactory(ignoredConfig -> jobGraph);\n\n        final TestingJobResultStore jobResultStore =\n                TestingJobResultStore.builder()\n                        .withGetDirtyResultsSupplier(\n                                () -> CollectionUtil.ofNullable(dirtyJobResult))\n                        .build();\n        final JobGraphStore jobGraphStore = new StandaloneJobGraphStore();\n        return testInstance.createFactory(\n                new TestingJobPersistenceComponentFactory(jobGraphStore, jobResultStore),\n                Executors.directExecutor(),\n                new TestingRpcService(),\n                TestingPartialDispatcherServices.builder()\n                        .withHighAvailabilityServices(\n                                new TestingHighAvailabilityServicesBuilder()\n                                        .setJobGraphStore(jobGraphStore)\n                                        .setJobResultStore(jobResultStore)\n                                        .build())\n                        .build(storageDir.toFile(), new Configuration()),\n                NoOpFatalErrorHandler.INSTANCE);\n    }",
          "conflictNames": [
              "jobGraph",
              "dirtyJobResult",
              "storageDir",
              "testInstance",
              "jobResultStore"
          ]
      },
      "suggestions": [
          {
              "name": "executionPlanStore",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/SessionDispatcherLeaderProcessTest.java",
      "locators": [
          {
              "line": 173,
              "column": 24
          },
          {
              "line": 176,
              "column": 31
          },
          {
              "line": 181,
              "column": 44
          }
      ],
      "old_name": "otherJobGraph",
      "new_name": "otherExecutionPlan",
      "ctx": {
          "symbolName": "otherJobGraph",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraph",
          "scopeHint": "in testRecoveryWithMultipleJobGraphsAndOneMatchingDirtyJobResult(...)",
          "filePath": "SessionDispatcherLeaderProcessTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testRecoveryWithMultipleJobGraphsAndOneMatchingDirtyJobResult() throws Exception {\n        final JobResult matchingDirtyJobResult =\n                TestingJobResultStore.createSuccessfulJobResult(JOB_GRAPH.getJobID());\n        final JobGraph otherJobGraph = JobGraphTestUtils.emptyJobGraph();\n\n        testJobRecovery(\n                Arrays.asList(otherJobGraph, JOB_GRAPH),\n                Collections.singleton(matchingDirtyJobResult),\n                actualRecoveredJobGraphs ->\n                        assertThat(actualRecoveredJobGraphs)\n                                .singleElement()\n                                .isEqualTo(otherJobGraph),\n                actualRecoveredDirtyJobResults ->\n                        assertThat(actualRecoveredDirtyJobResults)\n                                .singleElement()\n                                .isEqualTo(matchingDirtyJobResult));\n    }",
          "conflictNames": [
              "matchingDirtyJobResult"
          ]
      },
      "suggestions": [
          {
              "name": "otherExecutionPlan",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/SessionDispatcherLeaderProcessTest.java",
      "locators": [
          {
              "line": 217,
              "column": 55
          },
          {
              "line": 227,
              "column": 21
          },
          {
              "line": 236,
              "column": 47
          },
          {
              "line": 269,
              "column": 55
          },
          {
              "line": 279,
              "column": 21
          },
          {
              "line": 294,
              "column": 30
          }
      ],
      "old_name": "recoveredJobGraphsFuture",
      "new_name": "recoveredExecutionPlansFuture",
      "ctx": {
          "symbolName": "recoveredJobGraphsFuture",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CompletableFuture<Collection<JobGraph>>",
          "scopeHint": "in testJobRecovery(...)",
          "filePath": "SessionDispatcherLeaderProcessTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void testJobRecovery(\n            Collection<JobGraph> jobGraphsToRecover,\n            Set<JobResult> dirtyJobResults,\n            Consumer<Collection<JobGraph>> recoveredJobGraphAssertion,\n            Consumer<Collection<JobResult>> recoveredDirtyJobResultAssertion)\n            throws Exception {\n        jobGraphStore =\n                TestingJobGraphStore.newBuilder().setInitialJobGraphs(jobGraphsToRecover).build();\n\n        jobResultStore =\n                TestingJobResultStore.builder()\n                        .withGetDirtyResultsSupplier(() -> dirtyJobResults)\n                        .build();\n\n        final CompletableFuture<Collection<JobGraph>> recoveredJobGraphsFuture =\n                new CompletableFuture<>();\n        final CompletableFuture<Collection<JobResult>> recoveredDirtyJobResultsFuture =\n                new CompletableFuture<>();\n        dispatcherServiceFactory =\n                (ignoredDispatcherId,\n                        recoveredJobs,\n                        recoveredDirtyJobResults,\n                        ignoredJobGraphWriter,\n                        ignoredJobResultStore) -> {\n                    recoveredJobGraphsFuture.complete(recoveredJobs);\n                    recoveredDirtyJobResultsFuture.complete(recoveredDirtyJobResults);\n                    return TestingDispatcherGatewayService.newBuilder().build();\n                };\n\n        try (final SessionDispatcherLeaderProcess dispatcherLeaderProcess =\n                createDispatcherLeaderProcess()) {\n            dispatcherLeaderProcess.start();\n\n            recoveredJobGraphAssertion.accept(recoveredJobGraphsFuture.get());\n            recoveredDirtyJobResultAssertion.accept(recoveredDirtyJobResultsFuture.get());\n        }\n    }",
          "conflictNames": [
              "jobGraphsToRecover",
              "dirtyJobResults",
              "recoveredJobGraphAssertion",
              "recoveredDirtyJobResultAssertion",
              "recoveredDirtyJobResultsFuture",
              "dispatcherLeaderProcess"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/SessionDispatcherLeaderProcessTest.java",
      "locators": [
          {
              "line": 568,
              "column": 28
          },
          {
              "line": 570,
              "column": 24
          }
      ],
      "old_name": "submittedJobGraph",
      "new_name": "submittedExecutionPlan",
      "ctx": {
          "symbolName": "submittedJobGraph",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraph",
          "scopeHint": "in onAddedJobGraph_submitsRecoveredJob(...)",
          "filePath": "SessionDispatcherLeaderProcessTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void onAddedJobGraph_submitsRecoveredJob() throws Exception {\n        final CompletableFuture<JobGraph> submittedJobFuture = new CompletableFuture<>();\n        final TestingDispatcherGateway testingDispatcherGateway =\n                TestingDispatcherGateway.newBuilder()\n                        .setSubmitFunction(\n                                submittedJob -> {\n                                    submittedJobFuture.complete(submittedJob);\n                                    return CompletableFuture.completedFuture(Acknowledge.get());\n                                })\n                        .build();\n\n        dispatcherServiceFactory =\n                createFactoryBasedOnGenericSupplier(\n                        () ->\n                                TestingDispatcherGatewayService.newBuilder()\n                                        .setDispatcherGateway(testingDispatcherGateway)\n                                        .build());\n\n        try (final SessionDispatcherLeaderProcess dispatcherLeaderProcess =\n                createDispatcherLeaderProcess()) {\n            dispatcherLeaderProcess.start();\n\n            // wait first for the dispatcher service to be created\n            dispatcherLeaderProcess.getDispatcherGateway().get();\n\n            jobGraphStore.putJobGraph(JOB_GRAPH);\n            dispatcherLeaderProcess.onAddedJobGraph(JOB_GRAPH.getJobID());\n\n            final JobGraph submittedJobGraph = submittedJobFuture.get();\n\n            assertThat(submittedJobGraph.getJobID()).isEqualTo(JOB_GRAPH.getJobID());\n        }\n    }",
          "conflictNames": [
              "submittedJobFuture",
              "testingDispatcherGateway",
              "dispatcherLeaderProcess"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java",
      "locators": [
          {
              "line": 961,
              "column": 36
          },
          {
              "line": 963,
              "column": 9
          },
          {
              "line": 964,
              "column": 37
          },
          {
              "line": 968,
              "column": 44
          },
          {
              "line": 981,
              "column": 20
          }
      ],
      "old_name": "submittedJobGraphStore",
      "new_name": "submittedExecutionPlanStore",
      "ctx": {
          "symbolName": "submittedJobGraphStore",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestingJobGraphStore",
          "scopeHint": "in testPersistedJobGraphWhenDispatcherIsShutDown(...)",
          "filePath": "DispatcherTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testPersistedJobGraphWhenDispatcherIsShutDown() throws Exception {\n        final TestingJobGraphStore submittedJobGraphStore =\n                TestingJobGraphStore.newBuilder().build();\n        submittedJobGraphStore.start(null);\n        haServices.setJobGraphStore(submittedJobGraphStore);\n\n        dispatcher =\n                createTestingDispatcherBuilder()\n                        .setJobGraphWriter(submittedJobGraphStore)\n                        .build(rpcService);\n\n        dispatcher.start();\n\n        final DispatcherGateway dispatcherGateway =\n                dispatcher.getSelfGateway(DispatcherGateway.class);\n        dispatcherGateway.submitJob(jobGraph, TIMEOUT).get();\n\n        assertThat(dispatcher.getNumberJobs(TIMEOUT).get(), Matchers.is(1));\n\n        dispatcher.close();\n\n        assertThat(submittedJobGraphStore.contains(jobGraph.getJobID()), Matchers.is(true));\n    }",
          "conflictNames": [
              "dispatcherGateway"
          ]
      },
      "suggestions": [
          {
              "name": "submittedExecutionPlanStore",
              "confidence": 0.8
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java",
      "locators": [
          {
              "line": 1068,
              "column": 36
          },
          {
              "line": 1081,
              "column": 9
          },
          {
              "line": 1086,
              "column": 44
          }
      ],
      "old_name": "testingJobGraphStore",
      "new_name": "testingExecutionPlanStore",
      "ctx": {
          "symbolName": "testingJobGraphStore",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestingJobGraphStore",
          "scopeHint": "in testOnRemovedJobGraphDoesNotCleanUpHAFiles(...)",
          "filePath": "DispatcherTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testOnRemovedJobGraphDoesNotCleanUpHAFiles() throws Exception {\n        final CompletableFuture<JobID> removeJobGraphFuture = new CompletableFuture<>();\n        final CompletableFuture<JobID> releaseJobGraphFuture = new CompletableFuture<>();\n\n        final TestingJobGraphStore testingJobGraphStore =\n                TestingJobGraphStore.newBuilder()\n                        .setGlobalCleanupFunction(\n                                (jobId, executor) -> {\n                                    removeJobGraphFuture.complete(jobId);\n                                    return FutureUtils.completedVoidFuture();\n                                })\n                        .setLocalCleanupFunction(\n                                (jobId, executor) -> {\n                                    releaseJobGraphFuture.complete(jobId);\n                                    return FutureUtils.completedVoidFuture();\n                                })\n                        .build();\n        testingJobGraphStore.start(null);\n\n        dispatcher =\n                createTestingDispatcherBuilder()\n                        .setRecoveredJobs(Collections.singleton(jobGraph))\n                        .setJobGraphWriter(testingJobGraphStore)\n                        .build(rpcService);\n        dispatcher.start();\n\n        final CompletableFuture<Void> processFuture =\n                dispatcher.onRemovedJobGraph(jobGraph.getJobID());\n\n        processFuture.join();\n\n        assertThat(releaseJobGraphFuture.get(), is(jobGraph.getJobID()));\n\n        try {\n            removeJobGraphFuture.get(10L, TimeUnit.MILLISECONDS);\n            fail(\"onRemovedJobGraph should not remove the job from the JobGraphStore.\");\n        } catch (TimeoutException expected) {\n        }\n    }",
          "conflictNames": [
              "removeJobGraphFuture",
              "releaseJobGraphFuture",
              "processFuture"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java",
      "locators": [
          {
              "line": 1349,
              "column": 36
          },
          {
              "line": 1356,
              "column": 37
          },
          {
              "line": 1357,
              "column": 9
          },
          {
              "line": 1393,
              "column": 36
          },
          {
              "line": 1400,
              "column": 37
          },
          {
              "line": 1401,
              "column": 9
          }
      ],
      "old_name": "jobGraphStore",
      "new_name": "executionPlanStore",
      "ctx": {
          "symbolName": "jobGraphStore",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestingJobGraphStore",
          "scopeHint": "in testInvalidResourceRequirementsUpdate(...)",
          "filePath": "DispatcherTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testInvalidResourceRequirementsUpdate() throws Exception {\n        // the adaptive scheduler isn't strictly required, but it simplifies testing\n        configuration.set(JobManagerOptions.SCHEDULER, JobManagerOptions.SchedulerType.Adaptive);\n\n        final AtomicReference<CompletableFuture<Void>> jobGraphPersistedFutureRef =\n                new AtomicReference<>();\n        final TestingJobGraphStore jobGraphStore =\n                TestingJobGraphStore.newBuilder()\n                        .setPutJobGraphConsumer(\n                                jobGraph ->\n                                        Optional.ofNullable(jobGraphPersistedFutureRef.get())\n                                                .map(f -> f.complete(null)))\n                        .build();\n        haServices.setJobGraphStore(jobGraphStore);\n        jobGraphStore.start(null);\n\n        dispatcher =\n                createAndStartDispatcher(\n                        heartbeatServices,\n                        haServices,\n                        JobMasterServiceLeadershipRunnerFactory.INSTANCE);\n        final DispatcherGateway dispatcherGateway =\n                dispatcher.getSelfGateway(DispatcherGateway.class);\n        jobMasterLeaderElection.isLeader(UUID.randomUUID());\n\n        dispatcherGateway.submitJob(jobGraph, TIMEOUT).get();\n\n        // We can try updating the JRR once the scheduler has been started.\n        awaitStatus(dispatcherGateway, jobId, JobStatus.CREATED);\n\n        final CompletableFuture<Void> jobGraphPersistedFuture = new CompletableFuture<>();\n        jobGraphPersistedFutureRef.set(jobGraphPersistedFuture);\n        assertThatFuture(\n                        dispatcherGateway.updateJobResourceRequirements(\n                                jobId, JobResourceRequirements.empty()))\n                .eventuallyFailsWith(ExecutionException.class)\n                .withCauseInstanceOf(RestHandlerException.class);\n\n        // verify that validation error prevents the requirement from being persisted and applied\n        assertThatFuture(jobGraphPersistedFuture).willNotCompleteWithin(Duration.ofMillis(5));\n        assertThatFuture(dispatcherGateway.requestJobResourceRequirements(jobId))\n                .eventuallySucceeds()\n                .isNotEqualTo(JobResourceRequirements.empty());\n    }",
          "conflictNames": [
              "jobGraphPersistedFutureRef",
              "dispatcherGateway",
              "jobGraphPersistedFuture"
          ]
      },
      "suggestions": [
          {
              "name": "executionPlanStore",
              "confidence": 0.8
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java",
      "locators": [
          {
              "line": 383,
              "column": 23
          },
          {
              "line": 391,
              "column": 17
          }
      ],
      "old_name": "noRecoveredJobGraphHasDirtyJobResult",
      "new_name": "noRecoveredExecutionPlanHasDirtyJobResult",
      "ctx": {
          "symbolName": "noRecoveredJobGraphHasDirtyJobResult",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "boolean",
          "scopeHint": "in assertRecoveredJobsAndDirtyJobResults(...)",
          "filePath": "Dispatcher.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void assertRecoveredJobsAndDirtyJobResults(\n            Collection<JobGraph> recoveredJobs, Collection<JobResult> recoveredDirtyJobResults) {\n        final Set<JobID> jobIdsOfFinishedJobs =\n                recoveredDirtyJobResults.stream()\n                        .map(JobResult::getJobId)\n                        .collect(Collectors.toSet());\n\n        final boolean noRecoveredJobGraphHasDirtyJobResult =\n                recoveredJobs.stream()\n                        .noneMatch(\n                                recoveredJobGraph ->\n                                        jobIdsOfFinishedJobs.contains(\n                                                recoveredJobGraph.getJobID()));\n\n        Preconditions.checkArgument(\n                noRecoveredJobGraphHasDirtyJobResult,\n                \"There should be no overlap between the recovered JobGraphs and the passed dirty JobResults based on their job ID.\");\n    }",
          "conflictNames": [
              "recoveredJobs",
              "recoveredDirtyJobResults",
              "jobIdsOfFinishedJobs"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/SessionDispatcherLeaderProcess.java",
      "locators": [
          {
              "line": 146,
              "column": 36
          },
          {
              "line": 150,
              "column": 48
          },
          {
              "line": 158,
              "column": 69
          },
          {
              "line": 160,
              "column": 16
          }
      ],
      "old_name": "recoveredJobGraphs",
      "new_name": "recoveredExecutionPlans",
      "ctx": {
          "symbolName": "recoveredJobGraphs",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Collection<JobGraph>",
          "scopeHint": "in recoverJobs(...)",
          "filePath": "SessionDispatcherLeaderProcess.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private Collection<JobGraph> recoverJobs(Set<JobID> recoveredDirtyJobResults) {\n        log.info(\"Recover all persisted job graphs that are not finished, yet.\");\n        final Collection<JobID> jobIds = getJobIds();\n        final Collection<JobGraph> recoveredJobGraphs = new ArrayList<>();\n\n        for (JobID jobId : jobIds) {\n            if (!recoveredDirtyJobResults.contains(jobId)) {\n                tryRecoverJob(jobId).ifPresent(recoveredJobGraphs::add);\n            } else {\n                log.info(\n                        \"Skipping recovery of a job with job id {}, because it already reached a globally terminal state\",\n                        jobId);\n            }\n        }\n\n        log.info(\"Successfully recovered {} persisted job graphs.\", recoveredJobGraphs.size());\n\n        return recoveredJobGraphs;\n    }",
          "conflictNames": [
              "recoveredDirtyJobResults",
              "jobIds"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/SessionDispatcherLeaderProcess.java",
      "locators": [
          {
              "line": 59,
              "column": 33
          },
          {
              "line": 70,
              "column": 27
          },
          {
              "line": 77,
              "column": 14
          },
          {
              "line": 77,
              "column": 30
          },
          {
              "line": 92,
              "column": 13
          },
          {
              "line": 97,
              "column": 29
          },
          {
              "line": 103,
              "column": 34
          },
          {
              "line": 104,
              "column": 60
          },
          {
              "line": 108,
              "column": 34
          },
          {
              "line": 113,
              "column": 25
          },
          {
              "line": 115,
              "column": 25
          },
          {
              "line": 165,
              "column": 20
          },
          {
              "line": 174,
              "column": 28
          },
          {
              "line": 174,
              "column": 39
          },
          {
              "line": 175,
              "column": 17
          },
          {
              "line": 180,
              "column": 40
          },
          {
              "line": 209,
              "column": 13
          },
          {
              "line": 228,
              "column": 17
          },
          {
              "line": 242,
              "column": 80
          },
          {
              "line": 243,
              "column": 53
          },
          {
              "line": 246,
              "column": 61
          },
          {
              "line": 250,
              "column": 28
          },
          {
              "line": 289,
              "column": 17
          },
          {
              "line": 317,
              "column": 27
          },
          {
              "line": 324,
              "column": 17
          }
      ],
      "old_name": "jobGraph",
      "new_name": "executionPlan",
      "ctx": {
          "symbolName": "jobGraph",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraph",
          "scopeHint": "in tryRecoverJob(...)",
          "filePath": "SessionDispatcherLeaderProcess.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private Optional<JobGraph> tryRecoverJob(JobID jobId) {\n        log.info(\"Trying to recover job with job id {}.\", jobId);\n        try {\n            final JobGraph jobGraph = jobGraphStore.recoverJobGraph(jobId);\n            if (jobGraph == null) {\n                log.info(\n                        \"Skipping recovery of job with job id {}, because it already finished in a previous execution\",\n                        jobId);\n            }\n            return Optional.ofNullable(jobGraph);\n        } catch (Exception e) {\n            throw new FlinkRuntimeException(\n                    String.format(\"Could not recover job with job id %s.\", jobId), e);\n        }\n    }",
          "conflictNames": [
              "jobId"
          ]
      },
      "suggestions": [
          {
              "name": "executionPlan",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/TestingJobGraphStore.java",
      "locators": [
          {
              "line": 255,
              "column": 40
          },
          {
              "line": 269,
              "column": 21
          },
          {
              "line": 275,
              "column": 20
          }
      ],
      "old_name": "jobGraphStore",
      "new_name": "executionPlanStore",
      "ctx": {
          "symbolName": "jobGraphStore",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestingJobGraphStore",
          "scopeHint": "in build(...)",
          "filePath": "TestingJobGraphStore.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public TestingJobGraphStore build() {\n            final TestingJobGraphStore jobGraphStore =\n                    new TestingJobGraphStore(\n                            startConsumer,\n                            stopRunnable,\n                            jobIdsFunction,\n                            recoverJobGraphFunction,\n                            putJobGraphConsumer,\n                            putJobResourceRequirementsConsumer,\n                            globalCleanupFunction,\n                            localCleanupFunction,\n                            initialJobGraphs);\n\n            if (startJobGraphStore) {\n                try {\n                    jobGraphStore.start(null);\n                } catch (Exception e) {\n                    ExceptionUtils.rethrow(e);\n                }\n            }\n\n            return jobGraphStore;\n        }"
      },
      "suggestions": [
          {
              "name": "executionPlanStore",
              "confidence": 0.8
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/StandaloneJobGraphStoreTest.java",
      "locators": [
          {
              "line": 36,
              "column": 33
          },
          {
              "line": 40,
              "column": 25
          },
          {
              "line": 42,
              "column": 9
          },
          {
              "line": 43,
              "column": 25
          },
          {
              "line": 45,
              "column": 9
          },
          {
              "line": 46,
              "column": 25
          },
          {
              "line": 48,
              "column": 20
          }
      ],
      "old_name": "jobGraphs",
      "new_name": "executionPlans",
      "ctx": {
          "symbolName": "jobGraphs",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "StandaloneJobGraphStore",
          "scopeHint": "in testNoOps(...)",
          "filePath": "StandaloneJobGraphStoreTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Tests that all operations work and don't change the state. */\n    @Test\n    public void testNoOps() throws Exception {\n        StandaloneJobGraphStore jobGraphs = new StandaloneJobGraphStore();\n\n        JobGraph jobGraph = JobGraphTestUtils.emptyJobGraph();\n\n        assertEquals(0, jobGraphs.getJobIds().size());\n\n        jobGraphs.putJobGraph(jobGraph);\n        assertEquals(0, jobGraphs.getJobIds().size());\n\n        jobGraphs.globalCleanupAsync(jobGraph.getJobID(), Executors.directExecutor()).join();\n        assertEquals(0, jobGraphs.getJobIds().size());\n\n        assertNull(jobGraphs.recoverJobGraph(new JobID()));\n    }",
          "conflictNames": [
              "jobGraph"
          ]
      },
      "suggestions": [
          {
              "name": "executionPlans",
              "confidence": 0.8
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/StandaloneJobGraphStoreTest.java",
      "locators": [
          {
              "line": 36,
              "column": 33
          },
          {
              "line": 38,
              "column": 18
          },
          {
              "line": 40,
              "column": 25
          },
          {
              "line": 42,
              "column": 9
          },
          {
              "line": 42,
              "column": 31
          },
          {
              "line": 43,
              "column": 25
          },
          {
              "line": 45,
              "column": 9
          },
          {
              "line": 45,
              "column": 38
          },
          {
              "line": 46,
              "column": 25
          },
          {
              "line": 48,
              "column": 20
          }
      ],
      "old_name": "jobGraph",
      "new_name": "executionPlan",
      "ctx": {
          "symbolName": "jobGraph",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraph",
          "scopeHint": "in testNoOps(...)",
          "filePath": "StandaloneJobGraphStoreTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Tests that all operations work and don't change the state. */\n    @Test\n    public void testNoOps() throws Exception {\n        StandaloneJobGraphStore jobGraphs = new StandaloneJobGraphStore();\n\n        JobGraph jobGraph = JobGraphTestUtils.emptyJobGraph();\n\n        assertEquals(0, jobGraphs.getJobIds().size());\n\n        jobGraphs.putJobGraph(jobGraph);\n        assertEquals(0, jobGraphs.getJobIds().size());\n\n        jobGraphs.globalCleanupAsync(jobGraph.getJobID(), Executors.directExecutor()).join();\n        assertEquals(0, jobGraphs.getJobIds().size());\n\n        assertNull(jobGraphs.recoverJobGraph(new JobID()));\n    }",
          "conflictNames": [
              "jobGraphs"
          ]
      },
      "suggestions": [
          {
              "name": "executionPlan",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/TestingJobGraphStore.java",
      "locators": [
          {
              "line": 100,
              "column": 63
          },
          {
              "line": 101,
              "column": 30
          },
          {
              "line": 118,
              "column": 51
          },
          {
              "line": 120,
              "column": 36
          },
          {
              "line": 121,
              "column": 24
          },
          {
              "line": 121,
              "column": 45
          },
          {
              "line": 128,
              "column": 24
          },
          {
              "line": 130,
              "column": 51
          },
          {
              "line": 255,
              "column": 40
          },
          {
              "line": 269,
              "column": 21
          },
          {
              "line": 275,
              "column": 20
          }
      ],
      "old_name": "jobGraph",
      "new_name": "executionPlan",
      "ctx": {
          "symbolName": "jobGraph",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "JobGraph",
          "scopeHint": "in putJobGraph(...)",
          "filePath": "TestingJobGraphStore.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "ride\n    public synchronized JobGraph recoverJobGraph(JobID jobId) throws Exception {\n        verifyIsStarted();\n        return recoverJobGraphFunction.apply(jobId, storedJobs);\n    }\n\n    @Override\n    public synchronized void putJobGraph(JobGraph jobGraph) throws Exception {\n        verifyIsStarted();\n        putJobGraphConsumer.accept(jobGraph);\n        storedJobs.put(jobGraph.getJobID(), jobGraph);\n    }\n\n    @Override\n    public void putJobResourceRequirements(\n            JobID jobId, J"
      },
      "suggestions": [
          {
              "name": "executionPlan",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/TestingJobGraphStore.java",
      "locators": [
          {
              "line": 84,
              "column": 34
          },
          {
              "line": 94,
              "column": 23
          },
          {
              "line": 94,
              "column": 41
          },
          {
              "line": 95,
              "column": 28
          },
          {
              "line": 95,
              "column": 56
          },
          {
              "line": 188,
              "column": 38
          },
          {
              "line": 244,
              "column": 65
          },
          {
              "line": 245,
              "column": 18
          },
          {
              "line": 245,
              "column": 37
          },
          {
              "line": 265,
              "column": 29
          }
      ],
      "old_name": "initialJobGraph",
      "new_name": "initialExecutionPlan",
      "ctx": {
          "symbolName": "initialJobGraph",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "JobGraph",
          "scopeHint": "in TestingJobGraphStore(...)",
          "filePath": "TestingJobGraphStore.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": " putJobGraphConsumer;\n        this.putJobResourceRequirementsConsumer = putJobResourceRequirementsConsumer;\n        this.globalCleanupFunction = globalCleanupFunction;\n        this.localCleanupFunction = localCleanupFunction;\n\n        for (JobGraph initialJobGraph : initialJobGraphs) {\n            storedJobs.put(initialJobGraph.getJobID(), initialJobGraph);\n        }\n    }\n\n    @Override\n    public synchronized void start(@Nullable JobGraphListener jobGraphListener) throws Exception {\n        startC",
          "conflictNames": [
              "startConsumer",
              "stopRunnable",
              "jobIdsFunction",
              "recoverJobGraphFunction",
              "putJobGraphConsumer",
              "putJobResourceRequirementsConsumer",
              "globalCleanupFunction",
              "localCleanupFunction",
              "initialJobGraphs"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/DefaultJobGraphStore.java",
      "locators": [
          {
              "line": 70,
              "column": 49
          },
          {
              "line": 73,
              "column": 40
          },
          {
              "line": 75,
              "column": 37
          },
          {
              "line": 79,
              "column": 30
          },
          {
              "line": 87,
              "column": 34
          },
          {
              "line": 88,
              "column": 31
          },
          {
              "line": 89,
              "column": 14
          },
          {
              "line": 90,
              "column": 14
          },
          {
              "line": 90,
              "column": 50
          },
          {
              "line": 91,
              "column": 14
          },
          {
              "line": 91,
              "column": 47
          },
          {
              "line": 97,
              "column": 40
          },
          {
              "line": 100,
              "column": 22
          },
          {
              "line": 100,
              "column": 54
          },
          {
              "line": 101,
              "column": 17
          },
          {
              "line": 116,
              "column": 21
          },
          {
              "line": 122,
              "column": 21
          },
          {
              "line": 140,
              "column": 62
          },
          {
              "line": 142,
              "column": 29
          },
          {
              "line": 149,
              "column": 46
          },
          {
              "line": 153,
              "column": 21
          },
          {
              "line": 153,
              "column": 54
          },
          {
              "line": 166,
              "column": 26
          },
          {
              "line": 168,
              "column": 21
          },
          {
              "line": 168,
              "column": 32
          },
          {
              "line": 185,
              "column": 36
          },
          {
              "line": 187,
              "column": 43
          },
          {
              "line": 190,
              "column": 24
          },
          {
              "line": 193,
              "column": 21
          },
          {
              "line": 200,
              "column": 38
          },
          {
              "line": 201,
              "column": 22
          },
          {
              "line": 203,
              "column": 29
          },
          {
              "line": 204,
              "column": 29
          },
          {
              "line": 206,
              "column": 56
          },
          {
              "line": 214,
              "column": 42
          },
          {
              "line": 218,
              "column": 25
          },
          {
              "line": 218,
              "column": 67
          },
          {
              "line": 224,
              "column": 62
          },
          {
              "line": 224,
              "column": 72
          },
          {
              "line": 228,
              "column": 25
          },
          {
              "line": 228,
              "column": 80
          },
          {
              "line": 229,
              "column": 55
          },
          {
              "line": 233,
              "column": 63
          },
          {
              "line": 233,
              "column": 73
          },
          {
              "line": 243,
              "column": 37
          },
          {
              "line": 243,
              "column": 47
          },
          {
              "line": 250,
              "column": 38
          },
          {
              "line": 251,
              "column": 17
          },
          {
              "line": 257,
              "column": 53
          },
          {
              "line": 258,
              "column": 25
          },
          {
              "line": 268,
              "column": 72
          },
          {
              "line": 270,
              "column": 41
          },
          {
              "line": 275,
              "column": 70
          },
          {
              "line": 284,
              "column": 23
          },
          {
              "line": 294,
              "column": 44
          },
          {
              "line": 314,
              "column": 73
          },
          {
              "line": 316,
              "column": 21
          },
          {
              "line": 316,
              "column": 54
          },
          {
              "line": 319,
              "column": 71
          },
          {
              "line": 342,
              "column": 61
          },
          {
              "line": 346,
              "column": 21
          },
          {
              "line": 349,
              "column": 62
          },
          {
              "line": 356,
              "column": 28
          },
          {
              "line": 365,
              "column": 58
          },
          {
              "line": 378,
              "column": 25
          },
          {
              "line": 397,
              "column": 25
          }
      ],
      "old_name": "jobGraph",
      "new_name": "executionPlan",
      "ctx": {
          "symbolName": "jobGraph",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraph",
          "scopeHint": "in recoverJobGraph(...)",
          "filePath": "DefaultJobGraphStore.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Nullable\n    @Override\n    public JobGraph recoverJobGraph(JobID jobId) throws Exception {\n        checkNotNull(jobId, \"Job ID\");\n\n        LOG.debug(\"Recovering job graph {} from {}.\", jobId, jobGraphStateHandleStore);\n\n        final String name = jobGraphStoreUtil.jobIDToName(jobId);\n\n        synchronized (lock) {\n            verifyIsRunning();\n\n            boolean success = false;\n\n            RetrievableStateHandle<JobGraph> jobGraphRetrievableStateHandle;\n\n            try {\n                try {\n                    jobGraphRetrievableStateHandle = jobGraphStateHandleStore.getAndLock(name);\n                } catch (StateHandleStore.NotExistException ignored) {\n                    success = true;\n                    return null;\n                } catch (Exception e) {\n                    throw new FlinkException(\n                            \"Could not retrieve the submitted job graph state handle \"\n                                    + \"for \"\n                                    + name\n                                    + \" from the submitted job graph store.\",\n                            e);\n                }\n\n                JobGraph jobGraph;\n                try {\n                    jobGraph = jobGraphRetrievableStateHandle.retrieveState();\n                } catch (ClassNotFoundException cnfe) {\n                    throw new FlinkException(\n                            \"Could not retrieve submitted JobGraph from state handle under \"\n                                    + name\n                                    + \". This indicates that you are trying to recover from state written by an \"\n                                    + \"older Flink version which is not compatible. Try cleaning the state handle store.\",\n                            cnfe);\n                } catch (IOException ioe) {\n                    throw new FlinkException(\n                            \"Could not retrieve submitted JobGraph from state handle under \"\n                                    + name\n                                    + \". This indicates that the retrieved state handle is broken. Try cleaning the state handle \"\n                                    + \"store.\",\n                            ioe);\n                }\n\n                addedJobGraphs.add(jobGraph.getJobID());\n\n                LOG.info(\"Recovered {}.\", jobGraph);\n\n                success = true;\n                return jobGraph;\n            } finally {\n                if (!success) {\n                    jobGraphStateHandleStore.release(name);\n                }\n            }\n        }\n    }",
          "conflictNames": [
              "jobId",
              "name",
              "success",
              "jobGraphRetrievableStateHandle"
          ]
      },
      "suggestions": [
          {
              "name": "executionPlan",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/DefaultJobGraphStore.java",
      "locators": [
          {
              "line": 149,
              "column": 46
          },
          {
              "line": 153,
              "column": 21
          },
          {
              "line": 168,
              "column": 32
          }
      ],
      "old_name": "jobGraphRetrievableStateHandle",
      "new_name": "executionPlanRetrievableStateHandle",
      "ctx": {
          "symbolName": "jobGraphRetrievableStateHandle",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RetrievableStateHandle<JobGraph>",
          "scopeHint": "in recoverJobGraph(...)",
          "filePath": "DefaultJobGraphStore.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Nullable\n    @Override\n    public JobGraph recoverJobGraph(JobID jobId) throws Exception {\n        checkNotNull(jobId, \"Job ID\");\n\n        LOG.debug(\"Recovering job graph {} from {}.\", jobId, jobGraphStateHandleStore);\n\n        final String name = jobGraphStoreUtil.jobIDToName(jobId);\n\n        synchronized (lock) {\n            verifyIsRunning();\n\n            boolean success = false;\n\n            RetrievableStateHandle<JobGraph> jobGraphRetrievableStateHandle;\n\n            try {\n                try {\n                    jobGraphRetrievableStateHandle = jobGraphStateHandleStore.getAndLock(name);\n                } catch (StateHandleStore.NotExistException ignored) {\n                    success = true;\n                    return null;\n                } catch (Exception e) {\n                    throw new FlinkException(\n                            \"Could not retrieve the submitted job graph state handle \"\n                                    + \"for \"\n                                    + name\n                                    + \" from the submitted job graph store.\",\n                            e);\n                }\n\n                JobGraph jobGraph;\n                try {\n                    jobGraph = jobGraphRetrievableStateHandle.retrieveState();\n                } catch (ClassNotFoundException cnfe) {\n                    throw new FlinkException(\n                            \"Could not retrieve submitted JobGraph from state handle under \"\n                                    + name\n                                    + \". This indicates that you are trying to recover from state written by an \"\n                                    + \"older Flink version which is not compatible. Try cleaning the state handle store.\",\n                            cnfe);\n                } catch (IOException ioe) {\n                    throw new FlinkException(\n                            \"Could not retrieve submitted JobGraph from state handle under \"\n                                    + name\n                                    + \". This indicates that the retrieved state handle is broken. Try cleaning the state handle \"\n                                    + \"store.\",\n                            ioe);\n                }\n\n                addedJobGraphs.add(jobGraph.getJobID());\n\n                LOG.info(\"Recovered {}.\", jobGraph);\n\n                success = true;\n                return jobGraph;\n            } finally {\n                if (!success) {\n                    jobGraphStateHandleStore.release(name);\n                }\n            }\n        }\n    }",
          "conflictNames": [
              "jobId",
              "name",
              "success",
              "jobGraph"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/DefaultJobGraphStoreTest.java",
      "locators": [
          {
              "line": 101,
              "column": 29
          },
          {
              "line": 104,
              "column": 17
          },
          {
              "line": 119,
              "column": 29
          },
          {
              "line": 122,
              "column": 17
          },
          {
              "line": 138,
              "column": 29
          },
          {
              "line": 141,
              "column": 13
          },
          {
              "line": 163,
              "column": 29
          },
          {
              "line": 164,
              "column": 9
          },
          {
              "line": 190,
              "column": 29
          },
          {
              "line": 191,
              "column": 9
          },
          {
              "line": 193,
              "column": 9
          },
          {
              "line": 210,
              "column": 29
          },
          {
              "line": 212,
              "column": 9
          },
          {
              "line": 213,
              "column": 9
          },
          {
              "line": 227,
              "column": 29
          },
          {
              "line": 228,
              "column": 9
          },
          {
              "line": 240,
              "column": 29
          },
          {
              "line": 244,
              "column": 25
          },
          {
              "line": 261,
              "column": 29
          },
          {
              "line": 262,
              "column": 42
          },
          {
              "line": 271,
              "column": 29
          },
          {
              "line": 272,
              "column": 9
          },
          {
              "line": 286,
              "column": 29
          },
          {
              "line": 287,
              "column": 9
          },
          {
              "line": 303,
              "column": 29
          },
          {
              "line": 304,
              "column": 9
          },
          {
              "line": 332,
              "column": 29
          },
          {
              "line": 333,
              "column": 9
          },
          {
              "line": 344,
              "column": 29
          },
          {
              "line": 345,
              "column": 9
          },
          {
              "line": 346,
              "column": 9
          },
          {
              "line": 358,
              "column": 29
          },
          {
              "line": 359,
              "column": 9
          },
          {
              "line": 369,
              "column": 29
          },
          {
              "line": 370,
              "column": 9
          },
          {
              "line": 371,
              "column": 9
          },
          {
              "line": 406,
              "column": 29
          },
          {
              "line": 407,
              "column": 9
          },
          {
              "line": 408,
              "column": 9
          },
          {
              "line": 412,
              "column": 17
          },
          {
              "line": 419,
              "column": 9
          },
          {
              "line": 423,
              "column": 17
          },
          {
              "line": 427,
              "column": 27
          },
          {
              "line": 431,
              "column": 48
          },
          {
              "line": 443,
              "column": 29
          },
          {
              "line": 447,
              "column": 25
          },
          {
              "line": 453,
              "column": 29
          },
          {
              "line": 468,
              "column": 9
          },
          {
              "line": 469,
              "column": 16
          }
      ],
      "old_name": "jobGraphStore",
      "new_name": "executionPlanStore",
      "ctx": {
          "symbolName": "jobGraphStore",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraphStore",
          "scopeHint": "in testRecoverJobGraph(...)",
          "filePath": "DefaultJobGraphStoreTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testRecoverJobGraph() throws Exception {\n        final RetrievableStateHandle<JobGraph> stateHandle =\n                jobGraphStorageHelper.store(testingJobGraph);\n        final TestingStateHandleStore<JobGraph> stateHandleStore =\n                builder.setGetFunction(ignore -> stateHandle).build();\n\n        final JobGraphStore jobGraphStore = createAndStartJobGraphStore(stateHandleStore);\n\n        final JobGraph recoveredJobGraph =\n                jobGraphStore.recoverJobGraph(testingJobGraph.getJobID());\n        assertThat(recoveredJobGraph, is(notNullValue()));\n        assertThat(recoveredJobGraph.getJobID(), is(testingJobGraph.getJobID()));\n    }",
          "conflictNames": [
              "stateHandle",
              "stateHandleStore",
              "recoveredJobGraph"
          ]
      },
      "suggestions": [
          {
              "name": "executionPlanStore",
              "confidence": 0.8
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/DefaultJobGraphStoreTest.java",
      "locators": [
          {
              "line": 103,
              "column": 24
          },
          {
              "line": 105,
              "column": 20
          },
          {
              "line": 106,
              "column": 20
          },
          {
              "line": 121,
              "column": 24
          },
          {
              "line": 123,
              "column": 20
          }
      ],
      "old_name": "recoveredJobGraph",
      "new_name": "recoveredExecutionPlan",
      "ctx": {
          "symbolName": "recoveredJobGraph",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraph",
          "scopeHint": "in testRecoverJobGraph(...)",
          "filePath": "DefaultJobGraphStoreTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testRecoverJobGraph() throws Exception {\n        final RetrievableStateHandle<JobGraph> stateHandle =\n                jobGraphStorageHelper.store(testingJobGraph);\n        final TestingStateHandleStore<JobGraph> stateHandleStore =\n                builder.setGetFunction(ignore -> stateHandle).build();\n\n        final JobGraphStore jobGraphStore = createAndStartJobGraphStore(stateHandleStore);\n\n        final JobGraph recoveredJobGraph =\n                jobGraphStore.recoverJobGraph(testingJobGraph.getJobID());\n        assertThat(recoveredJobGraph, is(notNullValue()));\n        assertThat(recoveredJobGraph.getJobID(), is(testingJobGraph.getJobID()));\n    }",
          "conflictNames": [
              "stateHandle",
              "stateHandleStore",
              "jobGraphStore"
          ]
      },
      "suggestions": [
          {
              "name": "recoveredExecutionPlan",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperJobGraphStoreWatcherTest.java",
      "locators": [
          {
              "line": 79,
              "column": 40
          },
          {
              "line": 100,
              "column": 13
          },
          {
              "line": 106,
              "column": 45
          },
          {
              "line": 108,
              "column": 9
          },
          {
              "line": 109,
              "column": 16
          }
      ],
      "old_name": "jobGraphStoreWatcher",
      "new_name": "executionPlanStoreWatcher",
      "ctx": {
          "symbolName": "jobGraphStoreWatcher",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraphStoreWatcher",
          "scopeHint": "in testJobGraphAddedAndRemovedShouldNotifyGraphStoreListener(...)",
          "filePath": "ZooKeeperJobGraphStoreWatcherTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testJobGraphAddedAndRemovedShouldNotifyGraphStoreListener() throws Exception {\n        try (final CuratorFrameworkWithUnhandledErrorListener curatorFrameworkWrapper =\n                ZooKeeperUtils.startCuratorFramework(\n                        configuration, NoOpFatalErrorHandler.INSTANCE)) {\n            final CuratorFramework client = curatorFrameworkWrapper.asCuratorFramework();\n            final JobGraphStoreWatcher jobGraphStoreWatcher =\n                    createAndStartJobGraphStoreWatcher(client);\n\n            final ZooKeeperStateHandleStore<JobGraph> stateHandleStore =\n                    createStateHandleStore(client);\n\n            final JobGraph jobGraph = JobGraphTestUtils.emptyJobGraph();\n            final JobID jobID = jobGraph.getJobID();\n            stateHandleStore.addAndLock(\"/\" + jobID, jobGraph);\n\n            CommonTestUtils.waitUntilCondition(\n                    () -> testingJobGraphListener.getAddedJobGraphs().size() > 0);\n\n            assertThat(testingJobGraphListener.getAddedJobGraphs()).containsExactly(jobID);\n\n            stateHandleStore.releaseAndTryRemove(\"/\" + jobID);\n\n            CommonTestUtils.waitUntilCondition(\n                    () -> testingJobGraphListener.getRemovedJobGraphs().size() > 0);\n            assertThat(testingJobGraphListener.getRemovedJobGraphs()).containsExactly(jobID);\n\n            jobGraphStoreWatcher.stop();\n        }\n    }",
          "conflictNames": [
              "curatorFrameworkWrapper",
              "client",
              "stateHandleStore",
              "jobGraph",
              "jobID"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperJobGraphsStoreITCase.java",
      "locators": [
          {
              "line": 92,
              "column": 23
          },
          {
              "line": 97,
              "column": 13
          },
          {
              "line": 102,
              "column": 24
          },
          {
              "line": 105,
              "column": 13
          },
          {
              "line": 108,
              "column": 40
          },
          {
              "line": 113,
              "column": 39
          },
          {
              "line": 117,
              "column": 13
          },
          {
              "line": 120,
              "column": 22
          },
          {
              "line": 125,
              "column": 39
          },
          {
              "line": 128,
              "column": 13
          },
          {
              "line": 131,
              "column": 24
          },
          {
              "line": 138,
              "column": 13
          },
          {
              "line": 140,
              "column": 13
          },
          {
              "line": 164,
              "column": 23
          },
          {
              "line": 169,
              "column": 13
          },
          {
              "line": 180,
              "column": 17
          },
          {
              "line": 183,
              "column": 40
          },
          {
              "line": 188,
              "column": 37
          },
          {
              "line": 193,
              "column": 17
          },
          {
              "line": 199,
              "column": 24
          },
          {
              "line": 205,
              "column": 13
          },
          {
              "line": 211,
              "column": 23
          },
          {
              "line": 215,
              "column": 13
          },
          {
              "line": 241,
              "column": 13
          },
          {
              "line": 244,
              "column": 13
          },
          {
              "line": 261,
              "column": 17
          },
          {
              "line": 262,
              "column": 17
          },
          {
              "line": 273,
              "column": 23
          },
          {
              "line": 279,
              "column": 9
          },
          {
              "line": 284,
              "column": 9
          }
      ],
      "old_name": "jobGraphs",
      "new_name": "executionPlans",
      "ctx": {
          "symbolName": "jobGraphs",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraphStore",
          "scopeHint": "in testPutAndRemoveJobGraph(...)",
          "filePath": "ZooKeeperJobGraphsStoreITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testPutAndRemoveJobGraph() throws Exception {\n        JobGraphStore jobGraphs = createZooKeeperJobGraphStore(\"/testPutAndRemoveJobGraph\");\n\n        try {\n            JobGraphStore.JobGraphListener listener = mock(JobGraphStore.JobGraphListener.class);\n\n            jobGraphs.start(listener);\n\n            JobGraph jobGraph = createJobGraph(new JobID(), \"JobName\");\n\n            // Empty state\n            assertThat(jobGraphs.getJobIds()).isEmpty();\n\n            // Add initial\n            jobGraphs.putJobGraph(jobGraph);\n\n            // Verify initial job graph\n            Collection<JobID> jobIds = jobGraphs.getJobIds();\n            assertThat(jobIds).hasSize(1);\n\n            JobID jobId = jobIds.iterator().next();\n\n            verifyJobGraphs(jobGraph, jobGraphs.recoverJobGraph(jobId));\n\n            // Update (same ID)\n            jobGraph = createJobGraph(jobGraph.getJobID(), \"Updated JobName\");\n            jobGraphs.putJobGraph(jobGraph);\n\n            // Verify updated\n            jobIds = jobGraphs.getJobIds();\n            assertThat(jobIds).hasSize(1);\n\n            jobId = jobIds.iterator().next();\n\n            verifyJobGraphs(jobGraph, jobGraphs.recoverJobGraph(jobId));\n\n            // Remove\n            jobGraphs.globalCleanupAsync(jobGraph.getJobID(), Executors.directExecutor()).join();\n\n            // Empty state\n            assertThat(jobGraphs.getJobIds()).isEmpty();\n\n            // Nothing should have been notified\n            verify(listener, atMost(1)).onAddedJobGraph(any(JobID.class));\n            verify(listener, never()).onRemovedJobGraph(any(JobID.class));\n\n            // Don't fail if called again\n            jobGraphs.globalCleanupAsync(jobGraph.getJobID(), Executors.directExecutor()).join();\n        } finally {\n            jobGraphs.stop();\n        }\n    }",
          "conflictNames": [
              "listener",
              "jobGraph",
              "jobIds",
              "jobId"
          ]
      },
      "suggestions": [
          {
              "name": "executionPlans",
              "confidence": 0.8
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperJobGraphsStoreITCase.java",
      "locators": [
          {
              "line": 212,
              "column": 23
          },
          {
              "line": 217,
              "column": 13
          },
          {
              "line": 242,
              "column": 13
          },
          {
              "line": 251,
              "column": 13
          },
          {
              "line": 265,
              "column": 17
          },
          {
              "line": 266,
              "column": 17
          },
          {
              "line": 276,
              "column": 23
          },
          {
              "line": 280,
              "column": 9
          },
          {
              "line": 287,
              "column": 35
          }
      ],
      "old_name": "otherJobGraphs",
      "new_name": "otherExecutionPlans",
      "ctx": {
          "symbolName": "otherJobGraphs",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraphStore",
          "scopeHint": "in testConcurrentAddJobGraph(...)",
          "filePath": "ZooKeeperJobGraphsStoreITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testConcurrentAddJobGraph() throws Exception {\n        JobGraphStore jobGraphs = null;\n        JobGraphStore otherJobGraphs = null;\n\n        try {\n            jobGraphs = createZooKeeperJobGraphStore(\"/testConcurrentAddJobGraph\");\n\n            otherJobGraphs = createZooKeeperJobGraphStore(\"/testConcurrentAddJobGraph\");\n\n            JobGraph jobGraph = createJobGraph(new JobID());\n            JobGraph otherJobGraph = createJobGraph(new JobID());\n\n            JobGraphListener listener = mock(JobGraphStore.JobGraphListener.class);\n\n            final JobID[] actualOtherJobId = new JobID[1];\n            final CountDownLatch sync = new CountDownLatch(1);\n\n            doAnswer(\n                            new Answer<Void>() {\n                                @Override\n                                public Void answer(InvocationOnMock invocation) throws Throwable {\n                                    actualOtherJobId[0] = (JobID) invocation.getArguments()[0];\n                                    sync.countDown();\n\n                                    return null;\n                                }\n                            })\n                    .when(listener)\n                    .onAddedJobGraph(any(JobID.class));\n\n            // Test\n            jobGraphs.start(listener);\n            otherJobGraphs.start(NoOpJobGraphListener.INSTANCE);\n\n            jobGraphs.putJobGraph(jobGraph);\n\n            // Everything is cool... not much happening ;)\n            verify(listener, never()).onAddedJobGraph(any(JobID.class));\n            verify(listener, never()).onRemovedJobGraph(any(JobID.class));\n\n            // This bad boy adds the other job graph\n            otherJobGraphs.putJobGraph(otherJobGraph);\n\n            // Wait for the cache to call back\n            sync.await();\n\n            verify(listener, times(1)).onAddedJobGraph(any(JobID.class));\n            verify(listener, never()).onRemovedJobGraph(any(JobID.class));\n\n            assertThat(actualOtherJobId[0]).isEqualTo(otherJobGraph.getJobID());\n        } finally {\n            if (jobGraphs != null) {\n                jobGraphs.stop();\n            }\n\n            if (otherJobGraphs != null) {\n                otherJobGraphs.stop();\n            }\n        }\n    }",
          "conflictNames": [
              "jobGraphs",
              "jobGraph",
              "otherJobGraph",
              "listener",
              "actualOtherJobId",
              "sync"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperJobGraphsStoreITCase.java",
      "locators": [
          {
              "line": 212,
              "column": 23
          },
          {
              "line": 217,
              "column": 13
          },
          {
              "line": 220,
              "column": 22
          },
          {
              "line": 242,
              "column": 13
          },
          {
              "line": 251,
              "column": 13
          },
          {
              "line": 251,
              "column": 40
          },
          {
              "line": 259,
              "column": 55
          },
          {
              "line": 265,
              "column": 17
          },
          {
              "line": 266,
              "column": 17
          },
          {
              "line": 276,
              "column": 23
          },
          {
              "line": 280,
              "column": 9
          },
          {
              "line": 287,
              "column": 35
          }
      ],
      "old_name": "otherJobGraph",
      "new_name": "otherExecutionPlan",
      "ctx": {
          "symbolName": "otherJobGraph",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraph",
          "scopeHint": "in testConcurrentAddJobGraph(...)",
          "filePath": "ZooKeeperJobGraphsStoreITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testConcurrentAddJobGraph() throws Exception {\n        JobGraphStore jobGraphs = null;\n        JobGraphStore otherJobGraphs = null;\n\n        try {\n            jobGraphs = createZooKeeperJobGraphStore(\"/testConcurrentAddJobGraph\");\n\n            otherJobGraphs = createZooKeeperJobGraphStore(\"/testConcurrentAddJobGraph\");\n\n            JobGraph jobGraph = createJobGraph(new JobID());\n            JobGraph otherJobGraph = createJobGraph(new JobID());\n\n            JobGraphListener listener = mock(JobGraphStore.JobGraphListener.class);\n\n            final JobID[] actualOtherJobId = new JobID[1];\n            final CountDownLatch sync = new CountDownLatch(1);\n\n            doAnswer(\n                            new Answer<Void>() {\n                                @Override\n                                public Void answer(InvocationOnMock invocation) throws Throwable {\n                                    actualOtherJobId[0] = (JobID) invocation.getArguments()[0];\n                                    sync.countDown();\n\n                                    return null;\n                                }\n                            })\n                    .when(listener)\n                    .onAddedJobGraph(any(JobID.class));\n\n            // Test\n            jobGraphs.start(listener);\n            otherJobGraphs.start(NoOpJobGraphListener.INSTANCE);\n\n            jobGraphs.putJobGraph(jobGraph);\n\n            // Everything is cool... not much happening ;)\n            verify(listener, never()).onAddedJobGraph(any(JobID.class));\n            verify(listener, never()).onRemovedJobGraph(any(JobID.class));\n\n            // This bad boy adds the other job graph\n            otherJobGraphs.putJobGraph(otherJobGraph);\n\n            // Wait for the cache to call back\n            sync.await();\n\n            verify(listener, times(1)).onAddedJobGraph(any(JobID.class));\n            verify(listener, never()).onRemovedJobGraph(any(JobID.class));\n\n            assertThat(actualOtherJobId[0]).isEqualTo(otherJobGraph.getJobID());\n        } finally {\n            if (jobGraphs != null) {\n                jobGraphs.stop();\n            }\n\n            if (otherJobGraphs != null) {\n                otherJobGraphs.stop();\n            }\n        }\n    }",
          "conflictNames": [
              "jobGraphs",
              "otherJobGraphs",
              "jobGraph",
              "listener",
              "actualOtherJobId",
              "sync"
          ]
      },
      "suggestions": [
          {
              "name": "otherExecutionPlan",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperJobGraphsStoreITCase.java",
      "locators": [
          {
              "line": 300,
              "column": 29
          },
          {
              "line": 305,
              "column": 9
          },
          {
              "line": 311,
              "column": 17
          },
          {
              "line": 320,
              "column": 33
          },
          {
              "line": 329,
              "column": 9
          },
          {
              "line": 333,
              "column": 20
          },
          {
              "line": 336,
              "column": 9
          }
      ],
      "old_name": "otherSubmittedJobGraphStore",
      "new_name": "otherSubmittedExecutionPlanStore",
      "ctx": {
          "symbolName": "otherSubmittedJobGraphStore",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraphStore",
          "scopeHint": "in testJobGraphRemovalFailureAndLockRelease(...)",
          "filePath": "ZooKeeperJobGraphsStoreITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Tests that we fail with an exception if the job cannot be removed from the\n     * ZooKeeperJobGraphStore.\n     *\n     * <p>Tests that a close ZooKeeperJobGraphStore no longer holds any locks.\n     */\n    @Test\n    public void testJobGraphRemovalFailureAndLockRelease() throws Exception {\n        final JobGraphStore submittedJobGraphStore =\n                createZooKeeperJobGraphStore(\"/testConcurrentAddJobGraph\");\n        final JobGraphStore otherSubmittedJobGraphStore =\n                createZooKeeperJobGraphStore(\"/testConcurrentAddJobGraph\");\n\n        final TestingJobGraphListener listener = new TestingJobGraphListener();\n        submittedJobGraphStore.start(listener);\n        otherSubmittedJobGraphStore.start(listener);\n\n        final JobGraph jobGraph = JobGraphTestUtils.emptyJobGraph();\n        submittedJobGraphStore.putJobGraph(jobGraph);\n\n        final JobGraph recoveredJobGraph =\n                otherSubmittedJobGraphStore.recoverJobGraph(jobGraph.getJobID());\n\n        assertThat(recoveredJobGraph).isNotNull();\n\n        assertThatExceptionOfType(Exception.class)\n                .as(\n                        \"It should not be possible to remove the JobGraph since the first store still has a lock on it.\")\n                .isThrownBy(\n                        () ->\n                                otherSubmittedJobGraphStore\n                                        .globalCleanupAsync(\n                                                recoveredJobGraph.getJobID(),\n                                                Executors.directExecutor())\n                                        .join());\n\n        submittedJobGraphStore.stop();\n\n        // now we should be able to delete the job graph\n        otherSubmittedJobGraphStore\n                .globalCleanupAsync(recoveredJobGraph.getJobID(), Executors.directExecutor())\n                .join();\n\n        assertThat(otherSubmittedJobGraphStore.recoverJobGraph(recoveredJobGraph.getJobID()))\n                .isNull();\n\n        otherSubmittedJobGraphStore.stop();\n    }",
          "conflictNames": [
              "submittedJobGraphStore",
              "listener",
              "jobGraph",
              "recoveredJobGraph"
          ]
      },
      "suggestions": [
          {
              "name": "otherSubmittedExecutionPlanStore",
              "confidence": 0.77
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperJobGraphsStoreITCase.java",
      "locators": [
          {
              "line": 298,
              "column": 29
          },
          {
              "line": 304,
              "column": 9
          },
          {
              "line": 308,
              "column": 9
          },
          {
              "line": 326,
              "column": 9
          }
      ],
      "old_name": "submittedJobGraphStore",
      "new_name": "submittedExecutionPlanStore",
      "ctx": {
          "symbolName": "submittedJobGraphStore",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraphStore",
          "scopeHint": "in testJobGraphRemovalFailureAndLockRelease(...)",
          "filePath": "ZooKeeperJobGraphsStoreITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Tests that we fail with an exception if the job cannot be removed from the\n     * ZooKeeperJobGraphStore.\n     *\n     * <p>Tests that a close ZooKeeperJobGraphStore no longer holds any locks.\n     */\n    @Test\n    public void testJobGraphRemovalFailureAndLockRelease() throws Exception {\n        final JobGraphStore submittedJobGraphStore =\n                createZooKeeperJobGraphStore(\"/testConcurrentAddJobGraph\");\n        final JobGraphStore otherSubmittedJobGraphStore =\n                createZooKeeperJobGraphStore(\"/testConcurrentAddJobGraph\");\n\n        final TestingJobGraphListener listener = new TestingJobGraphListener();\n        submittedJobGraphStore.start(listener);\n        otherSubmittedJobGraphStore.start(listener);\n\n        final JobGraph jobGraph = JobGraphTestUtils.emptyJobGraph();\n        submittedJobGraphStore.putJobGraph(jobGraph);\n\n        final JobGraph recoveredJobGraph =\n                otherSubmittedJobGraphStore.recoverJobGraph(jobGraph.getJobID());\n\n        assertThat(recoveredJobGraph).isNotNull();\n\n        assertThatExceptionOfType(Exception.class)\n                .as(\n                        \"It should not be possible to remove the JobGraph since the first store still has a lock on it.\")\n                .isThrownBy(\n                        () ->\n                                otherSubmittedJobGraphStore\n                                        .globalCleanupAsync(\n                                                recoveredJobGraph.getJobID(),\n                                                Executors.directExecutor())\n                                        .join());\n\n        submittedJobGraphStore.stop();\n\n        // now we should be able to delete the job graph\n        otherSubmittedJobGraphStore\n                .globalCleanupAsync(recoveredJobGraph.getJobID(), Executors.directExecutor())\n                .join();\n\n        assertThat(otherSubmittedJobGraphStore.recoverJobGraph(recoveredJobGraph.getJobID()))\n                .isNull();\n\n        otherSubmittedJobGraphStore.stop();\n    }",
          "conflictNames": [
              "otherSubmittedJobGraphStore",
              "listener",
              "jobGraph",
              "recoveredJobGraph"
          ]
      },
      "suggestions": [
          {
              "name": "submittedExecutionPlanStore",
              "confidence": 0.77
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/292d7f449db89c662c60b265ed99e33416dba614^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperJobGraphsStoreITCase.java",
      "locators": [
          {
              "line": 310,
              "column": 24
          },
          {
              "line": 313,
              "column": 20
          },
          {
              "line": 322,
              "column": 49
          },
          {
              "line": 330,
              "column": 37
          },
          {
              "line": 333,
              "column": 64
          }
      ],
      "old_name": "recoveredJobGraph",
      "new_name": "recoveredExecutionPlan",
      "ctx": {
          "symbolName": "recoveredJobGraph",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraph",
          "scopeHint": "in testJobGraphRemovalFailureAndLockRelease(...)",
          "filePath": "ZooKeeperJobGraphsStoreITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Tests that we fail with an exception if the job cannot be removed from the\n     * ZooKeeperJobGraphStore.\n     *\n     * <p>Tests that a close ZooKeeperJobGraphStore no longer holds any locks.\n     */\n    @Test\n    public void testJobGraphRemovalFailureAndLockRelease() throws Exception {\n        final JobGraphStore submittedJobGraphStore =\n                createZooKeeperJobGraphStore(\"/testConcurrentAddJobGraph\");\n        final JobGraphStore otherSubmittedJobGraphStore =\n                createZooKeeperJobGraphStore(\"/testConcurrentAddJobGraph\");\n\n        final TestingJobGraphListener listener = new TestingJobGraphListener();\n        submittedJobGraphStore.start(listener);\n        otherSubmittedJobGraphStore.start(listener);\n\n        final JobGraph jobGraph = JobGraphTestUtils.emptyJobGraph();\n        submittedJobGraphStore.putJobGraph(jobGraph);\n\n        final JobGraph recoveredJobGraph =\n                otherSubmittedJobGraphStore.recoverJobGraph(jobGraph.getJobID());\n\n        assertThat(recoveredJobGraph).isNotNull();\n\n        assertThatExceptionOfType(Exception.class)\n                .as(\n                        \"It should not be possible to remove the JobGraph since the first store still has a lock on it.\")\n                .isThrownBy(\n                        () ->\n                                otherSubmittedJobGraphStore\n                                        .globalCleanupAsync(\n                                                recoveredJobGraph.getJobID(),\n                                                Executors.directExecutor())\n                                        .join());\n\n        submittedJobGraphStore.stop();\n\n        // now we should be able to delete the job graph\n        otherSubmittedJobGraphStore\n                .globalCleanupAsync(recoveredJobGraph.getJobID(), Executors.directExecutor())\n                .join();\n\n        assertThat(otherSubmittedJobGraphStore.recoverJobGraph(recoveredJobGraph.getJobID()))\n                .isNull();\n\n        otherSubmittedJobGraphStore.stop();\n    }",
          "conflictNames": [
              "submittedJobGraphStore",
              "otherSubmittedJobGraphStore",
              "listener",
              "jobGraph"
          ]
      },
      "suggestions": [
          {
              "name": "recoveredExecutionPlan",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/294084872604d599c1e2c52302ce0f08bb0e6492^1/flink-runtime/src/test/java/org/apache/flink/runtime/taskprocessing/AsyncExecutionControllerTest.java",
      "locators": [
          {
              "line": 49,
              "column": 29
          },
          {
              "line": 50,
              "column": 61
          },
          {
              "line": 146,
              "column": 37
          },
          {
              "line": 155,
              "column": 37
          },
          {
              "line": 159,
              "column": 18
          },
          {
              "line": 159,
              "column": 36
          },
          {
              "line": 170,
              "column": 32
          },
          {
              "line": 193,
              "column": 37
          },
          {
              "line": 199,
              "column": 81
          },
          {
              "line": 201,
              "column": 18
          },
          {
              "line": 201,
              "column": 36
          },
          {
              "line": 210,
              "column": 29
          },
          {
              "line": 221,
              "column": 29
          },
          {
              "line": 233,
              "column": 29
          },
          {
              "line": 258,
              "column": 41
          },
          {
              "line": 261,
              "column": 29
          },
          {
              "line": 266,
              "column": 41
          },
          {
              "line": 269,
              "column": 21
          }
      ],
      "old_name": "underlyingState",
      "new_name": "state",
      "ctx": {
          "symbolName": "underlyingState",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestUnderlyingState",
          "scopeHint": "in testStateOrder(...)",
          "filePath": "AsyncExecutionControllerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "// todo(20240330): this test is not completed, cause the order preservation is not implemented\n    // yet, just for illustrating the interaction between AEC and Async state API.\n    @Test\n    void testStateOrder() {\n        AsyncExecutionController aec =\n                new AsyncExecutionController<>(\n                        new SyncMailboxExecutor(), new TestStateExecutor(), 3);\n        TestUnderlyingState underlyingState = new TestUnderlyingState();\n        TestValueState valueState = new TestValueState(aec, underlyingState);\n        AtomicInteger output = new AtomicInteger();\n        Consumer<Void> userCode =\n                empty ->\n                        valueState\n                                .asyncValue()\n                                .thenAccept(\n                                        val -> {\n                                            if (val == null) {\n                                                valueState\n                                                        .asyncUpdate(1)\n                                                        .thenAccept(o -> output.set(1));\n                                            } else {\n                                                valueState\n                                                        .asyncUpdate(val + 1)\n                                                        .thenAccept(o -> output.set(val + 1));\n                                            }\n                                        });\n\n        // ============================ element1 ============================\n        String record1 = \"key1-r1\";\n        String key1 = \"key1\";\n        // Simulate the wrapping in {@link RecordProcessorUtils#getRecordProcessor()}, wrapping the\n        // record and key with RecordContext.\n        RecordContext<String, String> recordContext1 = new RecordContext<>(record1, key1);\n        valueState.setCurrentRecordCtx(recordContext1);\n        // execute user code\n        userCode.accept(null);\n        recordContext1.release();\n        assertThat(output.get()).isEqualTo(1);\n\n        // ============================ element2 ============================\n        String record2 = \"key1-r2\";\n        String key2 = \"key1\";\n        RecordContext<String, String> recordContext2 = new RecordContext<>(record2, key2);\n        valueState.setCurrentRecordCtx(recordContext2);\n        // execute user code\n        userCode.accept(null);\n        recordContext2.release();\n        assertThat(output.get()).isEqualTo(2);\n\n        // ============================ element3 ============================\n        String record3 = \"key3-r3\";\n        String key3 = \"key3\";\n        RecordContext<String, String> recordContext3 = new RecordContext<>(record3, key3);\n        valueState.setCurrentRecordCtx(recordContext3);\n        // execute user code\n        userCode.accept(null);\n        recordContext3.release();\n        assertThat(output.get()).isEqualTo(1);\n    }",
          "conflictNames": [
              "aec",
              "valueState",
              "output",
              "userCode",
              "record1",
              "key1",
              "recordContext1",
              "record2",
              "key2",
              "recordContext2",
              "record3",
              "key3",
              "recordContext3"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/294084872604d599c1e2c52302ce0f08bb0e6492^1/flink-runtime/src/test/java/org/apache/flink/runtime/taskprocessing/AsyncExecutionControllerTest.java",
      "locators": [
          {
              "line": 156,
              "column": 38
          },
          {
              "line": 160,
              "column": 37
          },
          {
              "line": 207,
              "column": 34
          },
          {
              "line": 210,
              "column": 46
          },
          {
              "line": 218,
              "column": 34
          },
          {
              "line": 221,
              "column": 46
          },
          {
              "line": 229,
              "column": 34
          },
          {
              "line": 233,
              "column": 46
          },
          {
              "line": 268,
              "column": 42
          },
          {
              "line": 270,
              "column": 29
          },
          {
              "line": 270,
              "column": 65
          }
      ],
      "old_name": "parameter",
      "new_name": "state",
      "ctx": {
          "symbolName": "parameter",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "TestRequestParameter",
          "scopeHint": "in TestProcessingRequest(...)",
          "filePath": "AsyncExecutionControllerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "RequestParameter requestParameter;\n\n        private RequestType requestType;\n\n        private InternalStateFuture<OUT> stateFuture;\n\n        public TestProcessingRequest(\n                TestUnderlyingState underlyingState,\n                TestRequestParameter parameter,\n                RequestType requestType,\n                InternalStateFuture<OUT> stateFuture) {\n            this.underlyingState = underlyingState;\n            this.requestParameter = parameter;\n            this.requestType = requestType",
          "conflictNames": [
              "underlyingState",
              "requestType",
              "stateFuture"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2a7b90443fbb2fbf3990005930f4c31c5e0a8bc0^1/flink-core/src/main/java/org/apache/flink/api/common/typeutils/base/EnumSerializer.java",
      "locators": [
          {
              "line": 251,
              "column": 31
          },
          {
              "line": 252,
              "column": 35
          }
      ],
      "old_name": "newEnumSerializer",
      "new_name": "oldEnumSerializerSnapshot",
      "ctx": {
          "symbolName": "newEnumSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "EnumSerializer<T>",
          "scopeHint": "in resolveSchemaCompatibility(...)",
          "filePath": "EnumSerializer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(\n                TypeSerializer<T> newSerializer) {\n            if (!(newSerializer instanceof EnumSerializer)) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            }\n\n            EnumSerializer<T> newEnumSerializer = (EnumSerializer<T>) newSerializer;\n            if (!enumClass.equals(newEnumSerializer.enumClass)) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            }\n\n            T[] currentEnums = enumClass.getEnumConstants();\n\n            if (Arrays.equals(previousEnums, currentEnums)) {\n                return TypeSerializerSchemaCompatibility.compatibleAsIs();\n            }\n\n            Set<T> reconfiguredEnumSet = new LinkedHashSet<>(Arrays.asList(previousEnums));\n            reconfiguredEnumSet.addAll(Arrays.asList(currentEnums));\n\n            @SuppressWarnings(\"unchecked\")\n            T[] reconfiguredEnums =\n                    reconfiguredEnumSet.toArray(\n                            (T[]) Array.newInstance(enumClass, reconfiguredEnumSet.size()));\n\n            EnumSerializer<T> reconfiguredSerializer =\n                    new EnumSerializer<>(enumClass, reconfiguredEnums);\n            return TypeSerializerSchemaCompatibility.compatibleWithReconfiguredSerializer(\n                    reconfiguredSerializer);\n        }",
          "conflictNames": [
              "newSerializer",
              "currentEnums",
              "reconfiguredEnumSet",
              "reconfiguredEnums",
              "reconfiguredSerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2aa9af15b418fb4308d089dad37e6b483d8a772a^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushWatermarkIntoTableSourceScanRuleBase.java",
      "locators": [
          {
              "line": 123,
              "column": 28
          },
          {
              "line": 125,
              "column": 24
          },
          {
              "line": 126,
              "column": 18
          },
          {
              "line": 126,
              "column": 43
          },
          {
              "line": 127,
              "column": 17
          },
          {
              "line": 127,
              "column": 37
          },
          {
              "line": 129,
              "column": 17
          },
          {
              "line": 161,
              "column": 44
          }
      ],
      "old_name": "idleTimeout",
      "new_name": "globalIdleTimeout",
      "ctx": {
          "symbolName": "idleTimeout",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Duration",
          "scopeHint": "in getNewScan(...)",
          "filePath": "PushWatermarkIntoTableSourceScanRuleBase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * It uses the input watermark expression to generate the {@link WatermarkGeneratorSupplier}.\n     * After the {@link WatermarkStrategy} is pushed into the scan, it will build a new scan.\n     * However, when {@link FlinkLogicalWatermarkAssigner} is the parent of the {@link\n     * FlinkLogicalTableSourceScan} it should modify the rowtime type to keep the type of plan is\n     * consistent. In other cases, it just keep the data type of the scan as same as before and\n     * leave the work when rewriting the projection.\n     *\n     * <p>NOTES: the row type of the scan is not always as same as the watermark assigner. Because\n     * the scan will not add the rowtime column into the row when pushing the watermark assigner\n     * into the scan. In some cases, query may have computed columns defined on rowtime column. If\n     * modifying the type of the rowtime(with time attribute), it will also influence the type of\n     * the computed column. Therefore, if the watermark assigner is not the parent of the scan, set\n     * the type of the scan as before and leave the work to projection.\n     */\n    protected FlinkLogicalTableSourceScan getNewScan(\n            FlinkLogicalWatermarkAssigner watermarkAssigner,\n            RexNode watermarkExpr,\n            FlinkLogicalTableSourceScan scan,\n            TableConfig tableConfig,\n            boolean useWatermarkAssignerRowType) {\n        final TableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n        final DynamicTableSource newDynamicTableSource = tableSourceTable.tableSource().copy();\n\n        final boolean isSourceWatermark =\n                newDynamicTableSource instanceof SupportsSourceWatermark\n                        && hasSourceWatermarkDeclaration(watermarkExpr);\n\n        final RelDataType newType;\n        if (useWatermarkAssignerRowType) {\n            // project is trivial and set rowtime type in scan\n            newType = watermarkAssigner.getRowType();\n        } else {\n            // project add/delete columns and set the rowtime column type in project\n            newType = scan.getRowType();\n        }\n\n        final RowType producedType = (RowType) FlinkTypeFactory.toLogicalType(newType);\n        final SourceAbilityContext abilityContext = SourceAbilityContext.from(scan);\n\n        final SourceAbilitySpec abilitySpec;\n        if (isSourceWatermark) {\n            final SourceWatermarkSpec sourceWatermarkSpec =\n                    new SourceWatermarkSpec(true, producedType);\n            sourceWatermarkSpec.apply(newDynamicTableSource, abilityContext);\n            abilitySpec = sourceWatermarkSpec;\n        } else {\n            final Duration idleTimeout =\n                    tableConfig.get(ExecutionConfigOptions.TABLE_EXEC_SOURCE_IDLE_TIMEOUT);\n            final long idleTimeoutMillis;\n            if (!idleTimeout.isZero() && !idleTimeout.isNegative()) {\n                idleTimeoutMillis = idleTimeout.toMillis();\n            } else {\n                idleTimeoutMillis = -1L;\n            }\n\n            Optional<RelHint> optionsHintOptional =\n                    scan.getHints().stream()\n                            .filter(\n                                    relHint ->\n                                            relHint.hintName.equalsIgnoreCase(\n                                                    FlinkHints.HINT_NAME_OPTIONS))\n                            .findFirst();\n            Configuration hintOptions =\n                    optionsHintOptional\n                            .map(relHint -> Configuration.fromMap(relHint.kvOptions))\n                            .orElseGet(Configuration::new);\n            RelOptTable table = scan.getTable();\n            Configuration tableOptions =\n                    Optional.of(table)\n                            .filter(TableSourceTable.class::isInstance)\n                            .map(\n                                    t -> {\n                                        Map<String, String> tableConfigs =\n                                                ((TableSourceTable) t)\n                                                        .contextResolvedTable()\n                                                        .getResolvedTable()\n                                                        .getOptions();\n                                        return Configuration.fromMap(tableConfigs);\n                                    })\n                            .orElseGet(Configuration::new);\n            WatermarkParams watermarkParams = parseWatermarkParams(hintOptions, tableOptions);\n\n            final WatermarkPushDownSpec watermarkPushDownSpec =\n                    new WatermarkPushDownSpec(\n                            watermarkExpr, idleTimeoutMillis, producedType, watermarkParams);\n            watermarkPushDownSpec.apply(newDynamicTableSource, abilityContext);\n            abilitySpec = watermarkPushDownSpec;\n        }\n\n        TableSourceTable newTableSourceTable =\n                tableSourceTable.copy(\n                        newDynamicTableSource, newType, new SourceAbilitySpec[] {abilitySpec});\n        return FlinkLogicalTableSourceScan.create(\n                scan.getCluster(), scan.getHints(), newTableSourceTable);\n    }",
          "conflictNames": [
              "watermarkAssigner",
              "watermarkExpr",
              "scan",
              "tableConfig",
              "useWatermarkAssignerRowType",
              "tableSourceTable",
              "newDynamicTableSource",
              "isSourceWatermark",
              "newType",
              "producedType",
              "abilityContext",
              "abilitySpec",
              "sourceWatermarkSpec",
              "idleTimeoutMillis",
              "optionsHintOptional",
              "hintOptions",
              "table",
              "tableOptions",
              "tableConfigs",
              "watermarkParams",
              "watermarkPushDownSpec",
              "newTableSourceTable"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2aa9af15b418fb4308d089dad37e6b483d8a772a^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushWatermarkIntoTableSourceScanRuleBase.java",
      "locators": [
          {
              "line": 125,
              "column": 24
          },
          {
              "line": 127,
              "column": 17
          },
          {
              "line": 129,
              "column": 17
          },
          {
              "line": 161,
              "column": 44
          }
      ],
      "old_name": "idleTimeoutMillis",
      "new_name": "globalIdleTimeoutMillis",
      "ctx": {
          "symbolName": "idleTimeoutMillis",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "long",
          "scopeHint": "in getNewScan(...)",
          "filePath": "PushWatermarkIntoTableSourceScanRuleBase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * It uses the input watermark expression to generate the {@link WatermarkGeneratorSupplier}.\n     * After the {@link WatermarkStrategy} is pushed into the scan, it will build a new scan.\n     * However, when {@link FlinkLogicalWatermarkAssigner} is the parent of the {@link\n     * FlinkLogicalTableSourceScan} it should modify the rowtime type to keep the type of plan is\n     * consistent. In other cases, it just keep the data type of the scan as same as before and\n     * leave the work when rewriting the projection.\n     *\n     * <p>NOTES: the row type of the scan is not always as same as the watermark assigner. Because\n     * the scan will not add the rowtime column into the row when pushing the watermark assigner\n     * into the scan. In some cases, query may have computed columns defined on rowtime column. If\n     * modifying the type of the rowtime(with time attribute), it will also influence the type of\n     * the computed column. Therefore, if the watermark assigner is not the parent of the scan, set\n     * the type of the scan as before and leave the work to projection.\n     */\n    protected FlinkLogicalTableSourceScan getNewScan(\n            FlinkLogicalWatermarkAssigner watermarkAssigner,\n            RexNode watermarkExpr,\n            FlinkLogicalTableSourceScan scan,\n            TableConfig tableConfig,\n            boolean useWatermarkAssignerRowType) {\n        final TableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n        final DynamicTableSource newDynamicTableSource = tableSourceTable.tableSource().copy();\n\n        final boolean isSourceWatermark =\n                newDynamicTableSource instanceof SupportsSourceWatermark\n                        && hasSourceWatermarkDeclaration(watermarkExpr);\n\n        final RelDataType newType;\n        if (useWatermarkAssignerRowType) {\n            // project is trivial and set rowtime type in scan\n            newType = watermarkAssigner.getRowType();\n        } else {\n            // project add/delete columns and set the rowtime column type in project\n            newType = scan.getRowType();\n        }\n\n        final RowType producedType = (RowType) FlinkTypeFactory.toLogicalType(newType);\n        final SourceAbilityContext abilityContext = SourceAbilityContext.from(scan);\n\n        final SourceAbilitySpec abilitySpec;\n        if (isSourceWatermark) {\n            final SourceWatermarkSpec sourceWatermarkSpec =\n                    new SourceWatermarkSpec(true, producedType);\n            sourceWatermarkSpec.apply(newDynamicTableSource, abilityContext);\n            abilitySpec = sourceWatermarkSpec;\n        } else {\n            final Duration idleTimeout =\n                    tableConfig.get(ExecutionConfigOptions.TABLE_EXEC_SOURCE_IDLE_TIMEOUT);\n            final long idleTimeoutMillis;\n            if (!idleTimeout.isZero() && !idleTimeout.isNegative()) {\n                idleTimeoutMillis = idleTimeout.toMillis();\n            } else {\n                idleTimeoutMillis = -1L;\n            }\n\n            Optional<RelHint> optionsHintOptional =\n                    scan.getHints().stream()\n                            .filter(\n                                    relHint ->\n                                            relHint.hintName.equalsIgnoreCase(\n                                                    FlinkHints.HINT_NAME_OPTIONS))\n                            .findFirst();\n            Configuration hintOptions =\n                    optionsHintOptional\n                            .map(relHint -> Configuration.fromMap(relHint.kvOptions))\n                            .orElseGet(Configuration::new);\n            RelOptTable table = scan.getTable();\n            Configuration tableOptions =\n                    Optional.of(table)\n                            .filter(TableSourceTable.class::isInstance)\n                            .map(\n                                    t -> {\n                                        Map<String, String> tableConfigs =\n                                                ((TableSourceTable) t)\n                                                        .contextResolvedTable()\n                                                        .getResolvedTable()\n                                                        .getOptions();\n                                        return Configuration.fromMap(tableConfigs);\n                                    })\n                            .orElseGet(Configuration::new);\n            WatermarkParams watermarkParams = parseWatermarkParams(hintOptions, tableOptions);\n\n            final WatermarkPushDownSpec watermarkPushDownSpec =\n                    new WatermarkPushDownSpec(\n                            watermarkExpr, idleTimeoutMillis, producedType, watermarkParams);\n            watermarkPushDownSpec.apply(newDynamicTableSource, abilityContext);\n            abilitySpec = watermarkPushDownSpec;\n        }\n\n        TableSourceTable newTableSourceTable =\n                tableSourceTable.copy(\n                        newDynamicTableSource, newType, new SourceAbilitySpec[] {abilitySpec});\n        return FlinkLogicalTableSourceScan.create(\n                scan.getCluster(), scan.getHints(), newTableSourceTable);\n    }",
          "conflictNames": [
              "watermarkAssigner",
              "watermarkExpr",
              "scan",
              "tableConfig",
              "useWatermarkAssignerRowType",
              "tableSourceTable",
              "newDynamicTableSource",
              "isSourceWatermark",
              "newType",
              "producedType",
              "abilityContext",
              "abilitySpec",
              "sourceWatermarkSpec",
              "idleTimeout",
              "optionsHintOptional",
              "hintOptions",
              "table",
              "tableOptions",
              "tableConfigs",
              "watermarkParams",
              "watermarkPushDownSpec",
              "newTableSourceTable"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2bcc308d3600b429416b01e95159c360dafcb0ab^1/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/filemerging/AcrossCheckpointFileMergingSnapshotManagerTest.java",
      "locators": [
          {
              "line": 172,
              "column": 36
          },
          {
              "line": 174,
              "column": 42
          }
      ],
      "old_name": "cp2StateHandle",
      "new_name": "cp2StateHandle1",
      "ctx": {
          "symbolName": "cp2StateHandle",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SegmentFileStateHandle",
          "scopeHint": "in testCheckpointNotification(...)",
          "filePath": "AcrossCheckpointFileMergingSnapshotManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testCheckpointNotification() throws Exception {\n        try (FileMergingSnapshotManagerBase fmsm =\n                        (FileMergingSnapshotManagerBase)\n                                createFileMergingSnapshotManager(checkpointBaseDir);\n                CloseableRegistry closeableRegistry = new CloseableRegistry()) {\n            FileMergingCheckpointStateOutputStream cp1Stream =\n                    writeCheckpointAndGetStream(1, fmsm, closeableRegistry);\n            SegmentFileStateHandle cp1StateHandle = cp1Stream.closeAndGetHandle();\n            fmsm.notifyCheckpointComplete(subtaskKey1, 1);\n            assertFileInManagedDir(fmsm, cp1StateHandle);\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(1);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(1);\n            // complete checkpoint-2\n            FileMergingCheckpointStateOutputStream cp2Stream =\n                    writeCheckpointAndGetStream(2, fmsm, closeableRegistry);\n            SegmentFileStateHandle cp2StateHandle = cp2Stream.closeAndGetHandle();\n            fmsm.notifyCheckpointComplete(subtaskKey1, 2);\n            assertFileInManagedDir(fmsm, cp2StateHandle);\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(1);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(2);\n\n            // subsume checkpoint-1\n            assertThat(fileExists(cp1StateHandle)).isTrue();\n            fmsm.notifyCheckpointSubsumed(subtaskKey1, 1);\n            assertThat(fileExists(cp1StateHandle)).isTrue();\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(1);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(1);\n\n            // abort checkpoint-3\n            FileMergingCheckpointStateOutputStream cp3Stream =\n                    writeCheckpointAndGetStream(3, fmsm, closeableRegistry);\n            SegmentFileStateHandle cp3StateHandle = cp3Stream.closeAndGetHandle();\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(1);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(2);\n            assertFileInManagedDir(fmsm, cp3StateHandle);\n            fmsm.notifyCheckpointAborted(subtaskKey1, 3);\n            assertThat(fileExists(cp3StateHandle)).isTrue();\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(1);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(1);\n        }\n    }",
          "conflictNames": [
              "fmsm",
              "closeableRegistry",
              "cp1Stream",
              "cp1StateHandle",
              "cp2Stream",
              "cp3Stream",
              "cp3StateHandle"
          ]
      },
      "suggestions": [
          {
              "name": "cp2StateHandle1",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/2bcc308d3600b429416b01e95159c360dafcb0ab^1/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/filemerging/AcrossCheckpointFileMergingSnapshotManagerTest.java",
      "locators": [
          {
              "line": 188,
              "column": 36
          },
          {
              "line": 191,
              "column": 42
          },
          {
              "line": 193,
              "column": 35
          }
      ],
      "old_name": "cp3StateHandle",
      "new_name": "cp3StateHandle1",
      "ctx": {
          "symbolName": "cp3StateHandle",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SegmentFileStateHandle",
          "scopeHint": "in testCheckpointNotification(...)",
          "filePath": "AcrossCheckpointFileMergingSnapshotManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testCheckpointNotification() throws Exception {\n        try (FileMergingSnapshotManagerBase fmsm =\n                        (FileMergingSnapshotManagerBase)\n                                createFileMergingSnapshotManager(checkpointBaseDir);\n                CloseableRegistry closeableRegistry = new CloseableRegistry()) {\n            FileMergingCheckpointStateOutputStream cp1Stream =\n                    writeCheckpointAndGetStream(1, fmsm, closeableRegistry);\n            SegmentFileStateHandle cp1StateHandle = cp1Stream.closeAndGetHandle();\n            fmsm.notifyCheckpointComplete(subtaskKey1, 1);\n            assertFileInManagedDir(fmsm, cp1StateHandle);\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(1);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(1);\n            // complete checkpoint-2\n            FileMergingCheckpointStateOutputStream cp2Stream =\n                    writeCheckpointAndGetStream(2, fmsm, closeableRegistry);\n            SegmentFileStateHandle cp2StateHandle = cp2Stream.closeAndGetHandle();\n            fmsm.notifyCheckpointComplete(subtaskKey1, 2);\n            assertFileInManagedDir(fmsm, cp2StateHandle);\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(1);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(2);\n\n            // subsume checkpoint-1\n            assertThat(fileExists(cp1StateHandle)).isTrue();\n            fmsm.notifyCheckpointSubsumed(subtaskKey1, 1);\n            assertThat(fileExists(cp1StateHandle)).isTrue();\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(1);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(1);\n\n            // abort checkpoint-3\n            FileMergingCheckpointStateOutputStream cp3Stream =\n                    writeCheckpointAndGetStream(3, fmsm, closeableRegistry);\n            SegmentFileStateHandle cp3StateHandle = cp3Stream.closeAndGetHandle();\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(1);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(2);\n            assertFileInManagedDir(fmsm, cp3StateHandle);\n            fmsm.notifyCheckpointAborted(subtaskKey1, 3);\n            assertThat(fileExists(cp3StateHandle)).isTrue();\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(1);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(1);\n        }\n    }",
          "conflictNames": [
              "fmsm",
              "closeableRegistry",
              "cp1Stream",
              "cp1StateHandle",
              "cp2Stream",
              "cp2StateHandle",
              "cp3Stream"
          ]
      },
      "suggestions": [
          {
              "name": "cp3StateHandle1",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/2bcc308d3600b429416b01e95159c360dafcb0ab^1/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/filemerging/WithinCheckpointFileMergingSnapshotManagerTest.java",
      "locators": [
          {
              "line": 178,
              "column": 36
          },
          {
              "line": 180,
              "column": 42
          }
      ],
      "old_name": "cp2StateHandle",
      "new_name": "cp2StateHandle1",
      "ctx": {
          "symbolName": "cp2StateHandle",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SegmentFileStateHandle",
          "scopeHint": "in testCheckpointNotification(...)",
          "filePath": "WithinCheckpointFileMergingSnapshotManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testCheckpointNotification() throws Exception {\n        try (FileMergingSnapshotManagerBase fmsm =\n                        (FileMergingSnapshotManagerBase)\n                                createFileMergingSnapshotManager(checkpointBaseDir);\n                CloseableRegistry closeableRegistry = new CloseableRegistry()) {\n            FileMergingCheckpointStateOutputStream cp1Stream =\n                    writeCheckpointAndGetStream(1, fmsm, closeableRegistry);\n            SegmentFileStateHandle cp1StateHandle = cp1Stream.closeAndGetHandle();\n            fmsm.notifyCheckpointComplete(subtaskKey1, 1);\n            assertFileInManagedDir(fmsm, cp1StateHandle);\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(1);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(1);\n\n            // complete checkpoint-2\n            FileMergingCheckpointStateOutputStream cp2Stream =\n                    writeCheckpointAndGetStream(2, fmsm, closeableRegistry);\n            SegmentFileStateHandle cp2StateHandle = cp2Stream.closeAndGetHandle();\n            fmsm.notifyCheckpointComplete(subtaskKey1, 2);\n            assertFileInManagedDir(fmsm, cp2StateHandle);\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(2);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(2);\n\n            // subsume checkpoint-1\n            assertThat(fileExists(cp1StateHandle)).isTrue();\n            fmsm.notifyCheckpointSubsumed(subtaskKey1, 1);\n            assertThat(fileExists(cp1StateHandle)).isFalse();\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(1);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(1);\n\n            // abort checkpoint-3\n            FileMergingCheckpointStateOutputStream cp3Stream =\n                    writeCheckpointAndGetStream(3, fmsm, closeableRegistry);\n            SegmentFileStateHandle cp3StateHandle = cp3Stream.closeAndGetHandle();\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(2);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(2);\n\n            assertFileInManagedDir(fmsm, cp3StateHandle);\n            fmsm.notifyCheckpointAborted(subtaskKey1, 3);\n            assertThat(fileExists(cp3StateHandle)).isFalse();\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(1);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(1);\n        }\n    }",
          "conflictNames": [
              "fmsm",
              "closeableRegistry",
              "cp1Stream",
              "cp1StateHandle",
              "cp2Stream",
              "cp3Stream",
              "cp3StateHandle"
          ]
      },
      "suggestions": [
          {
              "name": "cp2StateHandle1",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/2bcc308d3600b429416b01e95159c360dafcb0ab^1/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/filemerging/WithinCheckpointFileMergingSnapshotManagerTest.java",
      "locators": [
          {
              "line": 169,
              "column": 36
          },
          {
              "line": 171,
              "column": 42
          },
          {
              "line": 185,
              "column": 35
          },
          {
              "line": 187,
              "column": 35
          }
      ],
      "old_name": "cp1StateHandle",
      "new_name": "cp1StateHandle1",
      "ctx": {
          "symbolName": "cp1StateHandle",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SegmentFileStateHandle",
          "scopeHint": "in testCheckpointNotification(...)",
          "filePath": "WithinCheckpointFileMergingSnapshotManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testCheckpointNotification() throws Exception {\n        try (FileMergingSnapshotManagerBase fmsm =\n                        (FileMergingSnapshotManagerBase)\n                                createFileMergingSnapshotManager(checkpointBaseDir);\n                CloseableRegistry closeableRegistry = new CloseableRegistry()) {\n            FileMergingCheckpointStateOutputStream cp1Stream =\n                    writeCheckpointAndGetStream(1, fmsm, closeableRegistry);\n            SegmentFileStateHandle cp1StateHandle = cp1Stream.closeAndGetHandle();\n            fmsm.notifyCheckpointComplete(subtaskKey1, 1);\n            assertFileInManagedDir(fmsm, cp1StateHandle);\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(1);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(1);\n\n            // complete checkpoint-2\n            FileMergingCheckpointStateOutputStream cp2Stream =\n                    writeCheckpointAndGetStream(2, fmsm, closeableRegistry);\n            SegmentFileStateHandle cp2StateHandle = cp2Stream.closeAndGetHandle();\n            fmsm.notifyCheckpointComplete(subtaskKey1, 2);\n            assertFileInManagedDir(fmsm, cp2StateHandle);\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(2);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(2);\n\n            // subsume checkpoint-1\n            assertThat(fileExists(cp1StateHandle)).isTrue();\n            fmsm.notifyCheckpointSubsumed(subtaskKey1, 1);\n            assertThat(fileExists(cp1StateHandle)).isFalse();\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(1);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(1);\n\n            // abort checkpoint-3\n            FileMergingCheckpointStateOutputStream cp3Stream =\n                    writeCheckpointAndGetStream(3, fmsm, closeableRegistry);\n            SegmentFileStateHandle cp3StateHandle = cp3Stream.closeAndGetHandle();\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(2);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(2);\n\n            assertFileInManagedDir(fmsm, cp3StateHandle);\n            fmsm.notifyCheckpointAborted(subtaskKey1, 3);\n            assertThat(fileExists(cp3StateHandle)).isFalse();\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(1);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(1);\n        }\n    }",
          "conflictNames": [
              "fmsm",
              "closeableRegistry",
              "cp1Stream",
              "cp2Stream",
              "cp2StateHandle",
              "cp3Stream",
              "cp3StateHandle"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2bcc308d3600b429416b01e95159c360dafcb0ab^1/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/filemerging/WithinCheckpointFileMergingSnapshotManagerTest.java",
      "locators": [
          {
              "line": 194,
              "column": 36
          },
          {
              "line": 198,
              "column": 42
          },
          {
              "line": 200,
              "column": 35
          }
      ],
      "old_name": "cp3StateHandle",
      "new_name": "cp3StateHandle1",
      "ctx": {
          "symbolName": "cp3StateHandle",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SegmentFileStateHandle",
          "scopeHint": "in testCheckpointNotification(...)",
          "filePath": "WithinCheckpointFileMergingSnapshotManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testCheckpointNotification() throws Exception {\n        try (FileMergingSnapshotManagerBase fmsm =\n                        (FileMergingSnapshotManagerBase)\n                                createFileMergingSnapshotManager(checkpointBaseDir);\n                CloseableRegistry closeableRegistry = new CloseableRegistry()) {\n            FileMergingCheckpointStateOutputStream cp1Stream =\n                    writeCheckpointAndGetStream(1, fmsm, closeableRegistry);\n            SegmentFileStateHandle cp1StateHandle = cp1Stream.closeAndGetHandle();\n            fmsm.notifyCheckpointComplete(subtaskKey1, 1);\n            assertFileInManagedDir(fmsm, cp1StateHandle);\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(1);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(1);\n\n            // complete checkpoint-2\n            FileMergingCheckpointStateOutputStream cp2Stream =\n                    writeCheckpointAndGetStream(2, fmsm, closeableRegistry);\n            SegmentFileStateHandle cp2StateHandle = cp2Stream.closeAndGetHandle();\n            fmsm.notifyCheckpointComplete(subtaskKey1, 2);\n            assertFileInManagedDir(fmsm, cp2StateHandle);\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(2);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(2);\n\n            // subsume checkpoint-1\n            assertThat(fileExists(cp1StateHandle)).isTrue();\n            fmsm.notifyCheckpointSubsumed(subtaskKey1, 1);\n            assertThat(fileExists(cp1StateHandle)).isFalse();\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(1);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(1);\n\n            // abort checkpoint-3\n            FileMergingCheckpointStateOutputStream cp3Stream =\n                    writeCheckpointAndGetStream(3, fmsm, closeableRegistry);\n            SegmentFileStateHandle cp3StateHandle = cp3Stream.closeAndGetHandle();\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(2);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(2);\n\n            assertFileInManagedDir(fmsm, cp3StateHandle);\n            fmsm.notifyCheckpointAborted(subtaskKey1, 3);\n            assertThat(fileExists(cp3StateHandle)).isFalse();\n            assertThat(fmsm.spaceStat.physicalFileCount.get()).isEqualTo(1);\n            assertThat(fmsm.spaceStat.logicalFileCount.get()).isEqualTo(1);\n        }\n    }",
          "conflictNames": [
              "fmsm",
              "closeableRegistry",
              "cp1Stream",
              "cp1StateHandle",
              "cp2Stream",
              "cp2StateHandle",
              "cp3Stream"
          ]
      },
      "suggestions": [
          {
              "name": "cp3StateHandle1",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/2cde5613129b1343bf473c55511b56719e18559b^1/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/api/internal/ShowCreateUtil.java",
      "locators": [
          {
              "line": 95,
              "column": 23
          },
          {
              "line": 100,
              "column": 13
          },
          {
              "line": 112,
              "column": 33
          },
          {
              "line": 115,
              "column": 16
          }
      ],
      "old_name": "stringBuilder",
      "new_name": "sb",
      "ctx": {
          "symbolName": "stringBuilder",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "StringBuilder",
          "scopeHint": "in buildShowCreateViewRow(...)",
          "filePath": "ShowCreateUtil.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Show create view statement only for views. */\n    public static String buildShowCreateViewRow(\n            ResolvedCatalogBaseTable<?> view,\n            ObjectIdentifier viewIdentifier,\n            boolean isTemporary) {\n        if (view.getTableKind() != CatalogBaseTable.TableKind.VIEW) {\n            throw new TableException(\n                    String.format(\n                            \"SHOW CREATE VIEW is only supported for views, but %s is a table. Please use SHOW CREATE TABLE instead.\",\n                            viewIdentifier.asSerializableString()));\n        }\n        StringBuilder stringBuilder = new StringBuilder();\n        if (view.getOrigin() instanceof QueryOperationCatalogView) {\n            throw new TableException(\n                    \"SHOW CREATE VIEW is not supported for views registered by Table API.\");\n        } else {\n            stringBuilder.append(\n                    String.format(\n                            \"CREATE %sVIEW %s%s as%s%s\",\n                            isTemporary ? \"TEMPORARY \" : \"\",\n                            viewIdentifier.asSerializableString(),\n                            String.format(\"(%s)\", extractFormattedColumnNames(view)),\n                            System.lineSeparator(),\n                            ((CatalogView) view.getOrigin()).getExpandedQuery()));\n        }\n        extractFormattedComment(view)\n                .ifPresent(\n                        c ->\n                                stringBuilder.append(\n                                        String.format(\n                                                \" COMMENT '%s'%s\", c, System.lineSeparator())));\n        return stringBuilder.toString();\n    }",
          "conflictNames": [
              "view",
              "viewIdentifier",
              "isTemporary"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2e257896661ad5e0dca521fa274cad3a0bae7a61^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java",
      "locators": [
          {
              "line": 1230,
              "column": 13
          },
          {
              "line": 1232,
              "column": 13
          },
          {
              "line": 1234,
              "column": 13
          },
          {
              "line": 1237,
              "column": 28
          }
      ],
      "old_name": "minBuffersPerGate",
      "new_name": "expectedBuffersPerGate",
      "ctx": {
          "symbolName": "minBuffersPerGate",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in verifyBuffersInBufferPool(...)",
          "filePath": "SingleInputGateTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void verifyBuffersInBufferPool(boolean isPipeline, int subpartitionRandSize)\n            throws Exception {\n        IntermediateResultPartitionID[] partitionIds =\n                new IntermediateResultPartitionID[] {\n                    new IntermediateResultPartitionID(),\n                    new IntermediateResultPartitionID(),\n                    new IntermediateResultPartitionID()\n                };\n\n        IndexRange subpartitionIndexRange = new IndexRange(0, subpartitionRandSize - 1);\n        NettyShuffleEnvironmentBuilder nettyShuffleEnvironmentBuilder =\n                new NettyShuffleEnvironmentBuilder();\n        Optional<Integer> expectMaxRequiredBuffersPerGate =\n                isPipeline\n                        ? Optional.of(\n                                InputGateSpecUtils.DEFAULT_MAX_REQUIRED_BUFFERS_PER_GATE_FOR_STREAM)\n                        : Optional.of(\n                                InputGateSpecUtils.DEFAULT_MAX_REQUIRED_BUFFERS_PER_GATE_FOR_BATCH);\n        nettyShuffleEnvironmentBuilder.setMaxRequiredBuffersPerGate(\n                expectMaxRequiredBuffersPerGate);\n        NettyShuffleEnvironment netEnv = nettyShuffleEnvironmentBuilder.build();\n\n        SingleInputGate gate =\n                createSingleInputGate(\n                        partitionIds,\n                        isPipeline ? ResultPartitionType.PIPELINED : ResultPartitionType.BLOCKING,\n                        subpartitionIndexRange,\n                        netEnv,\n                        ResourceID.generate(),\n                        new TestingConnectionManager(),\n                        new TestingResultPartitionManager(new NoOpResultSubpartitionView()));\n        gate.setup();\n\n        for (InputChannel inputChannel : gate.inputChannels()) {\n            if (inputChannel instanceof RemoteInputChannel) {\n                assertThat(((RemoteInputChannel) inputChannel).getInitialCredit()).isEqualTo(0);\n            }\n        }\n\n        int maxBuffersPerGate = 2 * partitionIds.length * subpartitionRandSize + 8;\n        int minBuffersPerGate;\n        if (maxBuffersPerGate >= expectMaxRequiredBuffersPerGate.get()) {\n            minBuffersPerGate = expectMaxRequiredBuffersPerGate.get();\n        } else {\n            minBuffersPerGate = 2 * partitionIds.length * subpartitionRandSize + 1;\n        }\n        assertThat(gate.getBufferPool().getExpectedNumberOfMemorySegments())\n                .isEqualTo(minBuffersPerGate);\n        assertThat(gate.getBufferPool().getMaxNumberOfMemorySegments())\n                .isEqualTo(maxBuffersPerGate);\n    }",
          "conflictNames": [
              "isPipeline",
              "subpartitionRandSize",
              "partitionIds",
              "subpartitionIndexRange",
              "nettyShuffleEnvironmentBuilder",
              "expectMaxRequiredBuffersPerGate",
              "netEnv",
              "gate",
              "maxBuffersPerGate"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2ed858318f38eb9913e5f4b3019be6b6d0a8e6fb^1/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/restore/RocksDBIncrementalRestoreOperation.java",
      "locators": [
          {
              "line": 288,
              "column": 26
          },
          {
              "line": 293,
              "column": 13
          },
          {
              "line": 294,
              "column": 40
          },
          {
              "line": 295,
              "column": 33
          },
          {
              "line": 379,
              "column": 55
          },
          {
              "line": 381,
              "column": 17
          },
          {
              "line": 384,
              "column": 68
          },
          {
              "line": 392,
              "column": 21
          }
      ],
      "old_name": "initialHandle",
      "new_name": "selectedInitialHandle",
      "ctx": {
          "symbolName": "initialHandle",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "KeyedStateHandle",
          "scopeHint": "in restoreWithRescaling(...)",
          "filePath": "RocksDBIncrementalRestoreOperation.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Recovery from multi incremental states with rescaling. For rescaling, this method creates a\n     * temporary RocksDB instance for a key-groups shard. All contents from the temporary instance\n     * are copied into the real restore instance and then the temporary instance is discarded.\n     */\n    private void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles)\n            throws Exception {\n\n        // Prepare for restore with rescaling\n        KeyedStateHandle initialHandle =\n                RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(\n                        restoreStateHandles, keyGroupRange, overlapFractionThreshold);\n\n        // Init base DB instance\n        if (initialHandle != null) {\n            restoreStateHandles.remove(initialHandle);\n            initDBWithRescaling(initialHandle);\n        } else {\n            this.rocksHandle.openDB();\n        }\n\n        // Transfer remaining key-groups from temporary instance into base DB\n        byte[] startKeyGroupPrefixBytes = new byte[keyGroupPrefixBytes];\n        CompositeKeySerializationUtils.serializeKeyGroup(\n                keyGroupRange.getStartKeyGroup(), startKeyGroupPrefixBytes);\n\n        byte[] stopKeyGroupPrefixBytes = new byte[keyGroupPrefixBytes];\n        CompositeKeySerializationUtils.serializeKeyGroup(\n                keyGroupRange.getEndKeyGroup() + 1, stopKeyGroupPrefixBytes);\n\n        for (KeyedStateHandle rawStateHandle : restoreStateHandles) {\n\n            if (!(rawStateHandle instanceof IncrementalRemoteKeyedStateHandle)) {\n                throw unexpectedStateHandleException(\n                        IncrementalRemoteKeyedStateHandle.class, rawStateHandle.getClass());\n            }\n\n            logger.info(\n                    \"Starting to restore from state handle: {} with rescaling.\", rawStateHandle);\n            Path temporaryRestoreInstancePath =\n                    instanceBasePath\n                            .getAbsoluteFile()\n                            .toPath()\n                            .resolve(UUID.randomUUID().toString());\n            try (RestoredDBInstance tmpRestoreDBInfo =\n                            restoreDBInstanceFromStateHandle(\n                                    (IncrementalRemoteKeyedStateHandle) rawStateHandle,\n                                    temporaryRestoreInstancePath);\n                    RocksDBWriteBatchWrapper writeBatchWrapper =\n                            new RocksDBWriteBatchWrapper(\n                                    this.rocksHandle.getDb(), writeBatchSize)) {\n\n                List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors =\n                        tmpRestoreDBInfo.columnFamilyDescriptors;\n                List<ColumnFamilyHandle> tmpColumnFamilyHandles =\n                        tmpRestoreDBInfo.columnFamilyHandles;\n\n                // iterating only the requested descriptors automatically skips the default column\n                // family handle\n                for (int i = 0; i < tmpColumnFamilyDescriptors.size(); ++i) {\n                    ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i);\n\n                    ColumnFamilyHandle targetColumnFamilyHandle =\n                            this.rocksHandle.getOrRegisterStateColumnFamilyHandle(\n                                            null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))\n                                    .columnFamilyHandle;\n\n                    try (RocksIteratorWrapper iterator =\n                            RocksDBOperationUtils.getRocksIterator(\n                                    tmpRestoreDBInfo.db,\n                                    tmpColumnFamilyHandle,\n                                    tmpRestoreDBInfo.readOptions)) {\n\n                        iterator.seek(startKeyGroupPrefixBytes);\n\n                        while (iterator.isValid()) {\n\n                            if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(\n                                    iterator.key(), stopKeyGroupPrefixBytes)) {\n                                writeBatchWrapper.put(\n                                        targetColumnFamilyHandle, iterator.key(), iterator.value());\n                            } else {\n                                // Since the iterator will visit the record according to the sorted\n                                // order,\n                                // we can just break here.\n                                break;\n                            }\n\n                            iterator.next();\n                        }\n                    } // releases native iterator resources\n                }\n                logger.info(\n                        \"Finished restoring from state handle: {} with rescaling.\", rawStateHandle);\n            } finally {\n                cleanUpPathQuietly(temporaryRestoreInstancePath);\n            }\n        }\n    }",
          "conflictNames": [
              "restoreStateHandles",
              "startKeyGroupPrefixBytes",
              "stopKeyGroupPrefixBytes",
              "temporaryRestoreInstancePath",
              "tmpRestoreDBInfo",
              "writeBatchWrapper",
              "tmpColumnFamilyDescriptors",
              "tmpColumnFamilyHandles",
              "i",
              "tmpColumnFamilyHandle",
              "targetColumnFamilyHandle",
              "iterator"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2ed858318f38eb9913e5f4b3019be6b6d0a8e6fb^1/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/restore/RocksDBIncrementalRestoreOperation.java",
      "locators": [
          {
              "line": 250,
              "column": 18
          },
          {
              "line": 256,
              "column": 41
          },
          {
              "line": 265,
              "column": 42
          },
          {
              "line": 318,
              "column": 18
          },
          {
              "line": 326,
              "column": 37
          },
          {
              "line": 374,
              "column": 36
          },
          {
              "line": 445,
              "column": 72
          },
          {
              "line": 451,
              "column": 41
          },
          {
              "line": 468,
              "column": 25
          }
      ],
      "old_name": "temporaryRestoreInstancePath",
      "new_name": "absolutInstanceBasePath",
      "ctx": {
          "symbolName": "temporaryRestoreInstancePath",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Path",
          "scopeHint": "in transferRemoteStateToLocalDirectory(...)",
          "filePath": "RocksDBIncrementalRestoreOperation.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "  createColumnFamilyDescriptors(stateMetaInfoSnapshots, true),\n                stateMetaInfoSnapshots,\n                restoreSourcePath);\n    }\n\n    private IncrementalLocalKeyedStateHandle transferRemoteStateToLocalDirectory(\n            Path temporaryRestoreInstancePath, IncrementalRemoteKeyedStateHandle restoreStateHandle)\n            throws Exception {\n\n        try (RocksDBStateDownloader rocksDBStateDownloader =\n                new RocksDBStateDownloader(numberOfTransferringThreads)) {\n            rock",
          "conflictNames": [
              "restoreStateHandle",
              "rocksDBStateDownloader"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2ed858318f38eb9913e5f4b3019be6b6d0a8e6fb^1/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/restore/RocksDBIncrementalRestoreOperation.java",
      "locators": [
          {
              "line": 2,
              "column": 5
          },
          {
              "line": 2,
              "column": 43
          },
          {
              "line": 3,
              "column": 17
          },
          {
              "line": 3,
              "column": 25
          },
          {
              "line": 3,
              "column": 61
          },
          {
              "line": 4,
              "column": 5
          },
          {
              "line": 4,
              "column": 9
          },
          {
              "line": 4,
              "column": 17
          },
          {
              "line": 4,
              "column": 23
          },
          {
              "line": 4,
              "column": 38
          },
          {
              "line": 4,
              "column": 40
          },
          {
              "line": 4,
              "column": 46
          },
          {
              "line": 4,
              "column": 54
          },
          {
              "line": 5,
              "column": 10
          },
          {
              "line": 5,
              "column": 19
          },
          {
              "line": 5,
              "column": 31
          },
          {
              "line": 5,
              "column": 45
          },
          {
              "line": 5,
              "column": 55
          },
          {
              "line": 5,
              "column": 59
          },
          {
              "line": 6,
              "column": 29
          },
          {
              "line": 6,
              "column": 41
          },
          {
              "line": 7,
              "column": 6
          },
          {
              "line": 7,
              "column": 34
          },
          {
              "line": 7,
              "column": 38
          },
          {
              "line": 7,
              "column": 49
          },
          {
              "line": 7,
              "column": 57
          },
          {
              "line": 8,
              "column": 5
          },
          {
              "line": 8,
              "column": 14
          },
          {
              "line": 8,
              "column": 35
          },
          {
              "line": 8,
              "column": 53
          },
          {
              "line": 10,
              "column": 27
          },
          {
              "line": 12,
              "column": 15
          },
          {
              "line": 12,
              "column": 27
          },
          {
              "line": 12,
              "column": 51
          },
          {
              "line": 12,
              "column": 56
          },
          {
              "line": 12,
              "column": 58
          },
          {
              "line": 13,
              "column": 5
          },
          {
              "line": 13,
              "column": 9
          },
          {
              "line": 13,
              "column": 27
          },
          {
              "line": 13,
              "column": 34
          },
          {
              "line": 13,
              "column": 38
          },
          {
              "line": 13,
              "column": 42
          },
          {
              "line": 14,
              "column": 51
          },
          {
              "line": 14,
              "column": 68
          },
          {
              "line": 14,
              "column": 72
          },
          {
              "line": 15,
              "column": 13
          },
          {
              "line": 15,
              "column": 32
          },
          {
              "line": 15,
              "column": 34
          },
          {
              "line": 15,
              "column": 52
          },
          {
              "line": 15,
              "column": 60
          },
          {
              "line": 15,
              "column": 63
          },
          {
              "line": 16,
              "column": 5
          },
          {
              "line": 16,
              "column": 7
          },
          {
              "line": 16,
              "column": 11
          },
          {
              "line": 16,
              "column": 27
          },
          {
              "line": 19,
              "column": 22
          },
          {
              "line": 19,
              "column": 31
          },
          {
              "line": 19,
              "column": 40
          },
          {
              "line": 21,
              "column": 1
          },
          {
              "line": 21,
              "column": 21
          },
          {
              "line": 21,
              "column": 27
          },
          {
              "line": 21,
              "column": 42
          },
          {
              "line": 21,
              "column": 53
          },
          {
              "line": 21,
              "column": 56
          },
          {
              "line": 22,
              "column": 1
          },
          {
              "line": 22,
              "column": 21
          },
          {
              "line": 22,
              "column": 27
          },
          {
              "line": 22,
              "column": 42
          },
          {
              "line": 22,
              "column": 53
          },
          {
              "line": 22,
              "column": 56
          },
          {
              "line": 22,
              "column": 72
          },
          {
              "line": 22,
              "column": 74
          },
          {
              "line": 22,
              "column": 76
          },
          {
              "line": 23,
              "column": 1
          },
          {
              "line": 23,
              "column": 21
          },
          {
              "line": 23,
              "column": 30
          },
          {
              "line": 23,
              "column": 39
          },
          {
              "line": 23,
              "column": 74
          },
          {
              "line": 23,
              "column": 79
          },
          {
              "line": 24,
              "column": 1
          },
          {
              "line": 24,
              "column": 21
          },
          {
              "line": 24,
              "column": 30
          },
          {
              "line": 24,
              "column": 39
          },
          {
              "line": 25,
              "column": 1
          },
          {
              "line": 25,
              "column": 21
          },
          {
              "line": 25,
              "column": 30
          },
          {
              "line": 25,
              "column": 39
          },
          {
              "line": 25,
              "column": 59
          },
          {
              "line": 25,
              "column": 66
          },
          {
              "line": 25,
              "column": 71
          },
          {
              "line": 26,
              "column": 1
          },
          {
              "line": 26,
              "column": 21
          },
          {
              "line": 26,
              "column": 30
          },
          {
              "line": 26,
              "column": 39
          },
          {
              "line": 26,
              "column": 62
          },
          {
              "line": 26,
              "column": 67
          },
          {
              "line": 27,
              "column": 1
          },
          {
              "line": 27,
              "column": 21
          },
          {
              "line": 27,
              "column": 30
          },
          {
              "line": 27,
              "column": 39
          },
          {
              "line": 28,
              "column": 1
          },
          {
              "line": 28,
              "column": 21
          },
          {
              "line": 28,
              "column": 30
          },
          {
              "line": 28,
              "column": 39
          },
          {
              "line": 28,
              "column": 58
          },
          {
              "line": 29,
              "column": 1
          },
          {
              "line": 29,
              "column": 21
          },
          {
              "line": 29,
              "column": 30
          },
          {
              "line": 29,
              "column": 39
          },
          {
              "line": 30,
              "column": 1
          },
          {
              "line": 30,
              "column": 21
          },
          {
              "line": 30,
              "column": 30
          },
          {
              "line": 30,
              "column": 39
          },
          {
              "line": 30,
              "column": 71
          },
          {
              "line": 31,
              "column": 1
          },
          {
              "line": 31,
              "column": 21
          },
          {
              "line": 31,
              "column": 45
          },
          {
              "line": 32,
              "column": 1
          },
          {
              "line": 32,
              "column": 21
          },
          {
              "line": 32,
              "column": 47
          },
          {
              "line": 33,
              "column": 1
          },
          {
              "line": 33,
              "column": 21
          },
          {
              "line": 33,
              "column": 47
          },
          {
              "line": 34,
              "column": 1
          },
          {
              "line": 34,
              "column": 21
          },
          {
              "line": 34,
              "column": 29
          },
          {
              "line": 34,
              "column": 37
          },
          {
              "line": 35,
              "column": 1
          },
          {
              "line": 35,
              "column": 21
          },
          {
              "line": 35,
              "column": 29
          },
          {
              "line": 35,
              "column": 48
          },
          {
              "line": 35,
              "column": 51
          },
          {
              "line": 35,
              "column": 60
          },
          {
              "line": 36,
              "column": 1
          },
          {
              "line": 36,
              "column": 21
          },
          {
              "line": 36,
              "column": 29
          },
          {
              "line": 36,
              "column": 45
          },
          {
              "line": 36,
              "column": 54
          },
          {
              "line": 36,
              "column": 57
          },
          {
              "line": 36,
              "column": 61
          },
          {
              "line": 36,
              "column": 66
          },
          {
              "line": 37,
              "column": 1
          },
          {
              "line": 37,
              "column": 21
          },
          {
              "line": 37,
              "column": 29
          },
          {
              "line": 37,
              "column": 40
          },
          {
              "line": 38,
              "column": 1
          },
          {
              "line": 38,
              "column": 21
          },
          {
              "line": 38,
              "column": 29
          },
          {
              "line": 39,
              "column": 1
          },
          {
              "line": 39,
              "column": 21
          },
          {
              "line": 39,
              "column": 29
          },
          {
              "line": 40,
              "column": 1
          },
          {
              "line": 40,
              "column": 21
          },
          {
              "line": 40,
              "column": 29
          },
          {
              "line": 41,
              "column": 1
          },
          {
              "line": 41,
              "column": 21
          },
          {
              "line": 41,
              "column": 29
          },
          {
              "line": 42,
              "column": 1
          },
          {
              "line": 42,
              "column": 21
          },
          {
              "line": 42,
              "column": 29
          },
          {
              "line": 42,
              "column": 54
          },
          {
              "line": 42,
              "column": 57
          },
          {
              "line": 42,
              "column": 61
          },
          {
              "line": 43,
              "column": 1
          },
          {
              "line": 43,
              "column": 21
          },
          {
              "line": 43,
              "column": 29
          },
          {
              "line": 44,
              "column": 1
          },
          {
              "line": 44,
              "column": 21
          },
          {
              "line": 44,
              "column": 29
          },
          {
              "line": 44,
              "column": 42
          },
          {
              "line": 45,
              "column": 1
          },
          {
              "line": 45,
              "column": 21
          },
          {
              "line": 45,
              "column": 29
          },
          {
              "line": 46,
              "column": 1
          },
          {
              "line": 46,
              "column": 21
          },
          {
              "line": 46,
              "column": 29
          },
          {
              "line": 46,
              "column": 47
          },
          {
              "line": 46,
              "column": 50
          },
          {
              "line": 46,
              "column": 58
          },
          {
              "line": 47,
              "column": 1
          },
          {
              "line": 47,
              "column": 21
          },
          {
              "line": 47,
              "column": 29
          },
          {
              "line": 48,
              "column": 1
          },
          {
              "line": 48,
              "column": 21
          },
          {
              "line": 48,
              "column": 29
          },
          {
              "line": 48,
              "column": 43
          },
          {
              "line": 49,
              "column": 1
          },
          {
              "line": 49,
              "column": 21
          },
          {
              "line": 49,
              "column": 27
          },
          {
              "line": 49,
              "column": 31
          },
          {
              "line": 49,
              "column": 36
          },
          {
              "line": 50,
              "column": 1
          },
          {
              "line": 50,
              "column": 21
          },
          {
              "line": 50,
              "column": 27
          },
          {
              "line": 50,
              "column": 34
          },
          {
              "line": 51,
              "column": 1
          },
          {
              "line": 51,
              "column": 21
          },
          {
              "line": 51,
              "column": 27
          },
          {
              "line": 51,
              "column": 36
          },
          {
              "line": 51,
              "column": 41
          },
          {
              "line": 51,
              "column": 50
          },
          {
              "line": 53,
              "column": 1
          },
          {
              "line": 53,
              "column": 29
          },
          {
              "line": 53,
              "column": 37
          },
          {
              "line": 54,
              "column": 1
          },
          {
              "line": 54,
              "column": 29
          },
          {
              "line": 55,
              "column": 1
          },
          {
              "line": 55,
              "column": 29
          },
          {
              "line": 55,
              "column": 35
          },
          {
              "line": 56,
              "column": 1
          },
          {
              "line": 56,
              "column": 25
          },
          {
              "line": 57,
              "column": 1
          },
          {
              "line": 57,
              "column": 27
          },
          {
              "line": 58,
              "column": 1
          },
          {
              "line": 59,
              "column": 1
          },
          {
              "line": 59,
              "column": 33
          },
          {
              "line": 60,
              "column": 1
          },
          {
              "line": 61,
              "column": 1
          },
          {
              "line": 63,
              "column": 1
          },
          {
              "line": 63,
              "column": 21
          },
          {
              "line": 63,
              "column": 33
          },
          {
              "line": 64,
              "column": 1
          },
          {
              "line": 64,
              "column": 21
          },
          {
              "line": 66,
              "column": 1
          },
          {
              "line": 66,
              "column": 13
          },
          {
              "line": 66,
              "column": 17
          },
          {
              "line": 67,
              "column": 1
          },
          {
              "line": 67,
              "column": 13
          },
          {
              "line": 67,
              "column": 24
          },
          {
              "line": 68,
              "column": 1
          },
          {
              "line": 68,
              "column": 13
          },
          {
              "line": 69,
              "column": 1
          },
          {
              "line": 69,
              "column": 14
          },
          {
              "line": 69,
              "column": 18
          },
          {
              "line": 70,
              "column": 1
          },
          {
              "line": 70,
              "column": 15
          },
          {
              "line": 70,
              "column": 24
          },
          {
              "line": 71,
              "column": 1
          },
          {
              "line": 71,
              "column": 15
          },
          {
              "line": 71,
              "column": 25
          },
          {
              "line": 72,
              "column": 1
          },
          {
              "line": 72,
              "column": 15
          },
          {
              "line": 72,
              "column": 19
          },
          {
              "line": 73,
              "column": 1
          },
          {
              "line": 73,
              "column": 15
          },
          {
              "line": 74,
              "column": 1
          },
          {
              "line": 74,
              "column": 15
          },
          {
              "line": 75,
              "column": 1
          },
          {
              "line": 75,
              "column": 15
          },
          {
              "line": 76,
              "column": 1
          },
          {
              "line": 76,
              "column": 15
          },
          {
              "line": 77,
              "column": 1
          },
          {
              "line": 77,
              "column": 15
          },
          {
              "line": 78,
              "column": 1
          },
          {
              "line": 78,
              "column": 15
          },
          {
              "line": 78,
              "column": 23
          },
          {
              "line": 78,
              "column": 32
          },
          {
              "line": 80,
              "column": 1
          },
          {
              "line": 80,
              "column": 12
          },
          {
              "line": 80,
              "column": 28
          },
          {
              "line": 80,
              "column": 36
          },
          {
              "line": 80,
              "column": 53
          },
          {
              "line": 80,
              "column": 83
          },
          {
              "line": 82,
              "column": 39
          },
          {
              "line": 82,
              "column": 53
          },
          {
              "line": 82,
              "column": 70
          },
          {
              "line": 83,
              "column": 5
          },
          {
              "line": 83,
              "column": 45
          },
          {
              "line": 83,
              "column": 52
          },
          {
              "line": 83,
              "column": 83
          },
          {
              "line": 85,
              "column": 7
          },
          {
              "line": 85,
              "column": 17
          },
          {
              "line": 85,
              "column": 21
          },
          {
              "line": 86,
              "column": 68
          },
          {
              "line": 88,
              "column": 7
          },
          {
              "line": 88,
              "column": 14
          },
          {
              "line": 88,
              "column": 22
          },
          {
              "line": 88,
              "column": 39
          },
          {
              "line": 88,
              "column": 41
          },
          {
              "line": 89,
              "column": 7
          },
          {
              "line": 89,
              "column": 14
          },
          {
              "line": 89,
              "column": 86
          },
          {
              "line": 90,
              "column": 7
          },
          {
              "line": 90,
              "column": 14
          },
          {
              "line": 91,
              "column": 7
          },
          {
              "line": 91,
              "column": 14
          },
          {
              "line": 91,
              "column": 26
          },
          {
              "line": 92,
              "column": 7
          },
          {
              "line": 92,
              "column": 14
          },
          {
              "line": 92,
              "column": 31
          },
          {
              "line": 92,
              "column": 52
          },
          {
              "line": 93,
              "column": 7
          },
          {
              "line": 93,
              "column": 14
          },
          {
              "line": 94,
              "column": 7
          },
          {
              "line": 94,
              "column": 14
          },
          {
              "line": 94,
              "column": 20
          },
          {
              "line": 94,
              "column": 24
          },
          {
              "line": 95,
              "column": 7
          },
          {
              "line": 95,
              "column": 14
          },
          {
              "line": 95,
              "column": 19
          },
          {
              "line": 95,
              "column": 40
          },
          {
              "line": 96,
              "column": 7
          },
          {
              "line": 96,
              "column": 14
          },
          {
              "line": 96,
              "column": 19
          },
          {
              "line": 96,
              "column": 35
          },
          {
              "line": 97,
              "column": 7
          },
          {
              "line": 97,
              "column": 14
          },
          {
              "line": 97,
              "column": 27
          },
          {
              "line": 97,
              "column": 30
          },
          {
              "line": 97,
              "column": 38
          },
          {
              "line": 97,
              "column": 52
          },
          {
              "line": 97,
              "column": 55
          },
          {
              "line": 97,
              "column": 63
          },
          {
              "line": 98,
              "column": 7
          },
          {
              "line": 98,
              "column": 14
          },
          {
              "line": 99,
              "column": 7
          },
          {
              "line": 99,
              "column": 38
          },
          {
              "line": 100,
              "column": 7
          },
          {
              "line": 101,
              "column": 7
          },
          {
              "line": 101,
              "column": 14
          },
          {
              "line": 101,
              "column": 26
          },
          {
              "line": 101,
              "column": 35
          },
          {
              "line": 102,
              "column": 7
          },
          {
              "line": 102,
              "column": 14
          },
          {
              "line": 102,
              "column": 38
          },
          {
              "line": 104,
              "column": 7
          },
          {
              "line": 104,
              "column": 21
          },
          {
              "line": 104,
              "column": 29
          },
          {
              "line": 104,
              "column": 32
          },
          {
              "line": 104,
              "column": 42
          },
          {
              "line": 104,
              "column": 44
          },
          {
              "line": 104,
              "column": 46
          },
          {
              "line": 106,
              "column": 9
          },
          {
              "line": 106,
              "column": 43
          },
          {
              "line": 107,
              "column": 16
          },
          {
              "line": 107,
              "column": 33
          },
          {
              "line": 107,
              "column": 35
          },
          {
              "line": 109,
              "column": 13
          },
          {
              "line": 109,
              "column": 29
          },
          {
              "line": 110,
              "column": 13
          },
          {
              "line": 110,
              "column": 34
          },
          {
              "line": 111,
              "column": 25
          },
          {
              "line": 111,
              "column": 46
          },
          {
              "line": 113,
              "column": 20
          },
          {
              "line": 113,
              "column": 60
          },
          {
              "line": 114,
              "column": 21
          },
          {
              "line": 114,
              "column": 24
          },
          {
              "line": 114,
              "column": 32
          },
          {
              "line": 114,
              "column": 46
          },
          {
              "line": 114,
              "column": 49
          },
          {
              "line": 114,
              "column": 57
          },
          {
              "line": 115,
              "column": 14
          },
          {
              "line": 115,
              "column": 18
          },
          {
              "line": 116,
              "column": 14
          },
          {
              "line": 116,
              "column": 18
          },
          {
              "line": 117,
              "column": 18
          },
          {
              "line": 117,
              "column": 28
          },
          {
              "line": 118,
              "column": 18
          },
          {
              "line": 118,
              "column": 25
          },
          {
              "line": 118,
              "column": 39
          },
          {
              "line": 118,
              "column": 45
          },
          {
              "line": 118,
              "column": 60
          },
          {
              "line": 118,
              "column": 66
          },
          {
              "line": 119,
              "column": 23
          },
          {
              "line": 119,
              "column": 30
          },
          {
              "line": 119,
              "column": 35
          },
          {
              "line": 119,
              "column": 43
          },
          {
              "line": 119,
              "column": 50
          },
          {
              "line": 119,
              "column": 55
          },
          {
              "line": 120,
              "column": 17
          },
          {
              "line": 120,
              "column": 29
          },
          {
              "line": 121,
              "column": 29
          },
          {
              "line": 122,
              "column": 40
          },
          {
              "line": 122,
              "column": 65
          },
          {
              "line": 123,
              "column": 22
          },
          {
              "line": 123,
              "column": 33
          },
          {
              "line": 123,
              "column": 42
          },
          {
              "line": 124,
              "column": 20
          },
          {
              "line": 124,
              "column": 41
          },
          {
              "line": 125,
              "column": 32
          },
          {
              "line": 126,
              "column": 11
          },
          {
              "line": 128,
              "column": 40
          },
          {
              "line": 129,
              "column": 25
          },
          {
              "line": 130,
              "column": 30
          },
          {
              "line": 131,
              "column": 34
          },
          {
              "line": 131,
              "column": 40
          },
          {
              "line": 132,
              "column": 28
          },
          {
              "line": 132,
              "column": 35
          },
          {
              "line": 132,
              "column": 40
          },
          {
              "line": 133,
              "column": 29
          },
          {
              "line": 134,
              "column": 36
          },
          {
              "line": 135,
              "column": 27
          },
          {
              "line": 135,
              "column": 48
          },
          {
              "line": 136,
              "column": 11
          },
          {
              "line": 136,
              "column": 27
          },
          {
              "line": 136,
              "column": 29
          },
          {
              "line": 136,
              "column": 48
          },
          {
              "line": 136,
              "column": 50
          },
          {
              "line": 137,
              "column": 11
          },
          {
              "line": 137,
              "column": 26
          },
          {
              "line": 138,
              "column": 11
          },
          {
              "line": 138,
              "column": 34
          },
          {
              "line": 139,
              "column": 11
          },
          {
              "line": 140,
              "column": 11
          },
          {
              "line": 140,
              "column": 16
          },
          {
              "line": 140,
              "column": 25
          },
          {
              "line": 140,
              "column": 33
          },
          {
              "line": 140,
              "column": 42
          },
          {
              "line": 141,
              "column": 11
          },
          {
              "line": 141,
              "column": 26
          },
          {
              "line": 141,
              "column": 53
          },
          {
              "line": 142,
              "column": 11
          },
          {
              "line": 143,
              "column": 11
          },
          {
              "line": 143,
              "column": 29
          },
          {
              "line": 143,
              "column": 52
          },
          {
              "line": 144,
              "column": 11
          },
          {
              "line": 145,
              "column": 11
          },
          {
              "line": 145,
              "column": 14
          },
          {
              "line": 145,
              "column": 33
          },
          {
              "line": 146,
              "column": 11
          },
          {
              "line": 146,
              "column": 31
          },
          {
              "line": 146,
              "column": 61
          },
          {
              "line": 147,
              "column": 11
          },
          {
              "line": 147,
              "column": 26
          },
          {
              "line": 147,
              "column": 48
          },
          {
              "line": 148,
              "column": 11
          },
          {
              "line": 148,
              "column": 20
          },
          {
              "line": 148,
              "column": 23
          },
          {
              "line": 148,
              "column": 31
          },
          {
              "line": 148,
              "column": 44
          },
          {
              "line": 148,
              "column": 47
          },
          {
              "line": 148,
              "column": 55
          },
          {
              "line": 149,
              "column": 11
          },
          {
              "line": 152,
              "column": 40
          },
          {
              "line": 152,
              "column": 49
          },
          {
              "line": 152,
              "column": 60
          },
          {
              "line": 152,
              "column": 71
          },
          {
              "line": 153,
              "column": 11
          },
          {
              "line": 154,
              "column": 9
          },
          {
              "line": 154,
              "column": 56
          },
          {
              "line": 156,
              "column": 9
          },
          {
              "line": 156,
              "column": 64
          },
          {
              "line": 160,
              "column": 10
          },
          {
              "line": 160,
              "column": 36
          },
          {
              "line": 160,
              "column": 74
          },
          {
              "line": 162,
              "column": 17
          },
          {
              "line": 162,
              "column": 25
          },
          {
              "line": 163,
              "column": 39
          },
          {
              "line": 164,
              "column": 48
          },
          {
              "line": 166,
              "column": 9
          },
          {
              "line": 166,
              "column": 13
          },
          {
              "line": 166,
              "column": 21
          },
          {
              "line": 167,
              "column": 21
          },
          {
              "line": 167,
              "column": 30
          },
          {
              "line": 169,
              "column": 21
          },
          {
              "line": 169,
              "column": 33
          },
          {
              "line": 169,
              "column": 41
          },
          {
              "line": 172,
              "column": 19
          },
          {
              "line": 173,
              "column": 19
          },
          {
              "line": 173,
              "column": 53
          },
          {
              "line": 174,
              "column": 19
          },
          {
              "line": 174,
              "column": 40
          },
          {
              "line": 174,
              "column": 47
          },
          {
              "line": 174,
              "column": 52
          },
          {
              "line": 175,
              "column": 37
          },
          {
              "line": 177,
              "column": 29
          },
          {
              "line": 180,
              "column": 26
          },
          {
              "line": 180,
              "column": 39
          },
          {
              "line": 180,
              "column": 58
          },
          {
              "line": 180,
              "column": 71
          },
          {
              "line": 181,
              "column": 18
          },
          {
              "line": 182,
              "column": 7
          },
          {
              "line": 182,
              "column": 15
          },
          {
              "line": 182,
              "column": 26
          },
          {
              "line": 182,
              "column": 38
          },
          {
              "line": 182,
              "column": 90
          },
          {
              "line": 183,
              "column": 16
          },
          {
              "line": 184,
              "column": 23
          },
          {
              "line": 184,
              "column": 61
          },
          {
              "line": 184,
              "column": 74
          },
          {
              "line": 185,
              "column": 9
          },
          {
              "line": 185,
              "column": 30
          },
          {
              "line": 186,
              "column": 47
          },
          {
              "line": 188,
              "column": 24
          },
          {
              "line": 188,
              "column": 40
          },
          {
              "line": 188,
              "column": 51
          },
          {
              "line": 189,
              "column": 36
          },
          {
              "line": 190,
              "column": 16
          },
          {
              "line": 190,
              "column": 37
          },
          {
              "line": 191,
              "column": 46
          },
          {
              "line": 193,
              "column": 24
          },
          {
              "line": 193,
              "column": 40
          },
          {
              "line": 193,
              "column": 51
          },
          {
              "line": 194,
              "column": 35
          },
          {
              "line": 196,
              "column": 46
          },
          {
              "line": 203,
              "column": 16
          },
          {
              "line": 204,
              "column": 19
          },
          {
              "line": 204,
              "column": 21
          },
          {
              "line": 204,
              "column": 33
          },
          {
              "line": 204,
              "column": 60
          },
          {
              "line": 204,
              "column": 73
          },
          {
              "line": 207,
              "column": 7
          },
          {
              "line": 207,
              "column": 15
          },
          {
              "line": 207,
              "column": 29
          },
          {
              "line": 207,
              "column": 45
          },
          {
              "line": 209,
              "column": 59
          },
          {
              "line": 209,
              "column": 61
          },
          {
              "line": 210,
              "column": 21
          },
          {
              "line": 211,
              "column": 49
          },
          {
              "line": 213,
              "column": 29
          },
          {
              "line": 213,
              "column": 69
          },
          {
              "line": 216,
              "column": 7
          },
          {
              "line": 216,
              "column": 15
          },
          {
              "line": 217,
              "column": 26
          },
          {
              "line": 219,
              "column": 10
          },
          {
              "line": 220,
              "column": 17
          },
          {
              "line": 220,
              "column": 46
          },
          {
              "line": 220,
              "column": 92
          },
          {
              "line": 223,
              "column": 48
          },
          {
              "line": 224,
              "column": 12
          },
          {
              "line": 225,
              "column": 26
          },
          {
              "line": 229,
              "column": 7
          },
          {
              "line": 229,
              "column": 15
          },
          {
              "line": 230,
              "column": 26
          },
          {
              "line": 231,
              "column": 24
          },
          {
              "line": 231,
              "column": 27
          },
          {
              "line": 231,
              "column": 31
          },
          {
              "line": 231,
              "column": 46
          },
          {
              "line": 231,
              "column": 49
          },
          {
              "line": 231,
              "column": 53
          },
          {
              "line": 233,
              "column": 10
          },
          {
              "line": 234,
              "column": 20
          },
          {
              "line": 234,
              "column": 23
          },
          {
              "line": 234,
              "column": 27
          },
          {
              "line": 236,
              "column": 60
          },
          {
              "line": 236,
              "column": 86
          },
          {
              "line": 239,
              "column": 24
          },
          {
              "line": 239,
              "column": 43
          },
          {
              "line": 239,
              "column": 46
          },
          {
              "line": 239,
              "column": 66
          },
          {
              "line": 240,
              "column": 30
          },
          {
              "line": 240,
              "column": 32
          },
          {
              "line": 243,
              "column": 11
          },
          {
              "line": 244,
              "column": 32
          },
          {
              "line": 244,
              "column": 40
          },
          {
              "line": 249,
              "column": 7
          },
          {
              "line": 249,
              "column": 73
          },
          {
              "line": 251,
              "column": 26
          },
          {
              "line": 254,
              "column": 61
          },
          {
              "line": 255,
              "column": 59
          },
          {
              "line": 256,
              "column": 86
          },
          {
              "line": 259,
              "column": 13
          },
          {
              "line": 259,
              "column": 62
          },
          {
              "line": 263,
              "column": 51
          },
          {
              "line": 263,
              "column": 53
          },
          {
              "line": 264,
              "column": 46
          },
          {
              "line": 265,
              "column": 22
          },
          {
              "line": 271,
              "column": 7
          },
          {
              "line": 271,
              "column": 15
          },
          {
              "line": 271,
              "column": 31
          },
          {
              "line": 273,
              "column": 14
          },
          {
              "line": 273,
              "column": 19
          },
          {
              "line": 273,
              "column": 30
          },
          {
              "line": 273,
              "column": 47
          },
          {
              "line": 274,
              "column": 26
          },
          {
              "line": 275,
              "column": 28
          },
          {
              "line": 280,
              "column": 26
          },
          {
              "line": 280,
              "column": 28
          },
          {
              "line": 280,
              "column": 48
          },
          {
              "line": 280,
              "column": 58
          },
          {
              "line": 280,
              "column": 73
          },
          {
              "line": 280,
              "column": 80
          },
          {
              "line": 281,
              "column": 26
          },
          {
              "line": 281,
              "column": 91
          },
          {
              "line": 282,
              "column": 15
          },
          {
              "line": 282,
              "column": 19
          },
          {
              "line": 282,
              "column": 41
          },
          {
              "line": 282,
              "column": 73
          },
          {
              "line": 282,
              "column": 82
          },
          {
              "line": 282,
              "column": 86
          },
          {
              "line": 284,
              "column": 7
          },
          {
              "line": 284,
              "column": 15
          },
          {
              "line": 284,
              "column": 26
          },
          {
              "line": 284,
              "column": 35
          },
          {
              "line": 284,
              "column": 46
          },
          {
              "line": 285,
              "column": 26
          },
          {
              "line": 287,
              "column": 33
          },
          {
              "line": 287,
              "column": 43
          },
          {
              "line": 288,
              "column": 26
          },
          {
              "line": 288,
              "column": 28
          },
          {
              "line": 288,
              "column": 30
          },
          {
              "line": 289,
              "column": 42
          },
          {
              "line": 289,
              "column": 47
          },
          {
              "line": 289,
              "column": 80
          },
          {
              "line": 289,
              "column": 82
          },
          {
              "line": 290,
              "column": 73
          },
          {
              "line": 292,
              "column": 14
          },
          {
              "line": 292,
              "column": 25
          },
          {
              "line": 293,
              "column": 9
          },
          {
              "line": 293,
              "column": 13
          },
          {
              "line": 293,
              "column": 15
          },
          {
              "line": 293,
              "column": 17
          },
          {
              "line": 294,
              "column": 40
          },
          {
              "line": 294,
              "column": 42
          },
          {
              "line": 294,
              "column": 44
          },
          {
              "line": 295,
              "column": 13
          },
          {
              "line": 295,
              "column": 15
          },
          {
              "line": 295,
              "column": 20
          },
          {
              "line": 295,
              "column": 29
          },
          {
              "line": 295,
              "column": 33
          },
          {
              "line": 295,
              "column": 35
          },
          {
              "line": 295,
              "column": 37
          },
          {
              "line": 297,
              "column": 15
          },
          {
              "line": 300,
              "column": 25
          },
          {
              "line": 300,
              "column": 27
          },
          {
              "line": 300,
              "column": 57
          },
          {
              "line": 300,
              "column": 66
          },
          {
              "line": 301,
              "column": 33
          },
          {
              "line": 301,
              "column": 64
          },
          {
              "line": 302,
              "column": 15
          },
          {
              "line": 302,
              "column": 24
          },
          {
              "line": 302,
              "column": 27
          },
          {
              "line": 302,
              "column": 31
          },
          {
              "line": 302,
              "column": 36
          },
          {
              "line": 302,
              "column": 43
          },
          {
              "line": 302,
              "column": 46
          },
          {
              "line": 303,
              "column": 68
          },
          {
              "line": 305,
              "column": 32
          },
          {
              "line": 305,
              "column": 63
          },
          {
              "line": 306,
              "column": 15
          },
          {
              "line": 306,
              "column": 24
          },
          {
              "line": 306,
              "column": 27
          },
          {
              "line": 306,
              "column": 31
          },
          {
              "line": 306,
              "column": 36
          },
          {
              "line": 306,
              "column": 43
          },
          {
              "line": 306,
              "column": 46
          },
          {
              "line": 307,
              "column": 69
          },
          {
              "line": 311,
              "column": 13
          },
          {
              "line": 311,
              "column": 34
          },
          {
              "line": 312,
              "column": 50
          },
          {
              "line": 316,
              "column": 20
          },
          {
              "line": 317,
              "column": 27
          },
          {
              "line": 317,
              "column": 65
          },
          {
              "line": 317,
              "column": 75
          },
          {
              "line": 319,
              "column": 21
          },
          {
              "line": 320,
              "column": 42
          },
          {
              "line": 322,
              "column": 61
          },
          {
              "line": 327,
              "column": 30
          },
          {
              "line": 327,
              "column": 48
          },
          {
              "line": 328,
              "column": 42
          },
          {
              "line": 329,
              "column": 39
          },
          {
              "line": 329,
              "column": 65
          },
          {
              "line": 329,
              "column": 74
          },
          {
              "line": 331,
              "column": 18
          },
          {
              "line": 331,
              "column": 31
          },
          {
              "line": 331,
              "column": 39
          },
          {
              "line": 331,
              "column": 58
          },
          {
              "line": 331,
              "column": 66
          },
          {
              "line": 332,
              "column": 51
          },
          {
              "line": 332,
              "column": 59
          },
          {
              "line": 333,
              "column": 18
          },
          {
              "line": 333,
              "column": 31
          },
          {
              "line": 333,
              "column": 54
          },
          {
              "line": 334,
              "column": 51
          },
          {
              "line": 336,
              "column": 20
          },
          {
              "line": 336,
              "column": 26
          },
          {
              "line": 336,
              "column": 54
          },
          {
              "line": 336,
              "column": 68
          },
          {
              "line": 336,
              "column": 77
          },
          {
              "line": 337,
              "column": 23
          },
          {
              "line": 338,
              "column": 22
          },
          {
              "line": 338,
              "column": 26
          },
          {
              "line": 338,
              "column": 33
          },
          {
              "line": 338,
              "column": 49
          },
          {
              "line": 338,
              "column": 57
          },
          {
              "line": 338,
              "column": 65
          },
          {
              "line": 338,
              "column": 74
          },
          {
              "line": 339,
              "column": 30
          },
          {
              "line": 339,
              "column": 52
          },
          {
              "line": 339,
              "column": 76
          },
          {
              "line": 339,
              "column": 91
          },
          {
              "line": 341,
              "column": 30
          },
          {
              "line": 341,
              "column": 55
          },
          {
              "line": 342,
              "column": 31
          },
          {
              "line": 342,
              "column": 54
          },
          {
              "line": 342,
              "column": 73
          },
          {
              "line": 343,
              "column": 95
          },
          {
              "line": 344,
              "column": 47
          },
          {
              "line": 346,
              "column": 47
          },
          {
              "line": 347,
              "column": 42
          },
          {
              "line": 347,
              "column": 47
          },
          {
              "line": 349,
              "column": 49
          },
          {
              "line": 350,
              "column": 61
          },
          {
              "line": 352,
              "column": 25
          },
          {
              "line": 352,
              "column": 56
          },
          {
              "line": 354,
              "column": 27
          },
          {
              "line": 354,
              "column": 32
          },
          {
              "line": 354,
              "column": 41
          },
          {
              "line": 354,
              "column": 46
          },
          {
              "line": 356,
              "column": 29
          },
          {
              "line": 356,
              "column": 58
          },
          {
              "line": 356,
              "column": 63
          },
          {
              "line": 356,
              "column": 80
          },
          {
              "line": 357,
              "column": 37
          },
          {
              "line": 357,
              "column": 69
          },
          {
              "line": 358,
              "column": 35
          },
          {
              "line": 359,
              "column": 56
          },
          {
              "line": 359,
              "column": 67
          },
          {
              "line": 359,
              "column": 83
          },
          {
              "line": 361,
              "column": 37
          },
          {
              "line": 361,
              "column": 46
          },
          {
              "line": 361,
              "column": 56
          },
          {
              "line": 361,
              "column": 61
          },
          {
              "line": 361,
              "column": 63
          },
          {
              "line": 361,
              "column": 83
          },
          {
              "line": 367,
              "column": 29
          },
          {
              "line": 369,
              "column": 38
          },
          {
              "line": 369,
              "column": 42
          },
          {
              "line": 371,
              "column": 24
          },
          {
              "line": 372,
              "column": 27
          },
          {
              "line": 372,
              "column": 29
          },
          {
              "line": 372,
              "column": 41
          },
          {
              "line": 372,
              "column": 68
          },
          {
              "line": 372,
              "column": 78
          },
          {
              "line": 373,
              "column": 16
          },
          {
              "line": 374,
              "column": 30
          },
          {
              "line": 379,
              "column": 7
          },
          {
              "line": 379,
              "column": 15
          },
          {
              "line": 379,
              "column": 18
          },
          {
              "line": 379,
              "column": 20
          },
          {
              "line": 379,
              "column": 25
          },
          {
              "line": 379,
              "column": 34
          },
          {
              "line": 379,
              "column": 55
          },
          {
              "line": 379,
              "column": 57
          },
          {
              "line": 379,
              "column": 59
          },
          {
              "line": 379,
              "column": 83
          },
          {
              "line": 381,
              "column": 17
          },
          {
              "line": 381,
              "column": 19
          },
          {
              "line": 381,
              "column": 21
          },
          {
              "line": 381,
              "column": 31
          },
          {
              "line": 383,
              "column": 45
          },
          {
              "line": 383,
              "column": 47
          },
          {
              "line": 383,
              "column": 49
          },
          {
              "line": 384,
              "column": 68
          },
          {
              "line": 384,
              "column": 70
          },
          {
              "line": 384,
              "column": 72
          },
          {
              "line": 386,
              "column": 17
          },
          {
              "line": 386,
              "column": 32
          },
          {
              "line": 388,
              "column": 38
          },
          {
              "line": 388,
              "column": 43
          },
          {
              "line": 388,
              "column": 49
          },
          {
              "line": 388,
              "column": 54
          },
          {
              "line": 389,
              "column": 23
          },
          {
              "line": 390,
              "column": 23
          },
          {
              "line": 390,
              "column": 50
          },
          {
              "line": 392,
              "column": 21
          },
          {
              "line": 392,
              "column": 23
          },
          {
              "line": 392,
              "column": 25
          },
          {
              "line": 393,
              "column": 33
          },
          {
              "line": 394,
              "column": 31
          },
          {
              "line": 395,
              "column": 16
          },
          {
              "line": 395,
              "column": 32
          },
          {
              "line": 395,
              "column": 42
          },
          {
              "line": 395,
              "column": 54
          },
          {
              "line": 395,
              "column": 56
          },
          {
              "line": 395,
              "column": 58
          },
          {
              "line": 395,
              "column": 61
          },
          {
              "line": 395,
              "column": 65
          },
          {
              "line": 397,
              "column": 32
          },
          {
              "line": 397,
              "column": 35
          },
          {
              "line": 397,
              "column": 44
          },
          {
              "line": 401,
              "column": 12
          },
          {
              "line": 401,
              "column": 46
          },
          {
              "line": 402,
              "column": 7
          },
          {
              "line": 402,
              "column": 17
          },
          {
              "line": 402,
              "column": 45
          },
          {
              "line": 404,
              "column": 20
          },
          {
              "line": 404,
              "column": 27
          },
          {
              "line": 406,
              "column": 20
          },
          {
              "line": 406,
              "column": 27
          },
          {
              "line": 406,
              "column": 41
          },
          {
              "line": 406,
              "column": 67
          },
          {
              "line": 408,
              "column": 20
          },
          {
              "line": 408,
              "column": 27
          },
          {
              "line": 408,
              "column": 33
          },
          {
              "line": 408,
              "column": 46
          },
          {
              "line": 408,
              "column": 66
          },
          {
              "line": 410,
              "column": 20
          },
          {
              "line": 410,
              "column": 27
          },
          {
              "line": 410,
              "column": 33
          },
          {
              "line": 410,
              "column": 46
          },
          {
              "line": 410,
              "column": 54
          },
          {
              "line": 410,
              "column": 70
          },
          {
              "line": 410,
              "column": 78
          },
          {
              "line": 412,
              "column": 20
          },
          {
              "line": 412,
              "column": 27
          },
          {
              "line": 412,
              "column": 33
          },
          {
              "line": 414,
              "column": 11
          },
          {
              "line": 414,
              "column": 18
          },
          {
              "line": 414,
              "column": 30
          },
          {
              "line": 414,
              "column": 42
          },
          {
              "line": 416,
              "column": 11
          },
          {
              "line": 418,
              "column": 27
          },
          {
              "line": 418,
              "column": 40
          },
          {
              "line": 418,
              "column": 60
          },
          {
              "line": 419,
              "column": 27
          },
          {
              "line": 419,
              "column": 40
          },
          {
              "line": 419,
              "column": 48
          },
          {
              "line": 419,
              "column": 64
          },
          {
              "line": 419,
              "column": 72
          },
          {
              "line": 420,
              "column": 27
          },
          {
              "line": 421,
              "column": 15
          },
          {
              "line": 422,
              "column": 15
          },
          {
              "line": 422,
              "column": 34
          },
          {
              "line": 422,
              "column": 55
          },
          {
              "line": 423,
              "column": 15
          },
          {
              "line": 423,
              "column": 27
          },
          {
              "line": 423,
              "column": 49
          },
          {
              "line": 424,
              "column": 15
          },
          {
              "line": 424,
              "column": 27
          },
          {
              "line": 424,
              "column": 35
          },
          {
              "line": 424,
              "column": 53
          },
          {
              "line": 424,
              "column": 61
          },
          {
              "line": 425,
              "column": 15
          },
          {
              "line": 426,
              "column": 15
          },
          {
              "line": 426,
              "column": 25
          },
          {
              "line": 426,
              "column": 43
          },
          {
              "line": 429,
              "column": 15
          },
          {
              "line": 430,
              "column": 13
          },
          {
              "line": 430,
              "column": 18
          },
          {
              "line": 431,
              "column": 14
          },
          {
              "line": 431,
              "column": 27
          },
          {
              "line": 431,
              "column": 33
          },
          {
              "line": 431,
              "column": 48
          },
          {
              "line": 431,
              "column": 54
          },
          {
              "line": 432,
              "column": 31
          },
          {
              "line": 432,
              "column": 46
          },
          {
              "line": 432,
              "column": 54
          },
          {
              "line": 432,
              "column": 62
          },
          {
              "line": 433,
              "column": 22
          },
          {
              "line": 433,
              "column": 30
          },
          {
              "line": 433,
              "column": 63
          },
          {
              "line": 433,
              "column": 69
          },
          {
              "line": 433,
              "column": 88
          },
          {
              "line": 434,
              "column": 26
          },
          {
              "line": 434,
              "column": 31
          },
          {
              "line": 434,
              "column": 47
          },
          {
              "line": 434,
              "column": 53
          },
          {
              "line": 435,
              "column": 30
          },
          {
              "line": 435,
              "column": 36
          },
          {
              "line": 435,
              "column": 58
          },
          {
              "line": 436,
              "column": 17
          },
          {
              "line": 436,
              "column": 28
          },
          {
              "line": 436,
              "column": 50
          },
          {
              "line": 437,
              "column": 17
          },
          {
              "line": 437,
              "column": 31
          },
          {
              "line": 437,
              "column": 46
          },
          {
              "line": 438,
              "column": 17
          },
          {
              "line": 438,
              "column": 28
          },
          {
              "line": 439,
              "column": 17
          },
          {
              "line": 439,
              "column": 31
          },
          {
              "line": 439,
              "column": 46
          },
          {
              "line": 439,
              "column": 52
          },
          {
              "line": 440,
              "column": 17
          },
          {
              "line": 440,
              "column": 28
          },
          {
              "line": 440,
              "column": 41
          },
          {
              "line": 444,
              "column": 7
          },
          {
              "line": 446,
              "column": 26
          },
          {
              "line": 449,
              "column": 61
          },
          {
              "line": 450,
              "column": 59
          },
          {
              "line": 451,
              "column": 86
          },
          {
              "line": 454,
              "column": 24
          },
          {
              "line": 454,
              "column": 27
          },
          {
              "line": 454,
              "column": 31
          },
          {
              "line": 454,
              "column": 46
          },
          {
              "line": 454,
              "column": 49
          },
          {
              "line": 454,
              "column": 53
          },
          {
              "line": 457,
              "column": 10
          },
          {
              "line": 458,
              "column": 20
          },
          {
              "line": 458,
              "column": 23
          },
          {
              "line": 458,
              "column": 27
          },
          {
              "line": 460,
              "column": 10
          },
          {
              "line": 460,
              "column": 23
          },
          {
              "line": 460,
              "column": 31
          },
          {
              "line": 460,
              "column": 47
          },
          {
              "line": 460,
              "column": 55
          },
          {
              "line": 461,
              "column": 32
          },
          {
              "line": 461,
              "column": 40
          },
          {
              "line": 463,
              "column": 10
          },
          {
              "line": 463,
              "column": 23
          },
          {
              "line": 463,
              "column": 43
          },
          {
              "line": 464,
              "column": 27
          },
          {
              "line": 464,
              "column": 57
          },
          {
              "line": 467,
              "column": 30
          },
          {
              "line": 467,
              "column": 35
          },
          {
              "line": 468,
              "column": 59
          },
          {
              "line": 469,
              "column": 34
          },
          {
              "line": 469,
              "column": 42
          },
          {
              "line": 470,
              "column": 34
          },
          {
              "line": 471,
              "column": 38
          },
          {
              "line": 471,
              "column": 43
          },
          {
              "line": 471,
              "column": 62
          },
          {
              "line": 471,
              "column": 68
          },
          {
              "line": 472,
              "column": 35
          },
          {
              "line": 472,
              "column": 62
          },
          {
              "line": 472,
              "column": 68
          },
          {
              "line": 473,
              "column": 27
          },
          {
              "line": 473,
              "column": 50
          },
          {
              "line": 476,
              "column": 37
          },
          {
              "line": 476,
              "column": 58
          },
          {
              "line": 476,
              "column": 66
          },
          {
              "line": 480,
              "column": 10
          },
          {
              "line": 480,
              "column": 37
          },
          {
              "line": 480,
              "column": 51
          },
          {
              "line": 480,
              "column": 64
          },
          {
              "line": 480,
              "column": 72
          },
          {
              "line": 480,
              "column": 86
          },
          {
              "line": 483,
              "column": 7
          },
          {
              "line": 483,
              "column": 14
          },
          {
              "line": 483,
              "column": 27
          },
          {
              "line": 483,
              "column": 35
          },
          {
              "line": 483,
              "column": 57
          },
          {
              "line": 483,
              "column": 65
          },
          {
              "line": 484,
              "column": 14
          },
          {
              "line": 484,
              "column": 76
          },
          {
              "line": 484,
              "column": 92
          },
          {
              "line": 486,
              "column": 10
          },
          {
              "line": 486,
              "column": 23
          },
          {
              "line": 486,
              "column": 31
          },
          {
              "line": 486,
              "column": 47
          },
          {
              "line": 486,
              "column": 55
          },
          {
              "line": 487,
              "column": 27
          },
          {
              "line": 487,
              "column": 57
          },
          {
              "line": 490,
              "column": 16
          },
          {
              "line": 491,
              "column": 24
          },
          {
              "line": 492,
              "column": 22
          },
          {
              "line": 492,
              "column": 30
          },
          {
              "line": 492,
              "column": 45
          },
          {
              "line": 492,
              "column": 53
          },
          {
              "line": 493,
              "column": 34
          },
          {
              "line": 493,
              "column": 39
          },
          {
              "line": 493,
              "column": 58
          },
          {
              "line": 493,
              "column": 66
          },
          {
              "line": 495,
              "column": 31
          },
          {
              "line": 495,
              "column": 58
          },
          {
              "line": 495,
              "column": 64
          },
          {
              "line": 496,
              "column": 32
          },
          {
              "line": 496,
              "column": 48
          },
          {
              "line": 497,
              "column": 41
          },
          {
              "line": 497,
              "column": 70
          },
          {
              "line": 499,
              "column": 31
          },
          {
              "line": 499,
              "column": 51
          },
          {
              "line": 499,
              "column": 72
          },
          {
              "line": 501,
              "column": 22
          },
          {
              "line": 501,
              "column": 30
          },
          {
              "line": 501,
              "column": 50
          },
          {
              "line": 501,
              "column": 58
          },
          {
              "line": 503,
              "column": 25
          },
          {
              "line": 503,
              "column": 33
          },
          {
              "line": 506,
              "column": 17
          },
          {
              "line": 506,
              "column": 40
          },
          {
              "line": 507,
              "column": 7
          },
          {
              "line": 507,
              "column": 28
          },
          {
              "line": 507,
              "column": 31
          },
          {
              "line": 507,
              "column": 35
          },
          {
              "line": 508,
              "column": 26
          },
          {
              "line": 510,
              "column": 21
          },
          {
              "line": 513,
              "column": 13
          },
          {
              "line": 514,
              "column": 28
          },
          {
              "line": 514,
              "column": 37
          },
          {
              "line": 514,
              "column": 52
          },
          {
              "line": 515,
              "column": 23
          },
          {
              "line": 515,
              "column": 27
          },
          {
              "line": 515,
              "column": 46
          },
          {
              "line": 515,
              "column": 63
          },
          {
              "line": 516,
              "column": 33
          },
          {
              "line": 517,
              "column": 12
          },
          {
              "line": 518,
              "column": 13
          },
          {
              "line": 518,
              "column": 32
          },
          {
              "line": 518,
              "column": 43
          },
          {
              "line": 518,
              "column": 58
          },
          {
              "line": 519,
              "column": 17
          },
          {
              "line": 524,
              "column": 20
          },
          {
              "line": 524,
              "column": 23
          },
          {
              "line": 524,
              "column": 27
          },
          {
              "line": 524,
              "column": 62
          },
          {
              "line": 524,
              "column": 76
          },
          {
              "line": 525,
              "column": 28
          },
          {
              "line": 525,
              "column": 39
          },
          {
              "line": 525,
              "column": 44
          },
          {
              "line": 525,
              "column": 53
          },
          {
              "line": 526,
              "column": 12
          },
          {
              "line": 526,
              "column": 17
          },
          {
              "line": 526,
              "column": 20
          },
          {
              "line": 526,
              "column": 36
          },
          {
              "line": 526,
              "column": 46
          },
          {
              "line": 526,
              "column": 64
          },
          {
              "line": 527,
              "column": 17
          },
          {
              "line": 527,
              "column": 20
          },
          {
              "line": 527,
              "column": 24
          },
          {
              "line": 527,
              "column": 48
          },
          {
              "line": 527,
              "column": 55
          },
          {
              "line": 527,
              "column": 63
          },
          {
              "line": 528,
              "column": 28
          },
          {
              "line": 528,
              "column": 31
          },
          {
              "line": 528,
              "column": 62
          },
          {
              "line": 529,
              "column": 16
          },
          {
              "line": 530,
              "column": 13
          },
          {
              "line": 530,
              "column": 27
          },
          {
              "line": 530,
              "column": 30
          },
          {
              "line": 530,
              "column": 40
          },
          {
              "line": 531,
              "column": 24
          },
          {
              "line": 531,
              "column": 27
          },
          {
              "line": 531,
              "column": 31
          },
          {
              "line": 531,
              "column": 46
          },
          {
              "line": 531,
              "column": 49
          },
          {
              "line": 531,
              "column": 53
          },
          {
              "line": 532,
              "column": 36
          },
          {
              "line": 532,
              "column": 39
          },
          {
              "line": 532,
              "column": 43
          },
          {
              "line": 533,
              "column": 12
          },
          {
              "line": 533,
              "column": 15
          },
          {
              "line": 533,
              "column": 19
          },
          {
              "line": 533,
              "column": 43
          },
          {
              "line": 534,
              "column": 9
          },
          {
              "line": 534,
              "column": 14
          },
          {
              "line": 534,
              "column": 22
          },
          {
              "line": 534,
              "column": 25
          },
          {
              "line": 534,
              "column": 35
          },
          {
              "line": 534,
              "column": 37
          },
          {
              "line": 534,
              "column": 39
          },
          {
              "line": 535,
              "column": 33
          },
          {
              "line": 535,
              "column": 36
          },
          {
              "line": 535,
              "column": 53
          },
          {
              "line": 535,
              "column": 56
          },
          {
              "line": 535,
              "column": 59
          },
          {
              "line": 535,
              "column": 62
          },
          {
              "line": 535,
              "column": 70
          },
          {
              "line": 536,
              "column": 16
          },
          {
              "line": 536,
              "column": 30
          },
          {
              "line": 537,
              "column": 20
          },
          {
              "line": 537,
              "column": 23
          },
          {
              "line": 537,
              "column": 41
          },
          {
              "line": 537,
              "column": 44
          },
          {
              "line": 537,
              "column": 57
          },
          {
              "line": 537,
              "column": 60
          },
          {
              "line": 537,
              "column": 68
          },
          {
              "line": 537,
              "column": 89
          },
          {
              "line": 537,
              "column": 92
          },
          {
              "line": 538,
              "column": 33
          },
          {
              "line": 538,
              "column": 36
          },
          {
              "line": 538,
              "column": 47
          },
          {
              "line": 538,
              "column": 49
          },
          {
              "line": 538,
              "column": 51
          },
          {
              "line": 538,
              "column": 58
          },
          {
              "line": 538,
              "column": 72
          },
          {
              "line": 539,
              "column": 23
          },
          {
              "line": 539,
              "column": 26
          },
          {
              "line": 539,
              "column": 43
          },
          {
              "line": 539,
              "column": 49
          },
          {
              "line": 539,
              "column": 52
          },
          {
              "line": 539,
              "column": 55
          },
          {
              "line": 539,
              "column": 62
          },
          {
              "line": 539,
              "column": 71
          },
          {
              "line": 539,
              "column": 78
          },
          {
              "line": 540,
              "column": 20
          },
          {
              "line": 540,
              "column": 23
          },
          {
              "line": 540,
              "column": 39
          },
          {
              "line": 540,
              "column": 41
          },
          {
              "line": 540,
              "column": 43
          },
          {
              "line": 540,
              "column": 56
          },
          {
              "line": 540,
              "column": 59
          },
          {
              "line": 541,
              "column": 27
          },
          {
              "line": 541,
              "column": 30
          },
          {
              "line": 541,
              "column": 38
          },
          {
              "line": 541,
              "column": 50
          },
          {
              "line": 541,
              "column": 57
          },
          {
              "line": 541,
              "column": 60
          },
          {
              "line": 542,
              "column": 32
          },
          {
              "line": 542,
              "column": 35
          },
          {
              "line": 542,
              "column": 39
          },
          {
              "line": 542,
              "column": 57
          },
          {
              "line": 542,
              "column": 60
          },
          {
              "line": 543,
              "column": 13
          },
          {
              "line": 543,
              "column": 23
          },
          {
              "line": 543,
              "column": 26
          },
          {
              "line": 543,
              "column": 43
          },
          {
              "line": 543,
              "column": 51
          },
          {
              "line": 543,
              "column": 61
          },
          {
              "line": 543,
              "column": 66
          },
          {
              "line": 544,
              "column": 30
          },
          {
              "line": 544,
              "column": 33
          },
          {
              "line": 544,
              "column": 50
          },
          {
              "line": 544,
              "column": 60
          },
          {
              "line": 545,
              "column": 33
          },
          {
              "line": 545,
              "column": 38
          },
          {
              "line": 545,
              "column": 47
          },
          {
              "line": 546,
              "column": 41
          },
          {
              "line": 546,
              "column": 44
          },
          {
              "line": 547,
              "column": 45
          },
          {
              "line": 547,
              "column": 48
          },
          {
              "line": 548,
              "column": 52
          },
          {
              "line": 548,
              "column": 58
          },
          {
              "line": 548,
              "column": 70
          },
          {
              "line": 548,
              "column": 82
          },
          {
              "line": 548,
              "column": 85
          },
          {
              "line": 549,
              "column": 41
          },
          {
              "line": 549,
              "column": 44
          },
          {
              "line": 549,
              "column": 52
          },
          {
              "line": 549,
              "column": 61
          },
          {
              "line": 549,
              "column": 74
          },
          {
              "line": 549,
              "column": 77
          },
          {
              "line": 553,
              "column": 13
          },
          {
              "line": 553,
              "column": 21
          },
          {
              "line": 553,
              "column": 24
          },
          {
              "line": 553,
              "column": 34
          },
          {
              "line": 553,
              "column": 36
          },
          {
              "line": 553,
              "column": 38
          },
          {
              "line": 556,
              "column": 19
          },
          {
              "line": 556,
              "column": 22
          },
          {
              "line": 556,
              "column": 26
          },
          {
              "line": 559,
              "column": 11
          },
          {
              "line": 560,
              "column": 9
          },
          {
              "line": 560,
              "column": 14
          },
          {
              "line": 560,
              "column": 38
          },
          {
              "line": 561,
              "column": 11
          }
      ],
      "old_name": "i",
      "new_name": "descIdx",
      "ctx": {
          "symbolName": "i",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in restoreWithRescaling(...)",
          "filePath": "RocksDBIncrementalRestoreOperation.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Recovery from multi incremental states with rescaling. For rescaling, this method creates a\n     * temporary RocksDB instance for a key-groups shard. All contents from the temporary instance\n     * are copied into the real restore instance and then the temporary instance is discarded.\n     */\n    private void restoreWithRescaling(Collection<KeyedStateHandle> restoreStateHandles)\n            throws Exception {\n\n        // Prepare for restore with rescaling\n        KeyedStateHandle initialHandle =\n                RocksDBIncrementalCheckpointUtils.chooseTheBestStateHandleForInitial(\n                        restoreStateHandles, keyGroupRange, overlapFractionThreshold);\n\n        // Init base DB instance\n        if (initialHandle != null) {\n            restoreStateHandles.remove(initialHandle);\n            initDBWithRescaling(initialHandle);\n        } else {\n            this.rocksHandle.openDB();\n        }\n\n        // Transfer remaining key-groups from temporary instance into base DB\n        byte[] startKeyGroupPrefixBytes = new byte[keyGroupPrefixBytes];\n        CompositeKeySerializationUtils.serializeKeyGroup(\n                keyGroupRange.getStartKeyGroup(), startKeyGroupPrefixBytes);\n\n        byte[] stopKeyGroupPrefixBytes = new byte[keyGroupPrefixBytes];\n        CompositeKeySerializationUtils.serializeKeyGroup(\n                keyGroupRange.getEndKeyGroup() + 1, stopKeyGroupPrefixBytes);\n\n        for (KeyedStateHandle rawStateHandle : restoreStateHandles) {\n\n            if (!(rawStateHandle instanceof IncrementalRemoteKeyedStateHandle)) {\n                throw unexpectedStateHandleException(\n                        IncrementalRemoteKeyedStateHandle.class, rawStateHandle.getClass());\n            }\n\n            logger.info(\n                    \"Starting to restore from state handle: {} with rescaling.\", rawStateHandle);\n            Path temporaryRestoreInstancePath =\n                    instanceBasePath\n                            .getAbsoluteFile()\n                            .toPath()\n                            .resolve(UUID.randomUUID().toString());\n            try (RestoredDBInstance tmpRestoreDBInfo =\n                            restoreDBInstanceFromStateHandle(\n                                    (IncrementalRemoteKeyedStateHandle) rawStateHandle,\n                                    temporaryRestoreInstancePath);\n                    RocksDBWriteBatchWrapper writeBatchWrapper =\n                            new RocksDBWriteBatchWrapper(\n                                    this.rocksHandle.getDb(), writeBatchSize)) {\n\n                List<ColumnFamilyDescriptor> tmpColumnFamilyDescriptors =\n                        tmpRestoreDBInfo.columnFamilyDescriptors;\n                List<ColumnFamilyHandle> tmpColumnFamilyHandles =\n                        tmpRestoreDBInfo.columnFamilyHandles;\n\n                // iterating only the requested descriptors automatically skips the default column\n                // family handle\n                for (int i = 0; i < tmpColumnFamilyDescriptors.size(); ++i) {\n                    ColumnFamilyHandle tmpColumnFamilyHandle = tmpColumnFamilyHandles.get(i);\n\n                    ColumnFamilyHandle targetColumnFamilyHandle =\n                            this.rocksHandle.getOrRegisterStateColumnFamilyHandle(\n                                            null, tmpRestoreDBInfo.stateMetaInfoSnapshots.get(i))\n                                    .columnFamilyHandle;\n\n                    try (RocksIteratorWrapper iterator =\n                            RocksDBOperationUtils.getRocksIterator(\n                                    tmpRestoreDBInfo.db,\n                                    tmpColumnFamilyHandle,\n                                    tmpRestoreDBInfo.readOptions)) {\n\n                        iterator.seek(startKeyGroupPrefixBytes);\n\n                        while (iterator.isValid()) {\n\n                            if (RocksDBIncrementalCheckpointUtils.beforeThePrefixBytes(\n                                    iterator.key(), stopKeyGroupPrefixBytes)) {\n                                writeBatchWrapper.put(\n                                        targetColumnFamilyHandle, iterator.key(), iterator.value());\n                            } else {\n                                // Since the iterator will visit the record according to the sorted\n                                // order,\n                                // we can just break here.\n                                break;\n                            }\n\n                            iterator.next();\n                        }\n                    } // releases native iterator resources\n                }\n                logger.info(\n                        \"Finished restoring from state handle: {} with rescaling.\", rawStateHandle);\n            } finally {\n                cleanUpPathQuietly(temporaryRestoreInstancePath);\n            }\n        }\n    }",
          "conflictNames": [
              "restoreStateHandles",
              "initialHandle",
              "startKeyGroupPrefixBytes",
              "stopKeyGroupPrefixBytes",
              "temporaryRestoreInstancePath",
              "tmpRestoreDBInfo",
              "writeBatchWrapper",
              "tmpColumnFamilyDescriptors",
              "tmpColumnFamilyHandles",
              "tmpColumnFamilyHandle",
              "targetColumnFamilyHandle",
              "iterator"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2ed858318f38eb9913e5f4b3019be6b6d0a8e6fb^1/flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBStateDownloaderTest.java",
      "locators": [
          {
              "line": 89,
              "column": 13
          },
          {
              "line": 90,
              "column": 38
          },
          {
              "line": 91,
              "column": 29
          },
          {
              "line": 96,
              "column": 59
          },
          {
              "line": 97,
              "column": 29
          },
          {
              "line": 101,
              "column": 76
          },
          {
              "line": 102,
              "column": 77
          },
          {
              "line": 103,
              "column": 29
          },
          {
              "line": 124,
              "column": 29
          }
      ],
      "old_name": "contentNum",
      "new_name": "numSubHandles",
      "ctx": {
          "symbolName": "contentNum",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in testMultiThreadRestoreCorrectly(...)",
          "filePath": "RocksDBStateDownloaderTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Tests that download files with multi-thread correctly. */\n    @Test\n    public void testMultiThreadRestoreCorrectly() throws Exception {\n        Random random = new Random();\n        int contentNum = 6;\n        byte[][] contents = new byte[contentNum][];\n        for (int i = 0; i < contentNum; ++i) {\n            contents[i] = new byte[random.nextInt(100000) + 1];\n            random.nextBytes(contents[i]);\n        }\n\n        List<StreamStateHandle> handles = new ArrayList<>(contentNum);\n        for (int i = 0; i < contentNum; ++i) {\n            handles.add(new ByteStreamStateHandle(String.format(\"state%d\", i), contents[i]));\n        }\n\n        Map<StateHandleID, StreamStateHandle> sharedStates = new HashMap<>(contentNum);\n        Map<StateHandleID, StreamStateHandle> privateStates = new HashMap<>(contentNum);\n        for (int i = 0; i < contentNum; ++i) {\n            sharedStates.put(new StateHandleID(String.format(\"sharedState%d\", i)), handles.get(i));\n            privateStates.put(\n                    new StateHandleID(String.format(\"privateState%d\", i)), handles.get(i));\n        }\n\n        IncrementalRemoteKeyedStateHandle incrementalKeyedStateHandle =\n                new IncrementalRemoteKeyedStateHandle(\n                        UUID.randomUUID(),\n                        KeyGroupRange.of(0, 1),\n                        1,\n                        sharedStates,\n                        privateStates,\n                        handles.get(0));\n\n        Path dstPath = temporaryFolder.newFolder().toPath();\n        try (RocksDBStateDownloader rocksDBStateDownloader = new RocksDBStateDownloader(5)) {\n            rocksDBStateDownloader.transferAllStateDataToDirectory(\n                    incrementalKeyedStateHandle, dstPath, new CloseableRegistry());\n        }\n\n        for (int i = 0; i < contentNum; ++i) {\n            assertStateContentEqual(\n                    contents[i], dstPath.resolve(String.format(\"sharedState%d\", i)));\n        }\n    }",
          "conflictNames": [
              "random",
              "contents",
              "i",
              "handles",
              "sharedStates",
              "privateStates",
              "incrementalKeyedStateHandle",
              "dstPath",
              "rocksDBStateDownloader"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/2ed858318f38eb9913e5f4b3019be6b6d0a8e6fb^1/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBStateDownloader.java",
      "locators": [
          {
              "line": 68,
              "column": 78
          },
          {
              "line": 105,
              "column": 18
          },
          {
              "line": 111,
              "column": 45
          },
          {
              "line": 116,
              "column": 65
          }
      ],
      "old_name": "path",
      "new_name": "downloadDest",
      "ctx": {
          "symbolName": "path",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Path",
          "scopeHint": "in createDownloadRunnables(...)",
          "filePath": "RocksDBStateDownloader.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private List<Runnable> createDownloadRunnables(\n            Map<StateHandleID, StreamStateHandle> stateHandleMap,\n            Path restoreInstancePath,\n            CloseableRegistry closeableRegistry) {\n        List<Runnable> runnables = new ArrayList<>(stateHandleMap.size());\n        for (Map.Entry<StateHandleID, StreamStateHandle> entry : stateHandleMap.entrySet()) {\n            StateHandleID stateHandleID = entry.getKey();\n            StreamStateHandle remoteFileHandle = entry.getValue();\n\n            Path path = restoreInstancePath.resolve(stateHandleID.toString());\n\n            runnables.add(\n                    ThrowingRunnable.unchecked(\n                            () ->\n                                    downloadDataForStateHandle(\n                                            path, remoteFileHandle, closeableRegistry)));\n        }\n        return runnables;\n    }",
          "conflictNames": [
              "stateHandleMap",
              "restoreInstancePath",
              "closeableRegistry",
              "runnables",
              "stateHandleID",
              "remoteFileHandle"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/309e3246e0232a0a363aa44ab6d5524133f8f548^1/flink-table/flink-sql-gateway/src/main/java/org/apache/flink/table/gateway/rest/handler/materializedtable/scheduler/CreateEmbeddedSchedulerWorkflowHandler.java",
      "locators": [
          {
              "line": 75,
              "column": 29
          },
          {
              "line": 82,
              "column": 25
          },
          {
              "line": 82,
              "column": 75
          }
      ],
      "old_name": "dynamicOptions",
      "new_name": "initConfig",
      "ctx": {
          "symbolName": "dynamicOptions",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Map<String, String>",
          "scopeHint": "in handleRequest(...)",
          "filePath": "CreateEmbeddedSchedulerWorkflowHandler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    protected CompletableFuture<CreateEmbeddedSchedulerWorkflowResponseBody> handleRequest(\n            @Nullable SqlGatewayRestAPIVersion version,\n            @Nonnull HandlerRequest<CreateEmbeddedSchedulerWorkflowRequestBody> request)\n            throws RestHandlerException {\n        String materializedTableIdentifier =\n                request.getRequestBody().getMaterializedTableIdentifier();\n        String cronExpression = request.getRequestBody().getCronExpression();\n        Map<String, String> dynamicOptions = request.getRequestBody().getDynamicOptions();\n        Map<String, String> executionConfig = request.getRequestBody().getExecutionConfig();\n        String customScheduleTime = request.getRequestBody().getCustomScheduleTime();\n        String restEndpointURL = request.getRequestBody().getRestEndpointUrl();\n        WorkflowInfo workflowInfo =\n                new WorkflowInfo(\n                        materializedTableIdentifier,\n                        dynamicOptions == null ? Collections.emptyMap() : dynamicOptions,\n                        executionConfig == null ? Collections.emptyMap() : executionConfig,\n                        customScheduleTime,\n                        restEndpointURL);\n        try {\n            JobDetail jobDetail =\n                    quartzScheduler.createScheduleWorkflow(workflowInfo, cronExpression);\n            JobKey jobKey = jobDetail.getKey();\n            return CompletableFuture.completedFuture(\n                    new CreateEmbeddedSchedulerWorkflowResponseBody(\n                            jobKey.getName(), jobKey.getGroup()));\n        } catch (Exception e) {\n            throw new RestHandlerException(\n                    e.getMessage(), HttpResponseStatus.INTERNAL_SERVER_ERROR, e);\n        }\n    }",
          "conflictNames": [
              "version",
              "request",
              "materializedTableIdentifier",
              "cronExpression",
              "executionConfig",
              "customScheduleTime",
              "restEndpointURL",
              "workflowInfo",
              "jobDetail",
              "jobKey"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/30d75f1511b2b2beac4d7f18ee20941b3bd4cbe8^1/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/ForStStateBackend.java",
      "locators": [
          {
              "line": 311,
              "column": 16
          },
          {
              "line": 314,
              "column": 61
          },
          {
              "line": 316,
              "column": 77
          }
      ],
      "old_name": "childPath",
      "new_name": "opChildPath",
      "ctx": {
          "symbolName": "childPath",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in createAsyncKeyedStateBackend(...)",
          "filePath": "ForStStateBackend.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public <K> ForStKeyedStateBackend<K> createAsyncKeyedStateBackend(\n            KeyedStateBackendParameters<K> parameters) throws IOException {\n        Environment env = parameters.getEnv();\n\n        // first, make sure that the ForSt JNI library is loaded\n        // we do this explicitly here to have better error handling\n        String tempDir = env.getTaskManagerInfo().getTmpWorkingDirectory().getAbsolutePath();\n        ensureForStIsLoaded(tempDir);\n\n        // replace all characters that are not legal for filenames with underscore\n        String fileCompatibleIdentifier =\n                parameters.getOperatorIdentifier().replaceAll(\"[^a-zA-Z0-9\\\\-]\", \"_\");\n\n        lazyInitializeForJob(env, fileCompatibleIdentifier);\n\n        String childPath =\n                \"job_\" + jobId + \"_op_\" + fileCompatibleIdentifier + \"_uuid_\" + UUID.randomUUID();\n\n        File localBasePath = new File(getNextStoragePath(), childPath);\n        URI remoteBasePath =\n                remoteForStDirectory != null ? remoteForStDirectory.resolve(childPath) : null;\n\n        final OpaqueMemoryResource<ForStSharedResources> sharedResources =\n                ForStOperationUtils.allocateSharedCachesIfConfigured(\n                        memoryConfiguration,\n                        env,\n                        parameters.getManagedMemoryFraction(),\n                        LOG,\n                        forStMemoryFactory);\n        if (sharedResources != null) {\n            LOG.info(\"Obtained shared ForSt cache of size {} bytes\", sharedResources.getSize());\n        }\n        final ForStResourceContainer resourceContainer =\n                createOptionsAndResourceContainer(\n                        sharedResources,\n                        localBasePath,\n                        remoteBasePath,\n                        nativeMetricOptions.isStatisticsEnabled());\n\n        ForStKeyedStateBackendBuilder<K> builder =\n                new ForStKeyedStateBackendBuilder<>(\n                                resourceContainer,\n                                stateName -> resourceContainer.getColumnOptions(),\n                                parameters.getKeySerializer(),\n                                parameters.getNumberOfKeyGroups(),\n                                parameters.getMetricGroup(),\n                                parameters.getStateHandles())\n                        .setNativeMetricOptions(\n                                resourceContainer.getMemoryWatcherOptions(nativeMetricOptions));\n        return builder.build();\n    }",
          "conflictNames": [
              "parameters",
              "env",
              "tempDir",
              "fileCompatibleIdentifier",
              "localBasePath",
              "remoteBasePath",
              "sharedResources",
              "resourceContainer",
              "builder"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/31d6ce89c1934d0d312c5d240bed7b21f4370e51^1/flink-state-backends/flink-statebackend-forst/src/test/java/org/apache/flink/state/forst/ForStResourceContainerTest.java",
      "locators": [
          {
              "line": 334,
              "column": 20
          },
          {
              "line": 336,
              "column": 67
          }
      ],
      "old_name": "forstFileSystem",
      "new_name": "fileSystem",
      "ctx": {
          "symbolName": "forstFileSystem",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "FileSystem",
          "scopeHint": "in testFileSystemInit(...)",
          "filePath": "ForStResourceContainerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testFileSystemInit() throws Exception {\n        Path localBasePath = new Path(TMP_FOLDER.newFolder().getPath());\n        Path remoteBasePath = new Path(TMP_FOLDER.newFolder().getPath());\n        ArrayList<ColumnFamilyHandle> columnFamilyHandles = new ArrayList<>(1);\n        ArrayList<ColumnFamilyDescriptor> columnFamilyDescriptors = new ArrayList<>(1);\n        columnFamilyDescriptors.add(new ColumnFamilyDescriptor(RocksDB.DEFAULT_COLUMN_FAMILY));\n        DBOptions dbOptions2 =\n                new DBOptions().setCreateIfMissing(true).setAvoidFlushDuringShutdown(true);\n        FileSystem forstFileSystem =\n                ForStFlinkFileSystem.get(remoteBasePath.toUri(), localBasePath, null);\n        dbOptions2.setEnv(new FlinkEnv(remoteBasePath.toString(), forstFileSystem));\n        RocksDB db =\n                RocksDB.open(\n                        dbOptions2,\n                        remoteBasePath.getPath(),\n                        columnFamilyDescriptors,\n                        columnFamilyHandles);\n        db.put(\"key\".getBytes(), \"value\".getBytes());\n        db.getSnapshot();\n        db.close();\n    }",
          "conflictNames": [
              "localBasePath",
              "remoteBasePath",
              "columnFamilyHandles",
              "columnFamilyDescriptors",
              "dbOptions2",
              "db"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/324b54cf413229f78e6e709aaaa2e16a03d45df1^1/flink-yarn/src/main/java/org/apache/flink/yarn/YarnClusterDescriptor.java",
      "locators": [
          {
              "line": 15,
              "column": 48
          },
          {
              "line": 23,
              "column": 31
          },
          {
              "line": 26,
              "column": 56
          },
          {
              "line": 29,
              "column": 56
          },
          {
              "line": 38,
              "column": 44
          },
          {
              "line": 52,
              "column": 49
          },
          {
              "line": 58,
              "column": 79
          },
          {
              "line": 59,
              "column": 71
          },
          {
              "line": 98,
              "column": 39
          },
          {
              "line": 103,
              "column": 10
          },
          {
              "line": 105,
              "column": 10
          },
          {
              "line": 106,
              "column": 10
          },
          {
              "line": 107,
              "column": 10
          },
          {
              "line": 108,
              "column": 10
          },
          {
              "line": 109,
              "column": 10
          },
          {
              "line": 110,
              "column": 10
          },
          {
              "line": 111,
              "column": 10
          },
          {
              "line": 112,
              "column": 10
          },
          {
              "line": 112,
              "column": 28
          },
          {
              "line": 113,
              "column": 10
          },
          {
              "line": 114,
              "column": 10
          },
          {
              "line": 115,
              "column": 10
          },
          {
              "line": 116,
              "column": 10
          },
          {
              "line": 117,
              "column": 10
          },
          {
              "line": 118,
              "column": 10
          },
          {
              "line": 119,
              "column": 10
          },
          {
              "line": 120,
              "column": 10
          },
          {
              "line": 121,
              "column": 10
          },
          {
              "line": 122,
              "column": 10
          },
          {
              "line": 123,
              "column": 10
          },
          {
              "line": 124,
              "column": 10
          },
          {
              "line": 125,
              "column": 10
          },
          {
              "line": 126,
              "column": 10
          },
          {
              "line": 127,
              "column": 10
          },
          {
              "line": 133,
              "column": 79
          },
          {
              "line": 141,
              "column": 8
          },
          {
              "line": 143,
              "column": 8
          },
          {
              "line": 145,
              "column": 8
          },
          {
              "line": 147,
              "column": 8
          },
          {
              "line": 147,
              "column": 47
          },
          {
              "line": 147,
              "column": 79
          },
          {
              "line": 150,
              "column": 8
          },
          {
              "line": 153,
              "column": 8
          },
          {
              "line": 155,
              "column": 8
          },
          {
              "line": 155,
              "column": 39
          },
          {
              "line": 157,
              "column": 8
          },
          {
              "line": 159,
              "column": 8
          },
          {
              "line": 161,
              "column": 8
          },
          {
              "line": 163,
              "column": 8
          },
          {
              "line": 165,
              "column": 8
          },
          {
              "line": 167,
              "column": 8
          },
          {
              "line": 169,
              "column": 8
          },
          {
              "line": 175,
              "column": 41
          },
          {
              "line": 175,
              "column": 73
          },
          {
              "line": 180,
              "column": 42
          },
          {
              "line": 181,
              "column": 72
          },
          {
              "line": 191,
              "column": 46
          },
          {
              "line": 199,
              "column": 8
          },
          {
              "line": 209,
              "column": 8
          },
          {
              "line": 228,
              "column": 8
          },
          {
              "line": 237,
              "column": 64
          },
          {
              "line": 270,
              "column": 12
          },
          {
              "line": 281,
              "column": 19
          },
          {
              "line": 285,
              "column": 69
          },
          {
              "line": 290,
              "column": 12
          },
          {
              "line": 293,
              "column": 54
          },
          {
              "line": 299,
              "column": 8
          },
          {
              "line": 299,
              "column": 13
          },
          {
              "line": 299,
              "column": 30
          },
          {
              "line": 299,
              "column": 54
          },
          {
              "line": 301,
              "column": 24
          },
          {
              "line": 301,
              "column": 49
          },
          {
              "line": 301,
              "column": 66
          },
          {
              "line": 302,
              "column": 27
          },
          {
              "line": 303,
              "column": 23
          },
          {
              "line": 303,
              "column": 43
          },
          {
              "line": 306,
              "column": 8
          },
          {
              "line": 306,
              "column": 35
          },
          {
              "line": 306,
              "column": 60
          },
          {
              "line": 321,
              "column": 8
          },
          {
              "line": 321,
              "column": 13
          },
          {
              "line": 330,
              "column": 52
          },
          {
              "line": 331,
              "column": 66
          },
          {
              "line": 337,
              "column": 54
          },
          {
              "line": 338,
              "column": 71
          },
          {
              "line": 338,
              "column": 89
          },
          {
              "line": 345,
              "column": 71
          },
          {
              "line": 349,
              "column": 54
          },
          {
              "line": 350,
              "column": 71
          },
          {
              "line": 350,
              "column": 89
          },
          {
              "line": 351,
              "column": 72
          },
          {
              "line": 356,
              "column": 39
          },
          {
              "line": 356,
              "column": 49
          },
          {
              "line": 357,
              "column": 25
          },
          {
              "line": 357,
              "column": 69
          },
          {
              "line": 359,
              "column": 74
          },
          {
              "line": 359,
              "column": 84
          },
          {
              "line": 373,
              "column": 7
          },
          {
              "line": 374,
              "column": 12
          },
          {
              "line": 381,
              "column": 23
          },
          {
              "line": 384,
              "column": 7
          },
          {
              "line": 385,
              "column": 28
          },
          {
              "line": 385,
              "column": 55
          },
          {
              "line": 386,
              "column": 33
          },
          {
              "line": 389,
              "column": 43
          },
          {
              "line": 389,
              "column": 53
          },
          {
              "line": 390,
              "column": 29
          },
          {
              "line": 391,
              "column": 36
          },
          {
              "line": 393,
              "column": 78
          },
          {
              "line": 393,
              "column": 88
          },
          {
              "line": 403,
              "column": 76
          },
          {
              "line": 416,
              "column": 64
          },
          {
              "line": 420,
              "column": 36
          },
          {
              "line": 420,
              "column": 64
          },
          {
              "line": 424,
              "column": 7
          },
          {
              "line": 425,
              "column": 28
          },
          {
              "line": 439,
              "column": 7
          },
          {
              "line": 440,
              "column": 28
          },
          {
              "line": 461,
              "column": 39
          },
          {
              "line": 468,
              "column": 82
          },
          {
              "line": 483,
              "column": 7
          },
          {
              "line": 484,
              "column": 28
          },
          {
              "line": 502,
              "column": 7
          },
          {
              "line": 503,
              "column": 12
          },
          {
              "line": 522,
              "column": 72
          },
          {
              "line": 531,
              "column": 8
          },
          {
              "line": 531,
              "column": 29
          },
          {
              "line": 547,
              "column": 47
          },
          {
              "line": 574,
              "column": 31
          },
          {
              "line": 586,
              "column": 38
          },
          {
              "line": 598,
              "column": 48
          },
          {
              "line": 603,
              "column": 36
          },
          {
              "line": 605,
              "column": 13
          },
          {
              "line": 606,
              "column": 21
          },
          {
              "line": 613,
              "column": 47
          },
          {
              "line": 631,
              "column": 25
          },
          {
              "line": 633,
              "column": 63
          },
          {
              "line": 650,
              "column": 8
          },
          {
              "line": 650,
              "column": 34
          },
          {
              "line": 671,
              "column": 134
          },
          {
              "line": 674,
              "column": 45
          },
          {
              "line": 674,
              "column": 92
          },
          {
              "line": 685,
              "column": 45
          },
          {
              "line": 685,
              "column": 94
          },
          {
              "line": 696,
              "column": 99
          },
          {
              "line": 698,
              "column": 50
          },
          {
              "line": 726,
              "column": 8
          },
          {
              "line": 726,
              "column": 13
          },
          {
              "line": 738,
              "column": 77
          },
          {
              "line": 748,
              "column": 8
          },
          {
              "line": 748,
              "column": 13
          },
          {
              "line": 769,
              "column": 41
          },
          {
              "line": 773,
              "column": 56
          },
          {
              "line": 783,
              "column": 8
          },
          {
              "line": 800,
              "column": 72
          },
          {
              "line": 808,
              "column": 134
          },
          {
              "line": 814,
              "column": 29
          },
          {
              "line": 815,
              "column": 44
          },
          {
              "line": 817,
              "column": 33
          },
          {
              "line": 818,
              "column": 44
          },
          {
              "line": 826,
              "column": 28
          },
          {
              "line": 849,
              "column": 18
          },
          {
              "line": 849,
              "column": 41
          },
          {
              "line": 849,
              "column": 60
          },
          {
              "line": 850,
              "column": 20
          },
          {
              "line": 856,
              "column": 17
          },
          {
              "line": 856,
              "column": 26
          },
          {
              "line": 896,
              "column": 16
          },
          {
              "line": 896,
              "column": 43
          },
          {
              "line": 900,
              "column": 37
          },
          {
              "line": 900,
              "column": 83
          },
          {
              "line": 901,
              "column": 86
          },
          {
              "line": 902,
              "column": 71
          },
          {
              "line": 914,
              "column": 16
          },
          {
              "line": 914,
              "column": 43
          },
          {
              "line": 925,
              "column": 23
          },
          {
              "line": 927,
              "column": 30
          },
          {
              "line": 953,
              "column": 16
          },
          {
              "line": 956,
              "column": 58
          },
          {
              "line": 1002,
              "column": 21
          },
          {
              "line": 1039,
              "column": 20
          },
          {
              "line": 1040,
              "column": 17
          },
          {
              "line": 1041,
              "column": 17
          },
          {
              "line": 1042,
              "column": 49
          },
          {
              "line": 1042,
              "column": 77
          },
          {
              "line": 1043,
              "column": 31
          },
          {
              "line": 1069,
              "column": 97
          },
          {
              "line": 1073,
              "column": 39
          },
          {
              "line": 1075,
              "column": 25
          },
          {
              "line": 1076,
              "column": 43
          },
          {
              "line": 1091,
              "column": 39
          },
          {
              "line": 1094,
              "column": 47
          },
          {
              "line": 1129,
              "column": 59
          },
          {
              "line": 1155,
              "column": 29
          },
          {
              "line": 1155,
              "column": 51
          },
          {
              "line": 1155,
              "column": 79
          },
          {
              "line": 1156,
              "column": 33
          },
          {
              "line": 1160,
              "column": 75
          },
          {
              "line": 1160,
              "column": 105
          },
          {
              "line": 1167,
              "column": 34
          },
          {
              "line": 1167,
              "column": 44
          },
          {
              "line": 1168,
              "column": 46
          },
          {
              "line": 1169,
              "column": 44
          },
          {
              "line": 1176,
              "column": 24
          },
          {
              "line": 1178,
              "column": 24
          },
          {
              "line": 1180,
              "column": 28
          },
          {
              "line": 1186,
              "column": 24
          },
          {
              "line": 1190,
              "column": 24
          },
          {
              "line": 1193,
              "column": 26
          },
          {
              "line": 1193,
              "column": 47
          },
          {
              "line": 1253,
              "column": 117
          },
          {
              "line": 1269,
              "column": 117
          },
          {
              "line": 1276,
              "column": 49
          },
          {
              "line": 1277,
              "column": 30
          },
          {
              "line": 1281,
              "column": 8
          },
          {
              "line": 1281,
              "column": 13
          },
          {
              "line": 1281,
              "column": 22
          },
          {
              "line": 1289,
              "column": 42
          },
          {
              "line": 1289,
              "column": 82
          },
          {
              "line": 1291,
              "column": 47
          },
          {
              "line": 1295,
              "column": 8
          },
          {
              "line": 1295,
              "column": 13
          },
          {
              "line": 1304,
              "column": 21
          },
          {
              "line": 1304,
              "column": 47
          },
          {
              "line": 1305,
              "column": 56
          },
          {
              "line": 1305,
              "column": 75
          },
          {
              "line": 1307,
              "column": 69
          },
          {
              "line": 1332,
              "column": 8
          },
          {
              "line": 1341,
              "column": 8
          },
          {
              "line": 1355,
              "column": 8
          },
          {
              "line": 1355,
              "column": 13
          },
          {
              "line": 1369,
              "column": 8
          },
          {
              "line": 1382,
              "column": 8
          },
          {
              "line": 1404,
              "column": 7
          },
          {
              "line": 1426,
              "column": 36
          },
          {
              "line": 1450,
              "column": 8
          },
          {
              "line": 1450,
              "column": 13
          },
          {
              "line": 1450,
              "column": 22
          },
          {
              "line": 1450,
              "column": 31
          },
          {
              "line": 1451,
              "column": 22
          },
          {
              "line": 1458,
              "column": 50
          },
          {
              "line": 1464,
              "column": 8
          },
          {
              "line": 1464,
              "column": 13
          },
          {
              "line": 1465,
              "column": 22
          },
          {
              "line": 1484,
              "column": 8
          },
          {
              "line": 1484,
              "column": 13
          },
          {
              "line": 1485,
              "column": 22
          },
          {
              "line": 1496,
              "column": 47
          },
          {
              "line": 1497,
              "column": 8
          },
          {
              "line": 1499,
              "column": 41
          },
          {
              "line": 1502,
              "column": 39
          },
          {
              "line": 1505,
              "column": 8
          },
          {
              "line": 1506,
              "column": 12
          },
          {
              "line": 1509,
              "column": 12
          },
          {
              "line": 1516,
              "column": 12
          },
          {
              "line": 1517,
              "column": 12
          },
          {
              "line": 1518,
              "column": 49
          },
          {
              "line": 1519,
              "column": 12
          },
          {
              "line": 1521,
              "column": 12
          },
          {
              "line": 1523,
              "column": 12
          },
          {
              "line": 1524,
              "column": 12
          },
          {
              "line": 1524,
              "column": 58
          },
          {
              "line": 1525,
              "column": 12
          },
          {
              "line": 1526,
              "column": 22
          },
          {
              "line": 1528,
              "column": 12
          },
          {
              "line": 1530,
              "column": 48
          },
          {
              "line": 1546,
              "column": 51
          },
          {
              "line": 1554,
              "column": 45
          },
          {
              "line": 1565,
              "column": 51
          },
          {
              "line": 1566,
              "column": 45
          },
          {
              "line": 1569,
              "column": 46
          },
          {
              "line": 1569,
              "column": 86
          },
          {
              "line": 1583,
              "column": 51
          },
          {
              "line": 1607,
              "column": 16
          },
          {
              "line": 1609,
              "column": 26
          },
          {
              "line": 1615,
              "column": 41
          },
          {
              "line": 1624,
              "column": 16
          },
          {
              "line": 1626,
              "column": 26
          },
          {
              "line": 1632,
              "column": 45
          },
          {
              "line": 1641,
              "column": 16
          },
          {
              "line": 1641,
              "column": 52
          },
          {
              "line": 1642,
              "column": 63
          },
          {
              "line": 1642,
              "column": 76
          },
          {
              "line": 1643,
              "column": 26
          },
          {
              "line": 1644,
              "column": 45
          },
          {
              "line": 1647,
              "column": 53
          },
          {
              "line": 1649,
              "column": 45
          },
          {
              "line": 1649,
              "column": 57
          },
          {
              "line": 1649,
              "column": 74
          },
          {
              "line": 1649,
              "column": 87
          },
          {
              "line": 1658,
              "column": 16
          },
          {
              "line": 1660,
              "column": 26
          },
          {
              "line": 1667,
              "column": 40
          },
          {
              "line": 1677,
              "column": 8
          },
          {
              "line": 1678,
              "column": 12
          },
          {
              "line": 1689,
              "column": 8
          },
          {
              "line": 1691,
              "column": 12
          },
          {
              "line": 1692,
              "column": 12
          },
          {
              "line": 1693,
              "column": 12
          },
          {
              "line": 1699,
              "column": 83
          },
          {
              "line": 1705,
              "column": 11
          },
          {
              "line": 1706,
              "column": 16
          },
          {
              "line": 1728,
              "column": 5
          },
          {
              "line": 1728,
              "column": 59
          },
          {
              "line": 1729,
              "column": 54
          },
          {
              "line": 1729,
              "column": 64
          },
          {
              "line": 1730,
              "column": 27
          },
          {
              "line": 1732,
              "column": 37
          },
          {
              "line": 1736,
              "column": 24
          },
          {
              "line": 1739,
              "column": 32
          },
          {
              "line": 1739,
              "column": 42
          },
          {
              "line": 1747,
              "column": 24
          },
          {
              "line": 1747,
              "column": 34
          },
          {
              "line": 1747,
              "column": 73
          },
          {
              "line": 1747,
              "column": 88
          },
          {
              "line": 1754,
              "column": 5
          },
          {
              "line": 1754,
              "column": 61
          },
          {
              "line": 1761,
              "column": 36
          },
          {
              "line": 1769,
              "column": 5
          },
          {
              "line": 1769,
              "column": 63
          },
          {
              "line": 1771,
              "column": 37
          },
          {
              "line": 1779,
              "column": 18
          },
          {
              "line": 1781,
              "column": 15
          },
          {
              "line": 1784,
              "column": 36
          },
          {
              "line": 1786,
              "column": 15
          },
          {
              "line": 1786,
              "column": 31
          },
          {
              "line": 1793,
              "column": 35
          },
          {
              "line": 1793,
              "column": 58
          },
          {
              "line": 1795,
              "column": 17
          },
          {
              "line": 1796,
              "column": 49
          },
          {
              "line": 1797,
              "column": 34
          },
          {
              "line": 1797,
              "column": 43
          },
          {
              "line": 1799,
              "column": 34
          },
          {
              "line": 1799,
              "column": 45
          },
          {
              "line": 1830,
              "column": 8
          },
          {
              "line": 1835,
              "column": 8
          },
          {
              "line": 1842,
              "column": 8
          },
          {
              "line": 1842,
              "column": 13
          },
          {
              "line": 1857,
              "column": 69
          },
          {
              "line": 1862,
              "column": 8
          },
          {
              "line": 1862,
              "column": 13
          },
          {
              "line": 1864,
              "column": 42
          },
          {
              "line": 1866,
              "column": 26
          },
          {
              "line": 1866,
              "column": 63
          },
          {
              "line": 1870,
              "column": 19
          },
          {
              "line": 1876,
              "column": 89
          },
          {
              "line": 1876,
              "column": 117
          },
          {
              "line": 1884,
              "column": 52
          },
          {
              "line": 1890,
              "column": 37
          },
          {
              "line": 1891,
              "column": 44
          },
          {
              "line": 1891,
              "column": 54
          },
          {
              "line": 1892,
              "column": 11
          },
          {
              "line": 1897,
              "column": 11
          },
          {
              "line": 1899,
              "column": 11
          },
          {
              "line": 1901,
              "column": 11
          },
          {
              "line": 1902,
              "column": 53
          },
          {
              "line": 1903,
              "column": 11
          },
          {
              "line": 1904,
              "column": 11
          },
          {
              "line": 1905,
              "column": 11
          },
          {
              "line": 1906,
              "column": 11
          },
          {
              "line": 1909,
              "column": 43
          },
          {
              "line": 1910,
              "column": 11
          },
          {
              "line": 1914,
              "column": 11
          },
          {
              "line": 1918,
              "column": 60
          },
          {
              "line": 1919,
              "column": 18
          }
      ],
      "old_name": "v",
      "new_name": "e",
      "ctx": {
          "symbolName": "v",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "byte[]",
          "scopeHint": "in setTokensFor(...)",
          "filePath": "YarnClusterDescriptor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "nkConfiguration, null, null);\n        DelegationTokenContainer container = new DelegationTokenContainer();\n        delegationTokenManager.obtainDelegationTokens(container);\n\n        Credentials credentials = new Credentials();\n        for (byte[] v : container.getTokens().values()) {\n            credentials.addAll(HadoopDelegationTokenConverter.deserialize(v));\n        }\n        ByteBuffer tokens = ByteBuffer.wrap(HadoopDelegationTokenConverter.serialize(credentials));\n        contai",
          "conflictNames": [
              "containerLaunchContext",
              "delegationTokenManager",
              "container",
              "credentials",
              "tokens"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/32de7521ac7bbeab43916a3abefeb81102079d52^1/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/watermarkstatus/StatusWatermarkValve.java",
      "locators": [
          {
              "line": 19,
              "column": 53
          },
          {
              "line": 25,
              "column": 52
          },
          {
              "line": 37,
              "column": 4
          },
          {
              "line": 43,
              "column": 48
          },
          {
              "line": 47,
              "column": 25
          },
          {
              "line": 47,
              "column": 88
          },
          {
              "line": 55,
              "column": 28
          },
          {
              "line": 129,
              "column": 45
          },
          {
              "line": 130,
              "column": 76
          },
          {
              "line": 138,
              "column": 39
          },
          {
              "line": 138,
              "column": 75
          },
          {
              "line": 149,
              "column": 16
          },
          {
              "line": 195,
              "column": 16
          },
          {
              "line": 221,
              "column": 51
          },
          {
              "line": 234,
              "column": 51
          },
          {
              "line": 249,
              "column": 60
          },
          {
              "line": 270,
              "column": 94
          },
          {
              "line": 277,
              "column": 36
          },
          {
              "line": 278,
              "column": 28
          },
          {
              "line": 292,
              "column": 77
          },
          {
              "line": 302,
              "column": 37
          },
          {
              "line": 303,
              "column": 21
          }
      ],
      "old_name": "status",
      "new_name": "map",
      "ctx": {
          "symbolName": "status",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "SubpartitionStatus",
          "scopeHint": "in hasActiveSubpartitions(...)",
          "filePath": "StatusWatermarkValve.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "        * Utility to check if at least one subpartition in a given array of subpartitions is\n         * active.\n         */\n        private static boolean hasActiveSubpartitions(SubpartitionStatus[] subpartitionStatuses) {\n            for (SubpartitionStatus status : subpartitionStatuses) {\n                if (status.watermarkStatus.isActive()) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public int getInternalIndex(",
          "conflictNames": [
              "subpartitionStatuses"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/34ec781ac7547d376d09854983d169a3aca5130f^1/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/nodes/exec/testutils/RestoreTestBase.java",
      "locators": [
          {
              "line": 154,
              "column": 39
          },
          {
              "line": 158,
              "column": 29
          }
      ],
      "old_name": "shouldTakeSavepoint",
      "new_name": "shouldComplete",
      "ctx": {
          "symbolName": "shouldTakeSavepoint",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "boolean",
          "scopeHint": "in generateTestSetupFiles(...)",
          "filePath": "RestoreTestBase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Execute this test to generate test files. Remember to be using the correct branch when\n     * generating the test files.\n     */\n    @Disabled\n    @ParameterizedTest\n    @MethodSource(\"supportedPrograms\")\n    public void generateTestSetupFiles(TableTestProgram program) throws Exception {\n        final TableEnvironment tEnv =\n                TableEnvironment.create(EnvironmentSettings.inStreamingMode());\n        program.getSetupConfigOptionTestSteps().forEach(s -> s.apply(tEnv));\n        tEnv.getConfig()\n                .set(\n                        TableConfigOptions.PLAN_COMPILE_CATALOG_OBJECTS,\n                        TableConfigOptions.CatalogPlanCompilation.SCHEMA);\n        for (SourceTestStep sourceTestStep : program.getSetupSourceTestSteps()) {\n            final String id = TestValuesTableFactory.registerData(sourceTestStep.dataBeforeRestore);\n            final Map<String, String> options = new HashMap<>();\n            options.put(\"connector\", \"values\");\n            options.put(\"data-id\", id);\n            options.put(\"terminating\", \"false\");\n            options.put(\"disable-lookup\", \"true\");\n            options.put(\"runtime-source\", \"NewSource\");\n            sourceTestStep.apply(tEnv, options);\n        }\n\n        final List<CompletableFuture<?>> futures = new ArrayList<>();\n        for (SinkTestStep sinkTestStep : program.getSetupSinkTestSteps()) {\n            final CompletableFuture<Object> future = new CompletableFuture<>();\n            futures.add(future);\n            final String tableName = sinkTestStep.name;\n            TestValuesTableFactory.registerLocalRawResultsObserver(\n                    tableName,\n                    (integer, strings) -> {\n                        final boolean shouldTakeSavepoint =\n                                CollectionUtils.isEqualCollection(\n                                        TestValuesTableFactory.getRawResultsAsStrings(tableName),\n                                        sinkTestStep.getExpectedBeforeRestoreAsStrings());\n                        if (shouldTakeSavepoint) {\n                            future.complete(null);\n                        }\n                    });\n            final Map<String, String> options = new HashMap<>();\n            options.put(\"connector\", \"values\");\n            options.put(\"disable-lookup\", \"true\");\n            options.put(\"sink-insert-only\", \"false\");\n            sinkTestStep.apply(tEnv, options);\n        }\n\n        program.getSetupFunctionTestSteps().forEach(s -> s.apply(tEnv));\n\n        final SqlTestStep sqlTestStep = program.getRunSqlTestStep();\n\n        final CompiledPlan compiledPlan = tEnv.compilePlanSql(sqlTestStep.sql);\n        compiledPlan.writeToFile(getPlanPath(program, getLatestMetadata()));\n\n        final TableResult tableResult = compiledPlan.execute();\n        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).get();\n        final JobClient jobClient = tableResult.getJobClient().get();\n        final String savepoint =\n                jobClient\n                        .stopWithSavepoint(false, tmpDir.toString(), SavepointFormatType.DEFAULT)\n                        .get();\n        CommonTestUtils.waitForJobStatus(jobClient, Collections.singletonList(JobStatus.FINISHED));\n        final Path savepointPath = Paths.get(new URI(savepoint));\n        final Path savepointDirPath = getSavepointPath(program, getLatestMetadata());\n        Files.createDirectories(savepointDirPath);\n        Files.move(savepointPath, savepointDirPath, StandardCopyOption.ATOMIC_MOVE);\n    }",
          "conflictNames": [
              "program",
              "tEnv",
              "id",
              "options",
              "futures",
              "future",
              "tableName",
              "sqlTestStep",
              "compiledPlan",
              "tableResult",
              "jobClient",
              "savepoint",
              "savepointPath",
              "savepointDirPath"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/34f4f94828d7d7832323d3e2c8f835c07cfc0f4a^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/ResultPartitionTest.java",
      "locators": [
          {
              "line": 139,
              "column": 38
          },
          {
              "line": 143,
              "column": 29
          },
          {
              "line": 145,
              "column": 29
          },
          {
              "line": 150,
              "column": 20
          },
          {
              "line": 151,
              "column": 20
          },
          {
              "line": 152,
              "column": 20
          },
          {
              "line": 172,
              "column": 38
          },
          {
              "line": 176,
              "column": 13
          },
          {
              "line": 178,
              "column": 13
          },
          {
              "line": 180,
              "column": 24
          },
          {
              "line": 181,
              "column": 24
          },
          {
              "line": 183,
              "column": 24
          },
          {
              "line": 223,
              "column": 38
          },
          {
              "line": 228,
              "column": 13
          },
          {
              "line": 230,
              "column": 24
          },
          {
              "line": 231,
              "column": 24
          },
          {
              "line": 232,
              "column": 24
          },
          {
              "line": 458,
              "column": 38
          },
          {
              "line": 461,
              "column": 41
          },
          {
              "line": 466,
              "column": 13
          },
          {
              "line": 468,
              "column": 13
          },
          {
              "line": 479,
              "column": 38
          },
          {
              "line": 485,
              "column": 13
          },
          {
              "line": 487,
              "column": 13
          },
          {
              "line": 490,
              "column": 21
          },
          {
              "line": 504,
              "column": 38
          },
          {
              "line": 507,
              "column": 9
          },
          {
              "line": 509,
              "column": 17
          },
          {
              "line": 511,
              "column": 54
          },
          {
              "line": 519,
              "column": 29
          },
          {
              "line": 520,
              "column": 38
          },
          {
              "line": 523,
              "column": 21
          },
          {
              "line": 535,
              "column": 38
          },
          {
              "line": 538,
              "column": 46
          },
          {
              "line": 549,
              "column": 9
          },
          {
              "line": 550,
              "column": 9
          },
          {
              "line": 551,
              "column": 9
          },
          {
              "line": 552,
              "column": 9
          },
          {
              "line": 565,
              "column": 9
          },
          {
              "line": 566,
              "column": 9
          },
          {
              "line": 567,
              "column": 9
          },
          {
              "line": 568,
              "column": 9
          },
          {
              "line": 582,
              "column": 38
          },
          {
              "line": 585,
              "column": 46
          },
          {
              "line": 596,
              "column": 9
          },
          {
              "line": 597,
              "column": 9
          },
          {
              "line": 607,
              "column": 38
          },
          {
              "line": 610,
              "column": 46
          },
          {
              "line": 621,
              "column": 9
          },
          {
              "line": 632,
              "column": 9
          },
          {
              "line": 633,
              "column": 9
          },
          {
              "line": 646,
              "column": 9
          },
          {
              "line": 656,
              "column": 38
          },
          {
              "line": 659,
              "column": 46
          },
          {
              "line": 669,
              "column": 9
          },
          {
              "line": 679,
              "column": 38
          },
          {
              "line": 682,
              "column": 46
          },
          {
              "line": 693,
              "column": 9
          },
          {
              "line": 694,
              "column": 9
          },
          {
              "line": 714,
              "column": 38
          },
          {
              "line": 718,
              "column": 13
          },
          {
              "line": 721,
              "column": 21
          },
          {
              "line": 727,
              "column": 24
          },
          {
              "line": 730,
              "column": 13
          },
          {
              "line": 731,
              "column": 13
          },
          {
              "line": 734,
              "column": 21
          },
          {
              "line": 740,
              "column": 24
          },
          {
              "line": 748,
              "column": 38
          },
          {
              "line": 751,
              "column": 46
          },
          {
              "line": 763,
              "column": 9
          },
          {
              "line": 764,
              "column": 20
          },
          {
              "line": 766,
              "column": 9
          },
          {
              "line": 767,
              "column": 20
          },
          {
              "line": 770,
              "column": 9
          },
          {
              "line": 771,
              "column": 20
          },
          {
              "line": 773,
              "column": 9
          },
          {
              "line": 774,
              "column": 20
          },
          {
              "line": 777,
              "column": 9
          },
          {
              "line": 778,
              "column": 20
          },
          {
              "line": 781,
              "column": 9
          },
          {
              "line": 782,
              "column": 20
          },
          {
              "line": 785,
              "column": 9
          },
          {
              "line": 786,
              "column": 20
          },
          {
              "line": 790,
              "column": 20
          },
          {
              "line": 793,
              "column": 20
          },
          {
              "line": 797,
              "column": 20
          },
          {
              "line": 800,
              "column": 20
          },
          {
              "line": 804,
              "column": 20
          },
          {
              "line": 807,
              "column": 20
          },
          {
              "line": 811,
              "column": 20
          },
          {
              "line": 815,
              "column": 20
          },
          {
              "line": 818,
              "column": 20
          }
      ],
      "old_name": "bufferWritingResultPartition",
      "new_name": "resultPartition",
      "ctx": {
          "symbolName": "bufferWritingResultPartition",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "BufferWritingResultPartition",
          "scopeHint": "in testAddOnFinishedPartition(...)",
          "filePath": "ResultPartitionTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Tests {@link ResultPartition#emitRecord} on a partition which has already finished.\n     *\n     * @param partitionType the result partition type to set up\n     */\n    private void testAddOnFinishedPartition(final ResultPartitionType partitionType)\n            throws Exception {\n        BufferWritingResultPartition bufferWritingResultPartition =\n                createResultPartition(partitionType);\n        assertThatThrownBy(\n                        () -> {\n                            bufferWritingResultPartition.finish();\n                            // partitionWriter.emitRecord() should fail\n                            bufferWritingResultPartition.emitRecord(\n                                    ByteBuffer.allocate(bufferSize), 0);\n                        })\n                .isInstanceOf(IllegalStateException.class);\n\n        assertThat(bufferWritingResultPartition.numBuffersOut.getCount()).isZero();\n        assertThat(bufferWritingResultPartition.numBytesOut.getCount()).isZero();\n        assertThat(bufferWritingResultPartition.getBufferPool().bestEffortGetNumOfUsedBuffers())\n                .isZero();\n    }",
          "conflictNames": [
              "partitionType"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/356f5bb8e2e199e3e1c80ed3332d33816990d273^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/functions/sql/SqlWindowTableFunction.java",
      "locators": [
          {
              "line": 72,
              "column": 87
          },
          {
              "line": 73,
              "column": 8
          },
          {
              "line": 142,
              "column": 30
          },
          {
              "line": 143,
              "column": 17
          },
          {
              "line": 146,
              "column": 64
          },
          {
              "line": 149,
              "column": 33
          },
          {
              "line": 275,
              "column": 35
          },
          {
              "line": 276,
              "column": 37
          },
          {
              "line": 277,
              "column": 33
          },
          {
              "line": 277,
              "column": 45
          },
          {
              "line": 278,
              "column": 62
          },
          {
              "line": 281,
              "column": 88
          },
          {
              "line": 291,
              "column": 53
          },
          {
              "line": 302,
              "column": 68
          },
          {
              "line": 327,
              "column": 54
          },
          {
              "line": 331,
              "column": 37
          }
      ],
      "old_name": "field",
      "new_name": "timeAttributeField",
      "ctx": {
          "symbolName": "field",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RelDataTypeField",
          "scopeHint": "in inferRowType(...)",
          "filePath": "SqlWindowTableFunction.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Helper for {@link #ARG0_TABLE_FUNCTION_WINDOWING}. */\n    private static RelDataType inferRowType(SqlOperatorBinding opBinding) {\n        final RelDataTypeFactory typeFactory = opBinding.getTypeFactory();\n        final RelDataType inputRowType = opBinding.getOperandType(0);\n        final RelDataType descriptorType = opBinding.getOperandType(1);\n        final RelDataTypeField timeField = descriptorType.getFieldList().get(0);\n        final RelDataType timeAttributeType;\n        if (timeField.getType().getSqlTypeName() == SqlTypeName.NULL) {\n            // the type is not inferred yet, we should infer the type here,\n            // see org.apache.flink.table.planner.functions.sql.SqlDescriptorOperator.deriveType\n            RelDataTypeField field = inputRowType.getField(timeField.getName(), false, false);\n            if (field == null) {\n                throw new IllegalArgumentException(\n                        String.format(\n                                \"Can't find the time attribute field '%s' in the input schema %s.\",\n                                timeField.getName(), inputRowType.getFullTypeString()));\n            }\n            timeAttributeType = field.getType();\n        } else {\n            // the type has been inferred, use it directly\n            timeAttributeType = timeField.getType();\n        }\n        return inferRowType(typeFactory, inputRowType, timeAttributeType);\n    }",
          "conflictNames": [
              "opBinding",
              "typeFactory",
              "inputRowType",
              "descriptorType",
              "timeField",
              "timeAttributeType"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/35b2cae8cdbc8642ca51b922f62579357a47415b^1/flink-clients/src/main/java/org/apache/flink/client/program/StreamContextEnvironment.java",
      "locators": [
          {
              "line": 316,
              "column": 32
          },
          {
              "line": 317,
              "column": 9
          },
          {
              "line": 319,
              "column": 33
          }
      ],
      "old_name": "clusterCheckpointConfig",
      "new_name": "expectedCheckpointConfig",
      "ctx": {
          "symbolName": "clusterCheckpointConfig",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CheckpointConfig",
          "scopeHint": "in collectNotAllowedConfigurations(...)",
          "filePath": "StreamContextEnvironment.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Collects programmatic configuration changes.\n     *\n     * <p>Configuration is spread across instances of {@link Configuration} and POJOs (e.g. {@link\n     * ExecutionConfig}), so we need to have logic for comparing both. For supporting wildcards, the\n     * first can be accomplished by simply removing keys, the latter by setting equal fields before\n     * comparison.\n     */\n    private Collection<String> collectNotAllowedConfigurations() {\n        if (programConfigEnabled) {\n            return Collections.emptyList();\n        }\n\n        final List<String> errors = new ArrayList<>();\n\n        final Configuration clusterConfigMap = new Configuration(clusterConfiguration);\n        final Configuration envConfigMap = new Configuration(configuration);\n\n        // Removal must happen on Configuration objects (not instances of Map)\n        // to also ignore map-typed config options with prefix key notation\n        removeProgramConfigWildcards(clusterConfigMap);\n        removeProgramConfigWildcards(envConfigMap);\n\n        // Check Configuration\n        final MapDifference<String, String> diff =\n                Maps.difference(clusterConfigMap.toMap(), envConfigMap.toMap());\n        diff.entriesOnlyOnRight()\n                .forEach(\n                        (k, v) ->\n                                errors.add(\n                                        ConfigurationNotAllowedMessage.ofConfigurationAdded(k, v)));\n        diff.entriesOnlyOnLeft()\n                .forEach(\n                        (k, v) ->\n                                errors.add(\n                                        ConfigurationNotAllowedMessage.ofConfigurationRemoved(\n                                                k, v)));\n        diff.entriesDiffering()\n                .forEach(\n                        (k, v) ->\n                                errors.add(\n                                        ConfigurationNotAllowedMessage.ofConfigurationChanged(\n                                                k, v)));\n\n        final Configuration enrichedClusterConfig = new Configuration(clusterConfiguration);\n        enrichProgramConfigWildcards(enrichedClusterConfig);\n\n        // Check CheckpointConfig\n        final CheckpointConfig clusterCheckpointConfig = new CheckpointConfig();\n        clusterCheckpointConfig.configure(enrichedClusterConfig);\n        if (!Arrays.equals(\n                serializeConfig(clusterCheckpointConfig), serializeConfig(checkpointCfg))) {\n            errors.add(\n                    ConfigurationNotAllowedMessage.ofConfigurationObject(\n                            checkpointCfg.getClass().getSimpleName()));\n        }\n\n        // Check ExecutionConfig\n        final ExecutionConfig clusterExecutionConfig = new ExecutionConfig();\n        clusterExecutionConfig.configure(enrichedClusterConfig, this.getUserClassloader());\n        if (!Arrays.equals(serializeConfig(clusterExecutionConfig), serializeConfig(config))) {\n            errors.add(\n                    ConfigurationNotAllowedMessage.ofConfigurationObject(\n                            config.getClass().getSimpleName()));\n        }\n\n        return errors;\n    }",
          "conflictNames": [
              "errors",
              "clusterConfigMap",
              "envConfigMap",
              "diff",
              "enrichedClusterConfig",
              "clusterExecutionConfig"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/35b2cae8cdbc8642ca51b922f62579357a47415b^1/flink-clients/src/main/java/org/apache/flink/client/program/StreamContextEnvironment.java",
      "locators": [
          {
              "line": 326,
              "column": 31
          },
          {
              "line": 327,
              "column": 9
          },
          {
              "line": 328,
              "column": 44
          }
      ],
      "old_name": "clusterExecutionConfig",
      "new_name": "expectedExecutionConfig",
      "ctx": {
          "symbolName": "clusterExecutionConfig",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ExecutionConfig",
          "scopeHint": "in collectNotAllowedConfigurations(...)",
          "filePath": "StreamContextEnvironment.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Collects programmatic configuration changes.\n     *\n     * <p>Configuration is spread across instances of {@link Configuration} and POJOs (e.g. {@link\n     * ExecutionConfig}), so we need to have logic for comparing both. For supporting wildcards, the\n     * first can be accomplished by simply removing keys, the latter by setting equal fields before\n     * comparison.\n     */\n    private Collection<String> collectNotAllowedConfigurations() {\n        if (programConfigEnabled) {\n            return Collections.emptyList();\n        }\n\n        final List<String> errors = new ArrayList<>();\n\n        final Configuration clusterConfigMap = new Configuration(clusterConfiguration);\n        final Configuration envConfigMap = new Configuration(configuration);\n\n        // Removal must happen on Configuration objects (not instances of Map)\n        // to also ignore map-typed config options with prefix key notation\n        removeProgramConfigWildcards(clusterConfigMap);\n        removeProgramConfigWildcards(envConfigMap);\n\n        // Check Configuration\n        final MapDifference<String, String> diff =\n                Maps.difference(clusterConfigMap.toMap(), envConfigMap.toMap());\n        diff.entriesOnlyOnRight()\n                .forEach(\n                        (k, v) ->\n                                errors.add(\n                                        ConfigurationNotAllowedMessage.ofConfigurationAdded(k, v)));\n        diff.entriesOnlyOnLeft()\n                .forEach(\n                        (k, v) ->\n                                errors.add(\n                                        ConfigurationNotAllowedMessage.ofConfigurationRemoved(\n                                                k, v)));\n        diff.entriesDiffering()\n                .forEach(\n                        (k, v) ->\n                                errors.add(\n                                        ConfigurationNotAllowedMessage.ofConfigurationChanged(\n                                                k, v)));\n\n        final Configuration enrichedClusterConfig = new Configuration(clusterConfiguration);\n        enrichProgramConfigWildcards(enrichedClusterConfig);\n\n        // Check CheckpointConfig\n        final CheckpointConfig clusterCheckpointConfig = new CheckpointConfig();\n        clusterCheckpointConfig.configure(enrichedClusterConfig);\n        if (!Arrays.equals(\n                serializeConfig(clusterCheckpointConfig), serializeConfig(checkpointCfg))) {\n            errors.add(\n                    ConfigurationNotAllowedMessage.ofConfigurationObject(\n                            checkpointCfg.getClass().getSimpleName()));\n        }\n\n        // Check ExecutionConfig\n        final ExecutionConfig clusterExecutionConfig = new ExecutionConfig();\n        clusterExecutionConfig.configure(enrichedClusterConfig, this.getUserClassloader());\n        if (!Arrays.equals(serializeConfig(clusterExecutionConfig), serializeConfig(config))) {\n            errors.add(\n                    ConfigurationNotAllowedMessage.ofConfigurationObject(\n                            config.getClass().getSimpleName()));\n        }\n\n        return errors;\n    }",
          "conflictNames": [
              "errors",
              "clusterConfigMap",
              "envConfigMap",
              "diff",
              "enrichedClusterConfig",
              "clusterCheckpointConfig"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/36347e5731bd402a608026eb6dfad1c8ef07adbc^1/flink-table/flink-sql-parser/src/main/java/org/apache/flink/sql/parser/dql/SqlShowTables.java",
      "locators": [
          {
              "line": 117,
              "column": 26
          },
          {
              "line": 118,
              "column": 57
          }
      ],
      "old_name": "prefix",
      "new_name": "notPrefix",
      "ctx": {
          "symbolName": "prefix",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in unparse(...)",
          "filePath": "SqlShowTables.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void unparse(SqlWriter writer, int leftPrec, int rightPrec) {\n        if (this.preposition == null) {\n            writer.keyword(\"SHOW TABLES\");\n        } else if (databaseName != null) {\n            writer.keyword(\"SHOW TABLES \" + this.preposition);\n            databaseName.unparse(writer, leftPrec, rightPrec);\n        }\n        if (isWithLike()) {\n            final String prefix = isNotLike() ? \"NOT \" : \"\";\n            writer.keyword(String.format(\"%sLIKE '%s'\", prefix, getLikeSqlPattern()));\n        }\n    }",
          "conflictNames": [
              "writer",
              "leftPrec",
              "rightPrec"
          ]
      },
      "suggestions": [
          {
              "name": "notPrefix",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/36347e5731bd402a608026eb6dfad1c8ef07adbc^1/flink-table/flink-sql-parser/src/main/java/org/apache/flink/sql/parser/dql/SqlShowViews.java",
      "locators": [
          {
              "line": 118,
              "column": 26
          },
          {
              "line": 119,
              "column": 57
          }
      ],
      "old_name": "prefix",
      "new_name": "notPrefix",
      "ctx": {
          "symbolName": "prefix",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in unparse(...)",
          "filePath": "SqlShowViews.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void unparse(SqlWriter writer, int leftPrec, int rightPrec) {\n        if (preposition == null) {\n            writer.keyword(\"SHOW VIEWS\");\n        } else if (databaseName != null) {\n            writer.keyword(\"SHOW VIEWS \" + preposition);\n            databaseName.unparse(writer, leftPrec, rightPrec);\n        }\n\n        if (isWithLike()) {\n            final String prefix = isNotLike() ? \"NOT \" : \"\";\n            writer.keyword(String.format(\"%sLIKE '%s'\", prefix, getLikeSqlPattern()));\n        }\n    }",
          "conflictNames": [
              "writer",
              "leftPrec",
              "rightPrec"
          ]
      },
      "suggestions": [
          {
              "name": "notPrefix",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/363a69dad3c22c9b7063f4eb9ba9ca17b930432a^1/flink-formats/flink-orc/src/main/java/org/apache/flink/orc/writer/PhysicalWriterImpl.java",
      "locators": [
          {
              "line": 188,
              "column": 14
          },
          {
              "line": 191,
              "column": 53
          },
          {
              "line": 199,
              "column": 14
          },
          {
              "line": 202,
              "column": 51
          },
          {
              "line": 212,
              "column": 14
          },
          {
              "line": 214,
              "column": 38
          }
      ],
      "old_name": "startPosition",
      "new_name": "startPosn",
      "ctx": {
          "symbolName": "startPosition",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "long",
          "scopeHint": "in writeFileMetadata(...)",
          "filePath": "PhysicalWriterImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void writeFileMetadata(OrcProto.Metadata.Builder builder) throws IOException {\n        long startPosition = out.getPos();\n        OrcProto.Metadata metadata = builder.build();\n        writeMetadata(metadata);\n        this.metadataLength = (int) (out.getPos() - startPosition);\n    }",
          "conflictNames": [
              "builder",
              "metadata"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/363a69dad3c22c9b7063f4eb9ba9ca17b930432a^1/flink-formats/flink-orc/src/main/java/org/apache/flink/orc/writer/PhysicalWriterImpl.java",
      "locators": [
          {
              "line": 154,
              "column": 52
          },
          {
              "line": 155,
              "column": 39
          },
          {
              "line": 158,
              "column": 35
          },
          {
              "line": 178,
              "column": 52
          },
          {
              "line": 179,
              "column": 13
          },
          {
              "line": 270,
              "column": 58
          },
          {
              "line": 271,
              "column": 45
          },
          {
              "line": 274,
              "column": 41
          }
      ],
      "old_name": "pair",
      "new_name": "stream",
      "ctx": {
          "symbolName": "pair",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Entry<StreamName, BufferedStream>",
          "scopeHint": "in finalizeStripe(...)",
          "filePath": "PhysicalWriterImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "ic void finalizeStripe(\n            OrcProto.StripeFooter.Builder footerBuilder,\n            OrcProto.StripeInformation.Builder dirEntry)\n            throws IOException {\n        long indexSize = 0;\n        long dataSize = 0;\n\n        for (Map.Entry<StreamName, BufferedStream> pair : streams.entrySet()) {\n            BufferedStream receiver = pair.getValue();\n            if (!receiver.isSuppressed) {\n                long streamSize = receiver.getOutputSize();\n                StreamName name = pair.getKey();\n         ",
          "conflictNames": [
              "footerBuilder",
              "dirEntry",
              "indexSize",
              "dataSize",
              "receiver",
              "streamSize",
              "name",
              "footer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/363a69dad3c22c9b7063f4eb9ba9ca17b930432a^1/flink-formats/flink-orc/src/main/java/org/apache/flink/orc/writer/PhysicalWriterImpl.java",
      "locators": [
          {
              "line": 268,
              "column": 14
          },
          {
              "line": 276,
              "column": 21
          },
          {
              "line": 281,
              "column": 16
          },
          {
              "line": 338,
              "column": 18
          },
          {
              "line": 339,
              "column": 42
          },
          {
              "line": 340,
              "column": 26
          }
      ],
      "old_name": "size",
      "new_name": "result",
      "ctx": {
          "symbolName": "size",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "long",
          "scopeHint": "in getFileBytes(...)",
          "filePath": "PhysicalWriterImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public long getFileBytes(int column) {\n        long size = 0;\n\n        for (final Map.Entry<StreamName, BufferedStream> pair : streams.entrySet()) {\n            final BufferedStream receiver = pair.getValue();\n            if (!receiver.isSuppressed) {\n\n                final StreamName name = pair.getKey();\n                if (name.getColumn() == column && name.getArea() != StreamName.Area.INDEX) {\n                    size += receiver.getOutputSize();\n                }\n            }\n        }\n\n        return size;\n    }",
          "conflictNames": [
              "column",
              "receiver",
              "name"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/363a69dad3c22c9b7063f4eb9ba9ca17b930432a^1/flink-formats/flink-orc/src/main/java/org/apache/flink/orc/writer/PhysicalWriterImpl.java",
      "locators": [
          {
              "line": 154,
              "column": 52
          },
          {
              "line": 155,
              "column": 39
          },
          {
              "line": 158,
              "column": 35
          },
          {
              "line": 178,
              "column": 52
          },
          {
              "line": 179,
              "column": 13
          },
          {
              "line": 270,
              "column": 58
          },
          {
              "line": 271,
              "column": 45
          },
          {
              "line": 274,
              "column": 41
          }
      ],
      "old_name": "pair",
      "new_name": "entry",
      "ctx": {
          "symbolName": "pair",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Entry<StreamName, BufferedStream>",
          "scopeHint": "in finalizeStripe(...)",
          "filePath": "PhysicalWriterImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "ic void finalizeStripe(\n            OrcProto.StripeFooter.Builder footerBuilder,\n            OrcProto.StripeInformation.Builder dirEntry)\n            throws IOException {\n        long indexSize = 0;\n        long dataSize = 0;\n\n        for (Map.Entry<StreamName, BufferedStream> pair : streams.entrySet()) {\n            BufferedStream receiver = pair.getValue();\n            if (!receiver.isSuppressed) {\n                long streamSize = receiver.getOutputSize();\n                StreamName name = pair.getKey();\n         ",
          "conflictNames": [
              "footerBuilder",
              "dirEntry",
              "indexSize",
              "dataSize",
              "receiver",
              "streamSize",
              "name",
              "footer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/36b9da50da9405b5b79f0d4da9393921982ab040^1/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendTestBase.java",
      "locators": [
          {
              "line": 383,
              "column": 33
          },
          {
              "line": 391,
              "column": 17
          },
          {
              "line": 449,
              "column": 33
          },
          {
              "line": 464,
              "column": 17
          },
          {
              "line": 5005,
              "column": 39
          },
          {
              "line": 5014,
              "column": 17
          },
          {
              "line": 5015,
              "column": 17
          }
      ],
      "old_name": "keyedState1",
      "new_name": "keyedState",
      "ctx": {
          "symbolName": "keyedState1",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ValueState<Integer>",
          "scopeHint": "in testGetKeys(...)",
          "filePath": "StateBackendTestBase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@TestTemplate\n    void testGetKeys() throws Exception {\n        final int namespace1ElementsNum = 1000;\n        final int namespace2ElementsNum = 1000;\n        String fieldName = \"get-keys-test\";\n        CheckpointableKeyedStateBackend<Integer> backend =\n                createKeyedBackend(IntSerializer.INSTANCE);\n        try {\n            final String ns1 = \"ns1\";\n            ValueState<Integer> keyedState1 =\n                    backend.getPartitionedState(\n                            ns1,\n                            StringSerializer.INSTANCE,\n                            new ValueStateDescriptor<>(fieldName, IntSerializer.INSTANCE));\n\n            for (int key = 0; key < namespace1ElementsNum; key++) {\n                backend.setCurrentKey(key);\n                keyedState1.update(key * 2);\n            }\n\n            final String ns2 = \"ns2\";\n            ValueState<Integer> keyedState2 =\n                    backend.getPartitionedState(\n                            ns2,\n                            StringSerializer.INSTANCE,\n                            new ValueStateDescriptor<>(fieldName, IntSerializer.INSTANCE));\n\n            for (int key = namespace1ElementsNum;\n                    key < namespace1ElementsNum + namespace2ElementsNum;\n                    key++) {\n                backend.setCurrentKey(key);\n                keyedState2.update(key * 2);\n            }\n\n            // valid for namespace1\n            try (Stream<Integer> keysStream = backend.getKeys(fieldName, ns1).sorted()) {\n                PrimitiveIterator.OfInt actualIterator =\n                        keysStream.mapToInt(value -> value.intValue()).iterator();\n\n                for (int expectedKey = 0; expectedKey < namespace1ElementsNum; expectedKey++) {\n                    assertThat(actualIterator).hasNext();\n                    assertThat(actualIterator.nextInt()).isEqualTo(expectedKey);\n                }\n\n                assertThat(actualIterator).isExhausted();\n            }\n\n            // valid for namespace2\n            try (Stream<Integer> keysStream = backend.getKeys(fieldName, ns2).sorted()) {\n                PrimitiveIterator.OfInt actualIterator =\n                        keysStream.mapToInt(value -> value.intValue()).iterator();\n\n                for (int expectedKey = namespace1ElementsNum;\n                        expectedKey < namespace1ElementsNum + namespace2ElementsNum;\n                        expectedKey++) {\n                    assertThat(actualIterator).hasNext();\n                    assertThat(actualIterator.nextInt()).isEqualTo(expectedKey);\n                }\n\n                assertThat(actualIterator).isExhausted();\n            }\n        } finally {\n            IOUtils.closeQuietly(backend);\n            backend.dispose();\n        }\n    }",
          "conflictNames": [
              "namespace1ElementsNum",
              "namespace2ElementsNum",
              "fieldName",
              "backend",
              "ns1",
              "key",
              "ns2",
              "keyedState2",
              "keysStream",
              "actualIterator",
              "expectedKey"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/36c3d778b4570e5445fcfe1d33ea79554a5011f1^1/flink-tests/src/test/java/org/apache/flink/test/state/operator/restore/StreamOperatorSnapshotRestoreTest.java",
      "locators": [
          {
              "line": 159,
              "column": 24
          },
          {
              "line": 162,
              "column": 32
          },
          {
              "line": 165,
              "column": 56
          },
          {
              "line": 168,
              "column": 56
          }
      ],
      "old_name": "fsstateBackend",
      "new_name": "hashMapStateBackend",
      "ctx": {
          "symbolName": "fsstateBackend",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "FsStateBackend",
          "scopeHint": "in testOperatorStatesSnapshotRestoreInternal(...)",
          "filePath": "StreamOperatorSnapshotRestoreTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void testOperatorStatesSnapshotRestoreInternal(final int mode) throws Exception {\n\n        // -------------------------------------------------------------------------- snapshot\n\n        StateBackend stateBackend;\n        FsStateBackend fsstateBackend = createStateBackendInternal();\n        switch (stateBackendEnum) {\n            case FILE:\n                stateBackend = fsstateBackend;\n                break;\n            case ROCKSDB_FULLY_ASYNC:\n                stateBackend = new RocksDBStateBackend(fsstateBackend, TernaryBoolean.FALSE);\n                break;\n            case ROCKSDB_INCREMENTAL:\n                stateBackend = new RocksDBStateBackend(fsstateBackend, TernaryBoolean.TRUE);\n                break;\n            default:\n                throw new IllegalStateException(\n                        String.format(\"Do not support statebackend type %s\", stateBackendEnum));\n        }\n\n        TestOneInputStreamOperator op = new TestOneInputStreamOperator(false);\n\n        JobID jobID = new JobID();\n        JobVertexID jobVertexID = new JobVertexID();\n        int subtaskIdx = 0;\n\n        LocalSnapshotDirectoryProvider directoryProvider =\n                mode == ONLY_JM_RECOVERY\n                        ? null\n                        : new LocalSnapshotDirectoryProviderImpl(\n                                temporaryFolder.newFolder(), jobID, jobVertexID, subtaskIdx);\n\n        LocalRecoveryConfig localRecoveryConfig =\n                (directoryProvider == null)\n                        ? LocalRecoveryConfig.BACKUP_AND_RECOVERY_DISABLED\n                        : LocalRecoveryConfig.backupAndRecoveryEnabled(directoryProvider);\n\n        MockEnvironment mockEnvironment =\n                new MockEnvironmentBuilder()\n                        .setJobID(jobID)\n                        .setJobVertexID(jobVertexID)\n                        .setTaskName(\"test\")\n                        .setManagedMemorySize(1024L * 1024L)\n                        .setInputSplitProvider(new MockInputSplitProvider())\n                        .setBufferSize(1024 * 1024)\n                        .setTaskStateManager(new TestTaskStateManager(localRecoveryConfig))\n                        .setMaxParallelism(MAX_PARALLELISM)\n                        .setSubtaskIndex(subtaskIdx)\n                        .setUserCodeClassLoader(getClass().getClassLoader())\n                        .build();\n\n        KeyedOneInputStreamOperatorTestHarness<Integer, Integer, Integer> testHarness =\n                new KeyedOneInputStreamOperatorTestHarness<>(\n                        op,\n                        (KeySelector<Integer, Integer>) value -> value,\n                        TypeInformation.of(Integer.class),\n                        mockEnvironment);\n\n        testHarness.setStateBackend(stateBackend);\n        testHarness.open();\n\n        for (int i = 0; i < 10; ++i) {\n            testHarness.processElement(new StreamRecord<>(i));\n        }\n\n        OperatorSnapshotFinalizer snapshotWithLocalState =\n                testHarness.snapshotWithLocalState(1L, 1L);\n\n        testHarness.close();\n\n        // -------------------------------------------------------------------------- restore\n\n        op = new TestOneInputStreamOperator(true);\n        testHarness =\n                new KeyedOneInputStreamOperatorTestHarness<>(\n                        op,\n                        (KeySelector<Integer, Integer>) value -> value,\n                        TypeInformation.of(Integer.class),\n                        MAX_PARALLELISM,\n                        1 /* num subtasks */,\n                        0 /* subtask index */);\n        testHarness.setTimeServiceManagerProvider(\n                new InternalTimeServiceManager.Provider() {\n                    @Override\n                    public <K> InternalTimeServiceManager<K> create(\n                            TaskIOMetricGroup taskIOMetricGroup,\n                            CheckpointableKeyedStateBackend<K> keyedStatedBackend,\n                            ClassLoader userClassloader,\n                            KeyContext keyContext,\n                            ProcessingTimeService processingTimeService,\n                            Iterable<KeyGroupStatePartitionStreamProvider> rawKeyedStates,\n                            StreamTaskCancellationContext cancellationContext)\n                            throws IOException {\n                        return null;\n                    }\n                });\n\n        testHarness.setStateBackend(stateBackend);\n\n        OperatorSubtaskState jobManagerOwnedState =\n                snapshotWithLocalState.getJobManagerOwnedState();\n        OperatorSubtaskState taskLocalState = snapshotWithLocalState.getTaskLocalState();\n\n        // We check if local state was created when we enabled local recovery\n        Assert.assertTrue(\n                mode > ONLY_JM_RECOVERY == (taskLocalState != null && taskLocalState.hasState()));\n\n        if (mode == TM_REMOVE_JM_RECOVERY) {\n            jobManagerOwnedState.getManagedKeyedState().discardState();\n        } else if (mode == JM_REMOVE_TM_RECOVERY) {\n            taskLocalState.getManagedKeyedState().discardState();\n        }\n\n        testHarness.initializeState(jobManagerOwnedState, taskLocalState);\n\n        testHarness.open();\n\n        for (int i = 0; i < 10; ++i) {\n            testHarness.processElement(new StreamRecord<>(i));\n        }\n\n        testHarness.close();\n    }",
          "conflictNames": [
              "mode",
              "stateBackend",
              "op",
              "jobID",
              "jobVertexID",
              "subtaskIdx",
              "directoryProvider",
              "localRecoveryConfig",
              "mockEnvironment",
              "testHarness",
              "i",
              "snapshotWithLocalState",
              "jobManagerOwnedState",
              "taskLocalState"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/37e25f2697ebd78b6dadab4594b53074a936dde2^1/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/catalog/CatalogManager.java",
      "locators": [
          {
              "line": 1318,
              "column": 20
          },
          {
              "line": 1323,
              "column": 29
          },
          {
              "line": 1323,
              "column": 60
          },
          {
              "line": 1354,
              "column": 20
          },
          {
              "line": 1359,
              "column": 29
          }
      ],
      "old_name": "tableOrView",
      "new_name": "lowerKindStr",
      "ctx": {
          "symbolName": "tableOrView",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in dropTableInternal(...)",
          "filePath": "CatalogManager.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void dropTableInternal(\n            ObjectIdentifier objectIdentifier,\n            boolean ignoreIfNotExists,\n            boolean isDropTable,\n            boolean isDropMaterializedTable) {\n        Predicate<CatalogBaseTable> filter =\n                isDropTable\n                        ? isDropMaterializedTable\n                                ? table -> table instanceof CatalogMaterializedTable\n                                : table -> table instanceof CatalogTable\n                        : table -> table instanceof CatalogView;\n        // Same name temporary table or view exists.\n        if (filter.test(temporaryTables.get(objectIdentifier))) {\n            String tableOrView = isDropTable ? \"table\" : \"view\";\n            throw new ValidationException(\n                    String.format(\n                            \"Temporary %s with identifier '%s' exists. \"\n                                    + \"Drop it first before removing the permanent %s.\",\n                            tableOrView, objectIdentifier, tableOrView));\n        }\n        final Optional<CatalogBaseTable> resultOpt = getUnresolvedTable(objectIdentifier);\n        if (resultOpt.isPresent() && filter.test(resultOpt.get())) {\n            execute(\n                    (catalog, path) -> {\n                        ResolvedCatalogBaseTable<?> resolvedTable =\n                                resolveCatalogBaseTable(resultOpt.get());\n                        managedTableListener.notifyTableDrop(\n                                catalog, objectIdentifier, resolvedTable, false, ignoreIfNotExists);\n\n                        catalog.dropTable(path, ignoreIfNotExists);\n                        if (isDropTable) {\n                            catalogModificationListeners.forEach(\n                                    listener ->\n                                            listener.onEvent(\n                                                    DropTableEvent.createEvent(\n                                                            CatalogContext.createContext(\n                                                                    objectIdentifier\n                                                                            .getCatalogName(),\n                                                                    catalog),\n                                                            objectIdentifier,\n                                                            resolvedTable,\n                                                            ignoreIfNotExists,\n                                                            false)));\n                        }\n                    },\n                    objectIdentifier,\n                    ignoreIfNotExists,\n                    \"DropTable\");\n        } else if (!ignoreIfNotExists) {\n            String tableOrView =\n                    isDropTable ? isDropMaterializedTable ? \"Materialized Table\" : \"Table\" : \"View\";\n            throw new ValidationException(\n                    String.format(\n                            \"%s with identifier '%s' does not exist.\",\n                            tableOrView, objectIdentifier.asSummaryString()));\n        }\n    }",
          "conflictNames": [
              "objectIdentifier",
              "ignoreIfNotExists",
              "isDropTable",
              "isDropMaterializedTable",
              "filter",
              "resultOpt",
              "resolvedTable",
              "tableOrView"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/37e25f2697ebd78b6dadab4594b53074a936dde2^1/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/catalog/CatalogManager.java",
      "locators": [
          {
              "line": 1318,
              "column": 20
          },
          {
              "line": 1323,
              "column": 29
          },
          {
              "line": 1323,
              "column": 60
          },
          {
              "line": 1354,
              "column": 20
          },
          {
              "line": 1359,
              "column": 29
          }
      ],
      "old_name": "tableOrView",
      "new_name": "kindStr",
      "ctx": {
          "symbolName": "tableOrView",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in dropTableInternal(...)",
          "filePath": "CatalogManager.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void dropTableInternal(\n            ObjectIdentifier objectIdentifier,\n            boolean ignoreIfNotExists,\n            boolean isDropTable,\n            boolean isDropMaterializedTable) {\n        Predicate<CatalogBaseTable> filter =\n                isDropTable\n                        ? isDropMaterializedTable\n                                ? table -> table instanceof CatalogMaterializedTable\n                                : table -> table instanceof CatalogTable\n                        : table -> table instanceof CatalogView;\n        // Same name temporary table or view exists.\n        if (filter.test(temporaryTables.get(objectIdentifier))) {\n            String tableOrView = isDropTable ? \"table\" : \"view\";\n            throw new ValidationException(\n                    String.format(\n                            \"Temporary %s with identifier '%s' exists. \"\n                                    + \"Drop it first before removing the permanent %s.\",\n                            tableOrView, objectIdentifier, tableOrView));\n        }\n        final Optional<CatalogBaseTable> resultOpt = getUnresolvedTable(objectIdentifier);\n        if (resultOpt.isPresent() && filter.test(resultOpt.get())) {\n            execute(\n                    (catalog, path) -> {\n                        ResolvedCatalogBaseTable<?> resolvedTable =\n                                resolveCatalogBaseTable(resultOpt.get());\n                        managedTableListener.notifyTableDrop(\n                                catalog, objectIdentifier, resolvedTable, false, ignoreIfNotExists);\n\n                        catalog.dropTable(path, ignoreIfNotExists);\n                        if (isDropTable) {\n                            catalogModificationListeners.forEach(\n                                    listener ->\n                                            listener.onEvent(\n                                                    DropTableEvent.createEvent(\n                                                            CatalogContext.createContext(\n                                                                    objectIdentifier\n                                                                            .getCatalogName(),\n                                                                    catalog),\n                                                            objectIdentifier,\n                                                            resolvedTable,\n                                                            ignoreIfNotExists,\n                                                            false)));\n                        }\n                    },\n                    objectIdentifier,\n                    ignoreIfNotExists,\n                    \"DropTable\");\n        } else if (!ignoreIfNotExists) {\n            String tableOrView =\n                    isDropTable ? isDropMaterializedTable ? \"Materialized Table\" : \"Table\" : \"View\";\n            throw new ValidationException(\n                    String.format(\n                            \"%s with identifier '%s' does not exist.\",\n                            tableOrView, objectIdentifier.asSummaryString()));\n        }\n    }",
          "conflictNames": [
              "objectIdentifier",
              "ignoreIfNotExists",
              "isDropTable",
              "isDropMaterializedTable",
              "filter",
              "resultOpt",
              "resolvedTable",
              "tableOrView"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/384d6b10a2d69b9384052c3d4c3ad82babd201d1^1/flink-table/flink-sql-gateway/src/test/java/org/apache/flink/table/gateway/service/operation/OperationManagerTest.java",
      "locators": [
          {
              "line": 133,
              "column": 36
          },
          {
              "line": 141,
              "column": 33
          },
          {
              "line": 152,
              "column": 23
          }
      ],
      "old_name": "exception",
      "new_name": "isRunning",
      "ctx": {
          "symbolName": "exception",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "AtomicReference<Throwable>",
          "scopeHint": "in testCancelOperationByForce(...)",
          "filePath": "OperationManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testCancelOperationByForce() throws Exception {\n        AtomicReference<Throwable> exception = new AtomicReference<>(null);\n        OperationHandle operationHandle =\n                operationManager.submitOperation(\n                        () -> {\n                            try {\n                                // mock cpu busy task that doesn't interrupt system call\n                                while (true) {}\n                            } catch (Throwable t) {\n                                exception.set(t);\n                                throw t;\n                            }\n                        });\n\n        threadFactory.newThread(() -> operationManager.cancelOperation(operationHandle)).start();\n        operationManager.awaitOperationTermination(operationHandle);\n\n        assertThat(operationManager.getOperationInfo(operationHandle).getStatus())\n                .isEqualTo(OperationStatus.CANCELED);\n        CommonTestUtils.waitUtil(\n                () -> exception.get() != null,\n                Duration.ofSeconds(10),\n                \"Failed to kill the task with infinite loop.\");\n    }",
          "conflictNames": [
              "operationHandle"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/38f4d133a784a58318f6b6cb9617646ab7a70fa1^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/allocator/SlotSharingSlotAllocator.java",
      "locators": [
          {
              "line": 75,
              "column": 22
          },
          {
              "line": 76,
              "column": 38
          },
          {
              "line": 222,
              "column": 40
          },
          {
              "line": 225,
              "column": 13
          },
          {
              "line": 227,
              "column": 16
          },
          {
              "line": 231,
              "column": 46
          },
          {
              "line": 232,
              "column": 42
          }
      ],
      "old_name": "requiredSlots",
      "new_name": "slotSharingGroupMetaInfo",
      "ctx": {
          "symbolName": "requiredSlots",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Integer",
          "scopeHint": "in calculateRequiredSlots(...)",
          "filePath": "SlotSharingSlotAllocator.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "eeSlotFunction, isSlotAvailableAndFreeFunction);\n    }\n\n    @Override\n    public ResourceCounter calculateRequiredSlots(\n            Iterable<JobInformation.VertexInformation> vertices) {\n        int numTotalRequiredSlots = 0;\n        for (Integer requiredSlots : getMaxParallelismForSlotSharingGroups(vertices).values()) {\n            numTotalRequiredSlots += requiredSlots;\n        }\n        return ResourceCounter.withResource(ResourceProfile.UNKNOWN, numTotalRequiredSlots);\n    }\n\n    private sta",
          "conflictNames": [
              "vertices",
              "numTotalRequiredSlots"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/3aa70df4e7da93ed32c26cfabdaeb606233419b1^1/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/operator/CepRuntimeContextTest.java",
      "locators": [
          {
              "line": 117,
              "column": 31
          },
          {
              "line": 130,
              "column": 68
          },
          {
              "line": 142,
              "column": 22
          }
      ],
      "old_name": "executionConfig",
      "new_name": "isObjectReused",
      "ctx": {
          "symbolName": "executionConfig",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ExecutionConfig",
          "scopeHint": "in testCepRuntimeContext(...)",
          "filePath": "CepRuntimeContextTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testCepRuntimeContext() {\n        final String taskName = \"foobarTask\";\n        final OperatorMetricGroup metricGroup =\n                UnregisteredMetricsGroup.createOperatorMetricGroup();\n        final int numberOfParallelSubtasks = 42;\n        final int indexOfSubtask = 43;\n        final int attemptNumber = 1337;\n        final String taskNameWithSubtask = \"barfoo\";\n        final ExecutionConfig executionConfig = mock(ExecutionConfig.class);\n        final ClassLoader userCodeClassLoader = mock(ClassLoader.class);\n        final DistributedCache distributedCache = mock(DistributedCache.class);\n\n        RuntimeContext mockedRuntimeContext = mock(RuntimeContext.class);\n\n        when(mockedRuntimeContext.getTaskName()).thenReturn(taskName);\n        when(mockedRuntimeContext.getMetricGroup()).thenReturn(metricGroup);\n        when(mockedRuntimeContext.getNumberOfParallelSubtasks())\n                .thenReturn(numberOfParallelSubtasks);\n        when(mockedRuntimeContext.getIndexOfThisSubtask()).thenReturn(indexOfSubtask);\n        when(mockedRuntimeContext.getAttemptNumber()).thenReturn(attemptNumber);\n        when(mockedRuntimeContext.getTaskNameWithSubtasks()).thenReturn(taskNameWithSubtask);\n        when(mockedRuntimeContext.getExecutionConfig()).thenReturn(executionConfig);\n        when(mockedRuntimeContext.getUserCodeClassLoader()).thenReturn(userCodeClassLoader);\n        when(mockedRuntimeContext.getDistributedCache()).thenReturn(distributedCache);\n\n        RuntimeContext runtimeContext = new CepRuntimeContext(mockedRuntimeContext);\n\n        assertEquals(taskName, runtimeContext.getTaskName());\n        assertEquals(metricGroup, runtimeContext.getMetricGroup());\n        assertEquals(numberOfParallelSubtasks, runtimeContext.getNumberOfParallelSubtasks());\n        assertEquals(indexOfSubtask, runtimeContext.getIndexOfThisSubtask());\n        assertEquals(attemptNumber, runtimeContext.getAttemptNumber());\n        assertEquals(taskNameWithSubtask, runtimeContext.getTaskNameWithSubtasks());\n        assertEquals(executionConfig, runtimeContext.getExecutionConfig());\n        assertEquals(userCodeClassLoader, runtimeContext.getUserCodeClassLoader());\n        assertEquals(distributedCache, runtimeContext.getDistributedCache());\n\n        try {\n            runtimeContext.getState(new ValueStateDescriptor<>(\"foobar\", Integer.class, 42));\n            fail(\"Expected getState to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getListState(new ListStateDescriptor<>(\"foobar\", Integer.class));\n            fail(\"Expected getListState to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getReducingState(\n                    new ReducingStateDescriptor<>(\n                            \"foobar\", mock(ReduceFunction.class), Integer.class));\n            fail(\"Expected getReducingState to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getAggregatingState(\n                    new AggregatingStateDescriptor<>(\n                            \"foobar\", mock(AggregateFunction.class), Integer.class));\n            fail(\"Expected getAggregatingState to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getMapState(\n                    new MapStateDescriptor<>(\"foobar\", Integer.class, String.class));\n            fail(\"Expected getMapState to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.addAccumulator(\"foobar\", mock(Accumulator.class));\n            fail(\"Expected addAccumulator to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getAccumulator(\"foobar\");\n            fail(\"Expected getAccumulator to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getIntCounter(\"foobar\");\n            fail(\"Expected getIntCounter to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getLongCounter(\"foobar\");\n            fail(\"Expected getLongCounter to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getDoubleCounter(\"foobar\");\n            fail(\"Expected getDoubleCounter to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getHistogram(\"foobar\");\n            fail(\"Expected getHistogram to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.hasBroadcastVariable(\"foobar\");\n            fail(\"Expected hasBroadcastVariable to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getBroadcastVariable(\"foobar\");\n            fail(\"Expected getBroadcastVariable to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getBroadcastVariableWithInitializer(\n                    \"foobar\", mock(BroadcastVariableInitializer.class));\n            fail(\n                    \"Expected getBroadcastVariableWithInitializer to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n    }",
          "conflictNames": [
              "taskName",
              "metricGroup",
              "numberOfParallelSubtasks",
              "indexOfSubtask",
              "attemptNumber",
              "taskNameWithSubtask",
              "userCodeClassLoader",
              "distributedCache",
              "mockedRuntimeContext",
              "runtimeContext"
          ]
      },
      "suggestions": [
          {
              "name": "isObjectReused",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/3aa70df4e7da93ed32c26cfabdaeb606233419b1^1/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/functions/async/RichAsyncFunctionTest.java",
      "locators": [
          {
              "line": 110,
              "column": 31
          },
          {
              "line": 122,
              "column": 68
          },
          {
              "line": 135,
              "column": 22
          }
      ],
      "old_name": "executionConfig",
      "new_name": "isObjectReused",
      "ctx": {
          "symbolName": "executionConfig",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ExecutionConfig",
          "scopeHint": "in testRuntimeContext(...)",
          "filePath": "RichAsyncFunctionTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Test the set of runtime context methods in the context of a {@link RichAsyncFunction}. */\n    @Test\n    public void testRuntimeContext() throws Exception {\n        RichAsyncFunction<Integer, Integer> function =\n                new RichAsyncFunction<Integer, Integer>() {\n                    private static final long serialVersionUID = 1707630162838967972L;\n\n                    @Override\n                    public void asyncInvoke(Integer input, ResultFuture<Integer> resultFuture)\n                            throws Exception {\n                        // no op\n                    }\n                };\n\n        final String taskName = \"foobarTask\";\n        final OperatorMetricGroup metricGroup =\n                UnregisteredMetricsGroup.createOperatorMetricGroup();\n        final int numberOfParallelSubtasks = 42;\n        final int indexOfSubtask = 43;\n        final int attemptNumber = 1337;\n        final String taskNameWithSubtask = \"barfoo\";\n        final ExecutionConfig executionConfig = mock(ExecutionConfig.class);\n        final ClassLoader userCodeClassLoader = mock(ClassLoader.class);\n\n        RuntimeContext mockedRuntimeContext = mock(RuntimeContext.class);\n\n        when(mockedRuntimeContext.getTaskName()).thenReturn(taskName);\n        when(mockedRuntimeContext.getMetricGroup()).thenReturn(metricGroup);\n        when(mockedRuntimeContext.getNumberOfParallelSubtasks())\n                .thenReturn(numberOfParallelSubtasks);\n        when(mockedRuntimeContext.getIndexOfThisSubtask()).thenReturn(indexOfSubtask);\n        when(mockedRuntimeContext.getAttemptNumber()).thenReturn(attemptNumber);\n        when(mockedRuntimeContext.getTaskNameWithSubtasks()).thenReturn(taskNameWithSubtask);\n        when(mockedRuntimeContext.getExecutionConfig()).thenReturn(executionConfig);\n        when(mockedRuntimeContext.getUserCodeClassLoader()).thenReturn(userCodeClassLoader);\n\n        function.setRuntimeContext(mockedRuntimeContext);\n\n        RuntimeContext runtimeContext = function.getRuntimeContext();\n\n        assertEquals(taskName, runtimeContext.getTaskName());\n        assertEquals(metricGroup, runtimeContext.getMetricGroup());\n        assertEquals(numberOfParallelSubtasks, runtimeContext.getNumberOfParallelSubtasks());\n        assertEquals(indexOfSubtask, runtimeContext.getIndexOfThisSubtask());\n        assertEquals(attemptNumber, runtimeContext.getAttemptNumber());\n        assertEquals(taskNameWithSubtask, runtimeContext.getTaskNameWithSubtasks());\n        assertEquals(executionConfig, runtimeContext.getExecutionConfig());\n        assertEquals(userCodeClassLoader, runtimeContext.getUserCodeClassLoader());\n\n        try {\n            runtimeContext.getDistributedCache();\n            fail(\"Expected getDistributedCached to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getState(new ValueStateDescriptor<>(\"foobar\", Integer.class, 42));\n            fail(\"Expected getState to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getListState(new ListStateDescriptor<>(\"foobar\", Integer.class));\n            fail(\"Expected getListState to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getReducingState(\n                    new ReducingStateDescriptor<>(\n                            \"foobar\",\n                            new ReduceFunction<Integer>() {\n                                private static final long serialVersionUID = 2136425961884441050L;\n\n                                @Override\n                                public Integer reduce(Integer value1, Integer value2)\n                                        throws Exception {\n                                    return value1;\n                                }\n                            },\n                            Integer.class));\n            fail(\"Expected getReducingState to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getAggregatingState(\n                    new AggregatingStateDescriptor<>(\n                            \"foobar\",\n                            new AggregateFunction<Integer, Integer, Integer>() {\n\n                                @Override\n                                public Integer createAccumulator() {\n                                    return null;\n                                }\n\n                                @Override\n                                public Integer add(Integer value, Integer accumulator) {\n                                    return null;\n                                }\n\n                                @Override\n                                public Integer getResult(Integer accumulator) {\n                                    return null;\n                                }\n\n                                @Override\n                                public Integer merge(Integer a, Integer b) {\n                                    return null;\n                                }\n                            },\n                            Integer.class));\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getMapState(\n                    new MapStateDescriptor<>(\"foobar\", Integer.class, String.class));\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.addAccumulator(\n                    \"foobar\",\n                    new Accumulator<Integer, Integer>() {\n                        private static final long serialVersionUID = -4673320336846482358L;\n\n                        @Override\n                        public void add(Integer value) {\n                            // no op\n                        }\n\n                        @Override\n                        public Integer getLocalValue() {\n                            return null;\n                        }\n\n                        @Override\n                        public void resetLocal() {}\n\n                        @Override\n                        public void merge(Accumulator<Integer, Integer> other) {}\n\n                        @Override\n                        public Accumulator<Integer, Integer> clone() {\n                            return null;\n                        }\n                    });\n            fail(\"Expected addAccumulator to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getAccumulator(\"foobar\");\n            fail(\"Expected getAccumulator to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getIntCounter(\"foobar\");\n            fail(\"Expected getIntCounter to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getLongCounter(\"foobar\");\n            fail(\"Expected getLongCounter to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getDoubleCounter(\"foobar\");\n            fail(\"Expected getDoubleCounter to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getHistogram(\"foobar\");\n            fail(\"Expected getHistogram to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.hasBroadcastVariable(\"foobar\");\n            fail(\"Expected hasBroadcastVariable to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getBroadcastVariable(\"foobar\");\n            fail(\"Expected getBroadcastVariable to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n\n        try {\n            runtimeContext.getBroadcastVariableWithInitializer(\n                    \"foobar\",\n                    new BroadcastVariableInitializer<Object, Object>() {\n                        @Override\n                        public Object initializeBroadcastVariable(Iterable<Object> data) {\n                            return null;\n                        }\n                    });\n            fail(\n                    \"Expected getBroadcastVariableWithInitializer to fail with unsupported operation exception.\");\n        } catch (UnsupportedOperationException e) {\n            // expected\n        }\n    }",
          "conflictNames": [
              "function",
              "taskName",
              "metricGroup",
              "numberOfParallelSubtasks",
              "indexOfSubtask",
              "attemptNumber",
              "taskNameWithSubtask",
              "userCodeClassLoader",
              "mockedRuntimeContext",
              "runtimeContext"
          ]
      },
      "suggestions": [
          {
              "name": "isObjectReused",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/3b53f30d396e5a7f22330d6522ea26450e238628^1/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/DefaultDispatcherRunnerITCase.java",
      "locators": [
          {
              "line": 207,
              "column": 47
          },
          {
              "line": 209,
              "column": 28
          },
          {
              "line": 214,
              "column": 28
          }
      ],
      "old_name": "leaderFuture",
      "new_name": "confirmedLeaderInformation",
      "ctx": {
          "symbolName": "leaderFuture",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CompletableFuture<UUID>",
          "scopeHint": "in leaderChange_withBlockingJobManagerTermination_doesNotAffectNewLeader(...)",
          "filePath": "DefaultDispatcherRunnerITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * See FLINK-11843. This is a probabilistic test which needs to be executed several times to\n     * fail.\n     */\n    @Test\n    void leaderChange_withBlockingJobManagerTermination_doesNotAffectNewLeader() throws Exception {\n        final TestingJobMasterServiceLeadershipRunnerFactory jobManagerRunnerFactory =\n                new TestingJobMasterServiceLeadershipRunnerFactory(1);\n        final TestingCleanupRunnerFactory cleanupRunnerFactory = new TestingCleanupRunnerFactory();\n        dispatcherRunnerFactory =\n                DefaultDispatcherRunnerFactory.createSessionRunner(\n                        new TestingDispatcherFactory(\n                                jobManagerRunnerFactory, cleanupRunnerFactory));\n        jobGraphStore = new SingleJobJobGraphStore(jobGraph);\n\n        try (final DispatcherRunner dispatcherRunner = createDispatcherRunner()) {\n\n            // initial run\n            dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get();\n            try (final TestingJobManagerRunner testingJobManagerRunner =\n                    jobManagerRunnerFactory.takeCreatedJobManagerRunner()) {\n\n                dispatcherLeaderElectionService.notLeader();\n\n                LOG.info(\"Re-grant leadership first time.\");\n                dispatcherLeaderElectionService.isLeader(UUID.randomUUID());\n\n                // give the Dispatcher some time to recover jobs\n                Thread.sleep(1L);\n\n                dispatcherLeaderElectionService.notLeader();\n\n                LOG.info(\"Re-grant leadership second time.\");\n                final UUID leaderSessionId = UUID.randomUUID();\n                final CompletableFuture<UUID> leaderFuture =\n                        dispatcherLeaderElectionService.isLeader(leaderSessionId);\n                assertThat(leaderFuture).isNotDone();\n\n                LOG.info(\"Complete the termination of the first job manager runner.\");\n                testingJobManagerRunner.completeTerminationFuture();\n\n                assertThat(leaderFuture.get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS))\n                        .isEqualTo(leaderSessionId);\n\n                // Wait for job to recover...\n                final DispatcherGateway leaderGateway =\n                        rpcServiceExtensionWrapper\n                                .getCustomExtension()\n                                .getTestingRpcService()\n                                .connect(\n                                        dispatcherLeaderElectionService.getAddress(),\n                                        DispatcherId.fromUuid(leaderSessionId),\n                                        DispatcherGateway.class)\n                                .get();\n                assertThat(Iterables.getOnlyElement(leaderGateway.listJobs(TIMEOUT).get()))\n                        .isEqualTo(jobGraph.getJobID());\n            }\n        }\n    }",
          "conflictNames": [
              "jobManagerRunnerFactory",
              "cleanupRunnerFactory",
              "dispatcherRunner",
              "testingJobManagerRunner",
              "leaderSessionId",
              "leaderGateway"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/3bc4f4fc17de1de758be7aca094146dfec844a37^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/reuse/ScanReuserUtils.java",
      "locators": [
          {
              "line": 226,
              "column": 17
          },
          {
              "line": 232,
              "column": 26
          }
      ],
      "old_name": "newExpr",
      "new_name": "adjustedWatermarkExpr",
      "ctx": {
          "symbolName": "newExpr",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RexNode",
          "scopeHint": "in adjustWatermarkIndex(...)",
          "filePath": "ScanReuserUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static WatermarkPushDownSpec adjustWatermarkIndex(\n            ResolvedSchema tableSchema,\n            RowType oldSourceType,\n            RowType newSourceType,\n            WatermarkPushDownSpec spec) {\n        List<String> newFieldNames = newSourceType.getFieldNames();\n        String rowtimeColumn = tableSchema.getWatermarkSpecs().get(0).getRowtimeAttribute();\n        if (newFieldNames.contains(rowtimeColumn)) {\n            List<RowType.RowField> fields = new ArrayList<>();\n            for (int i = 0; i < newSourceType.getFieldCount(); i++) {\n                String name = newFieldNames.get(i);\n                LogicalType type = newSourceType.getTypeAt(i);\n                if (name.equals(rowtimeColumn)) {\n                    if (type instanceof LocalZonedTimestampType) {\n                        type =\n                                new LocalZonedTimestampType(\n                                        type.isNullable(), TimestampKind.ROWTIME, 3);\n                    } else if (type instanceof TimestampType) {\n                        type = new TimestampType(type.isNullable(), TimestampKind.ROWTIME, 3);\n                    } else {\n                        throw new TableException(\n                                String.format(\n                                        \"Watermark only supports LocalZonedTimestampType and TimestampType \"\n                                                + \"while current type %s is not supported by watermark. \"\n                                                + \"This should not happen.\",\n                                        type.asSummaryString()));\n                    }\n                }\n                fields.add(new RowType.RowField(name, type));\n            }\n            newSourceType = new RowType(fields);\n        }\n        RexNode newExpr =\n                adjustRexNodeIndex(\n                                oldSourceType,\n                                newSourceType,\n                                Collections.singletonList(spec.getWatermarkExpr()))\n                        .get(0);\n        return spec.copy(newExpr, newSourceType);\n    }",
          "conflictNames": [
              "tableSchema",
              "oldSourceType",
              "newSourceType",
              "spec",
              "newFieldNames",
              "rowtimeColumn",
              "fields",
              "i",
              "name",
              "type"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/3bc4f4fc17de1de758be7aca094146dfec844a37^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushWatermarkIntoTableSourceScanAcrossCalcRule.java",
      "locators": [
          {
              "line": 85,
              "column": 17
          },
          {
              "line": 112,
              "column": 33
          },
          {
              "line": 113,
              "column": 33
          },
          {
              "line": 115,
              "column": 25
          }
      ],
      "old_name": "rowTimeColumn",
      "new_name": "rowtimeExpr",
      "ctx": {
          "symbolName": "rowTimeColumn",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RexNode",
          "scopeHint": "in onMatch(...)",
          "filePath": "PushWatermarkIntoTableSourceScanAcrossCalcRule.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void onMatch(RelOptRuleCall call) {\n        FlinkLogicalWatermarkAssigner watermarkAssigner = call.rel(0);\n        FlinkLogicalCalc calc = call.rel(1);\n\n        RexProgram originProgram = calc.getProgram();\n        List<RexNode> projectList =\n                originProgram.getProjectList().stream()\n                        .map(originProgram::expandLocalRef)\n                        .collect(Collectors.toList());\n\n        // get watermark expression\n        RexNode rowTimeColumn = projectList.get(watermarkAssigner.rowtimeFieldIndex());\n        RexNode newWatermarkExpr =\n                watermarkAssigner\n                        .watermarkExpr()\n                        .accept(\n                                new RexShuttle() {\n                                    @Override\n                                    public RexNode visitInputRef(RexInputRef inputRef) {\n                                        return projectList.get(inputRef.getIndex());\n                                    }\n                                });\n\n        // push watermark assigner into the scan\n        FlinkLogicalTableSourceScan newScan =\n                getNewScan(\n                        watermarkAssigner,\n                        newWatermarkExpr,\n                        call.rel(2),\n                        ShortcutUtils.unwrapContext(calc).getTableConfig(),\n                        false); // useWatermarkAssignerRowType\n\n        FlinkTypeFactory typeFactory = ShortcutUtils.unwrapTypeFactory(calc);\n        RexBuilder builder = call.builder().getRexBuilder();\n        // cast timestamp/timestamp_ltz type to rowtime type.\n        RexNode newRowTimeColumn =\n                builder.makeReinterpretCast(\n                        typeFactory.createRowtimeIndicatorType(\n                                rowTimeColumn.getType().isNullable(),\n                                rowTimeColumn.getType().getSqlTypeName()\n                                        == SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE),\n                        rowTimeColumn,\n                        null);\n\n        // build new calc program\n        RexProgramBuilder programBuilder = new RexProgramBuilder(newScan.getRowType(), builder);\n\n        List<String> outputFieldNames = originProgram.getOutputRowType().getFieldNames();\n        for (int i = 0; i < projectList.size(); i++) {\n            if (i == watermarkAssigner.rowtimeFieldIndex()) {\n                // replace the origin computed column to keep type consistent\n                programBuilder.addProject(newRowTimeColumn, outputFieldNames.get(i));\n            } else {\n                programBuilder.addProject(projectList.get(i), outputFieldNames.get(i));\n            }\n        }\n        if (originProgram.getCondition() != null) {\n            programBuilder.addCondition(originProgram.expandLocalRef(originProgram.getCondition()));\n        }\n\n        FlinkLogicalCalc newCalc = FlinkLogicalCalc.create(newScan, programBuilder.getProgram());\n        call.transformTo(newCalc);\n    }",
          "conflictNames": [
              "call",
              "watermarkAssigner",
              "calc",
              "originProgram",
              "projectList",
              "newWatermarkExpr",
              "newScan",
              "typeFactory",
              "builder",
              "newRowTimeColumn",
              "programBuilder",
              "outputFieldNames",
              "i",
              "newCalc"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/3bc4f4fc17de1de758be7aca094146dfec844a37^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushWatermarkIntoTableSourceScanAcrossCalcRule.java",
      "locators": [
          {
              "line": 109,
              "column": 17
          },
          {
              "line": 125,
              "column": 43
          }
      ],
      "old_name": "newRowTimeColumn",
      "new_name": "newRowtimeExpr",
      "ctx": {
          "symbolName": "newRowTimeColumn",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RexNode",
          "scopeHint": "in onMatch(...)",
          "filePath": "PushWatermarkIntoTableSourceScanAcrossCalcRule.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void onMatch(RelOptRuleCall call) {\n        FlinkLogicalWatermarkAssigner watermarkAssigner = call.rel(0);\n        FlinkLogicalCalc calc = call.rel(1);\n\n        RexProgram originProgram = calc.getProgram();\n        List<RexNode> projectList =\n                originProgram.getProjectList().stream()\n                        .map(originProgram::expandLocalRef)\n                        .collect(Collectors.toList());\n\n        // get watermark expression\n        RexNode rowTimeColumn = projectList.get(watermarkAssigner.rowtimeFieldIndex());\n        RexNode newWatermarkExpr =\n                watermarkAssigner\n                        .watermarkExpr()\n                        .accept(\n                                new RexShuttle() {\n                                    @Override\n                                    public RexNode visitInputRef(RexInputRef inputRef) {\n                                        return projectList.get(inputRef.getIndex());\n                                    }\n                                });\n\n        // push watermark assigner into the scan\n        FlinkLogicalTableSourceScan newScan =\n                getNewScan(\n                        watermarkAssigner,\n                        newWatermarkExpr,\n                        call.rel(2),\n                        ShortcutUtils.unwrapContext(calc).getTableConfig(),\n                        false); // useWatermarkAssignerRowType\n\n        FlinkTypeFactory typeFactory = ShortcutUtils.unwrapTypeFactory(calc);\n        RexBuilder builder = call.builder().getRexBuilder();\n        // cast timestamp/timestamp_ltz type to rowtime type.\n        RexNode newRowTimeColumn =\n                builder.makeReinterpretCast(\n                        typeFactory.createRowtimeIndicatorType(\n                                rowTimeColumn.getType().isNullable(),\n                                rowTimeColumn.getType().getSqlTypeName()\n                                        == SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE),\n                        rowTimeColumn,\n                        null);\n\n        // build new calc program\n        RexProgramBuilder programBuilder = new RexProgramBuilder(newScan.getRowType(), builder);\n\n        List<String> outputFieldNames = originProgram.getOutputRowType().getFieldNames();\n        for (int i = 0; i < projectList.size(); i++) {\n            if (i == watermarkAssigner.rowtimeFieldIndex()) {\n                // replace the origin computed column to keep type consistent\n                programBuilder.addProject(newRowTimeColumn, outputFieldNames.get(i));\n            } else {\n                programBuilder.addProject(projectList.get(i), outputFieldNames.get(i));\n            }\n        }\n        if (originProgram.getCondition() != null) {\n            programBuilder.addCondition(originProgram.expandLocalRef(originProgram.getCondition()));\n        }\n\n        FlinkLogicalCalc newCalc = FlinkLogicalCalc.create(newScan, programBuilder.getProgram());\n        call.transformTo(newCalc);\n    }",
          "conflictNames": [
              "call",
              "watermarkAssigner",
              "calc",
              "originProgram",
              "projectList",
              "rowTimeColumn",
              "newWatermarkExpr",
              "newScan",
              "typeFactory",
              "builder",
              "programBuilder",
              "outputFieldNames",
              "i",
              "newCalc"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/3bc4f4fc17de1de758be7aca094146dfec844a37^1/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/nodes/exec/testutils/RestoreTestBase.java",
      "locators": [
          {
              "line": 233,
              "column": 34
          },
          {
              "line": 236,
              "column": 25
          },
          {
              "line": 240,
              "column": 80
          }
      ],
      "old_name": "results",
      "new_name": "expected",
      "ctx": {
          "symbolName": "results",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<String>",
          "scopeHint": "in registerSinkObserver(...)",
          "filePath": "RestoreTestBase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void registerSinkObserver(\n            final List<CompletableFuture<?>> futures,\n            final SinkTestStep sinkTestStep,\n            final boolean ignoreAfter) {\n        final CompletableFuture<Object> future = new CompletableFuture<>();\n        futures.add(future);\n        final String tableName = sinkTestStep.name;\n        TestValuesTableFactory.registerLocalRawResultsObserver(\n                tableName,\n                (integer, strings) -> {\n                    List<String> results =\n                            new ArrayList<>(sinkTestStep.getExpectedBeforeRestoreAsStrings());\n                    if (!ignoreAfter) {\n                        results.addAll(sinkTestStep.getExpectedAfterRestoreAsStrings());\n                    }\n                    List<String> expectedResults = getExpectedResults(sinkTestStep, tableName);\n                    final boolean shouldComplete =\n                            CollectionUtils.isEqualCollection(expectedResults, results);\n                    if (shouldComplete) {\n                        future.complete(null);\n                    }\n                });\n    }",
          "conflictNames": [
              "futures",
              "sinkTestStep",
              "ignoreAfter",
              "future",
              "tableName",
              "expectedResults",
              "shouldComplete"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/3bc4f4fc17de1de758be7aca094146dfec844a37^1/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/nodes/exec/testutils/RestoreTestBase.java",
      "locators": [
          {
              "line": 238,
              "column": 34
          },
          {
              "line": 240,
              "column": 63
          },
          {
              "line": 395,
              "column": 30
          },
          {
              "line": 396,
              "column": 28
          }
      ],
      "old_name": "expectedResults",
      "new_name": "actual",
      "ctx": {
          "symbolName": "expectedResults",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<String>",
          "scopeHint": "in registerSinkObserver(...)",
          "filePath": "RestoreTestBase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void registerSinkObserver(\n            final List<CompletableFuture<?>> futures,\n            final SinkTestStep sinkTestStep,\n            final boolean ignoreAfter) {\n        final CompletableFuture<Object> future = new CompletableFuture<>();\n        futures.add(future);\n        final String tableName = sinkTestStep.name;\n        TestValuesTableFactory.registerLocalRawResultsObserver(\n                tableName,\n                (integer, strings) -> {\n                    List<String> results =\n                            new ArrayList<>(sinkTestStep.getExpectedBeforeRestoreAsStrings());\n                    if (!ignoreAfter) {\n                        results.addAll(sinkTestStep.getExpectedAfterRestoreAsStrings());\n                    }\n                    List<String> expectedResults = getExpectedResults(sinkTestStep, tableName);\n                    final boolean shouldComplete =\n                            CollectionUtils.isEqualCollection(expectedResults, results);\n                    if (shouldComplete) {\n                        future.complete(null);\n                    }\n                });\n    }",
          "conflictNames": [
              "futures",
              "sinkTestStep",
              "ignoreAfter",
              "future",
              "tableName",
              "results",
              "shouldComplete"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/3bc96001656cda6ccaeda22741c75e035505ec1b^1/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/sync/ForStSyncKeyedStateBackend.java",
      "locators": [
          {
              "line": 808,
              "column": 42
          },
          {
              "line": 825,
              "column": 17
          }
      ],
      "old_name": "rocksDBState",
      "new_name": "forStState",
      "ctx": {
          "symbolName": "rocksDBState",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "AbstractForStSyncState<?, ?, SV>",
          "scopeHint": "in migrateStateValues(...)",
          "filePath": "ForStSyncKeyedStateBackend.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Migrate only the state value, that is the \"value\" that is stored in RocksDB. We don't migrate\n     * the key here, which is made up of key group, key, namespace and map key (in case of\n     * MapState).\n     */\n    @SuppressWarnings(\"unchecked\")\n    private <N, S extends State, SV> void migrateStateValues(\n            StateDescriptor<S, SV> stateDesc,\n            Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo)\n            throws Exception {\n\n        if (stateDesc.getType() == StateDescriptor.Type.MAP) {\n            TypeSerializerSnapshot<SV> previousSerializerSnapshot =\n                    stateMetaInfo.f1.getPreviousStateSerializerSnapshot();\n            checkState(\n                    previousSerializerSnapshot != null,\n                    \"the previous serializer snapshot should exist.\");\n            checkState(\n                    previousSerializerSnapshot instanceof MapSerializerSnapshot,\n                    \"previous serializer snapshot should be a MapSerializerSnapshot.\");\n\n            TypeSerializer<SV> newSerializer = stateMetaInfo.f1.getStateSerializer();\n            checkState(\n                    newSerializer instanceof MapSerializer,\n                    \"new serializer should be a MapSerializer.\");\n\n            MapSerializer<?, ?> mapSerializer = (MapSerializer<?, ?>) newSerializer;\n            MapSerializerSnapshot<?, ?> mapSerializerSnapshot =\n                    (MapSerializerSnapshot<?, ?>) previousSerializerSnapshot;\n            if (!checkMapStateKeySchemaCompatibility(mapSerializerSnapshot, mapSerializer)) {\n                throw new StateMigrationException(\n                        \"The new serializer for a MapState requires state migration in order for the job to proceed, since the key schema has changed. However, migration for MapState currently only allows value schema evolutions.\");\n            }\n        }\n\n        LOG.info(\n                \"Performing state migration for state {} because the state serializer's schema, i.e. serialization format, has changed.\",\n                stateDesc);\n\n        // we need to get an actual state instance because migration is different\n        // for different state types. For example, ListState needs to deal with\n        // individual elements\n        State state = createState(stateDesc, stateMetaInfo);\n        if (!(state instanceof AbstractForStSyncState)) {\n            throw new FlinkRuntimeException(\n                    \"State should be an AbstractForStSyncState but is \" + state);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        AbstractForStSyncState<?, ?, SV> rocksDBState = (AbstractForStSyncState<?, ?, SV>) state;\n\n        Snapshot rocksDBSnapshot = db.getSnapshot();\n        try (ForStIteratorWrapper iterator =\n                        ForStOperationUtils.getForStIterator(db, stateMetaInfo.f0, readOptions);\n                ForStDBWriteBatchWrapper batchWriter =\n                        new ForStDBWriteBatchWrapper(db, getWriteOptions(), getWriteBatchSize());\n                Closeable ignored =\n                        cancelStreamRegistry.registerCloseableTemporarily(\n                                writeBatchWrapper.getCancelCloseable())) {\n            iterator.seekToFirst();\n\n            DataInputDeserializer serializedValueInput = new DataInputDeserializer();\n            DataOutputSerializer migratedSerializedValueOutput = new DataOutputSerializer(512);\n            while (iterator.isValid()) {\n                serializedValueInput.setBuffer(iterator.value());\n\n                rocksDBState.migrateSerializedValue(\n                        serializedValueInput,\n                        migratedSerializedValueOutput,\n                        stateMetaInfo.f1.getPreviousStateSerializer(),\n                        stateMetaInfo.f1.getStateSerializer());\n\n                batchWriter.put(\n                        stateMetaInfo.f0,\n                        iterator.key(),\n                        migratedSerializedValueOutput.getCopyOfBuffer());\n\n                migratedSerializedValueOutput.clear();\n                iterator.next();\n            }\n        } finally {\n            db.releaseSnapshot(rocksDBSnapshot);\n            rocksDBSnapshot.close();\n        }\n    }",
          "conflictNames": [
              "stateDesc",
              "stateMetaInfo",
              "previousSerializerSnapshot",
              "newSerializer",
              "mapSerializer",
              "mapSerializerSnapshot",
              "state",
              "rocksDBSnapshot",
              "iterator",
              "batchWriter",
              "ignored",
              "serializedValueInput",
              "migratedSerializedValueOutput"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/3bc96001656cda6ccaeda22741c75e035505ec1b^1/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/sync/ForStSyncKeyedStateBackend.java",
      "locators": [
          {
              "line": 810,
              "column": 18
          },
          {
              "line": 840,
              "column": 32
          },
          {
              "line": 841,
              "column": 13
          }
      ],
      "old_name": "rocksDBSnapshot",
      "new_name": "forstSnapshot",
      "ctx": {
          "symbolName": "rocksDBSnapshot",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Snapshot",
          "scopeHint": "in migrateStateValues(...)",
          "filePath": "ForStSyncKeyedStateBackend.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Migrate only the state value, that is the \"value\" that is stored in RocksDB. We don't migrate\n     * the key here, which is made up of key group, key, namespace and map key (in case of\n     * MapState).\n     */\n    @SuppressWarnings(\"unchecked\")\n    private <N, S extends State, SV> void migrateStateValues(\n            StateDescriptor<S, SV> stateDesc,\n            Tuple2<ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo<N, SV>> stateMetaInfo)\n            throws Exception {\n\n        if (stateDesc.getType() == StateDescriptor.Type.MAP) {\n            TypeSerializerSnapshot<SV> previousSerializerSnapshot =\n                    stateMetaInfo.f1.getPreviousStateSerializerSnapshot();\n            checkState(\n                    previousSerializerSnapshot != null,\n                    \"the previous serializer snapshot should exist.\");\n            checkState(\n                    previousSerializerSnapshot instanceof MapSerializerSnapshot,\n                    \"previous serializer snapshot should be a MapSerializerSnapshot.\");\n\n            TypeSerializer<SV> newSerializer = stateMetaInfo.f1.getStateSerializer();\n            checkState(\n                    newSerializer instanceof MapSerializer,\n                    \"new serializer should be a MapSerializer.\");\n\n            MapSerializer<?, ?> mapSerializer = (MapSerializer<?, ?>) newSerializer;\n            MapSerializerSnapshot<?, ?> mapSerializerSnapshot =\n                    (MapSerializerSnapshot<?, ?>) previousSerializerSnapshot;\n            if (!checkMapStateKeySchemaCompatibility(mapSerializerSnapshot, mapSerializer)) {\n                throw new StateMigrationException(\n                        \"The new serializer for a MapState requires state migration in order for the job to proceed, since the key schema has changed. However, migration for MapState currently only allows value schema evolutions.\");\n            }\n        }\n\n        LOG.info(\n                \"Performing state migration for state {} because the state serializer's schema, i.e. serialization format, has changed.\",\n                stateDesc);\n\n        // we need to get an actual state instance because migration is different\n        // for different state types. For example, ListState needs to deal with\n        // individual elements\n        State state = createState(stateDesc, stateMetaInfo);\n        if (!(state instanceof AbstractForStSyncState)) {\n            throw new FlinkRuntimeException(\n                    \"State should be an AbstractForStSyncState but is \" + state);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        AbstractForStSyncState<?, ?, SV> rocksDBState = (AbstractForStSyncState<?, ?, SV>) state;\n\n        Snapshot rocksDBSnapshot = db.getSnapshot();\n        try (ForStIteratorWrapper iterator =\n                        ForStOperationUtils.getForStIterator(db, stateMetaInfo.f0, readOptions);\n                ForStDBWriteBatchWrapper batchWriter =\n                        new ForStDBWriteBatchWrapper(db, getWriteOptions(), getWriteBatchSize());\n                Closeable ignored =\n                        cancelStreamRegistry.registerCloseableTemporarily(\n                                writeBatchWrapper.getCancelCloseable())) {\n            iterator.seekToFirst();\n\n            DataInputDeserializer serializedValueInput = new DataInputDeserializer();\n            DataOutputSerializer migratedSerializedValueOutput = new DataOutputSerializer(512);\n            while (iterator.isValid()) {\n                serializedValueInput.setBuffer(iterator.value());\n\n                rocksDBState.migrateSerializedValue(\n                        serializedValueInput,\n                        migratedSerializedValueOutput,\n                        stateMetaInfo.f1.getPreviousStateSerializer(),\n                        stateMetaInfo.f1.getStateSerializer());\n\n                batchWriter.put(\n                        stateMetaInfo.f0,\n                        iterator.key(),\n                        migratedSerializedValueOutput.getCopyOfBuffer());\n\n                migratedSerializedValueOutput.clear();\n                iterator.next();\n            }\n        } finally {\n            db.releaseSnapshot(rocksDBSnapshot);\n            rocksDBSnapshot.close();\n        }\n    }",
          "conflictNames": [
              "stateDesc",
              "stateMetaInfo",
              "previousSerializerSnapshot",
              "newSerializer",
              "mapSerializer",
              "mapSerializerSnapshot",
              "state",
              "rocksDBState",
              "iterator",
              "batchWriter",
              "ignored",
              "serializedValueInput",
              "migratedSerializedValueOutput"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/3bc96001656cda6ccaeda22741c75e035505ec1b^1/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/sync/ForStSyncKeyedStateBackendBuilder.java",
      "locators": [
          {
              "line": 303,
              "column": 23
          },
          {
              "line": 349,
              "column": 29
          },
          {
              "line": 372,
              "column": 34
          },
          {
              "line": 423,
              "column": 17
          }
      ],
      "old_name": "rocksDBResourceGuard",
      "new_name": "forStResourceGuard",
      "ctx": {
          "symbolName": "rocksDBResourceGuard",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ResourceGuard",
          "scopeHint": "in build(...)",
          "filePath": "ForStSyncKeyedStateBackendBuilder.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public ForStSyncKeyedStateBackend<K> build() throws BackendBuildingException {\n        ForStDBWriteBatchWrapper writeBatchWrapper = null;\n        ColumnFamilyHandle defaultColumnFamilyHandle = null;\n        ForStNativeMetricMonitor nativeMetricMonitor = null;\n        CloseableRegistry cancelRegistryForBackend = new CloseableRegistry();\n        LinkedHashMap<String, ForStOperationUtils.ForStKvStateInfo> kvStateInformation =\n                new LinkedHashMap<>();\n        LinkedHashMap<String, HeapPriorityQueueSnapshotRestoreWrapper<?>> registeredPQStates =\n                new LinkedHashMap<>();\n        RocksDB db = null;\n        ForStRestoreOperation restoreOperation = null;\n        CompletableFuture<Void> asyncCompactAfterRestoreFuture = null;\n\n        ForStDBTtlCompactFiltersManager ttlCompactFiltersManager =\n                new ForStDBTtlCompactFiltersManager(\n                        ttlTimeProvider,\n                        optionsContainer.getQueryTimeAfterNumEntries(),\n                        optionsContainer.getPeriodicCompactionTime());\n\n        ForStSnapshotStrategyBase<K, ?> checkpointStrategy = null;\n\n        ResourceGuard rocksDBResourceGuard = new ResourceGuard();\n        PriorityQueueSetFactory priorityQueueFactory;\n        SerializedCompositeKeyBuilder<K> sharedRocksKeyBuilder;\n        // Number of bytes required to prefix the key groups.\n        int keyGroupPrefixBytes =\n                CompositeKeySerializationUtils.computeRequiredBytesInKeyGroupPrefix(\n                        numberOfKeyGroups);\n\n        try {\n            // Current thread (task thread) must be a Flink thread to enable proper cache\n            // management.\n            setFlinkThread();\n            // Variables for snapshot strategy when incremental checkpoint is enabled\n            UUID backendUID = UUID.randomUUID();\n            SortedMap<Long, Collection<HandleAndLocalPath>> materializedSstFiles = new TreeMap<>();\n            long lastCompletedCheckpointId = -1L;\n            prepareDirectories();\n            restoreOperation =\n                    getForStDBRestoreOperation(\n                            keyGroupPrefixBytes,\n                            kvStateInformation,\n                            registeredPQStates,\n                            ttlCompactFiltersManager);\n            ForStRestoreResult restoreResult = restoreOperation.restore();\n            db = restoreResult.getDb();\n            defaultColumnFamilyHandle = restoreResult.getDefaultColumnFamilyHandle();\n            nativeMetricMonitor = restoreResult.getNativeMetricMonitor();\n\n            writeBatchWrapper =\n                    new ForStDBWriteBatchWrapper(\n                            db, optionsContainer.getWriteOptions(), writeBatchSize);\n\n            // it is important that we only create the key builder after the restore, and not\n            // before;\n            // restore operations may reconfigure the key serializer, so accessing the key\n            // serializer\n            // only now we can be certain that the key serializer used in the builder is final.\n            sharedRocksKeyBuilder =\n                    new SerializedCompositeKeyBuilder<>(\n                            keySerializerProvider.currentSchemaSerializer(),\n                            keyGroupPrefixBytes,\n                            32);\n            // init snapshot strategy after db is assured to be initialized\n            checkpointStrategy =\n                    initializeSnapshotStrategy(\n                            db,\n                            rocksDBResourceGuard,\n                            keySerializerProvider.currentSchemaSerializer(),\n                            kvStateInformation,\n                            keyGroupRange,\n                            keyGroupPrefixBytes,\n                            backendUID,\n                            materializedSstFiles,\n                            lastCompletedCheckpointId);\n\n            // init priority queue factory\n            priorityQueueFactory =\n                    initPriorityQueueFactory(\n                            keyGroupPrefixBytes,\n                            kvStateInformation,\n                            db,\n                            writeBatchWrapper,\n                            nativeMetricMonitor);\n        } catch (Throwable e) {\n            // Do clean up\n            List<ColumnFamilyOptions> columnFamilyOptions =\n                    new ArrayList<>(kvStateInformation.values().size());\n            IOUtils.closeQuietly(cancelRegistryForBackend);\n            IOUtils.closeQuietly(writeBatchWrapper);\n            IOUtils.closeQuietly(rocksDBResourceGuard);\n            ForStOperationUtils.addColumnFamilyOptionsToCloseLater(\n                    columnFamilyOptions, defaultColumnFamilyHandle);\n            IOUtils.closeQuietly(defaultColumnFamilyHandle);\n            IOUtils.closeQuietly(nativeMetricMonitor);\n            for (ForStOperationUtils.ForStKvStateInfo kvStateInfo : kvStateInformation.values()) {\n                ForStOperationUtils.addColumnFamilyOptionsToCloseLater(\n                        columnFamilyOptions, kvStateInfo.columnFamilyHandle);\n                IOUtils.closeQuietly(kvStateInfo.columnFamilyHandle);\n            }\n            IOUtils.closeQuietly(db);\n            // it's possible that db has been initialized but later restore steps failed\n            IOUtils.closeQuietly(restoreOperation);\n            IOUtils.closeAllQuietly(columnFamilyOptions);\n            IOUtils.closeQuietly(optionsContainer);\n            ttlCompactFiltersManager.disposeAndClearRegisteredCompactionFactories();\n            kvStateInformation.clear();\n\n            try {\n                FileUtils.deleteDirectory(new File(instanceBasePath.getPath()));\n            } catch (Exception ex) {\n                logger.warn(\"Failed to delete base path for RocksDB: \" + instanceBasePath, ex);\n            }\n            // Log and rethrow\n            if (e instanceof BackendBuildingException) {\n                throw (BackendBuildingException) e;\n            } else {\n                String errMsg = \"Caught unexpected exception.\";\n                logger.error(errMsg, e);\n                throw new BackendBuildingException(errMsg, e);\n            }\n        }\n        InternalKeyContext<K> keyContext =\n                new InternalKeyContextImpl<>(keyGroupRange, numberOfKeyGroups);\n        logger.info(\"Finished building RocksDB keyed state-backend at {}.\", instanceBasePath);\n        return new ForStSyncKeyedStateBackend<>(\n                this.userCodeClassLoader,\n                this.instanceBasePath,\n                this.optionsContainer,\n                columnFamilyOptionsFactory,\n                this.kvStateRegistry,\n                this.keySerializerProvider.currentSchemaSerializer(),\n                this.executionConfig,\n                this.ttlTimeProvider,\n                latencyTrackingStateConfig,\n                db,\n                kvStateInformation,\n                registeredPQStates,\n                keyGroupPrefixBytes,\n                cancelRegistryForBackend,\n                this.keyGroupCompressionDecorator,\n                rocksDBResourceGuard,\n                checkpointStrategy,\n                writeBatchWrapper,\n                defaultColumnFamilyHandle,\n                nativeMetricMonitor,\n                sharedRocksKeyBuilder,\n                priorityQueueFactory,\n                ttlCompactFiltersManager,\n                keyContext,\n                writeBatchSize,\n                asyncCompactAfterRestoreFuture);\n    }",
          "conflictNames": [
              "writeBatchWrapper",
              "defaultColumnFamilyHandle",
              "nativeMetricMonitor",
              "cancelRegistryForBackend",
              "kvStateInformation",
              "registeredPQStates",
              "db",
              "restoreOperation",
              "asyncCompactAfterRestoreFuture",
              "ttlCompactFiltersManager",
              "checkpointStrategy",
              "priorityQueueFactory",
              "sharedRocksKeyBuilder",
              "keyGroupPrefixBytes",
              "backendUID",
              "materializedSstFiles",
              "lastCompletedCheckpointId",
              "restoreResult",
              "columnFamilyOptions",
              "errMsg",
              "keyContext"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/3cdf228191a073c7008f88faa0b088c6a2428012^1/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotProviderImpl.java",
      "locators": [
          {
              "line": 90,
              "column": 61
          },
          {
              "line": 93,
              "column": 16
          }
      ],
      "old_name": "selectedAvailableSlot",
      "new_name": "slot",
      "ctx": {
          "symbolName": "selectedAvailableSlot",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Optional<SlotInfoAndLocality>",
          "scopeHint": "in tryAllocateFromAvailable(...)",
          "filePath": "PhysicalSlotProviderImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private Optional<PhysicalSlot> tryAllocateFromAvailable(\n            SlotRequestId slotRequestId, SlotProfile slotProfile) {\n        FreeSlotInfoTracker freeSlotInfoTracker = slotPool.getFreeSlotInfoTracker();\n\n        Optional<SlotSelectionStrategy.SlotInfoAndLocality> selectedAvailableSlot =\n                slotSelectionStrategy.selectBestSlotForProfile(freeSlotInfoTracker, slotProfile);\n\n        return selectedAvailableSlot.flatMap(\n                slotInfoAndLocality -> {\n                    freeSlotInfoTracker.reserveSlot(\n                            slotInfoAndLocality.getSlotInfo().getAllocationId());\n                    return slotPool.allocateAvailableSlot(\n                            slotRequestId,\n                            slotInfoAndLocality.getSlotInfo().getAllocationId(),\n                            slotProfile.getPhysicalSlotResourceProfile());\n                });\n    }",
          "conflictNames": [
              "slotRequestId",
              "slotProfile",
              "freeSlotInfoTracker"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/3d350485755e47d2b09ac1b2067b6119ef960b5a^1/flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/connectors/hive/HiveSourceBuilder.java",
      "locators": [
          {
              "line": 345,
              "column": 21
          },
          {
              "line": 347,
              "column": 13
          },
          {
              "line": 351,
              "column": 13
          },
          {
              "line": 362,
              "column": 26
          }
      ],
      "old_name": "producedSchema",
      "new_name": "dataType",
      "ctx": {
          "symbolName": "producedSchema",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TableSchema",
          "scopeHint": "in getProducedRowType(...)",
          "filePath": "HiveSourceBuilder.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private RowType getProducedRowType() {\n        TableSchema producedSchema;\n        if (projectedFields == null) {\n            producedSchema = fullSchema;\n        } else {\n            String[] fullNames = fullSchema.getFieldNames();\n            DataType[] fullTypes = fullSchema.getFieldDataTypes();\n            producedSchema =\n                    TableSchema.builder()\n                            .fields(\n                                    Arrays.stream(projectedFields)\n                                            .mapToObj(i -> fullNames[i])\n                                            .toArray(String[]::new),\n                                    Arrays.stream(projectedFields)\n                                            .mapToObj(i -> fullTypes[i])\n                                            .toArray(DataType[]::new))\n                            .build();\n        }\n        return (RowType) producedSchema.toRowDataType().bridgedTo(RowData.class).getLogicalType();\n    }",
          "conflictNames": [
              "fullNames",
              "fullTypes"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/3d350485755e47d2b09ac1b2067b6119ef960b5a^1/flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/table/planner/delegation/hive/parse/HiveParserDDLSemanticAnalyzer.java",
      "locators": [
          {
              "line": 1069,
              "column": 29
          },
          {
              "line": 1074,
              "column": 33
          },
          {
              "line": 1199,
              "column": 21
          },
          {
              "line": 1204,
              "column": 25
          }
      ],
      "old_name": "tableSchema",
      "new_name": "schema",
      "ctx": {
          "symbolName": "tableSchema",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TableSchema",
          "scopeHint": "in convertCreateTable(...)",
          "filePath": "HiveParserDDLSemanticAnalyzer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private Operation convertCreateTable(HiveParserASTNode ast) throws SemanticException {\n        ObjectIdentifier tableIdentifier =\n                HiveParserBaseSemanticAnalyzer.getObjectIdentifier(\n                        catalogManager, (HiveParserASTNode) ast.getChild(0));\n        String[] qualifiedTabName =\n                new String[] {tableIdentifier.getDatabaseName(), tableIdentifier.getObjectName()};\n        String dbDotTab = HiveParserBaseSemanticAnalyzer.getDotName(qualifiedTabName);\n\n        String likeTableName;\n        List<FieldSchema> cols = new ArrayList<>();\n        List<FieldSchema> partCols = new ArrayList<>();\n        List<PrimaryKey> primaryKeys = new ArrayList<>();\n        List<NotNullConstraint> notNulls = new ArrayList<>();\n        String comment = null;\n        String location = null;\n        Map<String, String> tblProps = null;\n        boolean ifNotExists = false;\n        boolean isExt = false;\n        boolean isTemporary = false;\n        HiveParserASTNode selectStmt = null;\n        final int createTable = 0; // regular CREATE TABLE\n        final int ctlt = 1; // CREATE TABLE LIKE ... (CTLT)\n        final int ctas = 2; // CREATE TABLE AS SELECT ... (CTAS)\n        int commandType = createTable;\n\n        HiveParserBaseSemanticAnalyzer.HiveParserRowFormatParams rowFormatParams =\n                new HiveParserBaseSemanticAnalyzer.HiveParserRowFormatParams();\n        HiveParserStorageFormat storageFormat = new HiveParserStorageFormat(conf);\n\n        LOG.info(\"Creating table \" + dbDotTab + \" position=\" + ast.getCharPositionInLine());\n        int numCh = ast.getChildCount();\n\n        // Check the 1st-level children and do simple semantic checks: 1) CTLT and CTAS should not\n        // coexists.\n        // 2) CTLT or CTAS should not coexists with column list (target table schema).\n        // 3) CTAS does not support partitioning (for now).\n        for (int num = 1; num < numCh; num++) {\n            HiveParserASTNode child = (HiveParserASTNode) ast.getChild(num);\n            if (storageFormat.fillStorageFormat(child)) {\n                continue;\n            }\n            switch (child.getToken().getType()) {\n                case HiveASTParser.TOK_IFNOTEXISTS:\n                    ifNotExists = true;\n                    break;\n                case HiveASTParser.KW_EXTERNAL:\n                    isExt = true;\n                    break;\n                case HiveASTParser.KW_TEMPORARY:\n                    isTemporary = true;\n                    break;\n                case HiveASTParser.TOK_LIKETABLE:\n                    if (child.getChildCount() > 0) {\n                        likeTableName =\n                                HiveParserBaseSemanticAnalyzer.getUnescapedName(\n                                        (HiveParserASTNode) child.getChild(0));\n                        if (likeTableName != null) {\n                            if (commandType == ctas) {\n                                throw new ValidationException(\n                                        ErrorMsg.CTAS_CTLT_COEXISTENCE.getMsg());\n                            }\n                            if (cols.size() != 0) {\n                                throw new ValidationException(\n                                        ErrorMsg.CTLT_COLLST_COEXISTENCE.getMsg());\n                            }\n                        }\n                        commandType = ctlt;\n                        handleUnsupportedOperation(\"CREATE TABLE LIKE is not supported\");\n                    }\n                    break;\n\n                case HiveASTParser.TOK_QUERY: // CTAS\n                    if (commandType == ctlt) {\n                        throw new ValidationException(ErrorMsg.CTAS_CTLT_COEXISTENCE.getMsg());\n                    }\n                    if (cols.size() != 0) {\n                        throw new ValidationException(ErrorMsg.CTAS_COLLST_COEXISTENCE.getMsg());\n                    }\n                    if (partCols.size() != 0) {\n                        throw new ValidationException(ErrorMsg.CTAS_PARCOL_COEXISTENCE.getMsg());\n                    }\n                    if (isExt) {\n                        throw new ValidationException(ErrorMsg.CTAS_EXTTBL_COEXISTENCE.getMsg());\n                    }\n                    commandType = ctas;\n                    selectStmt = child;\n                    break;\n                case HiveASTParser.TOK_TABCOLLIST:\n                    cols =\n                            HiveParserBaseSemanticAnalyzer.getColumns(\n                                    child, true, primaryKeys, notNulls);\n                    break;\n                case HiveASTParser.TOK_TABLECOMMENT:\n                    comment =\n                            HiveParserBaseSemanticAnalyzer.unescapeSQLString(\n                                    child.getChild(0).getText());\n                    break;\n                case HiveASTParser.TOK_TABLEPARTCOLS:\n                    partCols =\n                            HiveParserBaseSemanticAnalyzer.getColumns(\n                                    (HiveParserASTNode) child.getChild(0), false);\n                    break;\n                case HiveASTParser.TOK_TABLEROWFORMAT:\n                    rowFormatParams.analyzeRowFormat(child);\n                    break;\n                case HiveASTParser.TOK_TABLELOCATION:\n                    location =\n                            HiveParserBaseSemanticAnalyzer.unescapeSQLString(\n                                    child.getChild(0).getText());\n                    break;\n                case HiveASTParser.TOK_TABLEPROPERTIES:\n                    tblProps = getProps((HiveParserASTNode) child.getChild(0));\n                    break;\n                case HiveASTParser.TOK_TABLESERIALIZER:\n                    child = (HiveParserASTNode) child.getChild(0);\n                    storageFormat.setSerde(\n                            HiveParserBaseSemanticAnalyzer.unescapeSQLString(\n                                    child.getChild(0).getText()));\n                    if (child.getChildCount() == 2) {\n                        HiveParserBaseSemanticAnalyzer.readProps(\n                                (HiveParserASTNode) (child.getChild(1).getChild(0)),\n                                storageFormat.getSerdeProps());\n                    }\n                    break;\n                case HiveASTParser.TOK_ALTERTABLE_BUCKETS:\n                    handleUnsupportedOperation(\"Bucketed table is not supported\");\n                    break;\n                case HiveASTParser.TOK_TABLESKEWED:\n                    handleUnsupportedOperation(\"Skewed table is not supported\");\n                    break;\n                default:\n                    throw new ValidationException(\"Unknown AST node for CREATE TABLE: \" + child);\n            }\n        }\n\n        if (storageFormat.getStorageHandler() != null) {\n            handleUnsupportedOperation(\"Storage handler table is not supported\");\n        }\n\n        if (commandType == createTable || commandType == ctlt) {\n            queryState.setCommandType(HiveOperation.CREATETABLE);\n        } else {\n            queryState.setCommandType(HiveOperation.CREATETABLE_AS_SELECT);\n        }\n\n        storageFormat.fillDefaultStorageFormat(isExt, false);\n\n        if (isTemporary) {\n            if (partCols.size() > 0) {\n                handleUnsupportedOperation(\n                        \"Partition columns are not supported on temporary tables\");\n            }\n            handleUnsupportedOperation(\"Temporary hive table is not supported\");\n        }\n\n        // Handle different types of CREATE TABLE command\n        switch (commandType) {\n            case createTable: // REGULAR CREATE TABLE DDL\n                tblProps = addDefaultProperties(tblProps);\n                return convertCreateTable(\n                        dbDotTab,\n                        isExt,\n                        ifNotExists,\n                        isTemporary,\n                        cols,\n                        partCols,\n                        comment,\n                        location,\n                        tblProps,\n                        rowFormatParams,\n                        storageFormat,\n                        primaryKeys,\n                        notNulls);\n\n            case ctlt: // create table like <tbl_name>\n                tblProps = addDefaultProperties(tblProps);\n                throw new SemanticException(\"CREATE TABLE LIKE is not supported yet\");\n\n            case ctas: // create table as select\n                tblProps = addDefaultProperties(tblProps);\n\n                // analyze the query\n                HiveParserCalcitePlanner calcitePlanner =\n                        hiveParser.createCalcitePlanner(context, queryState);\n                calcitePlanner.setCtasCols(cols);\n                RelNode queryRelNode = calcitePlanner.genLogicalPlan(selectStmt);\n                TableSchema tableSchema =\n                        HiveTableUtil.createTableSchema(\n                                cols, partCols, Collections.emptySet(), null);\n                CatalogTable destTable =\n                        new CatalogTableImpl(\n                                tableSchema,\n                                HiveCatalog.getFieldNames(partCols),\n                                tblProps,\n                                comment);\n\n                Tuple4<ObjectIdentifier, QueryOperation, Map<String, String>, Boolean>\n                        insertOperationInfo =\n                                dmlHelper.createInsertOperationInfo(\n                                        queryRelNode,\n                                        destTable,\n                                        tableIdentifier,\n                                        Collections.emptyMap(),\n                                        Collections.emptyList(),\n                                        false);\n\n                CreateTableOperation createTableOperation =\n                        convertCreateTable(\n                                dbDotTab,\n                                isExt,\n                                ifNotExists,\n                                isTemporary,\n                                cols,\n                                partCols,\n                                comment,\n                                location,\n                                tblProps,\n                                rowFormatParams,\n                                storageFormat,\n                                primaryKeys,\n                                notNulls);\n\n                return new CreateTableASOperation(\n                        createTableOperation,\n                        insertOperationInfo.f2,\n                        insertOperationInfo.f1,\n                        insertOperationInfo.f3);\n            default:\n                throw new ValidationException(\"Unrecognized command.\");\n        }\n    }",
          "conflictNames": [
              "ast",
              "tableIdentifier",
              "qualifiedTabName",
              "dbDotTab",
              "likeTableName",
              "cols",
              "partCols",
              "primaryKeys",
              "notNulls",
              "comment",
              "location",
              "tblProps",
              "ifNotExists",
              "isExt",
              "isTemporary",
              "selectStmt",
              "createTable",
              "ctlt",
              "ctas",
              "commandType",
              "rowFormatParams",
              "storageFormat",
              "numCh",
              "num",
              "child",
              "calcitePlanner",
              "queryRelNode",
              "destTable",
              "insertOperationInfo",
              "createTableOperation"
          ]
      },
      "suggestions": [
          {
              "name": "schema",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/3d350485755e47d2b09ac1b2067b6119ef960b5a^1/flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/table/planner/delegation/hive/parse/HiveParserDDLSemanticAnalyzer.java",
      "locators": [
          {
              "line": 2008,
              "column": 29
          },
          {
              "line": 2008,
              "column": 51
          },
          {
              "line": 2014,
              "column": 17
          },
          {
              "line": 2016,
              "column": 31
          },
          {
              "line": 2020,
              "column": 13
          },
          {
              "line": 2032,
              "column": 13
          },
          {
              "line": 2037,
              "column": 25
          },
          {
              "line": 2041,
              "column": 63
          },
          {
              "line": 2043,
              "column": 13
          },
          {
              "line": 2048,
              "column": 29
          }
      ],
      "old_name": "builder",
      "new_name": "newColumns",
      "ctx": {
          "symbolName": "builder",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Builder",
          "scopeHint": "in convertAlterTableModifyCols(...)",
          "filePath": "HiveParserDDLSemanticAnalyzer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private Operation convertAlterTableModifyCols(\n            CatalogBaseTable alteredTable, String tblName, HiveParserASTNode ast, boolean replace)\n            throws SemanticException {\n\n        List<FieldSchema> newCols =\n                HiveParserBaseSemanticAnalyzer.getColumns((HiveParserASTNode) ast.getChild(0));\n        boolean isCascade = false;\n        if (null != ast.getFirstChildWithType(HiveASTParser.TOK_CASCADE)) {\n            isCascade = true;\n        }\n\n        ObjectIdentifier tableIdentifier = parseObjectIdentifier(tblName);\n        CatalogTable oldTable = (CatalogTable) alteredTable;\n\n        // prepare properties\n        Map<String, String> props = new HashMap<>(oldTable.getOptions());\n        props.put(ALTER_TABLE_OP, ALTER_COLUMNS.name());\n        if (isCascade) {\n            props.put(ALTER_COL_CASCADE, \"true\");\n        }\n        TableSchema oldSchema = oldTable.getSchema();\n        final int numPartCol = oldTable.getPartitionKeys().size();\n        TableSchema.Builder builder = TableSchema.builder();\n        // add existing non-part col if we're not replacing\n        if (!replace) {\n            List<TableColumn> nonPartCols =\n                    oldSchema.getTableColumns().subList(0, oldSchema.getFieldCount() - numPartCol);\n            for (TableColumn column : nonPartCols) {\n                builder.add(column);\n            }\n            setWatermarkAndPK(builder, oldSchema);\n        }\n        // add new cols\n        for (FieldSchema col : newCols) {\n            builder.add(\n                    TableColumn.physical(\n                            col.getName(),\n                            HiveTypeUtil.toFlinkType(\n                                    TypeInfoUtils.getTypeInfoFromTypeString(col.getType()))));\n        }\n        // add part cols\n        List<TableColumn> partCols =\n                oldSchema\n                        .getTableColumns()\n                        .subList(oldSchema.getFieldCount() - numPartCol, oldSchema.getFieldCount());\n        for (TableColumn column : partCols) {\n            builder.add(column);\n        }\n        return new AlterTableSchemaOperation(\n                tableIdentifier,\n                new CatalogTableImpl(\n                        builder.build(), oldTable.getPartitionKeys(), props, oldTable.getComment()),\n                false);\n    }",
          "conflictNames": [
              "alteredTable",
              "tblName",
              "ast",
              "replace",
              "newCols",
              "isCascade",
              "tableIdentifier",
              "oldTable",
              "props",
              "oldSchema",
              "numPartCol",
              "nonPartCols",
              "partCols"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/3d350485755e47d2b09ac1b2067b6119ef960b5a^1/flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/table/planner/delegation/hive/HiveParserCalcitePlanner.java",
      "locators": [
          {
              "line": 823,
              "column": 30
          },
          {
              "line": 825,
              "column": 62
          }
      ],
      "old_name": "catalogTable",
      "new_name": "resolvedCatalogTable",
      "ctx": {
          "symbolName": "catalogTable",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CatalogTable",
          "scopeHint": "in genTableLogicalPlan(...)",
          "filePath": "HiveParserCalcitePlanner.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private RelNode genTableLogicalPlan(String tableAlias, HiveParserQB qb)\n            throws SemanticException {\n        HiveParserRowResolver rowResolver = new HiveParserRowResolver();\n\n        try {\n            // 1. If the table has a split sample, and it isn't TABLESAMPLE (n ROWS), throw\n            // exception\n            // 2. if the table has a bucket sample, throw exception\n            SplitSample splitSample = semanticAnalyzer.getNameToSplitSampleMap().get(tableAlias);\n            if ((splitSample != null\n                            && (splitSample.getPercent() != null\n                                    || splitSample.getTotalLength() != null))\n                    || qb.getParseInfo().needTableSample(tableAlias)) {\n                throw new UnsupportedOperationException(\"Only TABLESAMPLE (n ROWS) is supported.\");\n            }\n\n            // 2. Get Table Metadata\n            if (qb.getValuesTableToData().containsKey(tableAlias)) {\n                // a temp table has been created for VALUES, we need to convert it to LogicalValues\n                Tuple2<CatalogTable, List<List<String>>> tableValueTuple =\n                        qb.getValuesTableToData().get(tableAlias);\n                RelNode values =\n                        genValues(\n                                tableAlias,\n                                tableValueTuple.f0,\n                                rowResolver,\n                                cluster,\n                                tableValueTuple.f1);\n                relToRowResolver.put(values, rowResolver);\n                relToHiveColNameCalcitePosMap.put(values, buildHiveToCalciteColumnMap(rowResolver));\n                return values;\n            } else {\n                // 3. Get Table Logical Schema (Row Type)\n                // NOTE: Table logical schema = Non Partition Cols + Partition Cols + Virtual Cols\n                Tuple2<String, CatalogTable> nameAndTableTuple =\n                        qb.getMetaData().getSrcForAlias(tableAlias);\n                String tableName = nameAndTableTuple.f0;\n                CatalogTable catalogTable = nameAndTableTuple.f1;\n                TableSchema schema =\n                        HiveParserUtils.fromUnresolvedSchema(catalogTable.getUnresolvedSchema());\n                String[] fieldNames = schema.getFieldNames();\n                ColumnInfo colInfo;\n                // 3.1 Add Column info\n                for (String fieldName : fieldNames) {\n                    Optional<DataType> dataType = schema.getFieldDataType(fieldName);\n                    TypeInfo hiveType =\n                            HiveTypeUtil.toHiveTypeInfo(\n                                    dataType.orElseThrow(\n                                            () ->\n                                                    new SemanticException(\n                                                            String.format(\n                                                                    \"Can't get data type for column %s of table %s.\",\n                                                                    fieldName, tableName))),\n                                    false);\n                    colInfo = new ColumnInfo(fieldName, hiveType, tableAlias, false);\n                    colInfo.setSkewedCol(HiveParserUtils.isSkewedCol(tableAlias, qb, fieldName));\n                    rowResolver.put(tableAlias, fieldName, colInfo);\n                }\n\n                ObjectIdentifier tableIdentifier =\n                        HiveParserBaseSemanticAnalyzer.parseCompoundName(catalogManager, tableName);\n\n                // Build Hive Table Scan Rel\n                RelNode tableRel =\n                        catalogReader\n                                .getTable(\n                                        Arrays.asList(\n                                                tableIdentifier.getCatalogName(),\n                                                tableIdentifier.getDatabaseName(),\n                                                tableIdentifier.getObjectName()))\n                                .toRel(\n                                        ViewExpanders.toRelContext(\n                                                flinkPlanner.createToRelContext(), cluster));\n\n                if (splitSample != null) {\n                    tableRel =\n                            LogicalSort.create(\n                                    tableRel,\n                                    cluster.traitSet().canonize(RelCollations.EMPTY),\n                                    null,\n                                    cluster.getRexBuilder()\n                                            .makeExactLiteral(\n                                                    BigDecimal.valueOf(splitSample.getRowCount())));\n                }\n\n                // 6. Add Schema(RR) to RelNode-Schema map\n                Map<String, Integer> hiveToCalciteColMap = buildHiveToCalciteColumnMap(rowResolver);\n                relToRowResolver.put(tableRel, rowResolver);\n                relToHiveColNameCalcitePosMap.put(tableRel, hiveToCalciteColMap);\n                return tableRel;\n            }\n        } catch (Exception e) {\n            if (e instanceof SemanticException) {\n                throw (SemanticException) e;\n            } else {\n                throw (new RuntimeException(e));\n            }\n        }\n    }",
          "conflictNames": [
              "tableAlias",
              "qb",
              "rowResolver",
              "splitSample",
              "tableValueTuple",
              "values",
              "nameAndTableTuple",
              "tableName",
              "schema",
              "fieldNames",
              "colInfo",
              "dataType",
              "hiveType",
              "tableIdentifier",
              "tableRel",
              "hiveToCalciteColMap"
          ]
      },
      "suggestions": [
          {
              "name": "resolveCatalogTable",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/3d350485755e47d2b09ac1b2067b6119ef960b5a^1/flink-connectors/flink-connector-hive/src/test/java/org/apache/flink/connectors/hive/HiveDialectITCase.java",
      "locators": [
          {
              "line": 312,
              "column": 21
          },
          {
              "line": 313,
              "column": 20
          },
          {
              "line": 314,
              "column": 20
          },
          {
              "line": 315,
              "column": 20
          },
          {
              "line": 318,
              "column": 20
          },
          {
              "line": 321,
              "column": 20
          }
      ],
      "old_name": "tableSchema",
      "new_name": "schema",
      "ctx": {
          "symbolName": "tableSchema",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TableSchema",
          "scopeHint": "in testCreateTableWithConstraints(...)",
          "filePath": "HiveDialectITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testCreateTableWithConstraints() throws Exception {\n        Assume.assumeTrue(HiveVersionTestUtil.HIVE_310_OR_LATER);\n        tableEnv.executeSql(\n                \"create table tbl (x int,y int not null disable novalidate rely,z int not null disable novalidate norely,\"\n                        + \"constraint pk_name primary key (x) disable rely)\");\n        CatalogTable catalogTable =\n                (CatalogTable) hiveCatalog.getTable(new ObjectPath(\"default\", \"tbl\"));\n        TableSchema tableSchema = catalogTable.getSchema();\n        assertThat(tableSchema.getPrimaryKey()).as(\"PK not present\").isPresent();\n        assertThat(tableSchema.getPrimaryKey().get().getName()).isEqualTo(\"pk_name\");\n        assertThat(tableSchema.getFieldDataTypes()[0].getLogicalType().isNullable())\n                .as(\"PK cannot be null\")\n                .isFalse();\n        assertThat(tableSchema.getFieldDataTypes()[1].getLogicalType().isNullable())\n                .as(\"RELY NOT NULL should be reflected in schema\")\n                .isFalse();\n        assertThat(tableSchema.getFieldDataTypes()[2].getLogicalType().isNullable())\n                .as(\"NORELY NOT NULL shouldn't be reflected in schema\")\n                .isTrue();\n    }",
          "conflictNames": [
              "catalogTable"
          ]
      },
      "suggestions": [
          {
              "name": "schema",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/3d350485755e47d2b09ac1b2067b6119ef960b5a^1/flink-connectors/flink-connector-hive/src/test/java/org/apache/flink/connectors/hive/TableEnvHiveConnectorITCase.java",
      "locators": [
          {
              "line": 335,
              "column": 25
          },
          {
              "line": 336,
              "column": 24
          },
          {
              "line": 339,
              "column": 24
          },
          {
              "line": 342,
              "column": 24
          },
          {
              "line": 363,
              "column": 25
          },
          {
              "line": 364,
              "column": 24
          },
          {
              "line": 365,
              "column": 35
          },
          {
              "line": 373,
              "column": 13
          },
          {
              "line": 374,
              "column": 24
          },
          {
              "line": 379,
              "column": 13
          },
          {
              "line": 380,
              "column": 24
          }
      ],
      "old_name": "tableSchema",
      "new_name": "schema",
      "ctx": {
          "symbolName": "tableSchema",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TableSchema",
          "scopeHint": "in testNotNullConstraints(...)",
          "filePath": "TableEnvHiveConnectorITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testNotNullConstraints() throws Exception {\n        Assume.assumeTrue(HiveVersionTestUtil.HIVE_310_OR_LATER);\n        TableEnvironment tableEnv = getTableEnvWithHiveCatalog();\n        tableEnv.executeSql(\"create database db1\");\n        try {\n            tableEnv.executeSql(\n                    \"create table db1.tbl (x int,y bigint not null enable rely,z string not null enable norely)\");\n            CatalogBaseTable catalogTable = hiveCatalog.getTable(new ObjectPath(\"db1\", \"tbl\"));\n            TableSchema tableSchema = catalogTable.getSchema();\n            assertThat(tableSchema.getFieldDataTypes()[0].getLogicalType().isNullable())\n                    .as(\"By default columns should be nullable\")\n                    .isTrue();\n            assertThat(tableSchema.getFieldDataTypes()[1].getLogicalType().isNullable())\n                    .as(\"NOT NULL columns should be reflected in table schema\")\n                    .isFalse();\n            assertThat(tableSchema.getFieldDataTypes()[2].getLogicalType().isNullable())\n                    .as(\"NOT NULL NORELY columns should be considered nullable\")\n                    .isTrue();\n        } finally {\n            tableEnv.executeSql(\"drop database db1 cascade\");\n        }\n    }",
          "conflictNames": [
              "tableEnv",
              "catalogTable"
          ]
      },
      "suggestions": [
          {
              "name": "schema",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/3d350485755e47d2b09ac1b2067b6119ef960b5a^1/flink-connectors/flink-connector-hive/src/test/java/org/apache/flink/connectors/hive/read/HiveInputFormatPartitionReaderITCase.java",
      "locators": [
          {
              "line": 61,
              "column": 21
          },
          {
              "line": 69,
              "column": 25
          },
          {
              "line": 70,
              "column": 25
          },
          {
              "line": 83,
              "column": 51
          }
      ],
      "old_name": "tableSchema",
      "new_name": "schema",
      "ctx": {
          "symbolName": "tableSchema",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TableSchema",
          "scopeHint": "in testReadFormat(...)",
          "filePath": "HiveInputFormatPartitionReaderITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void testReadFormat(TableEnvironment tableEnv, HiveCatalog hiveCatalog, String format)\n            throws Exception {\n        String tableName = prepareData(tableEnv, format);\n        ObjectPath tablePath = new ObjectPath(\"default\", tableName);\n        TableSchema tableSchema = hiveCatalog.getTable(tablePath).getSchema();\n        // create partition reader\n        HiveInputFormatPartitionReader partitionReader =\n                new HiveInputFormatPartitionReader(\n                        HiveOptions.TABLE_EXEC_HIVE_LOAD_PARTITION_SPLITS_THREAD_NUM.defaultValue(),\n                        new JobConf(hiveCatalog.getHiveConf()),\n                        hiveCatalog.getHiveVersion(),\n                        tablePath,\n                        tableSchema.getFieldDataTypes(),\n                        tableSchema.getFieldNames(),\n                        Collections.emptyList(),\n                        null,\n                        false);\n        Table hiveTable = hiveCatalog.getHiveTable(tablePath);\n        // create HiveTablePartition to read from\n        HiveTablePartition tablePartition =\n                new HiveTablePartition(\n                        hiveTable.getSd(),\n                        HiveReflectionUtils.getTableMetadata(\n                                HiveShimLoader.loadHiveShim(hiveCatalog.getHiveVersion()),\n                                hiveTable));\n        partitionReader.open(Collections.singletonList(tablePartition));\n        GenericRowData reuse = new GenericRowData(tableSchema.getFieldCount());\n        int count = 0;\n        // this follows the way the partition reader is used during lookup join\n        while (partitionReader.read(reuse) != null) {\n            count++;\n        }\n        assertThat(count)\n                .isEqualTo(\n                        CollectionUtil.iteratorToList(\n                                        tableEnv.executeSql(\"select * from \" + tableName).collect())\n                                .size());\n    }",
          "conflictNames": [
              "tableEnv",
              "hiveCatalog",
              "format",
              "tableName",
              "tablePath",
              "partitionReader",
              "hiveTable",
              "tablePartition",
              "reuse",
              "count"
          ]
      },
      "suggestions": [
          {
              "name": "schema",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/3d350485755e47d2b09ac1b2067b6119ef960b5a^1/flink-connectors/flink-connector-hive/src/test/java/org/apache/flink/table/catalog/hive/HiveCatalogGenericMetadataTest.java",
      "locators": [
          {
              "line": 64,
              "column": 21
          },
          {
              "line": 80,
              "column": 42
          },
          {
              "line": 83,
              "column": 75
          },
          {
              "line": 324,
              "column": 21
          },
          {
              "line": 331,
              "column": 58
          },
          {
              "line": 334,
              "column": 58
          }
      ],
      "old_name": "tableSchema",
      "new_name": "waterMark",
      "ctx": {
          "symbolName": "tableSchema",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TableSchema",
          "scopeHint": "in testGenericTableSchema(...)",
          "filePath": "HiveCatalogGenericMetadataTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testGenericTableSchema() throws Exception {\n        catalog.createDatabase(db1, createDb(), false);\n\n        TableSchema tableSchema =\n                TableSchema.builder()\n                        .fields(\n                                new String[] {\"col1\", \"col2\", \"col3\"},\n                                new DataType[] {\n                                    DataTypes.TIMESTAMP(3),\n                                    DataTypes.TIMESTAMP(6),\n                                    DataTypes.TIMESTAMP(9)\n                                })\n                        .watermark(\"col3\", \"col3\", DataTypes.TIMESTAMP(9))\n                        .build();\n\n        ObjectPath tablePath = new ObjectPath(db1, \"generic_table\");\n        try {\n            catalog.createTable(\n                    tablePath,\n                    new CatalogTableImpl(tableSchema, getBatchTableProperties(), TEST_COMMENT),\n                    false);\n\n            assertThat(catalog.getTable(tablePath).getSchema()).isEqualTo(tableSchema);\n        } finally {\n            catalog.dropTable(tablePath, true);\n        }\n    }",
          "conflictNames": [
              "tablePath"
          ]
      },
      "suggestions": [
          {
              "name": "schema",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/3d350485755e47d2b09ac1b2067b6119ef960b5a^1/flink-connectors/flink-connector-hive/src/test/java/org/apache/flink/table/catalog/hive/HiveCatalogGenericMetadataTest.java",
      "locators": [
          {
              "line": 124,
              "column": 25
          },
          {
              "line": 139,
              "column": 64
          },
          {
              "line": 175,
              "column": 13
          },
          {
              "line": 189,
              "column": 64
          },
          {
              "line": 223,
              "column": 13
          },
          {
              "line": 235,
              "column": 64
          },
          {
              "line": 279,
              "column": 13
          },
          {
              "line": 295,
              "column": 64
          }
      ],
      "old_name": "expectedSchema",
      "new_name": "resolvedSchema",
      "ctx": {
          "symbolName": "expectedSchema",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TableSchema",
          "scopeHint": "in testTableSchemaCompatibility(...)",
          "filePath": "HiveCatalogGenericMetadataTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    // NOTE: Be careful to modify this test, it is important to backward compatibility\n    void testTableSchemaCompatibility() throws Exception {\n        catalog.createDatabase(db1, createDb(), false);\n        try {\n            // table with numeric types\n            ObjectPath tablePath = new ObjectPath(db1, \"generic1\");\n            Table hiveTable =\n                    org.apache.hadoop.hive.ql.metadata.Table.getEmptyTable(\n                            tablePath.getDatabaseName(), tablePath.getObjectName());\n            hiveTable.setDbName(tablePath.getDatabaseName());\n            hiveTable.setTableName(tablePath.getObjectName());\n            setLegacyGeneric(hiveTable.getParameters());\n            hiveTable.getParameters().put(\"flink.generic.table.schema.0.name\", \"ti\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.0.data-type\", \"TINYINT\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.1.name\", \"si\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.1.data-type\", \"SMALLINT\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.2.name\", \"i\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.2.data-type\", \"INT\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.3.name\", \"bi\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.3.data-type\", \"BIGINT\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.4.name\", \"f\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.4.data-type\", \"FLOAT\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.5.name\", \"d\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.5.data-type\", \"DOUBLE\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.6.name\", \"de\");\n            hiveTable\n                    .getParameters()\n                    .put(\"flink.generic.table.schema.6.data-type\", \"DECIMAL(10, 5)\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.7.name\", \"cost\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.7.expr\", \"`d` * `bi`\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.7.data-type\", \"DOUBLE\");\n            ((HiveCatalog) catalog).client.createTable(hiveTable);\n            CatalogBaseTable catalogBaseTable = catalog.getTable(tablePath);\n            assertThat(HiveCatalog.isHiveTable(catalogBaseTable.getOptions())).isFalse();\n            TableSchema expectedSchema =\n                    TableSchema.builder()\n                            .fields(\n                                    new String[] {\"ti\", \"si\", \"i\", \"bi\", \"f\", \"d\", \"de\"},\n                                    new DataType[] {\n                                        DataTypes.TINYINT(),\n                                        DataTypes.SMALLINT(),\n                                        DataTypes.INT(),\n                                        DataTypes.BIGINT(),\n                                        DataTypes.FLOAT(),\n                                        DataTypes.DOUBLE(),\n                                        DataTypes.DECIMAL(10, 5)\n                                    })\n                            .field(\"cost\", DataTypes.DOUBLE(), \"`d` * `bi`\")\n                            .build();\n            assertThat(catalogBaseTable.getSchema()).isEqualTo(expectedSchema);\n\n            // table with character types\n            tablePath = new ObjectPath(db1, \"generic2\");\n            hiveTable =\n                    org.apache.hadoop.hive.ql.metadata.Table.getEmptyTable(\n                            tablePath.getDatabaseName(), tablePath.getObjectName());\n            hiveTable.setDbName(tablePath.getDatabaseName());\n            hiveTable.setTableName(tablePath.getObjectName());\n            setLegacyGeneric(hiveTable.getParameters());\n            hiveTable.setTableName(tablePath.getObjectName());\n            hiveTable.getParameters().put(\"flink.generic.table.schema.0.name\", \"c\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.0.data-type\", \"CHAR(265)\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.1.name\", \"vc\");\n            hiveTable\n                    .getParameters()\n                    .put(\"flink.generic.table.schema.1.data-type\", \"VARCHAR(65536)\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.2.name\", \"s\");\n            hiveTable\n                    .getParameters()\n                    .put(\"flink.generic.table.schema.2.data-type\", \"VARCHAR(2147483647)\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.3.name\", \"b\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.3.data-type\", \"BINARY(1)\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.4.name\", \"vb\");\n            hiveTable\n                    .getParameters()\n                    .put(\"flink.generic.table.schema.4.data-type\", \"VARBINARY(255)\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.5.name\", \"bs\");\n            hiveTable\n                    .getParameters()\n                    .put(\"flink.generic.table.schema.5.data-type\", \"VARBINARY(2147483647)\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.6.name\", \"len\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.6.expr\", \"CHAR_LENGTH(`s`)\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.6.data-type\", \"INT\");\n            ((HiveCatalog) catalog).client.createTable(hiveTable);\n            catalogBaseTable = catalog.getTable(tablePath);\n            expectedSchema =\n                    TableSchema.builder()\n                            .fields(\n                                    new String[] {\"c\", \"vc\", \"s\", \"b\", \"vb\", \"bs\"},\n                                    new DataType[] {\n                                        DataTypes.CHAR(265),\n                                        DataTypes.VARCHAR(65536),\n                                        DataTypes.STRING(),\n                                        DataTypes.BINARY(1),\n                                        DataTypes.VARBINARY(255),\n                                        DataTypes.BYTES()\n                                    })\n                            .field(\"len\", DataTypes.INT(), \"CHAR_LENGTH(`s`)\")\n                            .build();\n            assertThat(catalogBaseTable.getSchema()).isEqualTo(expectedSchema);\n\n            // table with date/time types\n            tablePath = new ObjectPath(db1, \"generic3\");\n            hiveTable =\n                    org.apache.hadoop.hive.ql.metadata.Table.getEmptyTable(\n                            tablePath.getDatabaseName(), tablePath.getObjectName());\n            hiveTable.setDbName(tablePath.getDatabaseName());\n            hiveTable.setTableName(tablePath.getObjectName());\n            setLegacyGeneric(hiveTable.getParameters());\n            hiveTable.setTableName(tablePath.getObjectName());\n            hiveTable.getParameters().put(\"flink.generic.table.schema.0.name\", \"dt\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.0.data-type\", \"DATE\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.1.name\", \"t\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.1.data-type\", \"TIME(0)\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.2.name\", \"ts\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.2.data-type\", \"TIMESTAMP(3)\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.3.name\", \"tstz\");\n            hiveTable\n                    .getParameters()\n                    .put(\n                            \"flink.generic.table.schema.3.data-type\",\n                            \"TIMESTAMP(6) WITH LOCAL TIME ZONE\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.watermark.0.rowtime\", \"ts\");\n            hiveTable\n                    .getParameters()\n                    .put(\n                            \"flink.generic.table.schema.watermark.0.strategy.data-type\",\n                            \"TIMESTAMP(3)\");\n            hiveTable\n                    .getParameters()\n                    .put(\"flink.generic.table.schema.watermark.0.strategy.expr\", \"ts\");\n            ((HiveCatalog) catalog).client.createTable(hiveTable);\n            catalogBaseTable = catalog.getTable(tablePath);\n            expectedSchema =\n                    TableSchema.builder()\n                            .fields(\n                                    new String[] {\"dt\", \"t\", \"ts\", \"tstz\"},\n                                    new DataType[] {\n                                        DataTypes.DATE(),\n                                        DataTypes.TIME(),\n                                        DataTypes.TIMESTAMP(3),\n                                        DataTypes.TIMESTAMP_WITH_LOCAL_TIME_ZONE()\n                                    })\n                            .watermark(\"ts\", \"ts\", DataTypes.TIMESTAMP(3))\n                            .build();\n            assertThat(catalogBaseTable.getSchema()).isEqualTo(expectedSchema);\n\n            // table with complex/misc types\n            tablePath = new ObjectPath(db1, \"generic4\");\n            hiveTable =\n                    org.apache.hadoop.hive.ql.metadata.Table.getEmptyTable(\n                            tablePath.getDatabaseName(), tablePath.getObjectName());\n            hiveTable.setDbName(tablePath.getDatabaseName());\n            hiveTable.setTableName(tablePath.getObjectName());\n            setLegacyGeneric(hiveTable.getParameters());\n            hiveTable.setTableName(tablePath.getObjectName());\n            hiveTable.getParameters().put(\"flink.generic.table.schema.0.name\", \"a\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.0.data-type\", \"ARRAY<INT>\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.1.name\", \"m\");\n            hiveTable\n                    .getParameters()\n                    .put(\"flink.generic.table.schema.1.data-type\", \"MAP<BIGINT, TIMESTAMP(6)>\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.2.name\", \"mul\");\n            hiveTable\n                    .getParameters()\n                    .put(\"flink.generic.table.schema.2.data-type\", \"MULTISET<DOUBLE>\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.3.name\", \"r\");\n            hiveTable\n                    .getParameters()\n                    .put(\n                            \"flink.generic.table.schema.3.data-type\",\n                            \"ROW<`f1` INT, `f2` VARCHAR(2147483647)>\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.4.name\", \"b\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.4.data-type\", \"BOOLEAN\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.5.name\", \"ts\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.5.data-type\", \"TIMESTAMP(3)\");\n            hiveTable.getParameters().put(\"flink.generic.table.schema.watermark.0.rowtime\", \"ts\");\n            hiveTable\n                    .getParameters()\n                    .put(\n                            \"flink.generic.table.schema.watermark.0.strategy.data-type\",\n                            \"TIMESTAMP(3)\");\n            hiveTable\n                    .getParameters()\n                    .put(\n                            \"flink.generic.table.schema.watermark.0.strategy.expr\",\n                            \"`ts` - INTERVAL '5' SECOND\");\n            ((HiveCatalog) catalog).client.createTable(hiveTable);\n            catalogBaseTable = catalog.getTable(tablePath);\n            expectedSchema =\n                    TableSchema.builder()\n                            .fields(\n                                    new String[] {\"a\", \"m\", \"mul\", \"r\", \"b\", \"ts\"},\n                                    new DataType[] {\n                                        DataTypes.ARRAY(DataTypes.INT()),\n                                        DataTypes.MAP(DataTypes.BIGINT(), DataTypes.TIMESTAMP()),\n                                        DataTypes.MULTISET(DataTypes.DOUBLE()),\n                                        DataTypes.ROW(\n                                                DataTypes.FIELD(\"f1\", DataTypes.INT()),\n                                                DataTypes.FIELD(\"f2\", DataTypes.STRING())),\n                                        DataTypes.BOOLEAN(),\n                                        DataTypes.TIMESTAMP(3)\n                                    })\n                            .watermark(\"ts\", \"`ts` - INTERVAL '5' SECOND\", DataTypes.TIMESTAMP(3))\n                            .build();\n            assertThat(catalogBaseTable.getSchema()).isEqualTo(expectedSchema);\n        } finally {\n            catalog.dropDatabase(db1, true, true);\n        }\n    }",
          "conflictNames": [
              "tablePath",
              "hiveTable",
              "catalogBaseTable"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/3d350485755e47d2b09ac1b2067b6119ef960b5a^1/flink-connectors/flink-connector-hive/src/test/java/org/apache/flink/table/catalog/hive/HiveCatalogGenericMetadataTest.java",
      "locators": [
          {
              "line": 64,
              "column": 21
          },
          {
              "line": 80,
              "column": 42
          },
          {
              "line": 83,
              "column": 75
          },
          {
              "line": 324,
              "column": 21
          },
          {
              "line": 331,
              "column": 58
          },
          {
              "line": 334,
              "column": 58
          }
      ],
      "old_name": "tableSchema",
      "new_name": "resolvedSchema",
      "ctx": {
          "symbolName": "tableSchema",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TableSchema",
          "scopeHint": "in testGenericTableSchema(...)",
          "filePath": "HiveCatalogGenericMetadataTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testGenericTableSchema() throws Exception {\n        catalog.createDatabase(db1, createDb(), false);\n\n        TableSchema tableSchema =\n                TableSchema.builder()\n                        .fields(\n                                new String[] {\"col1\", \"col2\", \"col3\"},\n                                new DataType[] {\n                                    DataTypes.TIMESTAMP(3),\n                                    DataTypes.TIMESTAMP(6),\n                                    DataTypes.TIMESTAMP(9)\n                                })\n                        .watermark(\"col3\", \"col3\", DataTypes.TIMESTAMP(9))\n                        .build();\n\n        ObjectPath tablePath = new ObjectPath(db1, \"generic_table\");\n        try {\n            catalog.createTable(\n                    tablePath,\n                    new CatalogTableImpl(tableSchema, getBatchTableProperties(), TEST_COMMENT),\n                    false);\n\n            assertThat(catalog.getTable(tablePath).getSchema()).isEqualTo(tableSchema);\n        } finally {\n            catalog.dropTable(tablePath, true);\n        }\n    }",
          "conflictNames": [
              "tablePath"
          ]
      },
      "suggestions": [
          {
              "name": "schema",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/3d350485755e47d2b09ac1b2067b6119ef960b5a^1/flink-connectors/flink-connector-hive/src/test/java/org/apache/flink/table/catalog/hive/HiveCatalogHiveMetadataTest.java",
      "locators": [
          {
              "line": 190,
              "column": 22
          },
          {
              "line": 192,
              "column": 36
          },
          {
              "line": 225,
              "column": 22
          },
          {
              "line": 226,
              "column": 36
          },
          {
              "line": 273,
              "column": 22
          },
          {
              "line": 274,
              "column": 20
          },
          {
              "line": 275,
              "column": 31
          },
          {
              "line": 278,
              "column": 20
          },
          {
              "line": 280,
              "column": 20
          },
          {
              "line": 282,
              "column": 20
          },
          {
              "line": 323,
              "column": 22
          },
          {
              "line": 326,
              "column": 36
          },
          {
              "line": 341,
              "column": 37
          },
          {
              "line": 343,
              "column": 24
          },
          {
              "line": 600,
              "column": 22
          },
          {
              "line": 602,
              "column": 36
          }
      ],
      "old_name": "catalogTable",
      "new_name": "resolveCatalogTable",
      "ctx": {
          "symbolName": "catalogTable",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CatalogTable",
          "scopeHint": "in testAlterTableColumnStatistics(...)",
          "filePath": "HiveCatalogHiveMetadataTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testAlterTableColumnStatistics() throws Exception {\n        String hiveVersion = ((HiveCatalog) catalog).getHiveVersion();\n        boolean supportDateStats = hiveVersion.compareTo(HiveShimLoader.HIVE_VERSION_V2_3_0) >= 0;\n        catalog.createDatabase(db1, createDb(), false);\n        TableSchema.Builder builder =\n                TableSchema.builder()\n                        .field(\"first\", DataTypes.STRING())\n                        .field(\"second\", DataTypes.INT())\n                        .field(\"third\", DataTypes.BOOLEAN())\n                        .field(\"fourth\", DataTypes.DOUBLE())\n                        .field(\"fifth\", DataTypes.BIGINT())\n                        .field(\"sixth\", DataTypes.BYTES())\n                        .field(\"seventh\", DataTypes.DECIMAL(10, 3))\n                        .field(\"eighth\", DataTypes.DECIMAL(30, 3));\n        if (supportDateStats) {\n            builder.field(\"ninth\", DataTypes.DATE());\n        }\n        TableSchema tableSchema = builder.build();\n        CatalogTable catalogTable =\n                new CatalogTableImpl(tableSchema, getBatchTableProperties(), TEST_COMMENT);\n        catalog.createTable(path1, catalogTable, false);\n        Map<String, CatalogColumnStatisticsDataBase> columnStatisticsDataBaseMap = new HashMap<>();\n        columnStatisticsDataBaseMap.put(\n                \"first\", new CatalogColumnStatisticsDataString(10L, 5.2, 3L, 100L));\n        columnStatisticsDataBaseMap.put(\n                \"second\", new CatalogColumnStatisticsDataLong(0L, 1000L, 3L, 0L));\n        columnStatisticsDataBaseMap.put(\n                \"third\", new CatalogColumnStatisticsDataBoolean(15L, 20L, 3L));\n        columnStatisticsDataBaseMap.put(\n                \"fourth\", new CatalogColumnStatisticsDataDouble(15.02, 20.01, 3L, 10L));\n        columnStatisticsDataBaseMap.put(\n                \"fifth\", new CatalogColumnStatisticsDataLong(0L, 20L, 3L, 2L));\n        columnStatisticsDataBaseMap.put(\n                \"sixth\", new CatalogColumnStatisticsDataBinary(150L, 20D, 3L));\n        columnStatisticsDataBaseMap.put(\n                \"seventh\", new CatalogColumnStatisticsDataDouble(1.23, 99.456, 100L, 0L));\n        columnStatisticsDataBaseMap.put(\n                \"eighth\", new CatalogColumnStatisticsDataDouble(0.123, 123456.789, 5723L, 19L));\n        if (supportDateStats) {\n            columnStatisticsDataBaseMap.put(\n                    \"ninth\",\n                    new CatalogColumnStatisticsDataDate(new Date(71L), new Date(17923L), 132L, 0L));\n        }\n        CatalogColumnStatistics catalogColumnStatistics =\n                new CatalogColumnStatistics(columnStatisticsDataBaseMap);\n        catalog.alterTableColumnStatistics(path1, catalogColumnStatistics, false);\n\n        checkEquals(catalogColumnStatistics, catalog.getTableColumnStatistics(path1));\n    }",
          "conflictNames": [
              "hiveVersion",
              "supportDateStats",
              "builder",
              "tableSchema",
              "columnStatisticsDataBaseMap",
              "catalogColumnStatistics"
          ]
      },
      "suggestions": [
          {
              "name": "resolvedCatalogTable",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/3d350485755e47d2b09ac1b2067b6119ef960b5a^1/flink-connectors/flink-connector-hive/src/test/java/org/apache/flink/table/catalog/hive/HiveCatalogITCase.java",
      "locators": [
          {
              "line": 355,
              "column": 21
          },
          {
              "line": 371,
              "column": 20
          },
          {
              "line": 372,
              "column": 20
          }
      ],
      "old_name": "tableSchema",
      "new_name": "schema",
      "ctx": {
          "symbolName": "tableSchema",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TableSchema",
          "scopeHint": "in testTableWithPrimaryKey(...)",
          "filePath": "HiveCatalogITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testTableWithPrimaryKey() {\n        TableEnvironment tableEnv = TableEnvironment.create(EnvironmentSettings.inStreamingMode());\n        tableEnv.getConfig().set(TABLE_EXEC_RESOURCE_DEFAULT_PARALLELISM, 1);\n\n        tableEnv.registerCatalog(\"catalog1\", hiveCatalog);\n        tableEnv.useCatalog(\"catalog1\");\n\n        final String createTable =\n                \"CREATE TABLE pk_src (\\n\"\n                        + \"  uuid varchar(40) not null,\\n\"\n                        + \"  price DECIMAL(10, 2),\\n\"\n                        + \"  currency STRING,\\n\"\n                        + \"  ts6 TIMESTAMP(6),\\n\"\n                        + \"  ts AS CAST(ts6 AS TIMESTAMP(3)),\\n\"\n                        + \"  WATERMARK FOR ts AS ts,\\n\"\n                        + \"  constraint ct1 PRIMARY KEY(uuid) NOT ENFORCED)\\n\"\n                        + \"  WITH (\\n\"\n                        + \"    'connector.type' = 'filesystem',\"\n                        + \"    'connector.path' = 'file://fakePath',\"\n                        + \"    'format.type' = 'csv')\";\n\n        tableEnv.executeSql(createTable);\n\n        TableSchema tableSchema =\n                tableEnv.getCatalog(tableEnv.getCurrentCatalog())\n                        .map(\n                                catalog -> {\n                                    try {\n                                        final ObjectPath tablePath =\n                                                ObjectPath.fromString(\n                                                        catalog.getDefaultDatabase()\n                                                                + '.'\n                                                                + \"pk_src\");\n                                        return catalog.getTable(tablePath).getSchema();\n                                    } catch (TableNotExistException e) {\n                                        return null;\n                                    }\n                                })\n                        .orElse(null);\n        assertThat(tableSchema).isNotNull();\n        assertThat(tableSchema.getPrimaryKey())\n                .hasValue(UniqueConstraint.primaryKey(\"ct1\", Collections.singletonList(\"uuid\")));\n        tableEnv.executeSql(\"DROP TABLE pk_src\");\n    }",
          "conflictNames": [
              "tableEnv",
              "createTable",
              "tablePath"
          ]
      },
      "suggestions": [
          {
              "name": "schema",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/3d350485755e47d2b09ac1b2067b6119ef960b5a^1/flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/table/catalog/hive/HiveCatalog.java",
      "locators": [
          {
              "line": 743,
              "column": 21
          },
          {
              "line": 749,
              "column": 13
          },
          {
              "line": 763,
              "column": 34
          },
          {
              "line": 764,
              "column": 13
          },
          {
              "line": 767,
              "column": 13
          },
          {
              "line": 768,
              "column": 21
          },
          {
              "line": 772,
              "column": 45
          },
          {
              "line": 776,
              "column": 29
          },
          {
              "line": 778,
              "column": 71
          },
          {
              "line": 787,
              "column": 21
          },
          {
              "line": 791,
              "column": 41
          }
      ],
      "old_name": "tableSchema",
      "new_name": "schema",
      "ctx": {
          "symbolName": "tableSchema",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TableSchema",
          "scopeHint": "in instantiateCatalogTable(...)",
          "filePath": "HiveCatalog.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@VisibleForTesting\n    CatalogBaseTable instantiateCatalogTable(Table hiveTable) {\n        boolean isView = TableType.valueOf(hiveTable.getTableType()) == TableType.VIRTUAL_VIEW;\n\n        // Table properties\n        Map<String, String> properties = new HashMap<>(hiveTable.getParameters());\n\n        boolean isHiveTable = isHiveTable(properties);\n\n        TableSchema tableSchema;\n        // Partition keys\n        List<String> partitionKeys = new ArrayList<>();\n\n        if (isHiveTable) {\n            // Table schema\n            tableSchema = HiveTableUtil.createTableSchema(hiveConf, hiveTable, client, hiveShim);\n\n            if (!hiveTable.getPartitionKeys().isEmpty()) {\n                partitionKeys = getFieldNames(hiveTable.getPartitionKeys());\n            }\n        } else {\n            properties = retrieveFlinkProperties(properties);\n\n            if (ManagedTableFactory.DEFAULT_IDENTIFIER.equalsIgnoreCase(\n                    properties.get(CONNECTOR.key()))) {\n                // for Flink's managed table, we remove the connector option\n                properties.remove(CONNECTOR.key());\n            }\n\n            DescriptorProperties tableSchemaProps = new DescriptorProperties(true);\n            tableSchemaProps.putProperties(properties);\n            // try to get table schema with both new and old (1.10) key, in order to support tables\n            // created in old version\n            tableSchema =\n                    tableSchemaProps\n                            .getOptionalTableSchema(Schema.SCHEMA)\n                            .orElseGet(\n                                    () ->\n                                            tableSchemaProps\n                                                    .getOptionalTableSchema(\"generic.table.schema\")\n                                                    .orElseGet(\n                                                            () -> TableSchema.builder().build()));\n            partitionKeys = tableSchemaProps.getPartitionKeys();\n            // remove the schema from properties\n            properties = CatalogTableImpl.removeRedundant(properties, tableSchema, partitionKeys);\n        }\n\n        String comment = properties.remove(HiveCatalogConfig.COMMENT);\n\n        if (isView) {\n            return new CatalogViewImpl(\n                    hiveTable.getViewOriginalText(),\n                    hiveTable.getViewExpandedText(),\n                    tableSchema,\n                    properties,\n                    comment);\n        } else {\n            return new CatalogTableImpl(tableSchema, partitionKeys, properties, comment);\n        }\n    }",
          "conflictNames": [
              "hiveTable",
              "isView",
              "properties",
              "isHiveTable",
              "partitionKeys",
              "tableSchemaProps",
              "comment"
          ]
      },
      "suggestions": [
          {
              "name": "schema",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/3d350485755e47d2b09ac1b2067b6119ef960b5a^1/flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/table/catalog/hive/HiveCatalog.java",
      "locators": [
          {
              "line": 763,
              "column": 34
          },
          {
              "line": 764,
              "column": 13
          },
          {
              "line": 768,
              "column": 21
          },
          {
              "line": 772,
              "column": 45
          },
          {
              "line": 776,
              "column": 29
          }
      ],
      "old_name": "tableSchemaProps",
      "new_name": "catalogTable",
      "ctx": {
          "symbolName": "tableSchemaProps",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "DescriptorProperties",
          "scopeHint": "in instantiateCatalogTable(...)",
          "filePath": "HiveCatalog.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@VisibleForTesting\n    CatalogBaseTable instantiateCatalogTable(Table hiveTable) {\n        boolean isView = TableType.valueOf(hiveTable.getTableType()) == TableType.VIRTUAL_VIEW;\n\n        // Table properties\n        Map<String, String> properties = new HashMap<>(hiveTable.getParameters());\n\n        boolean isHiveTable = isHiveTable(properties);\n\n        TableSchema tableSchema;\n        // Partition keys\n        List<String> partitionKeys = new ArrayList<>();\n\n        if (isHiveTable) {\n            // Table schema\n            tableSchema = HiveTableUtil.createTableSchema(hiveConf, hiveTable, client, hiveShim);\n\n            if (!hiveTable.getPartitionKeys().isEmpty()) {\n                partitionKeys = getFieldNames(hiveTable.getPartitionKeys());\n            }\n        } else {\n            properties = retrieveFlinkProperties(properties);\n\n            if (ManagedTableFactory.DEFAULT_IDENTIFIER.equalsIgnoreCase(\n                    properties.get(CONNECTOR.key()))) {\n                // for Flink's managed table, we remove the connector option\n                properties.remove(CONNECTOR.key());\n            }\n\n            DescriptorProperties tableSchemaProps = new DescriptorProperties(true);\n            tableSchemaProps.putProperties(properties);\n            // try to get table schema with both new and old (1.10) key, in order to support tables\n            // created in old version\n            tableSchema =\n                    tableSchemaProps\n                            .getOptionalTableSchema(Schema.SCHEMA)\n                            .orElseGet(\n                                    () ->\n                                            tableSchemaProps\n                                                    .getOptionalTableSchema(\"generic.table.schema\")\n                                                    .orElseGet(\n                                                            () -> TableSchema.builder().build()));\n            partitionKeys = tableSchemaProps.getPartitionKeys();\n            // remove the schema from properties\n            properties = CatalogTableImpl.removeRedundant(properties, tableSchema, partitionKeys);\n        }\n\n        String comment = properties.remove(HiveCatalogConfig.COMMENT);\n\n        if (isView) {\n            return new CatalogViewImpl(\n                    hiveTable.getViewOriginalText(),\n                    hiveTable.getViewExpandedText(),\n                    tableSchema,\n                    properties,\n                    comment);\n        } else {\n            return new CatalogTableImpl(tableSchema, partitionKeys, properties, comment);\n        }\n    }",
          "conflictNames": [
              "hiveTable",
              "isView",
              "properties",
              "isHiveTable",
              "tableSchema",
              "partitionKeys",
              "comment"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/3d676a355e910966fc878bde62d73c1721c79942^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveScheduler.java",
      "locators": [
          {
              "line": 737,
              "column": 56
          },
          {
              "line": 740,
              "column": 48
          },
          {
              "line": 794,
              "column": 31
          },
          {
              "line": 795,
              "column": 53
          },
          {
              "line": 801,
              "column": 25
          }
      ],
      "old_name": "desiredResources",
      "new_name": "newDesiredResources",
      "ctx": {
          "symbolName": "desiredResources",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "ResourceCounter",
          "scopeHint": "in hasDesiredResources(...)",
          "filePath": "AdaptiveScheduler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "                + operator\n                                                        + \" does not exist\")));\n    }\n\n    // ----------------------------------------------------------------\n\n    @Override\n    public boolean hasDesiredResources(ResourceCounter desiredResources) {\n        final Collection<? extends SlotInfo> allSlots =\n                declarativeSlotPool.getFreeSlotsInformation();\n        ResourceCounter outstandingResources = desiredResources;\n\n        final Iterator<? extends SlotInfo> slotIter",
          "conflictNames": [
              "allSlots",
              "outstandingResources",
              "slotIterator",
              "slotInfo",
              "resourceProfile"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/3e5771695539967eae591aa0236860dbf96494fc^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerTest.java",
      "locators": [
          {
              "line": 1467,
              "column": 26
          },
          {
              "line": 1469,
              "column": 39
          },
          {
              "line": 1488,
              "column": 20
          },
          {
              "line": 1490,
              "column": 22
          },
          {
              "line": 1497,
              "column": 26
          },
          {
              "line": 1499,
              "column": 39
          },
          {
              "line": 1520,
              "column": 20
          },
          {
              "line": 1522,
              "column": 22
          },
          {
              "line": 1529,
              "column": 26
          },
          {
              "line": 1531,
              "column": 39
          },
          {
              "line": 1550,
              "column": 20
          },
          {
              "line": 1552,
              "column": 22
          }
      ],
      "old_name": "spanCollector",
      "new_name": "eventCollector",
      "ctx": {
          "symbolName": "spanCollector",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<Span>",
          "scopeHint": "in testHowToHandleFailureRejectedByStrategy(...)",
          "filePath": "AdaptiveSchedulerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testHowToHandleFailureRejectedByStrategy() throws Exception {\n        final Configuration configuration = new Configuration();\n        configuration.set(TraceOptions.REPORT_EVENTS_AS_SPANS, Boolean.TRUE);\n        final List<Span> spanCollector = new ArrayList<>(1);\n        final UnregisteredMetricGroups.UnregisteredJobManagerJobMetricGroup testMetricGroup =\n                createTestMetricGroup(spanCollector);\n\n        final AdaptiveScheduler scheduler =\n                new AdaptiveSchedulerBuilder(\n                                createJobGraph(),\n                                mainThreadExecutor,\n                                EXECUTOR_RESOURCE.getExecutor())\n                        .setRestartBackoffTimeStrategy(NoRestartBackoffTimeStrategy.INSTANCE)\n                        .setJobMasterConfiguration(configuration)\n                        .setJobManagerJobMetricGroup(testMetricGroup)\n                        .build();\n\n        assertThat(\n                        scheduler\n                                .howToHandleFailure(\n                                        new Exception(\"test\"), createFailureLabelsFuture())\n                                .canRestart())\n                .isFalse();\n\n        assertThat(spanCollector).isEmpty();\n        mainThreadExecutor.trigger();\n        checkMetrics(spanCollector, false);\n    }",
          "conflictNames": [
              "configuration",
              "testMetricGroup",
              "scheduler"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/3e5771695539967eae591aa0236860dbf96494fc^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerTest.java",
      "locators": [
          {
              "line": 1467,
              "column": 26
          },
          {
              "line": 1469,
              "column": 39
          },
          {
              "line": 1488,
              "column": 20
          },
          {
              "line": 1490,
              "column": 22
          },
          {
              "line": 1497,
              "column": 26
          },
          {
              "line": 1499,
              "column": 39
          },
          {
              "line": 1520,
              "column": 20
          },
          {
              "line": 1522,
              "column": 22
          },
          {
              "line": 1529,
              "column": 26
          },
          {
              "line": 1531,
              "column": 39
          },
          {
              "line": 1550,
              "column": 20
          },
          {
              "line": 1552,
              "column": 22
          },
          {
              "line": 2787,
              "column": 45
          },
          {
              "line": 2788,
              "column": 28
          },
          {
              "line": 2795,
              "column": 19
          },
          {
              "line": 2796,
              "column": 24
          },
          {
              "line": 2798,
              "column": 24
          },
          {
              "line": 2799,
              "column": 46
          }
      ],
      "old_name": "span",
      "new_name": "event",
      "ctx": {
          "symbolName": "span",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Span",
          "scopeHint": "in checkMetrics(...)",
          "filePath": "AdaptiveSchedulerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "anBuilder spanBuilder) {\n                output.add(spanBuilder.build());\n            }\n        };\n    }\n\n    private static void checkMetrics(List<Span> results, boolean canRestart) {\n        assertThat(results).isNotEmpty();\n        for (Span span : results) {\n            assertThat(span.getScope())\n                    .isEqualTo(JobFailureMetricReporter.class.getCanonicalName());\n            assertThat(span.getName()).isEqualTo(\"JobFailure\");\n            Map<String, Object> attribu",
          "conflictNames": [
              "results",
              "canRestart",
              "attributes"
          ]
      },
      "suggestions": [
          {
              "name": "event",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/3e5771695539967eae591aa0236860dbf96494fc^1/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/failover/ExecutionFailureHandlerTest.java",
      "locators": [
          {
              "line": 78,
              "column": 24
          },
          {
              "line": 91,
              "column": 9
          },
          {
              "line": 106,
              "column": 61
          },
          {
              "line": 107,
              "column": 33
          },
          {
              "line": 107,
              "column": 51
          },
          {
              "line": 139,
              "column": 22
          },
          {
              "line": 176,
              "column": 22
          },
          {
              "line": 218,
              "column": 22
          },
          {
              "line": 244,
              "column": 22
          },
          {
              "line": 311,
              "column": 22
          },
          {
              "line": 342,
              "column": 19
          },
          {
              "line": 343,
              "column": 24
          },
          {
              "line": 345,
              "column": 24
          },
          {
              "line": 346,
              "column": 46
          }
      ],
      "old_name": "span",
      "new_name": "event",
      "ctx": {
          "symbolName": "span",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Span",
          "scopeHint": "in checkMetrics(...)",
          "filePath": "ExecutionFailureHandlerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "executionVertexId, final Throwable cause) {\n\n            return tasksToRestart;\n        }\n    }\n\n    private void checkMetrics(List<Span> results, boolean global, boolean canRestart) {\n        assertThat(results).isNotEmpty();\n        for (Span span : results) {\n            assertThat(span.getScope())\n                    .isEqualTo(JobFailureMetricReporter.class.getCanonicalName());\n            assertThat(span.getName()).isEqualTo(\"JobFailure\");\n            Map<String, Object> attribu",
          "conflictNames": [
              "results",
              "global",
              "canRestart",
              "attributes"
          ]
      },
      "suggestions": [
          {
              "name": "event",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/3e5771695539967eae591aa0236860dbf96494fc^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/JobFailureMetricReporter.java",
      "locators": [
          {
              "line": 64,
              "column": 21
          },
          {
              "line": 70,
              "column": 13
          },
          {
              "line": 74,
              "column": 13
          },
          {
              "line": 79,
              "column": 13
          },
          {
              "line": 82,
              "column": 29
          }
      ],
      "old_name": "spanBuilder",
      "new_name": "eventBuilder",
      "ctx": {
          "symbolName": "spanBuilder",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SpanBuilder",
          "scopeHint": "in reportJobFailure(...)",
          "filePath": "JobFailureMetricReporter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void reportJobFailure(\n            long timestamp,\n            Boolean canRestart,\n            Boolean isGlobal,\n            Map<String, String> failureLabels) {\n        // Add base attributes\n        SpanBuilder spanBuilder =\n                Span.builder(JobFailureMetricReporter.class, \"JobFailure\")\n                        .setStartTsMillis(timestamp)\n                        .setEndTsMillis(timestamp);\n\n        if (canRestart != null) {\n            spanBuilder.setAttribute(\"canRestart\", String.valueOf(canRestart));\n        }\n\n        if (isGlobal != null) {\n            spanBuilder.setAttribute(\"isGlobalFailure\", String.valueOf(isGlobal));\n        }\n\n        // Add all failure labels\n        for (Map.Entry<String, String> entry : failureLabels.entrySet()) {\n            spanBuilder.setAttribute(\n                    FAILURE_LABEL_ATTRIBUTE_PREFIX + entry.getKey(), entry.getValue());\n        }\n        metricGroup.addSpan(spanBuilder);\n    }",
          "conflictNames": [
              "timestamp",
              "canRestart",
              "isGlobal",
              "failureLabels"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/3f53ef1fad8f45083cbad34eaaf2a67fb7fa9df4^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/physical/stream/PushFilterPastChangelogNormalizeRule.java",
      "locators": [
          {
              "line": 138,
              "column": 17
          },
          {
              "line": 154,
              "column": 8
          },
          {
              "line": 156,
              "column": 32
          },
          {
              "line": 179,
              "column": 8
          },
          {
              "line": 179,
              "column": 41
          },
          {
              "line": 181,
              "column": 32
          },
          {
              "line": 182,
              "column": 55
          },
          {
              "line": 190,
              "column": 40
          },
          {
              "line": 191,
              "column": 17
          },
          {
              "line": 192,
              "column": 27
          },
          {
              "line": 192,
              "column": 37
          },
          {
              "line": 192,
              "column": 81
          },
          {
              "line": 193,
              "column": 39
          },
          {
              "line": 193,
              "column": 48
          },
          {
              "line": 212,
              "column": 17
          },
          {
              "line": 213,
              "column": 53
          }
      ],
      "old_name": "project",
      "new_name": "shiftedProject",
      "ctx": {
          "symbolName": "project",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RexNode",
          "scopeHint": "in projectWith(...)",
          "filePath": "PushFilterPastChangelogNormalizeRule.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Returns a {@link StreamPhysicalCalc} which is a copy of {@param calc}, but with the\n     * projections applied from {@param projectFromCalc}.\n     */\n    private StreamPhysicalCalc projectWith(\n            RelBuilder relBuilder, StreamPhysicalCalc projectFromCalc, StreamPhysicalCalc calc) {\n        final RexProgramBuilder programBuilder =\n                new RexProgramBuilder(calc.getRowType(), relBuilder.getRexBuilder());\n        if (calc.getProgram().getCondition() != null) {\n            programBuilder.addCondition(\n                    calc.getProgram().expandLocalRef(calc.getProgram().getCondition()));\n        }\n\n        for (Pair<RexLocalRef, String> projectRef :\n                projectFromCalc.getProgram().getNamedProjects()) {\n            final RexNode project = projectFromCalc.getProgram().expandLocalRef(projectRef.left);\n            programBuilder.addProject(project, projectRef.right);\n        }\n\n        final RexProgram newProgram = programBuilder.getProgram();\n        return (StreamPhysicalCalc) calc.copy(calc.getTraitSet(), calc.getInput(), newProgram);\n    }",
          "conflictNames": [
              "relBuilder",
              "projectFromCalc",
              "calc",
              "programBuilder",
              "newProgram"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/3f53ef1fad8f45083cbad34eaaf2a67fb7fa9df4^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/physical/stream/PushFilterPastChangelogNormalizeRule.java",
      "locators": [
          {
              "line": 190,
              "column": 40
          },
          {
              "line": 192,
              "column": 81
          },
          {
              "line": 193,
              "column": 48
          }
      ],
      "old_name": "projectRef",
      "new_name": "ref",
      "ctx": {
          "symbolName": "projectRef",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Pair<RexLocalRef, String>",
          "scopeHint": "in projectWith(...)",
          "filePath": "PushFilterPastChangelogNormalizeRule.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": " relBuilder.getRexBuilder());\n        if (calc.getProgram().getCondition() != null) {\n            programBuilder.addCondition(\n                    calc.getProgram().expandLocalRef(calc.getProgram().getCondition()));\n        }\n\n        for (Pair<RexLocalRef, String> projectRef :\n                projectFromCalc.getProgram().getNamedProjects()) {\n            final RexNode project = projectFromCalc.getProgram().expandLocalRef(projectRef.left);\n            programBuilder.addProject(project, projectRef.right);\n      ",
          "conflictNames": [
              "relBuilder",
              "projectFromCalc",
              "calc",
              "programBuilder",
              "project",
              "newProgram"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/3f5428ff1092ac0332c6712318f18a1483aed797^1/flink-examples/flink-examples-table/src/main/java/org/apache/flink/table/examples/java/connectors/SocketDynamicTableSource.java",
      "locators": [
          {
              "line": 78,
              "column": 39
          },
          {
              "line": 81,
              "column": 42
          }
      ],
      "old_name": "sourceFunction",
      "new_name": "socketSource",
      "ctx": {
          "symbolName": "sourceFunction",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SourceFunction<RowData>",
          "scopeHint": "in getScanRuntimeProvider(...)",
          "filePath": "SocketDynamicTableSource.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public ScanRuntimeProvider getScanRuntimeProvider(ScanContext runtimeProviderContext) {\n\n        // create runtime classes that are shipped to the cluster\n\n        final DeserializationSchema<RowData> deserializer =\n                decodingFormat.createRuntimeDecoder(runtimeProviderContext, producedDataType);\n\n        final SourceFunction<RowData> sourceFunction =\n                new SocketSourceFunction(hostname, port, byteDelimiter, deserializer);\n\n        return SourceFunctionProvider.of(sourceFunction, false);\n    }",
          "conflictNames": [
              "runtimeProviderContext",
              "deserializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/3ff225c5f993282d6dfc7726fc08cc00058d9a7f^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/ExecutingTest.java",
      "locators": [
          {
              "line": 455,
              "column": 16
          },
          {
              "line": 471,
              "column": 35
          },
          {
              "line": 472,
              "column": 13
          },
          {
              "line": 473,
              "column": 13
          },
          {
              "line": 479,
              "column": 75
          }
      ],
      "old_name": "context",
      "new_name": "ctx",
      "ctx": {
          "symbolName": "context",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "MockExecutingContext",
          "scopeHint": "in testExecutingChecksForNewResourcesWhenBeingCreated(...)",
          "filePath": "ExecutingTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testExecutingChecksForNewResourcesWhenBeingCreated() throws Exception {\n        try (MockExecutingContext context = new MockExecutingContext()) {\n            context.setCanScaleUp(() -> true);\n            context.setExpectRestarting(\n                    restartingArguments -> {\n                        // expect immediate restart on scale up\n                        assertThat(restartingArguments.getBackoffTime(), is(Duration.ZERO));\n                    });\n\n            final Executing executing = new ExecutingStateBuilder().build(context);\n        }\n    }",
          "conflictNames": [
              "executing"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/41379fbdbde17e9fd85979bfbaace05a94db27c9^1/flink-runtime/src/test/java/org/apache/flink/runtime/state/ttl/TtlAwareSerializerSnapshotWrapperTest.java",
      "locators": [
          {
              "line": 41,
              "column": 41
          },
          {
              "line": 45,
              "column": 61
          },
          {
              "line": 56,
              "column": 41
          },
          {
              "line": 60,
              "column": 64
          },
          {
              "line": 71,
              "column": 41
          },
          {
              "line": 75,
              "column": 67
          }
      ],
      "old_name": "intSerializerSnapshot",
      "new_name": "listTypeSerializerSnapshot",
      "ctx": {
          "symbolName": "intSerializerSnapshot",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TypeSerializerSnapshot<Integer>",
          "scopeHint": "in testValueStateTtlAwareSerializerSnapshot(...)",
          "filePath": "TtlAwareSerializerSnapshotWrapperTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "\n    @Test\n    public void testValueStateTtlAwareSerializerSnapshot() {\n        TypeSerializerSnapshot<Integer> intSerializerSnapshot =\n                IntSerializer.INSTANCE.snapshotConfiguration();\n        TypeSerializerSnapshot<Integer> serializerSnapshot =\n                (new TtlAwareSerializerSnapshotWrapper<>(\n                                StateDescriptor.Type.VALUE, intSerializerSnapshot))\n                        .getTtlAwareSerializerSnapshot();\n        assertThat(serializerSnapshot).isInstanceOf(TtlAwareSerializerSnapshot.class);\n        assertThat(\n                        ((TtlAwareSerializer<Integer>) serializerSnapshot.restoreSerializer())\n                                .getOriginalTypeSerializer())\n                .isInstanceOf(IntSerializer.class);\n    }",
          "conflictNames": [
              "serializerSnapshot"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/416cb7aaa02c176e01485ff11ab4269f76b5e9e2^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/allocator/SlotSharingSlotAllocatorTest.java",
      "locators": [
          {
              "line": 99,
              "column": 33
          },
          {
              "line": 103,
              "column": 17
          },
          {
              "line": 121,
              "column": 33
          },
          {
              "line": 125,
              "column": 17
          },
          {
              "line": 183,
              "column": 58
          },
          {
              "line": 186,
              "column": 20
          }
      ],
      "old_name": "slotSharingAssignments",
      "new_name": "vertexParallelism",
      "ctx": {
          "symbolName": "slotSharingAssignments",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "VertexParallelism",
          "scopeHint": "in testDetermineParallelismWithMinimumSlots(...)",
          "filePath": "SlotSharingSlotAllocatorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testDetermineParallelismWithMinimumSlots() {\n        final SlotSharingSlotAllocator slotAllocator =\n                SlotSharingSlotAllocator.createSlotSharingSlotAllocator(\n                        TEST_RESERVE_SLOT_FUNCTION,\n                        TEST_FREE_SLOT_FUNCTION,\n                        TEST_IS_SLOT_FREE_FUNCTION);\n\n        final JobInformation jobInformation =\n                new TestJobInformation(Arrays.asList(vertex1, vertex2, vertex3));\n\n        final VertexParallelism slotSharingAssignments =\n                slotAllocator.determineParallelism(jobInformation, getSlots(2)).get();\n\n        final Map<JobVertexID, Integer> maxParallelismForVertices =\n                slotSharingAssignments.getMaxParallelismForVertices();\n\n        assertThat(maxParallelismForVertices.get(vertex1.getJobVertexID()), is(1));\n        assertThat(maxParallelismForVertices.get(vertex2.getJobVertexID()), is(1));\n        assertThat(maxParallelismForVertices.get(vertex3.getJobVertexID()), is(1));\n    }",
          "conflictNames": [
              "slotAllocator",
              "jobInformation",
              "maxParallelismForVertices"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/416cb7aaa02c176e01485ff11ab4269f76b5e9e2^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/allocator/SlotSharingSlotAllocatorTest.java",
      "locators": [
          {
              "line": 102,
              "column": 41
          },
          {
              "line": 105,
              "column": 20
          },
          {
              "line": 106,
              "column": 20
          },
          {
              "line": 107,
              "column": 20
          },
          {
              "line": 124,
              "column": 41
          },
          {
              "line": 128,
              "column": 17
          },
          {
              "line": 131,
              "column": 17
          },
          {
              "line": 134,
              "column": 17
          },
          {
              "line": 156,
              "column": 35
          },
          {
              "line": 164,
              "column": 31
          },
          {
              "line": 166,
              "column": 31
          },
          {
              "line": 168,
              "column": 31
          }
      ],
      "old_name": "maxParallelismForVertices",
      "new_name": "vertexParallelism",
      "ctx": {
          "symbolName": "maxParallelismForVertices",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Map<JobVertexID, Integer>",
          "scopeHint": "in testDetermineParallelismWithMinimumSlots(...)",
          "filePath": "SlotSharingSlotAllocatorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testDetermineParallelismWithMinimumSlots() {\n        final SlotSharingSlotAllocator slotAllocator =\n                SlotSharingSlotAllocator.createSlotSharingSlotAllocator(\n                        TEST_RESERVE_SLOT_FUNCTION,\n                        TEST_FREE_SLOT_FUNCTION,\n                        TEST_IS_SLOT_FREE_FUNCTION);\n\n        final JobInformation jobInformation =\n                new TestJobInformation(Arrays.asList(vertex1, vertex2, vertex3));\n\n        final VertexParallelism slotSharingAssignments =\n                slotAllocator.determineParallelism(jobInformation, getSlots(2)).get();\n\n        final Map<JobVertexID, Integer> maxParallelismForVertices =\n                slotSharingAssignments.getMaxParallelismForVertices();\n\n        assertThat(maxParallelismForVertices.get(vertex1.getJobVertexID()), is(1));\n        assertThat(maxParallelismForVertices.get(vertex2.getJobVertexID()), is(1));\n        assertThat(maxParallelismForVertices.get(vertex3.getJobVertexID()), is(1));\n    }",
          "conflictNames": [
              "slotAllocator",
              "jobInformation",
              "slotSharingAssignments"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/416cb7aaa02c176e01485ff11ab4269f76b5e9e2^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/allocator/SlotSharingSlotAllocatorTest.java",
      "locators": [
          {
              "line": 200,
              "column": 48
          },
          {
              "line": 205,
              "column": 46
          },
          {
              "line": 211,
              "column": 17
          },
          {
              "line": 237,
              "column": 48
          },
          {
              "line": 241,
              "column": 62
          }
      ],
      "old_name": "slotAssignments",
      "new_name": "jobSchedulingPlan",
      "ctx": {
          "symbolName": "slotAssignments",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "VertexParallelismWithSlotSharing",
          "scopeHint": "in testReserveAvailableResources(...)",
          "filePath": "SlotSharingSlotAllocatorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testReserveAvailableResources() {\n        final SlotSharingSlotAllocator slotAllocator =\n                SlotSharingSlotAllocator.createSlotSharingSlotAllocator(\n                        TEST_RESERVE_SLOT_FUNCTION,\n                        TEST_FREE_SLOT_FUNCTION,\n                        TEST_IS_SLOT_FREE_FUNCTION);\n\n        final JobInformation jobInformation =\n                new TestJobInformation(Arrays.asList(vertex1, vertex2, vertex3));\n\n        final VertexParallelismWithSlotSharing slotAssignments =\n                slotAllocator.determineParallelism(jobInformation, getSlots(50)).get();\n\n        final ReservedSlots reservedSlots =\n                slotAllocator\n                        .tryReserveResources(slotAssignments)\n                        .orElseThrow(\n                                () -> new RuntimeException(\"Expected that reservation succeeds.\"));\n\n        final Map<ExecutionVertexID, SlotInfo> expectedAssignments = new HashMap<>();\n        for (SlotSharingSlotAllocator.ExecutionSlotSharingGroupAndSlot assignment :\n                slotAssignments.getAssignments()) {\n            for (ExecutionVertexID containedExecutionVertex :\n                    assignment.getExecutionSlotSharingGroup().getContainedExecutionVertices()) {\n                expectedAssignments.put(containedExecutionVertex, assignment.getSlotInfo());\n            }\n        }\n\n        for (Map.Entry<ExecutionVertexID, SlotInfo> expectedAssignment :\n                expectedAssignments.entrySet()) {\n            final LogicalSlot assignedSlot = reservedSlots.getSlotFor(expectedAssignment.getKey());\n\n            final SlotInfo backingSlot = expectedAssignment.getValue();\n\n            assertThat(assignedSlot.getAllocationId(), is(backingSlot.getAllocationId()));\n        }\n    }",
          "conflictNames": [
              "slotAllocator",
              "jobInformation",
              "reservedSlots",
              "expectedAssignments",
              "assignedSlot",
              "backingSlot"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/416cb7aaa02c176e01485ff11ab4269f76b5e9e2^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveScheduler.java",
      "locators": [
          {
              "line": 245,
              "column": 32
          },
          {
              "line": 247,
              "column": 40
          },
          {
              "line": 248,
              "column": 68
          },
          {
              "line": 935,
              "column": 33
          },
          {
              "line": 939,
              "column": 13
          },
          {
              "line": 947,
              "column": 39
          },
          {
              "line": 957,
              "column": 62
          },
          {
              "line": 959,
              "column": 40
          },
          {
              "line": 969,
              "column": 57
          },
          {
              "line": 985,
              "column": 33
          },
          {
              "line": 988,
              "column": 38
          }
      ],
      "old_name": "vertexParallelism",
      "new_name": "schedulingPlan",
      "ctx": {
          "symbolName": "vertexParallelism",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "VertexParallelism",
          "scopeHint": "in createExecutionGraphWithAvailableResourcesAsync(...)",
          "filePath": "AdaptiveScheduler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private CompletableFuture<CreatingExecutionGraph.ExecutionGraphWithVertexParallelism>\n            createExecutionGraphWithAvailableResourcesAsync() {\n        final VertexParallelism vertexParallelism;\n        final VertexParallelismStore adjustedParallelismStore;\n\n        try {\n            vertexParallelism = determineParallelism(slotAllocator);\n            JobGraph adjustedJobGraph = jobInformation.copyJobGraph();\n\n            for (JobVertex vertex : adjustedJobGraph.getVertices()) {\n                JobVertexID id = vertex.getID();\n\n                // use the determined \"available parallelism\" to use\n                // the resources we have access to\n                vertex.setParallelism(vertexParallelism.getParallelism(id));\n            }\n\n            // use the originally configured max parallelism\n            // as the default for consistent runs\n            adjustedParallelismStore =\n                    computeVertexParallelismStoreForExecution(\n                            adjustedJobGraph,\n                            executionMode,\n                            (vertex) -> {\n                                VertexParallelismInformation vertexParallelismInfo =\n                                        initialParallelismStore.getParallelismInfo(vertex.getID());\n                                return vertexParallelismInfo.getMaxParallelism();\n                            });\n        } catch (Exception exception) {\n            return FutureUtils.completedExceptionally(exception);\n        }\n\n        return createExecutionGraphAndRestoreStateAsync(adjustedParallelismStore)\n                .thenApply(\n                        executionGraph ->\n                                CreatingExecutionGraph.ExecutionGraphWithVertexParallelism.create(\n                                        executionGraph, vertexParallelism));\n    }",
          "conflictNames": [
              "adjustedParallelismStore",
              "adjustedJobGraph",
              "id",
              "vertexParallelismInfo"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/416cb7aaa02c176e01485ff11ab4269f76b5e9e2^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveScheduler.java",
      "locators": [
          {
              "line": 245,
              "column": 32
          },
          {
              "line": 247,
              "column": 40
          },
          {
              "line": 248,
              "column": 68
          },
          {
              "line": 935,
              "column": 33
          },
          {
              "line": 939,
              "column": 13
          },
          {
              "line": 947,
              "column": 39
          },
          {
              "line": 957,
              "column": 62
          },
          {
              "line": 959,
              "column": 40
          },
          {
              "line": 969,
              "column": 57
          },
          {
              "line": 985,
              "column": 33
          },
          {
              "line": 988,
              "column": 38
          }
      ],
      "old_name": "vertexParallelism",
      "new_name": "jobSchedulingPlan",
      "ctx": {
          "symbolName": "vertexParallelism",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "VertexParallelism",
          "scopeHint": "in createExecutionGraphWithAvailableResourcesAsync(...)",
          "filePath": "AdaptiveScheduler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private CompletableFuture<CreatingExecutionGraph.ExecutionGraphWithVertexParallelism>\n            createExecutionGraphWithAvailableResourcesAsync() {\n        final VertexParallelism vertexParallelism;\n        final VertexParallelismStore adjustedParallelismStore;\n\n        try {\n            vertexParallelism = determineParallelism(slotAllocator);\n            JobGraph adjustedJobGraph = jobInformation.copyJobGraph();\n\n            for (JobVertex vertex : adjustedJobGraph.getVertices()) {\n                JobVertexID id = vertex.getID();\n\n                // use the determined \"available parallelism\" to use\n                // the resources we have access to\n                vertex.setParallelism(vertexParallelism.getParallelism(id));\n            }\n\n            // use the originally configured max parallelism\n            // as the default for consistent runs\n            adjustedParallelismStore =\n                    computeVertexParallelismStoreForExecution(\n                            adjustedJobGraph,\n                            executionMode,\n                            (vertex) -> {\n                                VertexParallelismInformation vertexParallelismInfo =\n                                        initialParallelismStore.getParallelismInfo(vertex.getID());\n                                return vertexParallelismInfo.getMaxParallelism();\n                            });\n        } catch (Exception exception) {\n            return FutureUtils.completedExceptionally(exception);\n        }\n\n        return createExecutionGraphAndRestoreStateAsync(adjustedParallelismStore)\n                .thenApply(\n                        executionGraph ->\n                                CreatingExecutionGraph.ExecutionGraphWithVertexParallelism.create(\n                                        executionGraph, vertexParallelism));\n    }",
          "conflictNames": [
              "adjustedParallelismStore",
              "adjustedJobGraph",
              "id",
              "vertexParallelismInfo"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/416cb7aaa02c176e01485ff11ab4269f76b5e9e2^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/allocator/SlotSharingSlotAllocator.java",
      "locators": [
          {
              "line": 2,
              "column": 5
          },
          {
              "line": 2,
              "column": 43
          },
          {
              "line": 3,
              "column": 9
          },
          {
              "line": 3,
              "column": 17
          },
          {
              "line": 3,
              "column": 53
          },
          {
              "line": 3,
              "column": 58
          },
          {
              "line": 3,
              "column": 62
          },
          {
              "line": 3,
              "column": 70
          },
          {
              "line": 4,
              "column": 6
          },
          {
              "line": 4,
              "column": 21
          },
          {
              "line": 4,
              "column": 23
          },
          {
              "line": 4,
              "column": 29
          },
          {
              "line": 4,
              "column": 37
          },
          {
              "line": 4,
              "column": 47
          },
          {
              "line": 4,
              "column": 56
          },
          {
              "line": 4,
              "column": 68
          },
          {
              "line": 5,
              "column": 13
          },
          {
              "line": 5,
              "column": 23
          },
          {
              "line": 5,
              "column": 27
          },
          {
              "line": 5,
              "column": 56
          },
          {
              "line": 5,
              "column": 68
          },
          {
              "line": 6,
              "column": 11
          },
          {
              "line": 6,
              "column": 39
          },
          {
              "line": 6,
              "column": 43
          },
          {
              "line": 6,
              "column": 54
          },
          {
              "line": 6,
              "column": 62
          },
          {
              "line": 6,
              "column": 69
          },
          {
              "line": 7,
              "column": 9
          },
          {
              "line": 7,
              "column": 30
          },
          {
              "line": 7,
              "column": 48
          },
          {
              "line": 9,
              "column": 30
          },
          {
              "line": 11,
              "column": 15
          },
          {
              "line": 11,
              "column": 27
          },
          {
              "line": 11,
              "column": 51
          },
          {
              "line": 11,
              "column": 56
          },
          {
              "line": 11,
              "column": 58
          },
          {
              "line": 12,
              "column": 5
          },
          {
              "line": 12,
              "column": 9
          },
          {
              "line": 12,
              "column": 27
          },
          {
              "line": 12,
              "column": 34
          },
          {
              "line": 12,
              "column": 38
          },
          {
              "line": 12,
              "column": 42
          },
          {
              "line": 13,
              "column": 51
          },
          {
              "line": 13,
              "column": 68
          },
          {
              "line": 13,
              "column": 72
          },
          {
              "line": 14,
              "column": 13
          },
          {
              "line": 14,
              "column": 32
          },
          {
              "line": 14,
              "column": 34
          },
          {
              "line": 14,
              "column": 52
          },
          {
              "line": 14,
              "column": 60
          },
          {
              "line": 14,
              "column": 63
          },
          {
              "line": 15,
              "column": 5
          },
          {
              "line": 15,
              "column": 7
          },
          {
              "line": 15,
              "column": 11
          },
          {
              "line": 15,
              "column": 27
          },
          {
              "line": 18,
              "column": 22
          },
          {
              "line": 18,
              "column": 30
          },
          {
              "line": 18,
              "column": 49
          },
          {
              "line": 20,
              "column": 1
          },
          {
              "line": 20,
              "column": 21
          },
          {
              "line": 20,
              "column": 29
          },
          {
              "line": 20,
              "column": 63
          },
          {
              "line": 21,
              "column": 1
          },
          {
              "line": 21,
              "column": 21
          },
          {
              "line": 21,
              "column": 29
          },
          {
              "line": 21,
              "column": 68
          },
          {
              "line": 22,
              "column": 1
          },
          {
              "line": 22,
              "column": 21
          },
          {
              "line": 22,
              "column": 29
          },
          {
              "line": 22,
              "column": 33
          },
          {
              "line": 22,
              "column": 50
          },
          {
              "line": 23,
              "column": 1
          },
          {
              "line": 23,
              "column": 21
          },
          {
              "line": 23,
              "column": 29
          },
          {
              "line": 24,
              "column": 1
          },
          {
              "line": 24,
              "column": 21
          },
          {
              "line": 24,
              "column": 29
          },
          {
              "line": 24,
              "column": 62
          },
          {
              "line": 25,
              "column": 1
          },
          {
              "line": 25,
              "column": 21
          },
          {
              "line": 25,
              "column": 29
          },
          {
              "line": 25,
              "column": 46
          },
          {
              "line": 26,
              "column": 1
          },
          {
              "line": 26,
              "column": 21
          },
          {
              "line": 26,
              "column": 29
          },
          {
              "line": 27,
              "column": 1
          },
          {
              "line": 27,
              "column": 21
          },
          {
              "line": 27,
              "column": 29
          },
          {
              "line": 28,
              "column": 1
          },
          {
              "line": 28,
              "column": 21
          },
          {
              "line": 28,
              "column": 29
          },
          {
              "line": 28,
              "column": 56
          },
          {
              "line": 29,
              "column": 1
          },
          {
              "line": 29,
              "column": 21
          },
          {
              "line": 29,
              "column": 29
          },
          {
              "line": 29,
              "column": 58
          },
          {
              "line": 30,
              "column": 1
          },
          {
              "line": 30,
              "column": 21
          },
          {
              "line": 30,
              "column": 29
          },
          {
              "line": 30,
              "column": 35
          },
          {
              "line": 31,
              "column": 1
          },
          {
              "line": 31,
              "column": 21
          },
          {
              "line": 31,
              "column": 27
          },
          {
              "line": 31,
              "column": 37
          },
          {
              "line": 31,
              "column": 39
          },
          {
              "line": 33,
              "column": 1
          },
          {
              "line": 33,
              "column": 21
          },
          {
              "line": 35,
              "column": 1
          },
          {
              "line": 35,
              "column": 15
          },
          {
              "line": 35,
              "column": 24
          },
          {
              "line": 36,
              "column": 1
          },
          {
              "line": 36,
              "column": 15
          },
          {
              "line": 36,
              "column": 25
          },
          {
              "line": 37,
              "column": 1
          },
          {
              "line": 37,
              "column": 15
          },
          {
              "line": 38,
              "column": 1
          },
          {
              "line": 38,
              "column": 15
          },
          {
              "line": 39,
              "column": 1
          },
          {
              "line": 39,
              "column": 15
          },
          {
              "line": 40,
              "column": 1
          },
          {
              "line": 40,
              "column": 15
          },
          {
              "line": 41,
              "column": 1
          },
          {
              "line": 41,
              "column": 15
          },
          {
              "line": 41,
              "column": 19
          },
          {
              "line": 42,
              "column": 1
          },
          {
              "line": 42,
              "column": 15
          },
          {
              "line": 43,
              "column": 1
          },
          {
              "line": 43,
              "column": 15
          },
          {
              "line": 43,
              "column": 21
          },
          {
              "line": 44,
              "column": 1
          },
          {
              "line": 44,
              "column": 15
          },
          {
              "line": 45,
              "column": 1
          },
          {
              "line": 45,
              "column": 15
          },
          {
              "line": 47,
              "column": 8
          },
          {
              "line": 47,
              "column": 27
          },
          {
              "line": 47,
              "column": 38
          },
          {
              "line": 47,
              "column": 65
          },
          {
              "line": 48,
              "column": 5
          },
          {
              "line": 48,
              "column": 22
          },
          {
              "line": 48,
              "column": 39
          },
          {
              "line": 50,
              "column": 7
          },
          {
              "line": 50,
              "column": 14
          },
          {
              "line": 50,
              "column": 35
          },
          {
              "line": 50,
              "column": 55
          },
          {
              "line": 51,
              "column": 7
          },
          {
              "line": 51,
              "column": 14
          },
          {
              "line": 51,
              "column": 32
          },
          {
              "line": 51,
              "column": 49
          },
          {
              "line": 52,
              "column": 7
          },
          {
              "line": 52,
              "column": 14
          },
          {
              "line": 52,
              "column": 28
          },
          {
              "line": 52,
              "column": 46
          },
          {
              "line": 52,
              "column": 50
          },
          {
              "line": 52,
              "column": 59
          },
          {
              "line": 52,
              "column": 77
          },
          {
              "line": 54,
              "column": 7
          },
          {
              "line": 54,
              "column": 21
          },
          {
              "line": 55,
              "column": 29
          },
          {
              "line": 56,
              "column": 26
          },
          {
              "line": 56,
              "column": 43
          },
          {
              "line": 57,
              "column": 22
          },
          {
              "line": 57,
              "column": 40
          },
          {
              "line": 57,
              "column": 44
          },
          {
              "line": 57,
              "column": 53
          },
          {
              "line": 57,
              "column": 71
          },
          {
              "line": 58,
              "column": 11
          },
          {
              "line": 58,
              "column": 30
          },
          {
              "line": 59,
              "column": 11
          },
          {
              "line": 59,
              "column": 27
          },
          {
              "line": 59,
              "column": 46
          },
          {
              "line": 60,
              "column": 11
          },
          {
              "line": 60,
              "column": 14
          },
          {
              "line": 60,
              "column": 23
          },
          {
              "line": 60,
              "column": 41
          },
          {
              "line": 60,
              "column": 47
          },
          {
              "line": 60,
              "column": 56
          },
          {
              "line": 60,
              "column": 74
          },
          {
              "line": 63,
              "column": 9
          },
          {
              "line": 63,
              "column": 16
          },
          {
              "line": 63,
              "column": 27
          },
          {
              "line": 63,
              "column": 58
          },
          {
              "line": 64,
              "column": 29
          },
          {
              "line": 65,
              "column": 26
          },
          {
              "line": 65,
              "column": 43
          },
          {
              "line": 66,
              "column": 22
          },
          {
              "line": 66,
              "column": 40
          },
          {
              "line": 66,
              "column": 44
          },
          {
              "line": 66,
              "column": 53
          },
          {
              "line": 66,
              "column": 71
          },
          {
              "line": 67,
              "column": 28
          },
          {
              "line": 68,
              "column": 43
          },
          {
              "line": 68,
              "column": 48
          },
          {
              "line": 68,
              "column": 57
          },
          {
              "line": 68,
              "column": 75
          },
          {
              "line": 71,
              "column": 11
          },
          {
              "line": 72,
              "column": 9
          },
          {
              "line": 72,
              "column": 41
          },
          {
              "line": 73,
              "column": 33
          },
          {
              "line": 73,
              "column": 51
          },
          {
              "line": 73,
              "column": 60
          },
          {
              "line": 74,
              "column": 9
          },
          {
              "line": 74,
              "column": 25
          },
          {
              "line": 75,
              "column": 26
          },
          {
              "line": 75,
              "column": 52
          },
          {
              "line": 75,
              "column": 66
          },
          {
              "line": 75,
              "column": 80
          },
          {
              "line": 76,
              "column": 25
          },
          {
              "line": 76,
              "column": 42
          },
          {
              "line": 78,
              "column": 33
          },
          {
              "line": 78,
              "column": 57
          },
          {
              "line": 78,
              "column": 82
          },
          {
              "line": 81,
              "column": 7
          },
          {
              "line": 81,
              "column": 17
          },
          {
              "line": 81,
              "column": 32
          },
          {
              "line": 81,
              "column": 67
          },
          {
              "line": 81,
              "column": 81
          },
          {
              "line": 82,
              "column": 33
          },
          {
              "line": 82,
              "column": 51
          },
          {
              "line": 82,
              "column": 60
          },
          {
              "line": 83,
              "column": 10
          },
          {
              "line": 83,
              "column": 27
          },
          {
              "line": 83,
              "column": 59
          },
          {
              "line": 83,
              "column": 73
          },
          {
              "line": 84,
              "column": 25
          },
          {
              "line": 84,
              "column": 43
          },
          {
              "line": 84,
              "column": 60
          },
          {
              "line": 85,
              "column": 24
          },
          {
              "line": 85,
              "column": 38
          },
          {
              "line": 86,
              "column": 39
          },
          {
              "line": 86,
              "column": 61
          },
          {
              "line": 87,
              "column": 30
          },
          {
              "line": 87,
              "column": 60
          },
          {
              "line": 88,
              "column": 47
          },
          {
              "line": 89,
              "column": 57
          },
          {
              "line": 90,
              "column": 66
          },
          {
              "line": 90,
              "column": 89
          },
          {
              "line": 92,
              "column": 27
          },
          {
              "line": 92,
              "column": 41
          },
          {
              "line": 95,
              "column": 11
          },
          {
              "line": 96,
              "column": 9
          },
          {
              "line": 96,
              "column": 15
          },
          {
              "line": 96,
              "column": 35
          },
          {
              "line": 96,
              "column": 39
          },
          {
              "line": 96,
              "column": 50
          },
          {
              "line": 96,
              "column": 61
          },
          {
              "line": 96,
              "column": 72
          },
          {
              "line": 97,
              "column": 24
          },
          {
              "line": 97,
              "column": 39
          },
          {
              "line": 97,
              "column": 51
          },
          {
              "line": 99,
              "column": 40
          },
          {
              "line": 100,
              "column": 9
          },
          {
              "line": 100,
              "column": 24
          },
          {
              "line": 100,
              "column": 39
          },
          {
              "line": 100,
              "column": 52
          },
          {
              "line": 100,
              "column": 71
          },
          {
              "line": 101,
              "column": 23
          },
          {
              "line": 104,
              "column": 10
          },
          {
              "line": 104,
              "column": 27
          },
          {
              "line": 104,
              "column": 56
          },
          {
              "line": 104,
              "column": 72
          },
          {
              "line": 105,
              "column": 23
          },
          {
              "line": 105,
              "column": 38
          },
          {
              "line": 105,
              "column": 58
          },
          {
              "line": 105,
              "column": 74
          },
          {
              "line": 107,
              "column": 10
          },
          {
              "line": 107,
              "column": 69
          },
          {
              "line": 109,
              "column": 10
          },
          {
              "line": 109,
              "column": 22
          },
          {
              "line": 109,
              "column": 32
          },
          {
              "line": 109,
              "column": 43
          },
          {
              "line": 109,
              "column": 63
          },
          {
              "line": 109,
              "column": 84
          },
          {
              "line": 110,
              "column": 10
          },
          {
              "line": 110,
              "column": 58
          },
          {
              "line": 112,
              "column": 22
          },
          {
              "line": 112,
              "column": 39
          },
          {
              "line": 112,
              "column": 61
          },
          {
              "line": 112,
              "column": 76
          },
          {
              "line": 113,
              "column": 14
          },
          {
              "line": 113,
              "column": 20
          },
          {
              "line": 113,
              "column": 35
          },
          {
              "line": 113,
              "column": 53
          },
          {
              "line": 113,
              "column": 63
          },
          {
              "line": 113,
              "column": 74
          },
          {
              "line": 114,
              "column": 29
          },
          {
              "line": 115,
              "column": 45
          },
          {
              "line": 115,
              "column": 67
          },
          {
              "line": 116,
              "column": 52
          },
          {
              "line": 118,
              "column": 14
          },
          {
              "line": 118,
              "column": 59
          },
          {
              "line": 119,
              "column": 27
          },
          {
              "line": 119,
              "column": 44
          },
          {
              "line": 120,
              "column": 34
          },
          {
              "line": 120,
              "column": 45
          },
          {
              "line": 121,
              "column": 37
          },
          {
              "line": 121,
              "column": 53
          },
          {
              "line": 122,
              "column": 45
          },
          {
              "line": 122,
              "column": 65
          },
          {
              "line": 124,
              "column": 14
          },
          {
              "line": 124,
              "column": 34
          },
          {
              "line": 124,
              "column": 45
          },
          {
              "line": 124,
              "column": 76
          },
          {
              "line": 125,
              "column": 33
          },
          {
              "line": 125,
              "column": 44
          },
          {
              "line": 125,
              "column": 68
          },
          {
              "line": 127,
              "column": 24
          },
          {
              "line": 127,
              "column": 35
          },
          {
              "line": 127,
              "column": 50
          },
          {
              "line": 127,
              "column": 61
          },
          {
              "line": 128,
              "column": 42
          },
          {
              "line": 129,
              "column": 18
          },
          {
              "line": 131,
              "column": 20
          },
          {
              "line": 132,
              "column": 35
          },
          {
              "line": 132,
              "column": 46
          },
          {
              "line": 132,
              "column": 68
          },
          {
              "line": 132,
              "column": 79
          },
          {
              "line": 134,
              "column": 30
          },
          {
              "line": 134,
              "column": 55
          },
          {
              "line": 137,
              "column": 19
          },
          {
              "line": 137,
              "column": 46
          },
          {
              "line": 137,
              "column": 50
          },
          {
              "line": 137,
              "column": 61
          },
          {
              "line": 137,
              "column": 82
          },
          {
              "line": 137,
              "column": 90
          },
          {
              "line": 141,
              "column": 9
          },
          {
              "line": 141,
              "column": 13
          },
          {
              "line": 141,
              "column": 51
          },
          {
              "line": 141,
              "column": 85
          },
          {
              "line": 141,
              "column": 89
          },
          {
              "line": 142,
              "column": 22
          },
          {
              "line": 142,
              "column": 43
          },
          {
              "line": 142,
              "column": 89
          },
          {
              "line": 142,
              "column": 95
          },
          {
              "line": 143,
              "column": 9
          },
          {
              "line": 143,
              "column": 13
          },
          {
              "line": 143,
              "column": 33
          },
          {
              "line": 143,
              "column": 35
          },
          {
              "line": 145,
              "column": 7
          },
          {
              "line": 145,
              "column": 17
          },
          {
              "line": 145,
              "column": 32
          },
          {
              "line": 145,
              "column": 59
          },
          {
              "line": 145,
              "column": 74
          },
          {
              "line": 146,
              "column": 24
          },
          {
              "line": 146,
              "column": 39
          },
          {
              "line": 146,
              "column": 44
          },
          {
              "line": 147,
              "column": 9
          },
          {
              "line": 147,
              "column": 21
          },
          {
              "line": 148,
              "column": 9
          },
          {
              "line": 148,
              "column": 21
          },
          {
              "line": 148,
              "column": 34
          },
          {
              "line": 148,
              "column": 57
          },
          {
              "line": 148,
              "column": 72
          },
          {
              "line": 148,
              "column": 85
          },
          {
              "line": 150,
              "column": 10
          },
          {
              "line": 150,
              "column": 27
          },
          {
              "line": 150,
              "column": 56
          },
          {
              "line": 150,
              "column": 72
          },
          {
              "line": 152,
              "column": 32
          },
          {
              "line": 152,
              "column": 61
          },
          {
              "line": 153,
              "column": 29
          },
          {
              "line": 153,
              "column": 43
          },
          {
              "line": 153,
              "column": 55
          },
          {
              "line": 153,
              "column": 70
          },
          {
              "line": 154,
              "column": 14
          },
          {
              "line": 154,
              "column": 19
          },
          {
              "line": 154,
              "column": 36
          },
          {
              "line": 155,
              "column": 27
          },
          {
              "line": 156,
              "column": 37
          },
          {
              "line": 157,
              "column": 37
          },
          {
              "line": 157,
              "column": 58
          },
          {
              "line": 157,
              "column": 71
          },
          {
              "line": 159,
              "column": 21
          },
          {
              "line": 159,
              "column": 37
          },
          {
              "line": 159,
              "column": 53
          },
          {
              "line": 159,
              "column": 85
          },
          {
              "line": 161,
              "column": 21
          },
          {
              "line": 161,
              "column": 48
          },
          {
              "line": 162,
              "column": 21
          },
          {
              "line": 162,
              "column": 34
          },
          {
              "line": 165,
              "column": 24
          },
          {
              "line": 165,
              "column": 40
          },
          {
              "line": 168,
              "column": 7
          },
          {
              "line": 168,
              "column": 17
          },
          {
              "line": 168,
              "column": 21
          },
          {
              "line": 168,
              "column": 43
          },
          {
              "line": 169,
              "column": 25
          },
          {
              "line": 169,
              "column": 39
          },
          {
              "line": 169,
              "column": 51
          },
          {
              "line": 169,
              "column": 66
          },
          {
              "line": 169,
              "column": 81
          },
          {
              "line": 171,
              "column": 30
          },
          {
              "line": 171,
              "column": 44
          },
          {
              "line": 171,
              "column": 65
          },
          {
              "line": 171,
              "column": 76
          },
          {
              "line": 173,
              "column": 42
          },
          {
              "line": 174,
              "column": 40
          },
          {
              "line": 177,
              "column": 7
          },
          {
              "line": 177,
              "column": 17
          },
          {
              "line": 177,
              "column": 52
          },
          {
              "line": 177,
              "column": 69
          },
          {
              "line": 178,
              "column": 20
          },
          {
              "line": 178,
              "column": 35
          },
          {
              "line": 178,
              "column": 53
          },
          {
              "line": 178,
              "column": 63
          },
          {
              "line": 178,
              "column": 74
          },
          {
              "line": 178,
              "column": 80
          },
          {
              "line": 178,
              "column": 87
          },
          {
              "line": 179,
              "column": 10
          },
          {
              "line": 179,
              "column": 55
          },
          {
              "line": 180,
              "column": 25
          },
          {
              "line": 180,
              "column": 43
          },
          {
              "line": 180,
              "column": 64
          },
          {
              "line": 180,
              "column": 75
          },
          {
              "line": 181,
              "column": 14
          },
          {
              "line": 181,
              "column": 19
          },
          {
              "line": 181,
              "column": 31
          },
          {
              "line": 181,
              "column": 43
          },
          {
              "line": 181,
              "column": 67
          },
          {
              "line": 181,
              "column": 77
          },
          {
              "line": 183,
              "column": 27
          },
          {
              "line": 183,
              "column": 71
          },
          {
              "line": 186,
              "column": 30
          },
          {
              "line": 189,
              "column": 7
          },
          {
              "line": 189,
              "column": 17
          },
          {
              "line": 189,
              "column": 35
          },
          {
              "line": 189,
              "column": 46
          },
          {
              "line": 189,
              "column": 68
          },
          {
              "line": 189,
              "column": 79
          },
          {
              "line": 190,
              "column": 44
          },
          {
              "line": 190,
              "column": 55
          },
          {
              "line": 191,
              "column": 10
          },
          {
              "line": 191,
              "column": 38
          },
          {
              "line": 191,
              "column": 73
          },
          {
              "line": 193,
              "column": 63
          },
          {
              "line": 193,
              "column": 74
          },
          {
              "line": 194,
              "column": 18
          },
          {
              "line": 194,
              "column": 22
          },
          {
              "line": 194,
              "column": 29
          },
          {
              "line": 194,
              "column": 55
          },
          {
              "line": 195,
              "column": 38
          },
          {
              "line": 196,
              "column": 42
          },
          {
              "line": 196,
              "column": 45
          },
          {
              "line": 197,
              "column": 40
          },
          {
              "line": 197,
              "column": 72
          },
          {
              "line": 201,
              "column": 37
          },
          {
              "line": 202,
              "column": 28
          },
          {
              "line": 202,
              "column": 39
          },
          {
              "line": 203,
              "column": 40
          },
          {
              "line": 206,
              "column": 11
          },
          {
              "line": 207,
              "column": 9
          },
          {
              "line": 207,
              "column": 15
          },
          {
              "line": 207,
              "column": 70
          },
          {
              "line": 207,
              "column": 88
          },
          {
              "line": 208,
              "column": 16
          },
          {
              "line": 208,
              "column": 18
          },
          {
              "line": 209,
              "column": 31
          },
          {
              "line": 209,
              "column": 35
          },
          {
              "line": 209,
              "column": 60
          },
          {
              "line": 209,
              "column": 64
          },
          {
              "line": 209,
              "column": 75
          },
          {
              "line": 210,
              "column": 20
          },
          {
              "line": 212,
              "column": 33
          },
          {
              "line": 212,
              "column": 60
          },
          {
              "line": 213,
              "column": 39
          },
          {
              "line": 213,
              "column": 43
          },
          {
              "line": 213,
              "column": 54
          },
          {
              "line": 213,
              "column": 68
          },
          {
              "line": 215,
              "column": 10
          },
          {
              "line": 215,
              "column": 29
          },
          {
              "line": 215,
              "column": 33
          },
          {
              "line": 215,
              "column": 44
          },
          {
              "line": 215,
              "column": 62
          },
          {
              "line": 215,
              "column": 66
          },
          {
              "line": 215,
              "column": 77
          },
          {
              "line": 216,
              "column": 32
          },
          {
              "line": 216,
              "column": 36
          },
          {
              "line": 216,
              "column": 47
          },
          {
              "line": 216,
              "column": 66
          },
          {
              "line": 218,
              "column": 10
          },
          {
              "line": 218,
              "column": 22
          },
          {
              "line": 218,
              "column": 33
          },
          {
              "line": 219,
              "column": 54
          },
          {
              "line": 219,
              "column": 58
          },
          {
              "line": 219,
              "column": 69
          },
          {
              "line": 219,
              "column": 79
          },
          {
              "line": 221,
              "column": 9
          },
          {
              "line": 221,
              "column": 35
          },
          {
              "line": 222,
              "column": 14
          },
          {
              "line": 222,
              "column": 29
          },
          {
              "line": 222,
              "column": 45
          },
          {
              "line": 222,
              "column": 58
          },
          {
              "line": 224,
              "column": 24
          },
          {
              "line": 224,
              "column": 35
          },
          {
              "line": 224,
              "column": 57
          },
          {
              "line": 224,
              "column": 68
          },
          {
              "line": 225,
              "column": 35
          },
          {
              "line": 225,
              "column": 39
          },
          {
              "line": 225,
              "column": 50
          },
          {
              "line": 225,
              "column": 60
          },
          {
              "line": 226,
              "column": 18
          },
          {
              "line": 227,
              "column": 49
          },
          {
              "line": 227,
              "column": 60
          },
          {
              "line": 229,
              "column": 28
          },
          {
              "line": 229,
              "column": 46
          },
          {
              "line": 230,
              "column": 31
          },
          {
              "line": 230,
              "column": 42
          },
          {
              "line": 231,
              "column": 43
          },
          {
              "line": 231,
              "column": 54
          },
          {
              "line": 232,
              "column": 42
          },
          {
              "line": 232,
              "column": 52
          },
          {
              "line": 232,
              "column": 59
          },
          {
              "line": 233,
              "column": 22
          },
          {
              "line": 233,
              "column": 30
          },
          {
              "line": 233,
              "column": 42
          },
          {
              "line": 233,
              "column": 75
          },
          {
              "line": 234,
              "column": 24
          },
          {
              "line": 234,
              "column": 45
          },
          {
              "line": 234,
              "column": 61
          },
          {
              "line": 238,
              "column": 23
          },
          {
              "line": 238,
              "column": 56
          },
          {
              "line": 240,
              "column": 23
          },
          {
              "line": 245,
              "column": 7
          },
          {
              "line": 245,
              "column": 20
          },
          {
              "line": 245,
              "column": 31
          },
          {
              "line": 246,
              "column": 38
          },
          {
              "line": 246,
              "column": 49
          },
          {
              "line": 246,
              "column": 69
          },
          {
              "line": 247,
              "column": 10
          },
          {
              "line": 247,
              "column": 22
          },
          {
              "line": 247,
              "column": 33
          },
          {
              "line": 247,
              "column": 44
          },
          {
              "line": 247,
              "column": 66
          },
          {
              "line": 249,
              "column": 20
          },
          {
              "line": 249,
              "column": 31
          },
          {
              "line": 249,
              "column": 50
          },
          {
              "line": 249,
              "column": 63
          },
          {
              "line": 250,
              "column": 17
          },
          {
              "line": 250,
              "column": 34
          },
          {
              "line": 250,
              "column": 66
          },
          {
              "line": 252,
              "column": 20
          },
          {
              "line": 255,
              "column": 7
          },
          {
              "line": 255,
              "column": 43
          },
          {
              "line": 256,
              "column": 39
          },
          {
              "line": 256,
              "column": 50
          },
          {
              "line": 257,
              "column": 21
          },
          {
              "line": 257,
              "column": 31
          },
          {
              "line": 257,
              "column": 46
          },
          {
              "line": 258,
              "column": 13
          },
          {
              "line": 258,
              "column": 18
          },
          {
              "line": 258,
              "column": 27
          },
          {
              "line": 258,
              "column": 45
          },
          {
              "line": 258,
              "column": 49
          },
          {
              "line": 258,
              "column": 58
          },
          {
              "line": 258,
              "column": 76
          },
          {
              "line": 266,
              "column": 7
          },
          {
              "line": 267,
              "column": 10
          },
          {
              "line": 267,
              "column": 19
          },
          {
              "line": 267,
              "column": 32
          },
          {
              "line": 268,
              "column": 33
          },
          {
              "line": 269,
              "column": 44
          },
          {
              "line": 269,
              "column": 65
          },
          {
              "line": 273,
              "column": 21
          },
          {
              "line": 274,
              "column": 27
          },
          {
              "line": 274,
              "column": 37
          },
          {
              "line": 274,
              "column": 45
          },
          {
              "line": 274,
              "column": 47
          },
          {
              "line": 276,
              "column": 38
          },
          {
              "line": 277,
              "column": 52
          },
          {
              "line": 277,
              "column": 82
          },
          {
              "line": 277,
              "column": 86
          },
          {
              "line": 277,
              "column": 89
          },
          {
              "line": 280,
              "column": 9
          },
          {
              "line": 280,
              "column": 24
          },
          {
              "line": 280,
              "column": 35
          },
          {
              "line": 281,
              "column": 11
          },
          {
              "line": 281,
              "column": 18
          },
          {
              "line": 281,
              "column": 33
          },
          {
              "line": 281,
              "column": 51
          },
          {
              "line": 281,
              "column": 61
          },
          {
              "line": 281,
              "column": 68
          },
          {
              "line": 283,
              "column": 13
          },
          {
              "line": 283,
              "column": 22
          },
          {
              "line": 283,
              "column": 33
          },
          {
              "line": 283,
              "column": 52
          },
          {
              "line": 283,
              "column": 70
          },
          {
              "line": 283,
              "column": 80
          },
          {
              "line": 283,
              "column": 87
          },
          {
              "line": 284,
              "column": 15
          },
          {
              "line": 284,
              "column": 23
          },
          {
              "line": 284,
              "column": 33
          },
          {
              "line": 284,
              "column": 40
          },
          {
              "line": 284,
              "column": 52
          },
          {
              "line": 284,
              "column": 62
          },
          {
              "line": 284,
              "column": 69
          },
          {
              "line": 287,
              "column": 13
          },
          {
              "line": 287,
              "column": 23
          },
          {
              "line": 287,
              "column": 33
          },
          {
              "line": 287,
              "column": 54
          },
          {
              "line": 287,
              "column": 64
          },
          {
              "line": 287,
              "column": 71
          },
          {
              "line": 288,
              "column": 25
          },
          {
              "line": 288,
              "column": 35
          },
          {
              "line": 288,
              "column": 42
          },
          {
              "line": 292,
              "column": 9
          },
          {
              "line": 292,
              "column": 24
          },
          {
              "line": 292,
              "column": 35
          },
          {
              "line": 293,
              "column": 11
          },
          {
              "line": 293,
              "column": 18
          },
          {
              "line": 293,
              "column": 29
          },
          {
              "line": 293,
              "column": 40
          },
          {
              "line": 293,
              "column": 55
          },
          {
              "line": 293,
              "column": 66
          },
          {
              "line": 294,
              "column": 11
          },
          {
              "line": 294,
              "column": 18
          },
          {
              "line": 296,
              "column": 13
          },
          {
              "line": 296,
              "column": 22
          },
          {
              "line": 296,
              "column": 33
          },
          {
              "line": 297,
              "column": 23
          },
          {
              "line": 297,
              "column": 34
          },
          {
              "line": 297,
              "column": 49
          },
          {
              "line": 297,
              "column": 60
          },
          {
              "line": 298,
              "column": 15
          },
          {
              "line": 298,
              "column": 24
          },
          {
              "line": 298,
              "column": 35
          },
          {
              "line": 298,
              "column": 52
          },
          {
              "line": 298,
              "column": 63
          },
          {
              "line": 299,
              "column": 15
          },
          {
              "line": 302,
              "column": 13
          },
          {
              "line": 302,
              "column": 22
          },
          {
              "line": 302,
              "column": 33
          },
          {
              "line": 302,
              "column": 51
          },
          {
              "line": 302,
              "column": 62
          },
          {
              "line": 303,
              "column": 26
          },
          {
              "line": 303,
              "column": 37
          },
          {
              "line": 306,
              "column": 13
          }
      ],
      "old_name": "i",
      "new_name": "subtaskIdx",
      "ctx": {
          "symbolName": "i",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in createExecutionSlotSharingGroups(...)",
          "filePath": "SlotSharingSlotAllocator.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static Iterable<ExecutionSlotSharingGroup> createExecutionSlotSharingGroups(\n            Map<JobVertexID, Integer> containedJobVertices) {\n        final Map<Integer, Set<ExecutionVertexID>> sharedSlotToVertexAssignment = new HashMap<>();\n\n        for (Map.Entry<JobVertexID, Integer> jobVertex : containedJobVertices.entrySet()) {\n            for (int i = 0; i < jobVertex.getValue(); i++) {\n                sharedSlotToVertexAssignment\n                        .computeIfAbsent(i, ignored -> new HashSet<>())\n                        .add(new ExecutionVertexID(jobVertex.getKey(), i));\n            }\n        }\n\n        return sharedSlotToVertexAssignment.values().stream()\n                .map(ExecutionSlotSharingGroup::new)\n                .collect(Collectors.toList());\n    }",
          "conflictNames": [
              "containedJobVertices",
              "sharedSlotToVertexAssignment"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/416cb7aaa02c176e01485ff11ab4269f76b5e9e2^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/allocator/SlotSharingSlotAllocator.java",
      "locators": [
          {
              "line": 180,
              "column": 47
          },
          {
              "line": 181,
              "column": 46
          },
          {
              "line": 183,
              "column": 35
          },
          {
              "line": 193,
              "column": 46
          },
          {
              "line": 194,
              "column": 33
          },
          {
              "line": 197,
              "column": 52
          }
      ],
      "old_name": "jobVertex",
      "new_name": "jobVertexId",
      "ctx": {
          "symbolName": "jobVertex",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "VertexInformation",
          "scopeHint": "in determineVertexParallelism(...)",
          "filePath": "SlotSharingSlotAllocator.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "obVertexID, Integer> determineVertexParallelism(\n            Collection<JobInformation.VertexInformation> containedJobVertices, int availableSlots) {\n        final Map<JobVertexID, Integer> vertexParallelism = new HashMap<>();\n        for (JobInformation.VertexInformation jobVertex : containedJobVertices) {\n            final int parallelism = Math.min(jobVertex.getParallelism(), availableSlots);\n\n            vertexParallelism.put(jobVertex.getJobVertexID(), parallelism);\n        }\n\n        return vertexParallelism;\n ",
          "conflictNames": [
              "containedJobVertices",
              "availableSlots",
              "vertexParallelism",
              "parallelism"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/416cb7aaa02c176e01485ff11ab4269f76b5e9e2^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/allocator/SlotSharingSlotAllocator.java",
      "locators": [
          {
              "line": 127,
              "column": 44
          },
          {
              "line": 132,
              "column": 62
          },
          {
              "line": 224,
              "column": 51
          },
          {
              "line": 227,
              "column": 43
          },
          {
              "line": 230,
              "column": 25
          },
          {
              "line": 293,
              "column": 49
          },
          {
              "line": 297,
              "column": 43
          },
          {
              "line": 298,
              "column": 18
          },
          {
              "line": 298,
              "column": 46
          },
          {
              "line": 303,
              "column": 20
          }
      ],
      "old_name": "executionSlotSharingGroup",
      "new_name": "assignment",
      "ctx": {
          "symbolName": "executionSlotSharingGroup",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "ExecutionSlotSharingGroup",
          "scopeHint": "in determineParallelism(...)",
          "filePath": "SlotSharingSlotAllocator.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "                   slotSharingGroup.getSlotSharingGroupId()));\n\n            final Iterable<ExecutionSlotSharingGroup> sharedSlotToVertexAssignment =\n                    createExecutionSlotSharingGroups(vertexParallelism);\n\n            for (ExecutionSlotSharingGroup executionSlotSharingGroup :\n                    sharedSlotToVertexAssignment) {\n                final SlotInfo slotInfo = slotIterator.next();\n\n                assignments.add(\n                        new ExecutionSlotSharingGroupAndSlot(executionSlotSharingGroup, ",
          "conflictNames": [
              "jobInformation",
              "freeSlots",
              "slotSharingGroupParallelism",
              "slotIterator",
              "assignments",
              "allVertexParallelism",
              "containedJobVertices",
              "vertexParallelism",
              "sharedSlotToVertexAssignment",
              "slotInfo"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/4217408576552fc929d9c8331495a9282064cd9c^1/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/sink/SinkWriterOperatorTestBase.java",
      "locators": [
          {
              "line": 80,
              "column": 26
          },
          {
              "line": 83,
              "column": 57
          },
          {
              "line": 88,
              "column": 20
          },
          {
              "line": 94,
              "column": 20
          },
          {
              "line": 102,
              "column": 26
          },
          {
              "line": 105,
              "column": 57
          },
          {
              "line": 113,
              "column": 20
          },
          {
              "line": 189,
              "column": 32
          },
          {
              "line": 191,
              "column": 58
          },
          {
              "line": 205,
              "column": 20
          },
          {
              "line": 247,
              "column": 26
          },
          {
              "line": 251,
              "column": 47
          },
          {
              "line": 260,
              "column": 66
          },
          {
              "line": 285,
              "column": 26
          },
          {
              "line": 289,
              "column": 66
          },
          {
              "line": 314,
              "column": 26
          },
          {
              "line": 317,
              "column": 51
          },
          {
              "line": 325,
              "column": 57
          },
          {
              "line": 365,
              "column": 26
          },
          {
              "line": 368,
              "column": 57
          },
          {
              "line": 374,
              "column": 20
          },
          {
              "line": 383,
              "column": 20
          }
      ],
      "old_name": "sinkAndSuppliers",
      "new_name": "sink",
      "ctx": {
          "symbolName": "sinkAndSuppliers",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SinkAndSuppliers",
          "scopeHint": "in testNotEmitCommittablesWithoutCommitter(...)",
          "filePath": "SinkWriterOperatorTestBase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testNotEmitCommittablesWithoutCommitter() throws Exception {\n        SinkAndSuppliers sinkAndSuppliers = sinkWithoutCommitter();\n        final OneInputStreamOperatorTestHarness<Integer, CommittableMessage<Integer>> testHarness =\n                new OneInputStreamOperatorTestHarness<>(\n                        new SinkWriterOperatorFactory<>(sinkAndSuppliers.sink));\n        testHarness.open();\n        testHarness.processElement(1, 1);\n\n        assertThat(testHarness.getOutput()).isEmpty();\n        assertThat(sinkAndSuppliers.elementSupplier.get())\n                .containsOnly(\"(1,1,\" + Long.MIN_VALUE + \")\");\n\n        testHarness.prepareSnapshotPreBarrier(1);\n        assertThat(testHarness.getOutput()).isEmpty();\n        // Elements are flushed\n        assertThat(sinkAndSuppliers.elementSupplier.get()).isEmpty();\n        testHarness.close();\n    }",
          "conflictNames": [
              "testHarness"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/4217408576552fc929d9c8331495a9282064cd9c^1/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/sink/SinkWriterOperatorTestBase.java",
      "locators": [
          {
              "line": 277,
              "column": 30
          },
          {
              "line": 295,
              "column": 46
          }
      ],
      "old_name": "operatorStateWithoutPreviousState",
      "new_name": "snapshot",
      "ctx": {
          "symbolName": "operatorStateWithoutPreviousState",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "OperatorSubtaskState",
          "scopeHint": "in testLoadPreviousSinkState(...)",
          "filePath": "SinkWriterOperatorTestBase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@ParameterizedTest\n    @ValueSource(booleans = {true, false})\n    public void testLoadPreviousSinkState(boolean stateful) throws Exception {\n        // 1. Build previous sink state\n        final List<String> previousSinkInputs =\n                Arrays.asList(\n                        \"bit\", \"mention\", \"thick\", \"stick\", \"stir\", \"easy\", \"sleep\", \"forth\",\n                        \"cost\", \"prompt\");\n\n        SinkAndSuppliers sinkAndSuppliers =\n                sinkWithSnapshottingWriter(stateful, DummySinkOperator.DUMMY_SINK_STATE_NAME);\n        final OneInputStreamOperatorTestHarness<String, String> previousSink =\n                new OneInputStreamOperatorTestHarness<>(\n                        new DummySinkOperator(sinkAndSuppliers.serializerSupplier.get()),\n                        StringSerializer.INSTANCE);\n\n        OperatorSubtaskState previousSinkState =\n                TestHarnessUtil.buildSubtaskState(previousSink, previousSinkInputs);\n\n        // 2. Load previous sink state and verify the output\n        final OneInputStreamOperatorTestHarness<Integer, CommittableMessage<Integer>>\n                compatibleWriterOperator =\n                        createTestHarnessWithBufferingSinkWriter(sinkAndSuppliers.sink);\n\n        final List<String> expectedOutput1 =\n                stateful ? new ArrayList<>(previousSinkInputs) : new ArrayList<>();\n        expectedOutput1.add(Tuple3.of(1, 1, Long.MIN_VALUE).toString());\n\n        // load the state from previous sink\n        compatibleWriterOperator.initializeState(previousSinkState);\n\n        compatibleWriterOperator.open();\n\n        compatibleWriterOperator.processElement(1, 1);\n\n        // this will flush out the committables that were restored from previous sink\n        compatibleWriterOperator.endInput();\n        compatibleWriterOperator.prepareSnapshotPreBarrier(1);\n\n        OperatorSubtaskState operatorStateWithoutPreviousState =\n                compatibleWriterOperator.snapshot(1L, 1L);\n\n        compatibleWriterOperator.close();\n\n        assertEmitted(expectedOutput1, compatibleWriterOperator.getOutput());\n\n        // 3. Restore the sink without previous sink's state\n        SinkAndSuppliers sinkAndSuppliers2 =\n                sinkWithSnapshottingWriter(stateful, DummySinkOperator.DUMMY_SINK_STATE_NAME);\n        final OneInputStreamOperatorTestHarness<Integer, CommittableMessage<Integer>>\n                restoredSinkOperator =\n                        createTestHarnessWithBufferingSinkWriter(sinkAndSuppliers2.sink);\n        final List<String> expectedOutput2 =\n                Arrays.asList(\n                        Tuple3.of(2, 2, Long.MIN_VALUE).toString(),\n                        Tuple3.of(3, 3, Long.MIN_VALUE).toString());\n\n        restoredSinkOperator.initializeState(operatorStateWithoutPreviousState);\n\n        restoredSinkOperator.open();\n\n        restoredSinkOperator.processElement(2, 2);\n        restoredSinkOperator.processElement(3, 3);\n\n        // this will flush out the committables that were restored\n        restoredSinkOperator.endInput();\n        restoredSinkOperator.prepareSnapshotPreBarrier(2);\n\n        assertEmitted(expectedOutput2, restoredSinkOperator.getOutput());\n        restoredSinkOperator.close();\n    }",
          "conflictNames": [
              "stateful",
              "previousSinkInputs",
              "sinkAndSuppliers",
              "previousSink",
              "previousSinkState",
              "compatibleWriterOperator",
              "expectedOutput1",
              "sinkAndSuppliers2",
              "restoredSinkOperator",
              "expectedOutput2"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/42b7e74ab20785289b62f5dd68d566995ba9dcfc^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/exec/common/CommonExecTableSourceScan.java",
      "locators": [
          {
              "line": 32,
              "column": 39
          },
          {
              "line": 111,
              "column": 43
          },
          {
              "line": 118,
              "column": 30
          },
          {
              "line": 122,
              "column": 43
          },
          {
              "line": 125,
              "column": 30
          },
          {
              "line": 129,
              "column": 43
          },
          {
              "line": 136,
              "column": 30
          },
          {
              "line": 138,
              "column": 37
          },
          {
              "line": 142,
              "column": 23
          },
          {
              "line": 143,
              "column": 13
          },
          {
              "line": 144,
              "column": 20
          },
          {
              "line": 146,
              "column": 43
          },
          {
              "line": 149,
              "column": 23
          },
          {
              "line": 150,
              "column": 13
          },
          {
              "line": 151,
              "column": 20
          }
      ],
      "old_name": "transformation",
      "new_name": "sourceTransform",
      "ctx": {
          "symbolName": "transformation",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Transformation<RowData>",
          "scopeHint": "in translateToPlanInternal(...)",
          "filePath": "CommonExecTableSourceScan.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    protected Transformation<RowData> translateToPlanInternal(\n            PlannerBase planner, ExecNodeConfig config) {\n        final StreamExecutionEnvironment env = planner.getExecEnv();\n        final TransformationMetadata meta = createTransformationMeta(SOURCE_TRANSFORMATION, config);\n        final InternalTypeInfo<RowData> outputTypeInfo =\n                InternalTypeInfo.of((RowType) getOutputType());\n        final ScanTableSource tableSource =\n                tableSourceSpec.getScanTableSource(\n                        planner.getFlinkContext(), ShortcutUtils.unwrapTypeFactory(planner));\n        ScanTableSource.ScanRuntimeProvider provider =\n                tableSource.getScanRuntimeProvider(ScanRuntimeProviderContext.INSTANCE);\n        if (provider instanceof SourceFunctionProvider) {\n            final SourceFunctionProvider sourceFunctionProvider = (SourceFunctionProvider) provider;\n            final SourceFunction<RowData> function = sourceFunctionProvider.createSourceFunction();\n            final Transformation<RowData> transformation =\n                    createSourceFunctionTransformation(\n                            env,\n                            function,\n                            sourceFunctionProvider.isBounded(),\n                            meta.getName(),\n                            outputTypeInfo);\n            return meta.fill(transformation);\n        } else if (provider instanceof InputFormatProvider) {\n            final InputFormat<RowData, ?> inputFormat =\n                    ((InputFormatProvider) provider).createInputFormat();\n            final Transformation<RowData> transformation =\n                    createInputFormatTransformation(\n                            env, inputFormat, outputTypeInfo, meta.getName());\n            return meta.fill(transformation);\n        } else if (provider instanceof SourceProvider) {\n            final Source<RowData, ?, ?> source = ((SourceProvider) provider).createSource();\n            // TODO: Push down watermark strategy to source scan\n            final Transformation<RowData> transformation =\n                    env.fromSource(\n                                    source,\n                                    WatermarkStrategy.noWatermarks(),\n                                    meta.getName(),\n                                    outputTypeInfo)\n                            .getTransformation();\n            return meta.fill(transformation);\n        } else if (provider instanceof DataStreamScanProvider) {\n            Transformation<RowData> transformation =\n                    ((DataStreamScanProvider) provider)\n                            .produceDataStream(createProviderContext(config), env)\n                            .getTransformation();\n            meta.fill(transformation);\n            transformation.setOutputType(outputTypeInfo);\n            return transformation;\n        } else if (provider instanceof TransformationScanProvider) {\n            final Transformation<RowData> transformation =\n                    ((TransformationScanProvider) provider)\n                            .createTransformation(createProviderContext(config));\n            meta.fill(transformation);\n            transformation.setOutputType(outputTypeInfo);\n            return transformation;\n        } else {\n            throw new UnsupportedOperationException(\n                    provider.getClass().getSimpleName() + \" is unsupported now.\");\n        }\n    }",
          "conflictNames": [
              "planner",
              "config",
              "env",
              "meta",
              "outputTypeInfo",
              "tableSource",
              "provider",
              "sourceFunctionProvider",
              "function",
              "inputFormat",
              "transformation",
              "source"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/42d918dec1658c4dc1f0586148704c46bc1dd8d0^1/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/CEPITCase.java",
      "locators": [
          {
              "line": 528,
              "column": 38
          },
          {
              "line": 535,
              "column": 22
          },
          {
              "line": 618,
              "column": 38
          },
          {
              "line": 625,
              "column": 22
          },
          {
              "line": 680,
              "column": 22
          },
          {
              "line": 682,
              "column": 9
          },
          {
              "line": 686,
              "column": 22
          },
          {
              "line": 768,
              "column": 22
          },
          {
              "line": 770,
              "column": 9
          },
          {
              "line": 774,
              "column": 22
          },
          {
              "line": 823,
              "column": 39
          },
          {
              "line": 826,
              "column": 22
          },
          {
              "line": 881,
              "column": 56
          },
          {
              "line": 977,
              "column": 56
          }
      ],
      "old_name": "expected",
      "new_name": "resultExpected",
      "ctx": {
          "symbolName": "expected",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<Either<String, String>>",
          "scopeHint": "in testTimeoutHandlingWithinFirstAndLast(...)",
          "filePath": "CEPITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testTimeoutHandlingWithinFirstAndLast() throws Exception {\n        StreamExecutionEnvironment env =\n                StreamExecutionEnvironment.getExecutionEnvironment(envConfiguration);\n        env.setParallelism(1);\n\n        // (Event, timestamp)\n        DataStream<Event> input =\n                env.fromData(\n                                Tuple2.of(new Event(1, \"start\", 1.0), 1L),\n                                Tuple2.of(new Event(1, \"middle\", 2.0), 5L),\n                                Tuple2.of(new Event(1, \"start\", 2.0), 4L),\n                                Tuple2.of(new Event(1, \"end\", 2.0), 6L))\n                        .assignTimestampsAndWatermarks(\n                                new AssignerWithPunctuatedWatermarks<Tuple2<Event, Long>>() {\n\n                                    @Override\n                                    public long extractTimestamp(\n                                            Tuple2<Event, Long> element, long currentTimestamp) {\n                                        return element.f1;\n                                    }\n\n                                    @Override\n                                    public Watermark checkAndGetNextWatermark(\n                                            Tuple2<Event, Long> lastElement,\n                                            long extractedTimestamp) {\n                                        return new Watermark(lastElement.f1 - 5);\n                                    }\n                                })\n                        .map(\n                                new MapFunction<Tuple2<Event, Long>, Event>() {\n\n                                    @Override\n                                    public Event map(Tuple2<Event, Long> value) throws Exception {\n                                        return value.f0;\n                                    }\n                                });\n\n        Pattern<Event, ?> pattern =\n                Pattern.<Event>begin(\"start\")\n                        .where(SimpleCondition.of(value -> value.getName().equals(\"start\")))\n                        .followedByAny(\"middle\")\n                        .where(SimpleCondition.of(value -> value.getName().equals(\"middle\")))\n                        .followedByAny(\"end\")\n                        .where(SimpleCondition.of(value -> value.getName().equals(\"end\")))\n                        .within(Time.milliseconds(3));\n\n        DataStream<Either<String, String>> result =\n                CEP.pattern(input, pattern)\n                        .select(\n                                new PatternTimeoutFunction<Event, String>() {\n                                    @Override\n                                    public String timeout(\n                                            Map<String, List<Event>> pattern, long timeoutTimestamp)\n                                            throws Exception {\n                                        return pattern.get(\"start\").get(0).getPrice() + \"\";\n                                    }\n                                },\n                                new PatternSelectFunction<Event, String>() {\n\n                                    @Override\n                                    public String select(Map<String, List<Event>> pattern) {\n                                        StringBuilder builder = new StringBuilder();\n\n                                        builder.append(pattern.get(\"start\").get(0).getPrice())\n                                                .append(\",\")\n                                                .append(pattern.get(\"middle\").get(0).getPrice())\n                                                .append(\",\")\n                                                .append(pattern.get(\"end\").get(0).getPrice());\n\n                                        return builder.toString();\n                                    }\n                                });\n\n        List<Either<String, String>> resultList = new ArrayList<>();\n\n        result.executeAndCollect().forEachRemaining(resultList::add);\n\n        resultList.sort(Comparator.comparing(Object::toString));\n\n        List<Either<String, String>> expected =\n                Arrays.asList(\n                        Either.Left.of(\"1.0\"),\n                        Either.Left.of(\"2.0\"),\n                        Either.Left.of(\"2.0\"),\n                        Either.Right.of(\"2.0,2.0,2.0\"));\n\n        assertEquals(expected, resultList);\n    }",
          "conflictNames": [
              "env",
              "input",
              "pattern",
              "result",
              "builder",
              "resultList"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/4645880039a3a9ef6fe7ee83999cfe5e56d54f94^1/flink-tests/src/test/java/org/apache/flink/runtime/util/ExceptionUtilsITCase.java",
      "locators": [
          {
              "line": 80,
              "column": 19
          },
          {
              "line": 91,
              "column": 47
          },
          {
              "line": 92,
              "column": 50
          }
      ],
      "old_name": "normalOut",
      "new_name": "initialRun",
      "ctx": {
          "symbolName": "normalOut",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RunResult",
          "scopeHint": "in testIsMetaspaceOutOfMemoryError(...)",
          "filePath": "ExceptionUtilsITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testIsMetaspaceOutOfMemoryError() throws IOException, InterruptedException {\n        String className = DummyClassLoadingProgram.class.getName();\n        final File compiledClassesFolder = TEMPORARY_FOLDER.getRoot();\n        final int classCount = 10;\n\n        // compile the classes first\n        final String sourcePattern =\n                \"public class %s { @Override public String toString() { return \\\"dummy\\\"; } }\";\n        final ClassLoaderBuilder classLoaderBuilder =\n                ClassLoaderUtils.withRoot(compiledClassesFolder);\n        for (int i = 0; i < classCount; i++) {\n            final String dummyClassName = \"DummyClass\" + i;\n            final String source = String.format(sourcePattern, dummyClassName);\n            classLoaderBuilder.addClass(dummyClassName, source);\n        }\n        classLoaderBuilder.generateSourcesAndCompile();\n\n        // load only one class and record required Metaspace\n        RunResult normalOut =\n                run(\n                        className,\n                        -1,\n                        INITIAL_BIG_METASPACE_SIZE,\n                        1,\n                        compiledClassesFolder.getAbsolutePath());\n\n        // multiply the Metaspace size to stabilize the test - relying solely on the Metaspace size\n        // of the initial run might cause OOMs to appear in the main thread (due to JVM-specific\n        // artifacts being loaded)\n        long okMetaspace = 3 * Long.parseLong(normalOut.getStandardOut());\n        assertThat(\"No error is expected here.\", normalOut.getErrorOut(), is(\"\"));\n\n        // load more classes to cause 'OutOfMemoryError: Metaspace'\n        RunResult oomOut =\n                run(\n                        className,\n                        -1,\n                        okMetaspace,\n                        classCount,\n                        compiledClassesFolder.getAbsolutePath());\n        assertThat(\n                \"OutOfMemoryError: Metaspace errors are caught and don't generate any output.\",\n                oomOut.getStandardOut(),\n                isEmptyString());\n        assertThat(\"Nothing should have been printed to stderr.\", oomOut.getErrorOut(), is(\"\"));\n    }",
          "conflictNames": [
              "className",
              "compiledClassesFolder",
              "classCount",
              "sourcePattern",
              "classLoaderBuilder",
              "i",
              "dummyClassName",
              "source",
              "okMetaspace",
              "oomOut"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/4645880039a3a9ef6fe7ee83999cfe5e56d54f94^1/flink-tests/src/test/java/org/apache/flink/runtime/util/ExceptionUtilsITCase.java",
      "locators": [
          {
              "line": 95,
              "column": 19
          },
          {
              "line": 104,
              "column": 17
          },
          {
              "line": 106,
              "column": 67
          }
      ],
      "old_name": "oomOut",
      "new_name": "outOfMemoryErrorRun",
      "ctx": {
          "symbolName": "oomOut",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RunResult",
          "scopeHint": "in testIsMetaspaceOutOfMemoryError(...)",
          "filePath": "ExceptionUtilsITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testIsMetaspaceOutOfMemoryError() throws IOException, InterruptedException {\n        String className = DummyClassLoadingProgram.class.getName();\n        final File compiledClassesFolder = TEMPORARY_FOLDER.getRoot();\n        final int classCount = 10;\n\n        // compile the classes first\n        final String sourcePattern =\n                \"public class %s { @Override public String toString() { return \\\"dummy\\\"; } }\";\n        final ClassLoaderBuilder classLoaderBuilder =\n                ClassLoaderUtils.withRoot(compiledClassesFolder);\n        for (int i = 0; i < classCount; i++) {\n            final String dummyClassName = \"DummyClass\" + i;\n            final String source = String.format(sourcePattern, dummyClassName);\n            classLoaderBuilder.addClass(dummyClassName, source);\n        }\n        classLoaderBuilder.generateSourcesAndCompile();\n\n        // load only one class and record required Metaspace\n        RunResult normalOut =\n                run(\n                        className,\n                        -1,\n                        INITIAL_BIG_METASPACE_SIZE,\n                        1,\n                        compiledClassesFolder.getAbsolutePath());\n\n        // multiply the Metaspace size to stabilize the test - relying solely on the Metaspace size\n        // of the initial run might cause OOMs to appear in the main thread (due to JVM-specific\n        // artifacts being loaded)\n        long okMetaspace = 3 * Long.parseLong(normalOut.getStandardOut());\n        assertThat(\"No error is expected here.\", normalOut.getErrorOut(), is(\"\"));\n\n        // load more classes to cause 'OutOfMemoryError: Metaspace'\n        RunResult oomOut =\n                run(\n                        className,\n                        -1,\n                        okMetaspace,\n                        classCount,\n                        compiledClassesFolder.getAbsolutePath());\n        assertThat(\n                \"OutOfMemoryError: Metaspace errors are caught and don't generate any output.\",\n                oomOut.getStandardOut(),\n                isEmptyString());\n        assertThat(\"Nothing should have been printed to stderr.\", oomOut.getErrorOut(), is(\"\"));\n    }",
          "conflictNames": [
              "className",
              "compiledClassesFolder",
              "classCount",
              "sourcePattern",
              "classLoaderBuilder",
              "i",
              "dummyClassName",
              "source",
              "normalOut",
              "okMetaspace"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/467791fea369a30a8334dacde49baedb7f1d7767^1/flink-datastream/src/test/java/org/apache/flink/datastream/impl/stream/KeyedPartitionStreamImplTest.java",
      "locators": [
          {
              "line": 116,
              "column": 76
          },
          {
              "line": 118,
              "column": 20
          },
          {
              "line": 119,
              "column": 20
          }
      ],
      "old_name": "resultStream1",
      "new_name": "resultStream",
      "ctx": {
          "symbolName": "resultStream1",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TwoNonKeyedPartitionStreams<Integer, Long>",
          "scopeHint": "in testProcessTwoOutput(...)",
          "filePath": "KeyedPartitionStreamImplTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testProcessTwoOutput() throws Exception {\n        ExecutionEnvironmentImpl env = StreamTestUtils.getEnv();\n        KeyedPartitionStream<Integer, Integer> stream = createKeyedStream(env);\n        NonKeyedPartitionStream.TwoNonKeyedPartitionStreams<Integer, Long> resultStream1 =\n                stream.process(new NoOpTwoOutputStreamProcessFunction());\n        assertThat(resultStream1.getFirst()).isInstanceOf(NonKeyedPartitionStream.class);\n        assertThat(resultStream1.getSecond()).isInstanceOf(NonKeyedPartitionStream.class);\n        KeyedPartitionStream.TwoKeyedPartitionStreams<Integer, Integer, Long> resultStream2 =\n                stream.process(new NoOpTwoOutputStreamProcessFunction(), x -> x, Math::toIntExact);\n        assertThat(resultStream2.getFirst()).isInstanceOf(KeyedPartitionStream.class);\n        assertThat(resultStream2.getSecond()).isInstanceOf(KeyedPartitionStream.class);\n        List<Transformation<?>> transformations = env.getTransformations();\n        assertThat(transformations).hasSize(2);\n        assertProcessType(transformations.get(0), OneInputTransformation.class, Types.INT);\n        assertProcessType(transformations.get(1), OneInputTransformation.class, Types.INT);\n    }",
          "conflictNames": [
              "env",
              "stream",
              "resultStream2",
              "transformations"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/47944ce00e0819231ae2e099f2382a188f4dae91^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/operations/converters/SqlNodeConverters.java",
      "locators": [
          {
              "line": 19,
              "column": 51
          },
          {
              "line": 24,
              "column": 50
          },
          {
              "line": 32,
              "column": 25
          },
          {
              "line": 38,
              "column": 29
          },
          {
              "line": 43,
              "column": 84
          },
          {
              "line": 49,
              "column": 26
          },
          {
              "line": 50,
              "column": 13
          },
          {
              "line": 51,
              "column": 32
          },
          {
              "line": 57,
              "column": 54
          },
          {
              "line": 58,
              "column": 46
          },
          {
              "line": 61,
              "column": 25
          },
          {
              "line": 61,
              "column": 60
          },
          {
              "line": 62,
              "column": 49
          }
      ],
      "old_name": "converter",
      "new_name": "classConverter",
      "ctx": {
          "symbolName": "converter",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SqlNodeConverter",
          "scopeHint": "in convertSqlNode(...)",
          "filePath": "SqlNodeConverters.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Convert the given validated SqlNode into Operation if there is a registered converter for the\n     * node.\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public static Optional<Operation> convertSqlNode(\n            SqlNode validatedSqlNode, ConvertContext context) {\n        SqlNodeConverter converter = CONVERTERS.get(validatedSqlNode.getClass());\n        if (converter != null) {\n            return Optional.of(converter.convertSqlNode(validatedSqlNode, context));\n        } else {\n            return Optional.empty();\n        }\n    }",
          "conflictNames": [
              "validatedSqlNode",
              "context"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/49b8726850cb0da5f3a888c836f31bfa69be739d^1/flink-formats/flink-parquet/src/main/java/org/apache/flink/formats/parquet/ParquetVectorizedInputFormat.java",
      "locators": [
          {
              "line": 22,
              "column": 47
          },
          {
              "line": 24,
              "column": 44
          },
          {
              "line": 32,
              "column": 48
          },
          {
              "line": 127,
              "column": 27
          },
          {
              "line": 145,
              "column": 34
          },
          {
              "line": 162,
              "column": 23
          },
          {
              "line": 163,
              "column": 9
          },
          {
              "line": 164,
              "column": 16
          },
          {
              "line": 308,
              "column": 35
          },
          {
              "line": 327,
              "column": 41
          },
          {
              "line": 336,
              "column": 35
          },
          {
              "line": 340,
              "column": 18
          },
          {
              "line": 340,
              "column": 27
          },
          {
              "line": 396,
              "column": 35
          },
          {
              "line": 427,
              "column": 49
          },
          {
              "line": 433,
              "column": 21
          },
          {
              "line": 460,
              "column": 17
          },
          {
              "line": 461,
              "column": 17
          },
          {
              "line": 462,
              "column": 17
          }
      ],
      "old_name": "reader",
      "new_name": "parquetFileReader",
      "ctx": {
          "symbolName": "reader",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ParquetFileReader",
          "scopeHint": "in createReader(...)",
          "filePath": "ParquetVectorizedInputFormat.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public ParquetReader createReader(final Configuration config, final SplitT split)\n            throws IOException {\n\n        final Path filePath = split.path();\n        final long splitOffset = split.offset();\n        final long splitLength = split.length();\n\n        org.apache.hadoop.fs.Path hadoopPath = new org.apache.hadoop.fs.Path(filePath.toUri());\n        ParquetMetadata footer =\n                readFooter(\n                        hadoopConfig.conf(),\n                        hadoopPath,\n                        range(splitOffset, splitOffset + splitLength));\n        MessageType fileSchema = footer.getFileMetaData().getSchema();\n        FilterCompat.Filter filter = getFilter(hadoopConfig.conf());\n        List<BlockMetaData> blocks = filterRowGroups(filter, footer.getBlocks(), fileSchema);\n\n        MessageType requestedSchema = clipParquetSchema(fileSchema);\n        ParquetFileReader reader =\n                new ParquetFileReader(\n                        hadoopConfig.conf(),\n                        footer.getFileMetaData(),\n                        hadoopPath,\n                        blocks,\n                        requestedSchema.getColumns());\n\n        long totalRowCount = 0;\n        for (BlockMetaData block : blocks) {\n            totalRowCount += block.getRowCount();\n        }\n\n        checkSchema(fileSchema, requestedSchema);\n\n        final Pool<ParquetReaderBatch<T>> poolOfBatches =\n                createPoolOfBatches(split, requestedSchema, numBatchesToCirculate(config));\n\n        return new ParquetReader(reader, requestedSchema, totalRowCount, poolOfBatches);\n    }",
          "conflictNames": [
              "config",
              "split",
              "filePath",
              "splitOffset",
              "splitLength",
              "hadoopPath",
              "footer",
              "fileSchema",
              "filter",
              "blocks",
              "requestedSchema",
              "totalRowCount",
              "poolOfBatches"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/4a2535cb8ab9f4ef807e98e8b92a6f921960c059^1/flink-table/flink-sql-gateway/src/main/java/org/apache/flink/table/gateway/service/materializedtable/MaterializedTableManager.java",
      "locators": [
          {
              "line": 960,
              "column": 34
          },
          {
              "line": 966,
              "column": 17
          },
          {
              "line": 967,
              "column": 44
          }
      ],
      "old_name": "resetedRefreshHandler",
      "new_name": "resetContinuousRefreshHandler",
      "ctx": {
          "symbolName": "resetedRefreshHandler",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ContinuousRefreshHandler",
          "scopeHint": "in genereateResetSavepointTableChange(...)",
          "filePath": "MaterializedTableManager.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private TableChange.ModifyRefreshHandler genereateResetSavepointTableChange(\n            byte[] serializedContinuousHandler) {\n        ContinuousRefreshHandler continuousRefreshHandler =\n                deserializeContinuousHandler(serializedContinuousHandler);\n        ContinuousRefreshHandler resetedRefreshHandler =\n                new ContinuousRefreshHandler(\n                        continuousRefreshHandler.getExecutionTarget(),\n                        continuousRefreshHandler.getJobId());\n\n        return TableChange.modifyRefreshHandler(\n                resetedRefreshHandler.asSummaryString(),\n                serializeContinuousHandler(resetedRefreshHandler));\n    }",
          "conflictNames": [
              "serializedContinuousHandler",
              "continuousRefreshHandler"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/4a8b8c03e3aa2677fe5ab94a09ee8ae754785938^1/flink-table/flink-sql-client/src/main/java/org/apache/flink/table/client/cli/CliOptionsParser.java",
      "locators": [
          {
              "line": 312,
              "column": 25
          },
          {
              "line": 313,
              "column": 13
          },
          {
              "line": 313,
              "column": 30
          },
          {
              "line": 314,
              "column": 20
          },
          {
              "line": 321,
              "column": 28
          },
          {
              "line": 322,
              "column": 34
          }
      ],
      "old_name": "urls",
      "new_name": "uris",
      "ctx": {
          "symbolName": "urls",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<URL>",
          "scopeHint": "in checkUrl(...)",
          "filePath": "CliOptionsParser.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static URL checkUrl(CommandLine line, Option option) {\n        final List<URL> urls = checkUrls(line, option);\n        if (urls != null && !urls.isEmpty()) {\n            return urls.get(0);\n        }\n        return null;\n    }",
          "conflictNames": [
              "line",
              "option"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/4a8b8c03e3aa2677fe5ab94a09ee8ae754785938^1/flink-table/flink-sql-client/src/main/java/org/apache/flink/table/client/cli/CliOptionsParser.java",
      "locators": [
          {
              "line": 286,
              "column": 13
          },
          {
              "line": 288,
              "column": 13
          },
          {
              "line": 289,
              "column": 43
          },
          {
              "line": 290,
              "column": 17
          },
          {
              "line": 292,
              "column": 33
          },
          {
              "line": 293,
              "column": 33
          },
          {
              "line": 294,
              "column": 33
          },
          {
              "line": 295,
              "column": 33
          },
          {
              "line": 304,
              "column": 13
          },
          {
              "line": 306,
              "column": 16
          },
          {
              "line": 312,
              "column": 25
          },
          {
              "line": 313,
              "column": 13
          },
          {
              "line": 313,
              "column": 30
          },
          {
              "line": 314,
              "column": 20
          },
          {
              "line": 321,
              "column": 28
          },
          {
              "line": 322,
              "column": 34
          },
          {
              "line": 325,
              "column": 30
          },
          {
              "line": 326,
              "column": 47
          },
          {
              "line": 328,
              "column": 72
          },
          {
              "line": 336,
              "column": 55
          }
      ],
      "old_name": "url",
      "new_name": "uri",
      "ctx": {
          "symbolName": "url",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "URL",
          "scopeHint": "in parseGatewayAddress(...)",
          "filePath": "CliOptionsParser.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static URL parseGatewayAddress(String cliOptionAddress) {\n        URL url;\n        try {\n            url = new URL(cliOptionAddress);\n            if (!NetUtils.isValidHostPort(url.getPort())) {\n                url =\n                        new URL(\n                                url.getProtocol(),\n                                url.getHost(),\n                                url.getDefaultPort(),\n                                url.getPath());\n            }\n\n        } catch (MalformedURLException e) {\n            // Required for backwards compatibility\n            LOG.warn(\n                    \"The gateway address should be specified as a URL, i.e. https://hostname:port/optional_path.\");\n            LOG.warn(\n                    \"Trying to fallback to hostname:port (will use non-encrypted, http connection).\");\n            url = NetUtils.getCorrectHostnamePort(cliOptionAddress);\n        }\n        return url;\n    }",
          "conflictNames": [
              "cliOptionAddress"
          ]
      },
      "suggestions": [
          {
              "name": "uri",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/4a8b8c03e3aa2677fe5ab94a09ee8ae754785938^1/flink-table/flink-sql-client/src/main/java/org/apache/flink/table/client/gateway/DefaultContextUtils.java",
      "locators": [
          {
              "line": 73,
              "column": 22
          },
          {
              "line": 74,
              "column": 39
          },
          {
              "line": 75,
              "column": 34
          },
          {
              "line": 93,
              "column": 35
          },
          {
              "line": 94,
              "column": 47
          },
          {
              "line": 95,
              "column": 42
          }
      ],
      "old_name": "url",
      "new_name": "uri",
      "ctx": {
          "symbolName": "url",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "URL",
          "scopeHint": "in discoverDependencies(...)",
          "filePath": "DefaultContextUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "------------------------------\n\n    private static List<URL> discoverDependencies(List<URL> jars, List<URL> libraries) {\n        final List<URL> dependencies = new ArrayList<>();\n        try {\n            // find jar files\n            for (URL url : jars) {\n                JarUtils.checkJarFile(url);\n                dependencies.add(url);\n            }\n\n            // find jar files in library directories\n            for (URL libUrl : libraries) {\n                final File dir = ne",
          "conflictNames": [
              "jars",
              "libraries",
              "dependencies",
              "dir",
              "files",
              "url"
          ]
      },
      "suggestions": [
          {
              "name": "uri",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/4a8b8c03e3aa2677fe5ab94a09ee8ae754785938^1/flink-table/flink-sql-client/src/main/java/org/apache/flink/table/client/gateway/DefaultContextUtils.java",
      "locators": [
          {
              "line": 79,
              "column": 22
          },
          {
              "line": 80,
              "column": 43
          }
      ],
      "old_name": "libUrl",
      "new_name": "libURI",
      "ctx": {
          "symbolName": "libUrl",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "URL",
          "scopeHint": "in discoverDependencies(...)",
          "filePath": "DefaultContextUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": " try {\n            // find jar files\n            for (URL url : jars) {\n                JarUtils.checkJarFile(url);\n                dependencies.add(url);\n            }\n\n            // find jar files in library directories\n            for (URL libUrl : libraries) {\n                final File dir = new File(libUrl.toURI());\n                if (!dir.isDirectory()) {\n                    throw new SqlClientException(\"Directory expected: \" + dir);\n                } else if (!dir.canRead()) ",
          "conflictNames": [
              "jars",
              "libraries",
              "dependencies",
              "dir",
              "files",
              "url"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/4a8b8c03e3aa2677fe5ab94a09ee8ae754785938^1/flink-clients/src/main/java/org/apache/flink/client/program/PackagedProgramUtils.java",
      "locators": [
          {
              "line": 197,
              "column": 26
          },
          {
              "line": 207,
              "column": 33
          },
          {
              "line": 218,
              "column": 13
          },
          {
              "line": 219,
              "column": 51
          },
          {
              "line": 223,
              "column": 20
          }
      ],
      "old_name": "pythonJarPath",
      "new_name": "optJarPath",
      "ctx": {
          "symbolName": "pythonJarPath",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<Path>",
          "scopeHint": "in getPythonJar(...)",
          "filePath": "PackagedProgramUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static URL getPythonJar() {\n        String flinkOptPath = System.getenv(ConfigConstants.ENV_FLINK_OPT_DIR);\n        final List<Path> pythonJarPath = new ArrayList<>();\n        try {\n            Files.walkFileTree(\n                    FileSystems.getDefault().getPath(flinkOptPath),\n                    new SimpleFileVisitor<Path>() {\n                        @Override\n                        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n                                throws IOException {\n                            FileVisitResult result = super.visitFile(file, attrs);\n                            if (file.getFileName().toString().startsWith(\"flink-python\")) {\n                                pythonJarPath.add(file);\n                            }\n                            return result;\n                        }\n                    });\n        } catch (IOException e) {\n            throw new RuntimeException(\n                    \"Exception encountered during finding the flink-python jar. This should not happen.\",\n                    e);\n        }\n\n        if (pythonJarPath.size() != 1) {\n            throw new RuntimeException(\"Found \" + pythonJarPath.size() + \" flink-python jar.\");\n        }\n\n        try {\n            return pythonJarPath.get(0).toUri().toURL();\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(\"URL is invalid. This should not happen.\", e);\n        }\n    }",
          "conflictNames": [
              "flinkOptPath",
              "result"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/4aebc43721873480dfbbaf2cfe784c3833f1cdc9^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/CreatingExecutionGraphTest.java",
      "locators": [
          {
              "line": 68,
              "column": 38
          },
          {
              "line": 81,
              "column": 9
          },
          {
              "line": 86,
              "column": 38
          },
          {
              "line": 108,
              "column": 9
          },
          {
              "line": 113,
              "column": 38
          },
          {
              "line": 135,
              "column": 9
          }
      ],
      "old_name": "creatingExecutionGraph",
      "new_name": "state",
      "ctx": {
          "symbolName": "creatingExecutionGraph",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CreatingExecutionGraph",
          "scopeHint": "in testCancelTransitionsToFinished(...)",
          "filePath": "CreatingExecutionGraphTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testCancelTransitionsToFinished() {\n        final CreatingExecutionGraph creatingExecutionGraph =\n                new CreatingExecutionGraph(\n                        context,\n                        new CompletableFuture<>(),\n                        LOG,\n                        CreatingExecutionGraphTest::createTestingOperatorCoordinatorHandler,\n                        null);\n\n        context.setExpectFinished(\n                archivedExecutionGraph -> {\n                    assertThat(archivedExecutionGraph.getState()).isEqualTo(JobStatus.CANCELED);\n                    assertThat(archivedExecutionGraph.getFailureInfo()).isNull();\n                });\n        creatingExecutionGraph.cancel();\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/4aebc43721873480dfbbaf2cfe784c3833f1cdc9^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/CreatedTest.java",
      "locators": [
          {
              "line": 50,
              "column": 17
          },
          {
              "line": 57,
              "column": 9
          },
          {
              "line": 62,
              "column": 17
          },
          {
              "line": 66,
              "column": 9
          },
          {
              "line": 72,
              "column": 17
          },
          {
              "line": 86,
              "column": 9
          },
          {
              "line": 91,
              "column": 17
          },
          {
              "line": 106,
              "column": 9
          },
          {
              "line": 111,
              "column": 17
          },
          {
              "line": 112,
              "column": 38
          }
      ],
      "old_name": "created",
      "new_name": "state",
      "ctx": {
          "symbolName": "created",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Created",
          "scopeHint": "in testCancel(...)",
          "filePath": "CreatedTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testCancel() {\n        Created created = new Created(ctx, LOG);\n\n        ctx.setExpectFinished(\n                archivedExecutionGraph -> {\n                    assertThat(archivedExecutionGraph.getState()).isEqualTo(JobStatus.CANCELED);\n                    assertThat(archivedExecutionGraph.getFailureInfo()).isNull();\n                });\n        created.cancel();\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/4aebc43721873480dfbbaf2cfe784c3833f1cdc9^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/WaitingForResourcesTest.java",
      "locators": [
          {
              "line": 78,
              "column": 29
          },
          {
              "line": 82,
              "column": 9
          },
          {
              "line": 88,
              "column": 29
          },
          {
              "line": 92,
              "column": 9
          },
          {
              "line": 98,
              "column": 29
          },
          {
              "line": 104,
              "column": 9
          },
          {
              "line": 111,
              "column": 29
          },
          {
              "line": 116,
              "column": 9
          },
          {
              "line": 127,
              "column": 29
          },
          {
              "line": 140,
              "column": 9
          },
          {
              "line": 158,
              "column": 29
          },
          {
              "line": 172,
              "column": 9
          },
          {
              "line": 177,
              "column": 9
          },
          {
              "line": 182,
              "column": 9
          },
          {
              "line": 200,
              "column": 29
          },
          {
              "line": 210,
              "column": 29
          },
          {
              "line": 221,
              "column": 29
          },
          {
              "line": 237,
              "column": 9
          },
          {
              "line": 243,
              "column": 29
          },
          {
              "line": 251,
              "column": 9
          },
          {
              "line": 257,
              "column": 29
          },
          {
              "line": 274,
              "column": 9
          }
      ],
      "old_name": "wfr",
      "new_name": "state",
      "ctx": {
          "symbolName": "wfr",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "WaitingForResources",
          "scopeHint": "in testNotEnoughResources(...)",
          "filePath": "WaitingForResourcesTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testNotEnoughResources() {\n        ctx.setHasDesiredResources(() -> false);\n        WaitingForResources wfr =\n                new WaitingForResources(ctx, LOG, Duration.ZERO, STABILIZATION_TIMEOUT);\n\n        // we expect no state transition.\n        wfr.onNewResourcesAvailable();\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/4d131705b19d06f55f94cc6e19728488fa5448f1^1/flink-runtime/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java",
      "locators": [
          {
              "line": 686,
              "column": 21
          },
          {
              "line": 686,
              "column": 64
          },
          {
              "line": 687,
              "column": 17
          },
          {
              "line": 701,
              "column": 21
          }
      ],
      "old_name": "isOutputOnlyAfterEndOfStream",
      "new_name": "currentNodeAttribute",
      "ctx": {
          "symbolName": "isOutputOnlyAfterEndOfStream",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "boolean",
          "scopeHint": "in createChain(...)",
          "filePath": "StreamingJobGraphGenerator.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private List<StreamEdge> createChain(\n            final Integer currentNodeId,\n            final int chainIndex,\n            final OperatorChainInfo chainInfo,\n            final Map<Integer, OperatorChainInfo> chainEntryPoints) {\n\n        Integer startNodeId = chainInfo.getStartNodeId();\n        if (!builtVertices.contains(startNodeId)) {\n\n            List<StreamEdge> transitiveOutEdges = new ArrayList<StreamEdge>();\n\n            List<StreamEdge> chainableOutputs = new ArrayList<StreamEdge>();\n            List<StreamEdge> nonChainableOutputs = new ArrayList<StreamEdge>();\n\n            StreamNode currentNode = streamGraph.getStreamNode(currentNodeId);\n\n            boolean isOutputOnlyAfterEndOfStream = currentNode.isOutputOnlyAfterEndOfStream();\n            if (isOutputOnlyAfterEndOfStream) {\n                outputBlockingNodesID.add(currentNode.getId());\n            }\n\n            for (StreamEdge outEdge : currentNode.getOutEdges()) {\n                if (isChainable(outEdge, streamGraph)) {\n                    chainableOutputs.add(outEdge);\n                } else {\n                    nonChainableOutputs.add(outEdge);\n                }\n            }\n\n            for (StreamEdge chainable : chainableOutputs) {\n                // Mark downstream nodes in the same chain as outputBlocking\n                if (isOutputOnlyAfterEndOfStream) {\n                    outputBlockingNodesID.add(chainable.getTargetId());\n                }\n                transitiveOutEdges.addAll(\n                        createChain(\n                                chainable.getTargetId(),\n                                chainIndex + 1,\n                                chainInfo,\n                                chainEntryPoints));\n                // Mark upstream nodes in the same chain as outputBlocking\n                if (outputBlockingNodesID.contains(chainable.getTargetId())) {\n                    outputBlockingNodesID.add(currentNodeId);\n                }\n            }\n\n            for (StreamEdge nonChainable : nonChainableOutputs) {\n                transitiveOutEdges.add(nonChainable);\n                createChain(\n                        nonChainable.getTargetId(),\n                        1, // operators start at position 1 because 0 is for chained source inputs\n                        chainEntryPoints.computeIfAbsent(\n                                nonChainable.getTargetId(),\n                                (k) -> chainInfo.newChain(nonChainable.getTargetId())),\n                        chainEntryPoints);\n            }\n\n            chainedNames.put(\n                    currentNodeId,\n                    createChainedName(\n                            currentNodeId,\n                            chainableOutputs,\n                            Optional.ofNullable(chainEntryPoints.get(currentNodeId))));\n            chainedMinResources.put(\n                    currentNodeId, createChainedMinResources(currentNodeId, chainableOutputs));\n            chainedPreferredResources.put(\n                    currentNodeId,\n                    createChainedPreferredResources(currentNodeId, chainableOutputs));\n\n            OperatorID currentOperatorId =\n                    chainInfo.addNodeToChain(\n                            currentNodeId,\n                            streamGraph.getStreamNode(currentNodeId).getOperatorName());\n\n            if (currentNode.getInputFormat() != null) {\n                getOrCreateFormatContainer(startNodeId)\n                        .addInputFormat(currentOperatorId, currentNode.getInputFormat());\n            }\n\n            if (currentNode.getOutputFormat() != null) {\n                getOrCreateFormatContainer(startNodeId)\n                        .addOutputFormat(currentOperatorId, currentNode.getOutputFormat());\n            }\n\n            StreamConfig config =\n                    currentNodeId.equals(startNodeId)\n                            ? createJobVertex(startNodeId, chainInfo)\n                            : new StreamConfig(new Configuration());\n\n            tryConvertPartitionerForDynamicGraph(chainableOutputs, nonChainableOutputs);\n\n            setOperatorConfig(currentNodeId, config, chainInfo.getChainedSources());\n\n            setOperatorChainedOutputsConfig(config, chainableOutputs);\n\n            // we cache the non-chainable outputs here, and set the non-chained config later\n            opNonChainableOutputsCache.put(currentNodeId, nonChainableOutputs);\n\n            if (currentNodeId.equals(startNodeId)) {\n                chainInfo.setTransitiveOutEdges(transitiveOutEdges);\n                chainInfos.put(startNodeId, chainInfo);\n\n                config.setChainStart();\n                config.setChainIndex(chainIndex);\n                config.setOperatorName(streamGraph.getStreamNode(currentNodeId).getOperatorName());\n                config.setTransitiveChainedTaskConfigs(chainedConfigs.get(startNodeId));\n\n            } else {\n                chainedConfigs.computeIfAbsent(\n                        startNodeId, k -> new HashMap<Integer, StreamConfig>());\n\n                config.setChainIndex(chainIndex);\n                StreamNode node = streamGraph.getStreamNode(currentNodeId);\n                config.setOperatorName(node.getOperatorName());\n                chainedConfigs.get(startNodeId).put(currentNodeId, config);\n            }\n\n            config.setOperatorID(currentOperatorId);\n\n            if (chainableOutputs.isEmpty()) {\n                config.setChainEnd();\n            }\n            return transitiveOutEdges;\n\n        } else {\n            return new ArrayList<>();\n        }\n    }",
          "conflictNames": [
              "currentNodeId",
              "chainIndex",
              "chainInfo",
              "chainEntryPoints",
              "startNodeId",
              "transitiveOutEdges",
              "chainableOutputs",
              "nonChainableOutputs",
              "currentNode",
              "currentOperatorId",
              "config",
              "node"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/4de0f76d0bcfc4953d2aef1f06ae490e46b03d37^1/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointsCleaner.java",
      "locators": [
          {
              "line": 2,
              "column": 7
          },
          {
              "line": 2,
              "column": 10
          },
          {
              "line": 2,
              "column": 18
          },
          {
              "line": 2,
              "column": 25
          },
          {
              "line": 2,
              "column": 34
          },
          {
              "line": 2,
              "column": 56
          },
          {
              "line": 2,
              "column": 61
          },
          {
              "line": 3,
              "column": 10
          },
          {
              "line": 3,
              "column": 27
          },
          {
              "line": 3,
              "column": 30
          },
          {
              "line": 3,
              "column": 35
          },
          {
              "line": 3,
              "column": 36
          },
          {
              "line": 3,
              "column": 38
          },
          {
              "line": 3,
              "column": 46
          },
          {
              "line": 3,
              "column": 47
          },
          {
              "line": 3,
              "column": 51
          },
          {
              "line": 3,
              "column": 63
          },
          {
              "line": 4,
              "column": 13
          },
          {
              "line": 5,
              "column": 5
          },
          {
              "line": 5,
              "column": 27
          },
          {
              "line": 5,
              "column": 38
          },
          {
              "line": 5,
              "column": 47
          },
          {
              "line": 5,
              "column": 50
          },
          {
              "line": 5,
              "column": 61
          },
          {
              "line": 6,
              "column": 14
          },
          {
              "line": 6,
              "column": 19
          },
          {
              "line": 6,
              "column": 26
          },
          {
              "line": 6,
              "column": 31
          },
          {
              "line": 6,
              "column": 34
          },
          {
              "line": 6,
              "column": 38
          },
          {
              "line": 6,
              "column": 52
          },
          {
              "line": 7,
              "column": 8
          },
          {
              "line": 7,
              "column": 11
          },
          {
              "line": 7,
              "column": 30
          },
          {
              "line": 7,
              "column": 40
          },
          {
              "line": 7,
              "column": 42
          },
          {
              "line": 7,
              "column": 45
          },
          {
              "line": 7,
              "column": 61
          },
          {
              "line": 8,
              "column": 11
          },
          {
              "line": 8,
              "column": 16
          },
          {
              "line": 8,
              "column": 19
          },
          {
              "line": 8,
              "column": 50
          },
          {
              "line": 8,
              "column": 55
          },
          {
              "line": 8,
              "column": 58
          },
          {
              "line": 10,
              "column": 24
          },
          {
              "line": 10,
              "column": 33
          },
          {
              "line": 10,
              "column": 36
          },
          {
              "line": 12,
              "column": 7
          },
          {
              "line": 12,
              "column": 12
          },
          {
              "line": 12,
              "column": 17
          },
          {
              "line": 12,
              "column": 32
          },
          {
              "line": 12,
              "column": 44
          },
          {
              "line": 12,
              "column": 45
          },
          {
              "line": 12,
              "column": 70
          },
          {
              "line": 13,
              "column": 13
          },
          {
              "line": 13,
              "column": 19
          },
          {
              "line": 13,
              "column": 24
          },
          {
              "line": 13,
              "column": 29
          },
          {
              "line": 13,
              "column": 32
          },
          {
              "line": 13,
              "column": 46
          },
          {
              "line": 14,
              "column": 50
          },
          {
              "line": 14,
              "column": 54
          },
          {
              "line": 14,
              "column": 57
          },
          {
              "line": 14,
              "column": 61
          },
          {
              "line": 14,
              "column": 73
          },
          {
              "line": 15,
              "column": 5
          },
          {
              "line": 15,
              "column": 6
          },
          {
              "line": 15,
              "column": 10
          },
          {
              "line": 15,
              "column": 15
          },
          {
              "line": 15,
              "column": 18
          },
          {
              "line": 15,
              "column": 26
          },
          {
              "line": 15,
              "column": 30
          },
          {
              "line": 15,
              "column": 44
          },
          {
              "line": 15,
              "column": 49
          },
          {
              "line": 15,
              "column": 57
          },
          {
              "line": 16,
              "column": 19
          },
          {
              "line": 16,
              "column": 24
          },
          {
              "line": 16,
              "column": 29
          },
          {
              "line": 16,
              "column": 32
          },
          {
              "line": 19,
              "column": 7
          },
          {
              "line": 19,
              "column": 18
          },
          {
              "line": 19,
              "column": 32
          },
          {
              "line": 19,
              "column": 36
          },
          {
              "line": 21,
              "column": 17
          },
          {
              "line": 21,
              "column": 38
          },
          {
              "line": 21,
              "column": 42
          },
          {
              "line": 22,
              "column": 17
          },
          {
              "line": 22,
              "column": 46
          },
          {
              "line": 22,
              "column": 54
          },
          {
              "line": 24,
              "column": 22
          },
          {
              "line": 25,
              "column": 22
          },
          {
              "line": 27,
              "column": 32
          },
          {
              "line": 28,
              "column": 32
          },
          {
              "line": 28,
              "column": 41
          },
          {
              "line": 29,
              "column": 32
          },
          {
              "line": 29,
              "column": 39
          },
          {
              "line": 29,
              "column": 45
          },
          {
              "line": 31,
              "column": 17
          },
          {
              "line": 31,
              "column": 27
          },
          {
              "line": 33,
              "column": 20
          },
          {
              "line": 35,
              "column": 19
          },
          {
              "line": 36,
              "column": 25
          },
          {
              "line": 36,
              "column": 34
          },
          {
              "line": 36,
              "column": 39
          },
          {
              "line": 36,
              "column": 45
          },
          {
              "line": 37,
              "column": 25
          },
          {
              "line": 37,
              "column": 31
          },
          {
              "line": 39,
              "column": 24
          },
          {
              "line": 39,
              "column": 39
          },
          {
              "line": 39,
              "column": 53
          },
          {
              "line": 39,
              "column": 60
          },
          {
              "line": 42,
              "column": 5
          },
          {
              "line": 42,
              "column": 7
          },
          {
              "line": 42,
              "column": 11
          },
          {
              "line": 42,
              "column": 20
          },
          {
              "line": 42,
              "column": 29
          },
          {
              "line": 42,
              "column": 37
          },
          {
              "line": 42,
              "column": 49
          },
          {
              "line": 42,
              "column": 71
          },
          {
              "line": 42,
              "column": 77
          },
          {
              "line": 42,
              "column": 85
          },
          {
              "line": 42,
              "column": 96
          },
          {
              "line": 43,
              "column": 6
          },
          {
              "line": 45,
              "column": 5
          },
          {
              "line": 45,
              "column": 11
          },
          {
              "line": 46,
              "column": 16
          },
          {
              "line": 46,
              "column": 27
          },
          {
              "line": 46,
              "column": 30
          },
          {
              "line": 46,
              "column": 37
          },
          {
              "line": 46,
              "column": 39
          },
          {
              "line": 46,
              "column": 45
          },
          {
              "line": 46,
              "column": 55
          },
          {
              "line": 46,
              "column": 66
          },
          {
              "line": 46,
              "column": 70
          },
          {
              "line": 47,
              "column": 11
          },
          {
              "line": 47,
              "column": 30
          },
          {
              "line": 47,
              "column": 43
          },
          {
              "line": 47,
              "column": 54
          },
          {
              "line": 47,
              "column": 60
          },
          {
              "line": 47,
              "column": 65
          },
          {
              "line": 47,
              "column": 76
          },
          {
              "line": 47,
              "column": 79
          },
          {
              "line": 48,
              "column": 11
          },
          {
              "line": 48,
              "column": 32
          },
          {
              "line": 48,
              "column": 38
          },
          {
              "line": 50,
              "column": 11
          },
          {
              "line": 50,
              "column": 22
          },
          {
              "line": 50,
              "column": 34
          },
          {
              "line": 50,
              "column": 40
          },
          {
              "line": 52,
              "column": 11
          },
          {
              "line": 53,
              "column": 11
          },
          {
              "line": 53,
              "column": 21
          },
          {
              "line": 53,
              "column": 27
          },
          {
              "line": 53,
              "column": 40
          },
          {
              "line": 55,
              "column": 11
          },
          {
              "line": 56,
              "column": 13
          },
          {
              "line": 57,
              "column": 11
          },
          {
              "line": 57,
              "column": 18
          },
          {
              "line": 57,
              "column": 23
          },
          {
              "line": 57,
              "column": 29
          },
          {
              "line": 57,
              "column": 39
          },
          {
              "line": 57,
              "column": 49
          },
          {
              "line": 59,
              "column": 19
          },
          {
              "line": 59,
              "column": 24
          },
          {
              "line": 60,
              "column": 11
          },
          {
              "line": 61,
              "column": 11
          },
          {
              "line": 61,
              "column": 29
          },
          {
              "line": 61,
              "column": 31
          },
          {
              "line": 61,
              "column": 35
          },
          {
              "line": 61,
              "column": 51
          },
          {
              "line": 61,
              "column": 55
          },
          {
              "line": 61,
              "column": 68
          },
          {
              "line": 63,
              "column": 10
          },
          {
              "line": 63,
              "column": 16
          },
          {
              "line": 63,
              "column": 22
          },
          {
              "line": 63,
              "column": 35
          },
          {
              "line": 64,
              "column": 19
          },
          {
              "line": 65,
              "column": 14
          },
          {
              "line": 65,
              "column": 24
          },
          {
              "line": 65,
              "column": 30
          },
          {
              "line": 65,
              "column": 43
          },
          {
              "line": 69,
              "column": 19
          },
          {
              "line": 69,
              "column": 24
          },
          {
              "line": 70,
              "column": 15
          },
          {
              "line": 70,
              "column": 26
          },
          {
              "line": 71,
              "column": 17
          },
          {
              "line": 72,
              "column": 20
          },
          {
              "line": 72,
              "column": 28
          },
          {
              "line": 73,
              "column": 15
          },
          {
              "line": 73,
              "column": 22
          },
          {
              "line": 73,
              "column": 24
          },
          {
              "line": 74,
              "column": 11
          },
          {
              "line": 74,
              "column": 30
          },
          {
              "line": 74,
              "column": 44
          },
          {
              "line": 75,
              "column": 35
          },
          {
              "line": 75,
              "column": 57
          },
          {
              "line": 75,
              "column": 66
          },
          {
              "line": 77,
              "column": 11
          },
          {
              "line": 77,
              "column": 19
          },
          {
              "line": 77,
              "column": 39
          },
          {
              "line": 77,
              "column": 59
          },
          {
              "line": 77,
              "column": 70
          },
          {
              "line": 77,
              "column": 72
          },
          {
              "line": 81,
              "column": 14
          },
          {
              "line": 81,
              "column": 22
          },
          {
              "line": 81,
              "column": 27
          },
          {
              "line": 81,
              "column": 41
          },
          {
              "line": 81,
              "column": 52
          },
          {
              "line": 81,
              "column": 55
          },
          {
              "line": 81,
              "column": 61
          },
          {
              "line": 81,
              "column": 69
          },
          {
              "line": 81,
              "column": 74
          },
          {
              "line": 81,
              "column": 90
          },
          {
              "line": 81,
              "column": 99
          },
          {
              "line": 82,
              "column": 21
          },
          {
              "line": 82,
              "column": 30
          },
          {
              "line": 82,
              "column": 34
          },
          {
              "line": 82,
              "column": 51
          },
          {
              "line": 82,
              "column": 62
          },
          {
              "line": 82,
              "column": 67
          },
          {
              "line": 84,
              "column": 20
          },
          {
              "line": 84,
              "column": 22
          },
          {
              "line": 84,
              "column": 26
          },
          {
              "line": 84,
              "column": 50
          },
          {
              "line": 86,
              "column": 26
          },
          {
              "line": 86,
              "column": 30
          },
          {
              "line": 86,
              "column": 44
          },
          {
              "line": 86,
              "column": 46
          },
          {
              "line": 86,
              "column": 50
          },
          {
              "line": 86,
              "column": 64
          },
          {
              "line": 86,
              "column": 66
          },
          {
              "line": 86,
              "column": 70
          },
          {
              "line": 87,
              "column": 19
          },
          {
              "line": 88,
              "column": 19
          },
          {
              "line": 88,
              "column": 23
          },
          {
              "line": 88,
              "column": 42
          },
          {
              "line": 88,
              "column": 44
          },
          {
              "line": 88,
              "column": 48
          },
          {
              "line": 93,
              "column": 10
          },
          {
              "line": 93,
              "column": 16
          },
          {
              "line": 93,
              "column": 42
          },
          {
              "line": 93,
              "column": 47
          },
          {
              "line": 93,
              "column": 67
          },
          {
              "line": 95,
              "column": 23
          },
          {
              "line": 95,
              "column": 29
          },
          {
              "line": 96,
              "column": 24
          },
          {
              "line": 96,
              "column": 28
          },
          {
              "line": 96,
              "column": 34
          },
          {
              "line": 96,
              "column": 43
          },
          {
              "line": 96,
              "column": 47
          },
          {
              "line": 96,
              "column": 59
          },
          {
              "line": 96,
              "column": 68
          },
          {
              "line": 96,
              "column": 70
          },
          {
              "line": 96,
              "column": 72
          },
          {
              "line": 96,
              "column": 75
          },
          {
              "line": 97,
              "column": 21
          },
          {
              "line": 97,
              "column": 46
          },
          {
              "line": 97,
              "column": 51
          },
          {
              "line": 98,
              "column": 15
          },
          {
              "line": 98,
              "column": 17
          },
          {
              "line": 98,
              "column": 29
          },
          {
              "line": 98,
              "column": 36
          },
          {
              "line": 98,
              "column": 45
          },
          {
              "line": 98,
              "column": 49
          },
          {
              "line": 100,
              "column": 19
          },
          {
              "line": 100,
              "column": 28
          },
          {
              "line": 100,
              "column": 32
          },
          {
              "line": 101,
              "column": 25
          },
          {
              "line": 101,
              "column": 43
          },
          {
              "line": 101,
              "column": 53
          },
          {
              "line": 101,
              "column": 61
          },
          {
              "line": 101,
              "column": 74
          },
          {
              "line": 101,
              "column": 81
          },
          {
              "line": 101,
              "column": 83
          },
          {
              "line": 102,
              "column": 19
          },
          {
              "line": 103,
              "column": 15
          },
          {
              "line": 103,
              "column": 27
          },
          {
              "line": 103,
              "column": 29
          },
          {
              "line": 103,
              "column": 33
          },
          {
              "line": 103,
              "column": 45
          },
          {
              "line": 103,
              "column": 60
          },
          {
              "line": 103,
              "column": 64
          },
          {
              "line": 103,
              "column": 76
          },
          {
              "line": 104,
              "column": 17
          },
          {
              "line": 104,
              "column": 22
          },
          {
              "line": 104,
              "column": 33
          },
          {
              "line": 105,
              "column": 22
          },
          {
              "line": 105,
              "column": 24
          },
          {
              "line": 105,
              "column": 28
          },
          {
              "line": 105,
              "column": 39
          },
          {
              "line": 105,
              "column": 52
          },
          {
              "line": 105,
              "column": 60
          },
          {
              "line": 106,
              "column": 23
          },
          {
              "line": 106,
              "column": 33
          },
          {
              "line": 106,
              "column": 37
          },
          {
              "line": 107,
              "column": 38
          },
          {
              "line": 107,
              "column": 51
          },
          {
              "line": 107,
              "column": 61
          },
          {
              "line": 107,
              "column": 65
          },
          {
              "line": 109,
              "column": 30
          },
          {
              "line": 109,
              "column": 53
          },
          {
              "line": 109,
              "column": 70
          },
          {
              "line": 109,
              "column": 80
          },
          {
              "line": 109,
              "column": 84
          },
          {
              "line": 110,
              "column": 27
          },
          {
              "line": 110,
              "column": 32
          },
          {
              "line": 111,
              "column": 35
          },
          {
              "line": 112,
              "column": 35
          },
          {
              "line": 112,
              "column": 51
          },
          {
              "line": 112,
              "column": 59
          },
          {
              "line": 112,
              "column": 69
          },
          {
              "line": 113,
              "column": 39
          },
          {
              "line": 114,
              "column": 33
          },
          {
              "line": 114,
              "column": 35
          },
          {
              "line": 115,
              "column": 27
          },
          {
              "line": 115,
              "column": 35
          },
          {
              "line": 115,
              "column": 39
          },
          {
              "line": 116,
              "column": 33
          },
          {
              "line": 116,
              "column": 40
          },
          {
              "line": 117,
              "column": 53
          },
          {
              "line": 117,
              "column": 61
          },
          {
              "line": 117,
              "column": 78
          },
          {
              "line": 124,
              "column": 19
          },
          {
              "line": 124,
              "column": 24
          },
          {
              "line": 124,
              "column": 38
          },
          {
              "line": 125,
              "column": 18
          },
          {
              "line": 125,
              "column": 20
          },
          {
              "line": 125,
              "column": 24
          },
          {
              "line": 125,
              "column": 38
          },
          {
              "line": 125,
              "column": 40
          },
          {
              "line": 125,
              "column": 44
          },
          {
              "line": 125,
              "column": 56
          },
          {
              "line": 125,
              "column": 63
          },
          {
              "line": 125,
              "column": 65
          },
          {
              "line": 126,
              "column": 11
          },
          {
              "line": 126,
              "column": 30
          },
          {
              "line": 126,
              "column": 44
          },
          {
              "line": 126,
              "column": 55
          },
          {
              "line": 126,
              "column": 57
          },
          {
              "line": 126,
              "column": 61
          },
          {
              "line": 126,
              "column": 83
          },
          {
              "line": 127,
              "column": 11
          },
          {
              "line": 127,
              "column": 22
          },
          {
              "line": 127,
              "column": 24
          },
          {
              "line": 127,
              "column": 28
          },
          {
              "line": 127,
              "column": 48
          },
          {
              "line": 127,
              "column": 72
          },
          {
              "line": 127,
              "column": 74
          },
          {
              "line": 130,
              "column": 11
          },
          {
              "line": 130,
              "column": 20
          },
          {
              "line": 131,
              "column": 15
          },
          {
              "line": 131,
              "column": 26
          },
          {
              "line": 132,
              "column": 20
          },
          {
              "line": 132,
              "column": 28
          },
          {
              "line": 132,
              "column": 37
          },
          {
              "line": 133,
              "column": 20
          },
          {
              "line": 133,
              "column": 28
          },
          {
              "line": 134,
              "column": 15
          },
          {
              "line": 134,
              "column": 22
          },
          {
              "line": 134,
              "column": 24
          },
          {
              "line": 135,
              "column": 13
          },
          {
              "line": 135,
              "column": 15
          },
          {
              "line": 135,
              "column": 22
          },
          {
              "line": 135,
              "column": 28
          },
          {
              "line": 135,
              "column": 41
          },
          {
              "line": 136,
              "column": 9
          },
          {
              "line": 136,
              "column": 11
          },
          {
              "line": 136,
              "column": 18
          },
          {
              "line": 136,
              "column": 20
          },
          {
              "line": 136,
              "column": 24
          },
          {
              "line": 139,
              "column": 27
          },
          {
              "line": 140,
              "column": 33
          },
          {
              "line": 140,
              "column": 40
          },
          {
              "line": 142,
              "column": 48
          },
          {
              "line": 142,
              "column": 66
          },
          {
              "line": 142,
              "column": 68
          },
          {
              "line": 142,
              "column": 73
          },
          {
              "line": 143,
              "column": 35
          },
          {
              "line": 143,
              "column": 45
          },
          {
              "line": 143,
              "column": 49
          },
          {
              "line": 144,
              "column": 33
          },
          {
              "line": 146,
              "column": 26
          },
          {
              "line": 146,
              "column": 29
          },
          {
              "line": 146,
              "column": 31
          },
          {
              "line": 146,
              "column": 38
          },
          {
              "line": 146,
              "column": 44
          },
          {
              "line": 146,
              "column": 57
          },
          {
              "line": 147,
              "column": 31
          },
          {
              "line": 152,
              "column": 11
          },
          {
              "line": 152,
              "column": 22
          },
          {
              "line": 152,
              "column": 24
          },
          {
              "line": 152,
              "column": 31
          },
          {
              "line": 152,
              "column": 37
          },
          {
              "line": 152,
              "column": 50
          },
          {
              "line": 153,
              "column": 19
          },
          {
              "line": 154,
              "column": 15
          },
          {
              "line": 154,
              "column": 22
          },
          {
              "line": 154,
              "column": 26
          },
          {
              "line": 154,
              "column": 36
          },
          {
              "line": 154,
              "column": 50
          },
          {
              "line": 154,
              "column": 61
          },
          {
              "line": 154,
              "column": 64
          },
          {
              "line": 154,
              "column": 74
          },
          {
              "line": 154,
              "column": 80
          },
          {
              "line": 154,
              "column": 81
          },
          {
              "line": 154,
              "column": 88
          },
          {
              "line": 155,
              "column": 17
          },
          {
              "line": 155,
              "column": 23
          },
          {
              "line": 155,
              "column": 36
          },
          {
              "line": 159,
              "column": 11
          },
          {
              "line": 159,
              "column": 19
          },
          {
              "line": 159,
              "column": 22
          },
          {
              "line": 159,
              "column": 24
          },
          {
              "line": 159,
              "column": 31
          },
          {
              "line": 159,
              "column": 37
          },
          {
              "line": 159,
              "column": 50
          },
          {
              "line": 160,
              "column": 19
          },
          {
              "line": 161,
              "column": 17
          },
          {
              "line": 161,
              "column": 23
          },
          {
              "line": 161,
              "column": 36
          },
          {
              "line": 162,
              "column": 17
          },
          {
              "line": 162,
              "column": 23
          },
          {
              "line": 162,
              "column": 25
          },
          {
              "line": 162,
              "column": 30
          },
          {
              "line": 162,
              "column": 36
          },
          {
              "line": 166,
              "column": 11
          },
          {
              "line": 166,
              "column": 22
          },
          {
              "line": 166,
              "column": 28
          },
          {
              "line": 166,
              "column": 30
          },
          {
              "line": 166,
              "column": 35
          },
          {
              "line": 166,
              "column": 41
          },
          {
              "line": 167,
              "column": 17
          },
          {
              "line": 167,
              "column": 23
          },
          {
              "line": 167,
              "column": 36
          },
          {
              "line": 167,
              "column": 50
          },
          {
              "line": 167,
              "column": 60
          },
          {
              "line": 168,
              "column": 15
          },
          {
              "line": 168,
              "column": 25
          },
          {
              "line": 168,
              "column": 32
          },
          {
              "line": 168,
              "column": 34
          },
          {
              "line": 172,
              "column": 8
          },
          {
              "line": 172,
              "column": 13
          },
          {
              "line": 173,
              "column": 17
          },
          {
              "line": 173,
              "column": 22
          },
          {
              "line": 173,
              "column": 28
          },
          {
              "line": 173,
              "column": 40
          },
          {
              "line": 174,
              "column": 19
          },
          {
              "line": 175,
              "column": 19
          },
          {
              "line": 175,
              "column": 29
          },
          {
              "line": 176,
              "column": 19
          },
          {
              "line": 176,
              "column": 29
          },
          {
              "line": 176,
              "column": 34
          },
          {
              "line": 176,
              "column": 42
          },
          {
              "line": 176,
              "column": 47
          },
          {
              "line": 176,
              "column": 53
          },
          {
              "line": 178,
              "column": 17
          },
          {
              "line": 178,
              "column": 23
          },
          {
              "line": 178,
              "column": 25
          },
          {
              "line": 178,
              "column": 30
          },
          {
              "line": 178,
              "column": 36
          },
          {
              "line": 179,
              "column": 19
          },
          {
              "line": 179,
              "column": 23
          },
          {
              "line": 179,
              "column": 35
          },
          {
              "line": 180,
              "column": 14
          },
          {
              "line": 180,
              "column": 22
          },
          {
              "line": 180,
              "column": 32
          }
      ],
      "old_name": "e",
      "new_name": "outerThrowable",
      "ctx": {
          "symbolName": "e",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Exception",
          "scopeHint": "in cleanSubsumedCheckpoints(...)",
          "filePath": "CheckpointsCleaner.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "t,\n                                checkpoint.shouldBeDiscardedOnSubsume(),\n                                postCleanAction,\n                                executor);\n                        iterator.remove();\n                    } catch (Exception e) {\n                        LOG.warn(\"Fail to discard the old checkpoint {}.\", checkpoint);\n                    }\n                }\n            }\n        }\n    }\n\n    public void cleanCheckpointOnFailedStoring(\n            CompletedCheckpoi",
          "conflictNames": [
              "upTo",
              "stillInUse",
              "postCleanAction",
              "executor",
              "iterator",
              "checkpoint"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/4e6dc79e785ff18920c15a38ba50f57111bf7623^1/flink-test-utils-parent/flink-test-utils/src/main/java/org/apache/flink/test/util/MultipleProgramsTestBase.java",
      "locators": [
          {
              "line": 77,
              "column": 25
          },
          {
              "line": 82,
              "column": 17
          },
          {
              "line": 83,
              "column": 17
          },
          {
              "line": 84,
              "column": 17
          },
          {
              "line": 89,
              "column": 17
          },
          {
              "line": 90,
              "column": 17
          },
          {
              "line": 91,
              "column": 17
          }
      ],
      "old_name": "testEnvironment",
      "new_name": "testStreamEnvironment",
      "ctx": {
          "symbolName": "testEnvironment",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestEnvironment",
          "scopeHint": "in setupEnvironment(...)",
          "filePath": "MultipleProgramsTestBase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@BeforeEach\n    public void setupEnvironment() {\n        TestEnvironment testEnvironment;\n        switch (mode) {\n            case CLUSTER:\n                // This only works because of the quirks we built in the TestEnvironment.\n                // We should refactor this in the future!!!\n                testEnvironment = MINI_CLUSTER_EXTENSION.getTestEnvironment();\n                testEnvironment.getConfig().disableObjectReuse();\n                testEnvironment.setAsContext();\n                break;\n            case CLUSTER_OBJECT_REUSE:\n                // This only works because of the quirks we built in the TestEnvironment.\n                // We should refactor this in the future!!!\n                testEnvironment = MINI_CLUSTER_EXTENSION.getTestEnvironment();\n                testEnvironment.getConfig().enableObjectReuse();\n                testEnvironment.setAsContext();\n                break;\n            case COLLECTION:\n                new CollectionTestEnvironment().setAsContext();\n                break;\n        }\n    }"
      },
      "suggestions": [
          {
              "name": "testEnvironmentStream",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/4e6dc79e785ff18920c15a38ba50f57111bf7623^1/flink-test-utils-parent/flink-test-utils/src/main/java/org/apache/flink/test/util/MultipleProgramsTestBaseJUnit4.java",
      "locators": [
          {
              "line": 82,
              "column": 25
          },
          {
              "line": 87,
              "column": 17
          },
          {
              "line": 88,
              "column": 17
          },
          {
              "line": 89,
              "column": 17
          },
          {
              "line": 94,
              "column": 17
          },
          {
              "line": 95,
              "column": 17
          },
          {
              "line": 96,
              "column": 17
          }
      ],
      "old_name": "testEnvironment",
      "new_name": "testStreamEnvironment",
      "ctx": {
          "symbolName": "testEnvironment",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestEnvironment",
          "scopeHint": "in setupEnvironment(...)",
          "filePath": "MultipleProgramsTestBaseJUnit4.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Before\n    public void setupEnvironment() {\n        TestEnvironment testEnvironment;\n        switch (mode) {\n            case CLUSTER:\n                // This only works because of the quirks we built in the TestEnvironment.\n                // We should refactor this in the future!!!\n                testEnvironment = MINI_CLUSTER_RESOURCE.getTestEnvironment();\n                testEnvironment.getConfig().disableObjectReuse();\n                testEnvironment.setAsContext();\n                break;\n            case CLUSTER_OBJECT_REUSE:\n                // This only works because of the quirks we built in the TestEnvironment.\n                // We should refactor this in the future!!!\n                testEnvironment = MINI_CLUSTER_RESOURCE.getTestEnvironment();\n                testEnvironment.getConfig().enableObjectReuse();\n                testEnvironment.setAsContext();\n                break;\n            case COLLECTION:\n                new CollectionTestEnvironment().setAsContext();\n                break;\n        }\n    }"
      },
      "suggestions": [
          {
              "name": "testEnvironmentStream",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/4e6dc79e785ff18920c15a38ba50f57111bf7623^1/flink-tests/src/test/java/org/apache/flink/test/example/client/LocalExecutorITCase.java",
      "locators": [
          {
              "line": 83,
              "column": 18
          },
          {
              "line": 84,
              "column": 13
          },
          {
              "line": 86,
              "column": 38
          }
      ],
      "old_name": "wcPlan",
      "new_name": "wcStreamGraph",
      "ctx": {
          "symbolName": "wcPlan",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Plan",
          "scopeHint": "in testLocalExecutorWithWordCount(...)",
          "filePath": "LocalExecutorITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test(timeout = 60_000)\n    public void testLocalExecutorWithWordCount() throws InterruptedException {\n        try {\n            // set up the files\n            File inFile = File.createTempFile(\"wctext\", \".in\");\n            File outFile = File.createTempFile(\"wctext\", \".out\");\n            inFile.deleteOnExit();\n            outFile.deleteOnExit();\n\n            try (FileWriter fw = new FileWriter(inFile)) {\n                fw.write(WordCountData.TEXT);\n            }\n\n            final Configuration config = new Configuration();\n            config.set(CoreOptions.FILESYTEM_DEFAULT_OVERRIDE, true);\n            config.set(DeploymentOptions.ATTACHED, true);\n\n            Plan wcPlan = getWordCountPlan(inFile, outFile, parallelism);\n            wcPlan.setExecutionConfig(new ExecutionConfig());\n            JobClient jobClient =\n                    executor.execute(wcPlan, config, ClassLoader.getSystemClassLoader()).get();\n            jobClient.getJobExecutionResult().get();\n        } catch (Exception e) {\n            e.printStackTrace();\n            Assert.fail(e.getMessage());\n        }\n\n        assertThat(miniCluster.isRunning(), is(false));\n    }",
          "conflictNames": [
              "inFile",
              "outFile",
              "fw",
              "config",
              "jobClient"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/4faf0966766e3734792f80ed66e512aa3033cacd^1/flink-formats/flink-parquet/src/test/java/org/apache/flink/formats/parquet/vector/ParquetInt64TimestampReaderTest.java",
      "locators": [
          {
              "line": 36,
              "column": 23
          },
          {
              "line": 38,
              "column": 17
          },
          {
              "line": 39,
              "column": 27
          },
          {
              "line": 48,
              "column": 23
          },
          {
              "line": 50,
              "column": 17
          },
          {
              "line": 51,
              "column": 27
          },
          {
              "line": 60,
              "column": 23
          },
          {
              "line": 62,
              "column": 17
          },
          {
              "line": 63,
              "column": 27
          }
      ],
      "old_name": "localDateTime",
      "new_name": "zonedDateTime",
      "ctx": {
          "symbolName": "localDateTime",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "LocalDateTime",
          "scopeHint": "in testReadInt64TimestampMicros(...)",
          "filePath": "ParquetInt64TimestampReaderTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "\n    @Test\n    public void testReadInt64TimestampMicros() {\n        LocalDateTime localDateTime = LocalDateTime.of(2021, 11, 22, 17, 50, 20, 112233);\n        long time =\n                localDateTime.toEpochSecond(OffsetDateTime.now().getOffset()) * 1_000_000\n                        + localDateTime.getNano() / 1_000;\n        TimestampData timestampData =\n                TimestampColumnReader.int64ToTimestamp(\n                        false, time, LogicalTypeAnnotation.TimeUnit.MICROS);\n        assertEquals(\"2021-11-22T17:50:20.000112\", timestampData.toString());\n    }",
          "conflictNames": [
              "time",
              "timestampData"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/503593ab2d463daf1a7de1546d5bb3e44c0c1ecb^1/flink-table/flink-table-runtime/src/test/java/org/apache/flink/table/runtime/operators/over/BufferDataOverWindowOperatorTest.java",
      "locators": [
          {
              "line": 21,
              "column": 25
          },
          {
              "line": 234,
              "column": 38
          },
          {
              "line": 235,
              "column": 30
          },
          {
              "line": 237,
              "column": 30
          },
          {
              "line": 243,
              "column": 32
          }
      ],
      "old_name": "conf",
      "new_name": "streamConfig",
      "ctx": {
          "symbolName": "conf",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "StreamConfig",
          "scopeHint": "in getOperatorConfig(...)",
          "filePath": "BufferDataOverWindowOperatorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n                    public StreamConfig getOperatorConfig() {\n                        StreamConfig conf = mock(StreamConfig.class);\n                        when(conf.<RowData>getTypeSerializerIn1(getUserCodeClassloader()))\n                                .thenReturn(inputSer);\n                        when(conf.getManagedMemoryFractionOperatorUseCaseOfSlot(\n                                        eq(ManagedMemoryUseCase.OPERATOR),\n                                        any(Configuration.class),\n                                        any(Configuration.class),\n                                        any(ClassLoader.class)))\n                                .thenReturn(0.99);\n                        return conf;\n                    }"
      },
      "suggestions": [
          {
              "name": "streamConfig",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/503593ab2d463daf1a7de1546d5bb3e44c0c1ecb^1/flink-table/flink-table-runtime/src/test/java/org/apache/flink/table/runtime/operators/over/NonBufferOverWindowOperatorTest.java",
      "locators": [
          {
              "line": 148,
              "column": 38
          },
          {
              "line": 149,
              "column": 30
          },
          {
              "line": 151,
              "column": 32
          }
      ],
      "old_name": "conf",
      "new_name": "streamConfig",
      "ctx": {
          "symbolName": "conf",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "StreamConfig",
          "scopeHint": "in getOperatorConfig(...)",
          "filePath": "NonBufferOverWindowOperatorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n                    public StreamConfig getOperatorConfig() {\n                        StreamConfig conf = mock(StreamConfig.class);\n                        when(conf.<RowData>getTypeSerializerIn1(getUserCodeClassloader()))\n                                .thenReturn(inputSer);\n                        return conf;\n                    }"
      },
      "suggestions": [
          {
              "name": "streamConfig",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/525f6bc818eb7f15a19fa81421584920de8f8876^1/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskExecutor.java",
      "locators": [
          {
              "line": 412,
              "column": 34
          },
          {
              "line": 413,
              "column": 25
          },
          {
              "line": 414,
              "column": 58
          },
          {
              "line": 421,
              "column": 53
          },
          {
              "line": 1296,
              "column": 22
          },
          {
              "line": 1297,
              "column": 48
          },
          {
              "line": 1301,
              "column": 33
          }
      ],
      "old_name": "logDir",
      "new_name": "baseDir",
      "ctx": {
          "symbolName": "logDir",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in requestLogList(...)",
          "filePath": "TaskExecutor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public CompletableFuture<Collection<LogInfo>> requestLogList(Time timeout) {\n        return CompletableFuture.supplyAsync(\n                () -> {\n                    final String logDir = taskManagerConfiguration.getTaskManagerLogDir();\n                    if (logDir != null) {\n                        final File[] logFiles = new File(logDir).listFiles();\n\n                        if (logFiles == null) {\n                            throw new CompletionException(\n                                    new FlinkException(\n                                            String.format(\n                                                    \"There isn't a log file in TaskExecutors log dir %s.\",\n                                                    logDir)));\n                        }\n\n                        return Arrays.stream(logFiles)\n                                .filter(File::isFile)\n                                .map(\n                                        logFile ->\n                                                new LogInfo(\n                                                        logFile.getName(),\n                                                        logFile.length(),\n                                                        logFile.lastModified()))\n                                .collect(Collectors.toList());\n                    }\n                    return Collections.emptyList();\n                },\n                ioExecutor);\n    }",
          "conflictNames": [
              "timeout",
              "logFiles"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/5269631af525a01d944cfa9994a116fb27b80b1b^1/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DefaultResourceAllocationStrategy.java",
      "locators": [
          {
              "line": 391,
              "column": 25
          },
          {
              "line": 399,
              "column": 17
          }
      ],
      "old_name": "totalAvailableResources",
      "new_name": "resourcesAvailable",
      "ctx": {
          "symbolName": "totalAvailableResources",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ResourceProfile",
          "scopeHint": "in tryFulFillRequiredResources(...)",
          "filePath": "DefaultResourceAllocationStrategy.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void tryFulFillRequiredResources(\n            List<InternalResourceInfo> availableRegisteredResources,\n            List<InternalResourceInfo> availablePendingResources,\n            ResourceProfile totalCurrentResources,\n            ResourceAllocationResult.Builder resultBuilder) {\n        ResourceProfile totalAvailableResources =\n                Stream.concat(\n                                availableRegisteredResources.stream(),\n                                availablePendingResources.stream())\n                        .map(internalResourceInfo -> internalResourceInfo.availableProfile)\n                        .reduce(ResourceProfile.ZERO, ResourceProfile::merge);\n\n        tryFulFillRequiredResourcesWithAction(\n                totalAvailableResources,\n                totalCurrentResources,\n                resultBuilder::addPendingTaskManagerAllocate);\n    }",
          "conflictNames": [
              "availableRegisteredResources",
              "availablePendingResources",
              "totalCurrentResources",
              "resultBuilder"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/52bf14b0ba949e048c78862be2ed8ebfb58c780e^1/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java",
      "locators": [
          {
              "line": 388,
              "column": 46
          },
          {
              "line": 392,
              "column": 26
          },
          {
              "line": 397,
              "column": 26
          }
      ],
      "old_name": "cancellationFuture",
      "new_name": "cancellationRequestFuture",
      "ctx": {
          "symbolName": "cancellationFuture",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CompletableFuture<Acknowledge>",
          "scopeHint": "in testCancellationDuringInitialization(...)",
          "filePath": "DispatcherTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testCancellationDuringInitialization() throws Exception {\n        final Tuple2<JobGraph, JobVertexBlockingOnInitializeOnJobMaster> blockingJobGraphAndVertex = getJobGraphAndVertexBlockingOnInitializeOnJobMaster();\n        final JobGraph blockingJobGraph = blockingJobGraphAndVertex.f0;\n        final JobVertexBlockingOnInitializeOnJobMaster blockingVertex = blockingJobGraphAndVertex.f1;\n\n        dispatcher =\n                createAndStartDispatcher(\n                        heartbeatServices,\n                        haServices,\n                        new ExpectedJobIdJobManagerRunnerFactory(blockingJobGraph.getJobID()));\n        jobMasterLeaderElectionService.isLeader(UUID.randomUUID());\n        final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);\n\n        assertThatFuture(dispatcherGateway.submitJob(blockingJobGraph, TIMEOUT)).eventuallySucceeds();\n        assertThatFuture(\n                dispatcherGateway.requestJobStatus(blockingJobGraph.getJobID(), TIMEOUT))\n                .eventuallySucceeds()\n                .isEqualTo(JobStatus.INITIALIZING);\n\n        // submission has succeeded, now cancel the job\n        final CompletableFuture<Acknowledge> cancellationFuture =\n                dispatcherGateway.cancelJob(blockingJobGraph.getJobID(), TIMEOUT);\n        assertThatFuture(\n                dispatcherGateway.requestJobStatus(blockingJobGraph.getJobID(), TIMEOUT)).eventuallySucceeds().isEqualTo(JobStatus.CANCELLING);\n        assertThatFuture(cancellationFuture).isNotDone();\n\n        // unblock initialization\n        blockingVertex.unblock();\n        // wait until cancelled\n        assertThatFuture(cancellationFuture).eventuallySucceeds();\n\n        assertThatFuture(\n                dispatcherGateway.requestJobResult(blockingJobGraph.getJobID(), TIMEOUT)).eventuallySucceeds().extracting(\n                        JobResult::getApplicationStatus)\n                        .isEqualTo(ApplicationStatus.CANCELED);\n    }",
          "conflictNames": [
              "blockingJobGraphAndVertex",
              "blockingJobGraph",
              "blockingVertex",
              "dispatcherGateway"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/5495a96a38663dc04753cb6db0c100aa2bc7d297^1/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/restore/RocksDBHandle.java",
      "locators": [
          {
              "line": 156,
              "column": 28
          },
          {
              "line": 159,
              "column": 21
          },
          {
              "line": 165,
              "column": 17
          },
          {
              "line": 173,
              "column": 17
          },
          {
              "line": 181,
              "column": 21
          },
          {
              "line": 187,
              "column": 16
          },
          {
              "line": 194,
              "column": 28
          },
          {
              "line": 196,
              "column": 13
          },
          {
              "line": 199,
              "column": 34
          },
          {
              "line": 201,
              "column": 9
          },
          {
              "line": 214,
              "column": 17
          },
          {
              "line": 216,
              "column": 16
          }
      ],
      "old_name": "registeredStateMetaInfoEntry",
      "new_name": "stateInfo",
      "ctx": {
          "symbolName": "registeredStateMetaInfoEntry",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RocksDbKvStateInfo",
          "scopeHint": "in getOrRegisterStateColumnFamilyHandle(...)",
          "filePath": "RocksDBHandle.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "RocksDbKvStateInfo getOrRegisterStateColumnFamilyHandle(\n            ColumnFamilyHandle columnFamilyHandle, StateMetaInfoSnapshot stateMetaInfoSnapshot) {\n\n        RocksDbKvStateInfo registeredStateMetaInfoEntry =\n                kvStateInformation.get(stateMetaInfoSnapshot.getName());\n\n        if (null == registeredStateMetaInfoEntry) {\n            // create a meta info for the state on restore;\n            // this allows us to retain the state in future snapshots even if it wasn't accessed\n            RegisteredStateMetaInfoBase stateMetaInfo =\n                    RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot);\n            if (columnFamilyHandle == null) {\n                registeredStateMetaInfoEntry =\n                        RocksDBOperationUtils.createStateInfo(\n                                stateMetaInfo,\n                                db,\n                                columnFamilyOptionsFactory,\n                                ttlCompactFiltersManager,\n                                writeBufferManagerCapacity);\n            } else {\n                registeredStateMetaInfoEntry =\n                        new RocksDbKvStateInfo(columnFamilyHandle, stateMetaInfo);\n            }\n\n            RocksDBOperationUtils.registerKvStateInformation(\n                    kvStateInformation,\n                    nativeMetricMonitor,\n                    stateMetaInfoSnapshot.getName(),\n                    registeredStateMetaInfoEntry);\n        } else {\n            // TODO with eager state registration in place, check here for serializer migration\n            // strategies\n        }\n\n        return registeredStateMetaInfoEntry;\n    }",
          "conflictNames": [
              "columnFamilyHandle",
              "stateMetaInfoSnapshot",
              "stateMetaInfo"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/5495a96a38663dc04753cb6db0c100aa2bc7d297^1/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBOperationUtils.java",
      "locators": [
          {
              "line": 2,
              "column": 7
          },
          {
              "line": 2,
              "column": 10
          },
          {
              "line": 2,
              "column": 18
          },
          {
              "line": 2,
              "column": 25
          },
          {
              "line": 2,
              "column": 34
          },
          {
              "line": 2,
              "column": 56
          },
          {
              "line": 2,
              "column": 61
          },
          {
              "line": 2,
              "column": 69
          },
          {
              "line": 3,
              "column": 19
          },
          {
              "line": 3,
              "column": 22
          },
          {
              "line": 3,
              "column": 27
          },
          {
              "line": 3,
              "column": 28
          },
          {
              "line": 3,
              "column": 30
          },
          {
              "line": 3,
              "column": 38
          },
          {
              "line": 3,
              "column": 39
          },
          {
              "line": 3,
              "column": 43
          },
          {
              "line": 3,
              "column": 55
          },
          {
              "line": 3,
              "column": 66
          },
          {
              "line": 4,
              "column": 42
          },
          {
              "line": 4,
              "column": 64
          },
          {
              "line": 5,
              "column": 6
          },
          {
              "line": 5,
              "column": 15
          },
          {
              "line": 5,
              "column": 18
          },
          {
              "line": 5,
              "column": 29
          },
          {
              "line": 5,
              "column": 41
          },
          {
              "line": 5,
              "column": 46
          },
          {
              "line": 5,
              "column": 53
          },
          {
              "line": 5,
              "column": 58
          },
          {
              "line": 5,
              "column": 61
          },
          {
              "line": 5,
              "column": 65
          },
          {
              "line": 6,
              "column": 7
          },
          {
              "line": 6,
              "column": 13
          },
          {
              "line": 6,
              "column": 16
          },
          {
              "line": 6,
              "column": 35
          },
          {
              "line": 6,
              "column": 45
          },
          {
              "line": 6,
              "column": 47
          },
          {
              "line": 6,
              "column": 50
          },
          {
              "line": 6,
              "column": 66
          },
          {
              "line": 7,
              "column": 6
          },
          {
              "line": 7,
              "column": 11
          },
          {
              "line": 7,
              "column": 14
          },
          {
              "line": 7,
              "column": 45
          },
          {
              "line": 7,
              "column": 50
          },
          {
              "line": 7,
              "column": 53
          },
          {
              "line": 9,
              "column": 23
          },
          {
              "line": 9,
              "column": 32
          },
          {
              "line": 9,
              "column": 35
          },
          {
              "line": 11,
              "column": 7
          },
          {
              "line": 11,
              "column": 12
          },
          {
              "line": 11,
              "column": 17
          },
          {
              "line": 11,
              "column": 32
          },
          {
              "line": 11,
              "column": 44
          },
          {
              "line": 11,
              "column": 45
          },
          {
              "line": 11,
              "column": 70
          },
          {
              "line": 12,
              "column": 13
          },
          {
              "line": 12,
              "column": 19
          },
          {
              "line": 12,
              "column": 24
          },
          {
              "line": 12,
              "column": 29
          },
          {
              "line": 12,
              "column": 32
          },
          {
              "line": 12,
              "column": 46
          },
          {
              "line": 13,
              "column": 50
          },
          {
              "line": 13,
              "column": 54
          },
          {
              "line": 13,
              "column": 57
          },
          {
              "line": 13,
              "column": 61
          },
          {
              "line": 13,
              "column": 73
          },
          {
              "line": 14,
              "column": 5
          },
          {
              "line": 14,
              "column": 6
          },
          {
              "line": 14,
              "column": 10
          },
          {
              "line": 14,
              "column": 15
          },
          {
              "line": 14,
              "column": 18
          },
          {
              "line": 14,
              "column": 26
          },
          {
              "line": 14,
              "column": 30
          },
          {
              "line": 14,
              "column": 44
          },
          {
              "line": 14,
              "column": 49
          },
          {
              "line": 14,
              "column": 57
          },
          {
              "line": 15,
              "column": 19
          },
          {
              "line": 15,
              "column": 24
          },
          {
              "line": 15,
              "column": 29
          },
          {
              "line": 15,
              "column": 32
          },
          {
              "line": 18,
              "column": 7
          },
          {
              "line": 18,
              "column": 18
          },
          {
              "line": 18,
              "column": 37
          },
          {
              "line": 18,
              "column": 48
          },
          {
              "line": 20,
              "column": 17
          },
          {
              "line": 21,
              "column": 17
          },
          {
              "line": 21,
              "column": 36
          },
          {
              "line": 21,
              "column": 47
          },
          {
              "line": 21,
              "column": 74
          },
          {
              "line": 21,
              "column": 82
          },
          {
              "line": 22,
              "column": 17
          },
          {
              "line": 22,
              "column": 31
          },
          {
              "line": 22,
              "column": 33
          },
          {
              "line": 22,
              "column": 35
          },
          {
              "line": 22,
              "column": 51
          },
          {
              "line": 23,
              "column": 17
          },
          {
              "line": 23,
              "column": 31
          },
          {
              "line": 23,
              "column": 34
          },
          {
              "line": 23,
              "column": 45
          },
          {
              "line": 23,
              "column": 47
          },
          {
              "line": 23,
              "column": 53
          },
          {
              "line": 23,
              "column": 59
          },
          {
              "line": 24,
              "column": 17
          },
          {
              "line": 24,
              "column": 31
          },
          {
              "line": 24,
              "column": 37
          },
          {
              "line": 24,
              "column": 40
          },
          {
              "line": 24,
              "column": 45
          },
          {
              "line": 24,
              "column": 47
          },
          {
              "line": 24,
              "column": 53
          },
          {
              "line": 24,
              "column": 55
          },
          {
              "line": 24,
              "column": 65
          },
          {
              "line": 25,
              "column": 17
          },
          {
              "line": 25,
              "column": 41
          },
          {
              "line": 25,
              "column": 45
          },
          {
              "line": 26,
              "column": 17
          },
          {
              "line": 27,
              "column": 17
          },
          {
              "line": 27,
              "column": 32
          },
          {
              "line": 27,
              "column": 43
          },
          {
              "line": 28,
              "column": 17
          },
          {
              "line": 28,
              "column": 32
          },
          {
              "line": 30,
              "column": 33
          },
          {
              "line": 31,
              "column": 37
          },
          {
              "line": 34,
              "column": 35
          },
          {
              "line": 34,
              "column": 38
          },
          {
              "line": 36,
              "column": 21
          },
          {
              "line": 38,
              "column": 30
          },
          {
              "line": 39,
              "column": 22
          },
          {
              "line": 40,
              "column": 22
          },
          {
              "line": 42,
              "column": 32
          },
          {
              "line": 44,
              "column": 21
          },
          {
              "line": 51,
              "column": 24
          },
          {
              "line": 51,
              "column": 43
          },
          {
              "line": 51,
              "column": 54
          },
          {
              "line": 51,
              "column": 64
          },
          {
              "line": 51,
              "column": 66
          },
          {
              "line": 51,
              "column": 72
          },
          {
              "line": 51,
              "column": 77
          },
          {
              "line": 53,
              "column": 25
          },
          {
              "line": 54,
              "column": 23
          },
          {
              "line": 55,
              "column": 11
          },
          {
              "line": 55,
              "column": 30
          },
          {
              "line": 55,
              "column": 43
          },
          {
              "line": 55,
              "column": 54
          },
          {
              "line": 55,
              "column": 60
          },
          {
              "line": 55,
              "column": 72
          },
          {
              "line": 57,
              "column": 29
          },
          {
              "line": 59,
              "column": 31
          },
          {
              "line": 59,
              "column": 46
          },
          {
              "line": 59,
              "column": 60
          },
          {
              "line": 60,
              "column": 35
          },
          {
              "line": 60,
              "column": 42
          },
          {
              "line": 60,
              "column": 60
          },
          {
              "line": 63,
              "column": 25
          },
          {
              "line": 64,
              "column": 27
          },
          {
              "line": 64,
              "column": 51
          },
          {
              "line": 65,
              "column": 18
          },
          {
              "line": 65,
              "column": 41
          },
          {
              "line": 65,
              "column": 55
          },
          {
              "line": 65,
              "column": 69
          },
          {
              "line": 67,
              "column": 13
          },
          {
              "line": 67,
              "column": 21
          },
          {
              "line": 67,
              "column": 24
          },
          {
              "line": 67,
              "column": 29
          },
          {
              "line": 67,
              "column": 33
          },
          {
              "line": 67,
              "column": 49
          },
          {
              "line": 67,
              "column": 52
          },
          {
              "line": 67,
              "column": 82
          },
          {
              "line": 67,
              "column": 83
          },
          {
              "line": 68,
              "column": 34
          },
          {
              "line": 68,
              "column": 72
          },
          {
              "line": 68,
              "column": 87
          },
          {
              "line": 68,
              "column": 107
          },
          {
              "line": 69,
              "column": 22
          },
          {
              "line": 70,
              "column": 18
          },
          {
              "line": 70,
              "column": 34
          },
          {
              "line": 71,
              "column": 22
          },
          {
              "line": 71,
              "column": 44
          },
          {
              "line": 71,
              "column": 58
          },
          {
              "line": 73,
              "column": 20
          },
          {
              "line": 76,
              "column": 16
          },
          {
              "line": 77,
              "column": 31
          },
          {
              "line": 78,
              "column": 31
          },
          {
              "line": 78,
              "column": 45
          },
          {
              "line": 79,
              "column": 31
          },
          {
              "line": 79,
              "column": 45
          },
          {
              "line": 80,
              "column": 42
          },
          {
              "line": 81,
              "column": 33
          },
          {
              "line": 81,
              "column": 51
          },
          {
              "line": 82,
              "column": 28
          },
          {
              "line": 82,
              "column": 35
          },
          {
              "line": 83,
              "column": 25
          },
          {
              "line": 83,
              "column": 29
          },
          {
              "line": 84,
              "column": 26
          },
          {
              "line": 84,
              "column": 66
          },
          {
              "line": 84,
              "column": 70
          },
          {
              "line": 84,
              "column": 80
          },
          {
              "line": 86,
              "column": 22
          },
          {
              "line": 86,
              "column": 24
          },
          {
              "line": 86,
              "column": 31
          },
          {
              "line": 87,
              "column": 21
          },
          {
              "line": 87,
              "column": 34
          },
          {
              "line": 87,
              "column": 42
          },
          {
              "line": 87,
              "column": 43
          },
          {
              "line": 87,
              "column": 45
          },
          {
              "line": 87,
              "column": 63
          },
          {
              "line": 89,
              "column": 20
          },
          {
              "line": 89,
              "column": 28
          },
          {
              "line": 89,
              "column": 46
          },
          {
              "line": 89,
              "column": 50
          },
          {
              "line": 89,
              "column": 71
          },
          {
              "line": 89,
              "column": 76
          },
          {
              "line": 92,
              "column": 13
          },
          {
              "line": 92,
              "column": 16
          },
          {
              "line": 92,
              "column": 19
          },
          {
              "line": 92,
              "column": 25
          },
          {
              "line": 93,
              "column": 11
          },
          {
              "line": 93,
              "column": 25
          },
          {
              "line": 93,
              "column": 32
          },
          {
              "line": 94,
              "column": 25
          },
          {
              "line": 94,
              "column": 39
          },
          {
              "line": 94,
              "column": 53
          },
          {
              "line": 94,
              "column": 64
          },
          {
              "line": 94,
              "column": 82
          },
          {
              "line": 94,
              "column": 88
          },
          {
              "line": 95,
              "column": 27
          },
          {
              "line": 95,
              "column": 30
          },
          {
              "line": 95,
              "column": 33
          },
          {
              "line": 95,
              "column": 55
          },
          {
              "line": 95,
              "column": 61
          },
          {
              "line": 95,
              "column": 64
          },
          {
              "line": 95,
              "column": 65
          },
          {
              "line": 95,
              "column": 70
          },
          {
              "line": 95,
              "column": 73
          },
          {
              "line": 96,
              "column": 10
          },
          {
              "line": 96,
              "column": 19
          },
          {
              "line": 99,
              "column": 26
          },
          {
              "line": 99,
              "column": 37
          },
          {
              "line": 99,
              "column": 41
          },
          {
              "line": 99,
              "column": 50
          },
          {
              "line": 100,
              "column": 42
          },
          {
              "line": 100,
              "column": 61
          },
          {
              "line": 100,
              "column": 65
          },
          {
              "line": 100,
              "column": 77
          },
          {
              "line": 101,
              "column": 10
          },
          {
              "line": 101,
              "column": 17
          },
          {
              "line": 101,
              "column": 27
          },
          {
              "line": 101,
              "column": 38
          },
          {
              "line": 101,
              "column": 45
          },
          {
              "line": 101,
              "column": 49
          },
          {
              "line": 101,
              "column": 73
          },
          {
              "line": 101,
              "column": 77
          },
          {
              "line": 104,
              "column": 25
          },
          {
              "line": 104,
              "column": 30
          },
          {
              "line": 104,
              "column": 38
          },
          {
              "line": 105,
              "column": 33
          },
          {
              "line": 105,
              "column": 35
          },
          {
              "line": 105,
              "column": 41
          },
          {
              "line": 105,
              "column": 46
          },
          {
              "line": 105,
              "column": 63
          },
          {
              "line": 105,
              "column": 76
          },
          {
              "line": 106,
              "column": 25
          },
          {
              "line": 106,
              "column": 27
          },
          {
              "line": 106,
              "column": 45
          },
          {
              "line": 106,
              "column": 47
          },
          {
              "line": 107,
              "column": 35
          },
          {
              "line": 108,
              "column": 21
          },
          {
              "line": 108,
              "column": 23
          },
          {
              "line": 108,
              "column": 29
          },
          {
              "line": 108,
              "column": 34
          },
          {
              "line": 108,
              "column": 51
          },
          {
              "line": 108,
              "column": 58
          },
          {
              "line": 108,
              "column": 63
          },
          {
              "line": 108,
              "column": 65
          },
          {
              "line": 110,
              "column": 15
          },
          {
              "line": 110,
              "column": 47
          },
          {
              "line": 110,
              "column": 51
          },
          {
              "line": 110,
              "column": 56
          },
          {
              "line": 110,
              "column": 58
          },
          {
              "line": 111,
              "column": 18
          },
          {
              "line": 111,
              "column": 20
          },
          {
              "line": 112,
              "column": 18
          },
          {
              "line": 112,
              "column": 20
          },
          {
              "line": 112,
              "column": 34
          },
          {
              "line": 112,
              "column": 39
          },
          {
              "line": 113,
              "column": 36
          },
          {
              "line": 113,
              "column": 40
          },
          {
              "line": 113,
              "column": 45
          },
          {
              "line": 113,
              "column": 47
          },
          {
              "line": 113,
              "column": 73
          },
          {
              "line": 118,
              "column": 10
          },
          {
              "line": 118,
              "column": 13
          },
          {
              "line": 118,
              "column": 22
          },
          {
              "line": 118,
              "column": 37
          },
          {
              "line": 118,
              "column": 41
          },
          {
              "line": 118,
              "column": 55
          },
          {
              "line": 118,
              "column": 72
          },
          {
              "line": 120,
              "column": 13
          },
          {
              "line": 120,
              "column": 16
          },
          {
              "line": 120,
              "column": 21
          },
          {
              "line": 120,
              "column": 43
          },
          {
              "line": 120,
              "column": 49
          },
          {
              "line": 120,
              "column": 53
          },
          {
              "line": 120,
              "column": 76
          },
          {
              "line": 120,
              "column": 87
          },
          {
              "line": 121,
              "column": 22
          },
          {
              "line": 121,
              "column": 30
          },
          {
              "line": 121,
              "column": 46
          },
          {
              "line": 123,
              "column": 27
          },
          {
              "line": 123,
              "column": 29
          },
          {
              "line": 123,
              "column": 35
          },
          {
              "line": 123,
              "column": 40
          },
          {
              "line": 123,
              "column": 57
          },
          {
              "line": 123,
              "column": 65
          },
          {
              "line": 123,
              "column": 68
          },
          {
              "line": 123,
              "column": 73
          },
          {
              "line": 124,
              "column": 14
          },
          {
              "line": 124,
              "column": 19
          },
          {
              "line": 124,
              "column": 21
          },
          {
              "line": 124,
              "column": 27
          },
          {
              "line": 124,
              "column": 29
          },
          {
              "line": 124,
              "column": 39
          },
          {
              "line": 124,
              "column": 42
          },
          {
              "line": 124,
              "column": 52
          },
          {
              "line": 127,
              "column": 21
          },
          {
              "line": 127,
              "column": 44
          },
          {
              "line": 127,
              "column": 52
          },
          {
              "line": 127,
              "column": 69
          },
          {
              "line": 127,
              "column": 77
          },
          {
              "line": 128,
              "column": 21
          },
          {
              "line": 128,
              "column": 32
          },
          {
              "line": 128,
              "column": 37
          },
          {
              "line": 128,
              "column": 44
          },
          {
              "line": 129,
              "column": 33
          },
          {
              "line": 129,
              "column": 36
          },
          {
              "line": 129,
              "column": 48
          },
          {
              "line": 131,
              "column": 22
          },
          {
              "line": 131,
              "column": 45
          },
          {
              "line": 132,
              "column": 19
          },
          {
              "line": 132,
              "column": 22
          },
          {
              "line": 132,
              "column": 36
          },
          {
              "line": 133,
              "column": 26
          },
          {
              "line": 133,
              "column": 36
          },
          {
              "line": 135,
              "column": 39
          },
          {
              "line": 135,
              "column": 47
          },
          {
              "line": 136,
              "column": 29
          },
          {
              "line": 136,
              "column": 34
          },
          {
              "line": 136,
              "column": 41
          },
          {
              "line": 138,
              "column": 26
          },
          {
              "line": 138,
              "column": 45
          },
          {
              "line": 139,
              "column": 20
          },
          {
              "line": 140,
              "column": 29
          },
          {
              "line": 140,
              "column": 32
          },
          {
              "line": 140,
              "column": 59
          },
          {
              "line": 141,
              "column": 29
          },
          {
              "line": 141,
              "column": 32
          },
          {
              "line": 141,
              "column": 69
          },
          {
              "line": 141,
              "column": 87
          },
          {
              "line": 142,
              "column": 10
          },
          {
              "line": 142,
              "column": 17
          },
          {
              "line": 142,
              "column": 28
          },
          {
              "line": 142,
              "column": 30
          },
          {
              "line": 142,
              "column": 36
          },
          {
              "line": 142,
              "column": 41
          },
          {
              "line": 142,
              "column": 58
          },
          {
              "line": 142,
              "column": 81
          },
          {
              "line": 142,
              "column": 85
          },
          {
              "line": 142,
              "column": 95
          },
          {
              "line": 145,
              "column": 27
          },
          {
              "line": 145,
              "column": 29
          },
          {
              "line": 145,
              "column": 35
          },
          {
              "line": 145,
              "column": 40
          },
          {
              "line": 145,
              "column": 57
          },
          {
              "line": 145,
              "column": 65
          },
          {
              "line": 145,
              "column": 68
          },
          {
              "line": 145,
              "column": 73
          },
          {
              "line": 146,
              "column": 14
          },
          {
              "line": 146,
              "column": 19
          },
          {
              "line": 146,
              "column": 21
          },
          {
              "line": 146,
              "column": 27
          },
          {
              "line": 146,
              "column": 29
          },
          {
              "line": 146,
              "column": 39
          },
          {
              "line": 146,
              "column": 42
          },
          {
              "line": 146,
              "column": 52
          },
          {
              "line": 149,
              "column": 21
          },
          {
              "line": 149,
              "column": 44
          },
          {
              "line": 149,
              "column": 52
          },
          {
              "line": 149,
              "column": 69
          },
          {
              "line": 149,
              "column": 77
          },
          {
              "line": 150,
              "column": 21
          },
          {
              "line": 150,
              "column": 32
          },
          {
              "line": 150,
              "column": 37
          },
          {
              "line": 150,
              "column": 44
          },
          {
              "line": 151,
              "column": 10
          },
          {
              "line": 151,
              "column": 18
          },
          {
              "line": 151,
              "column": 21
          },
          {
              "line": 151,
              "column": 26
          },
          {
              "line": 152,
              "column": 18
          },
          {
              "line": 152,
              "column": 28
          },
          {
              "line": 155,
              "column": 31
          },
          {
              "line": 155,
              "column": 39
          },
          {
              "line": 156,
              "column": 21
          },
          {
              "line": 156,
              "column": 26
          },
          {
              "line": 156,
              "column": 33
          },
          {
              "line": 161,
              "column": 10
          },
          {
              "line": 161,
              "column": 13
          },
          {
              "line": 161,
              "column": 26
          },
          {
              "line": 161,
              "column": 46
          },
          {
              "line": 163,
              "column": 12
          },
          {
              "line": 163,
              "column": 35
          },
          {
              "line": 163,
              "column": 46
          },
          {
              "line": 163,
              "column": 62
          },
          {
              "line": 163,
              "column": 70
          },
          {
              "line": 163,
              "column": 86
          },
          {
              "line": 165,
              "column": 32
          },
          {
              "line": 165,
              "column": 44
          },
          {
              "line": 165,
              "column": 47
          },
          {
              "line": 165,
              "column": 61
          },
          {
              "line": 166,
              "column": 14
          },
          {
              "line": 166,
              "column": 19
          },
          {
              "line": 166,
              "column": 21
          },
          {
              "line": 166,
              "column": 27
          },
          {
              "line": 166,
              "column": 29
          },
          {
              "line": 166,
              "column": 39
          },
          {
              "line": 166,
              "column": 42
          },
          {
              "line": 166,
              "column": 52
          },
          {
              "line": 168,
              "column": 21
          },
          {
              "line": 168,
              "column": 44
          },
          {
              "line": 168,
              "column": 52
          },
          {
              "line": 168,
              "column": 69
          },
          {
              "line": 168,
              "column": 77
          },
          {
              "line": 169,
              "column": 21
          },
          {
              "line": 169,
              "column": 32
          },
          {
              "line": 169,
              "column": 37
          },
          {
              "line": 169,
              "column": 44
          },
          {
              "line": 172,
              "column": 19
          },
          {
              "line": 172,
              "column": 22
          },
          {
              "line": 172,
              "column": 72
          },
          {
              "line": 172,
              "column": 82
          },
          {
              "line": 172,
              "column": 85
          },
          {
              "line": 172,
              "column": 90
          },
          {
              "line": 173,
              "column": 27
          },
          {
              "line": 173,
              "column": 35
          },
          {
              "line": 174,
              "column": 27
          },
          {
              "line": 174,
              "column": 35
          },
          {
              "line": 174,
              "column": 39
          },
          {
              "line": 174,
              "column": 45
          },
          {
              "line": 174,
              "column": 50
          },
          {
              "line": 174,
              "column": 63
          },
          {
              "line": 174,
              "column": 71
          },
          {
              "line": 174,
              "column": 77
          },
          {
              "line": 174,
              "column": 87
          },
          {
              "line": 176,
              "column": 12
          },
          {
              "line": 176,
              "column": 19
          },
          {
              "line": 176,
              "column": 23
          },
          {
              "line": 176,
              "column": 29
          },
          {
              "line": 176,
              "column": 39
          },
          {
              "line": 176,
              "column": 42
          },
          {
              "line": 176,
              "column": 47
          },
          {
              "line": 176,
              "column": 52
          },
          {
              "line": 176,
              "column": 57
          },
          {
              "line": 177,
              "column": 11
          },
          {
              "line": 177,
              "column": 25
          },
          {
              "line": 177,
              "column": 32
          },
          {
              "line": 178,
              "column": 25
          },
          {
              "line": 178,
              "column": 66
          },
          {
              "line": 178,
              "column": 70
          },
          {
              "line": 179,
              "column": 20
          },
          {
              "line": 179,
              "column": 26
          },
          {
              "line": 179,
              "column": 33
          },
          {
              "line": 179,
              "column": 38
          },
          {
              "line": 179,
              "column": 42
          },
          {
              "line": 179,
              "column": 56
          },
          {
              "line": 179,
              "column": 66
          },
          {
              "line": 179,
              "column": 71
          },
          {
              "line": 179,
              "column": 78
          },
          {
              "line": 179,
              "column": 81
          },
          {
              "line": 181,
              "column": 17
          },
          {
              "line": 181,
              "column": 22
          },
          {
              "line": 181,
              "column": 29
          },
          {
              "line": 182,
              "column": 22
          },
          {
              "line": 182,
              "column": 26
          },
          {
              "line": 182,
              "column": 34
          },
          {
              "line": 182,
              "column": 43
          },
          {
              "line": 182,
              "column": 47
          },
          {
              "line": 182,
              "column": 51
          },
          {
              "line": 182,
              "column": 56
          },
          {
              "line": 182,
              "column": 60
          },
          {
              "line": 182,
              "column": 67
          },
          {
              "line": 182,
              "column": 72
          },
          {
              "line": 182,
              "column": 83
          },
          {
              "line": 182,
              "column": 89
          },
          {
              "line": 182,
              "column": 97
          },
          {
              "line": 183,
              "column": 26
          },
          {
              "line": 183,
              "column": 32
          },
          {
              "line": 183,
              "column": 36
          },
          {
              "line": 183,
              "column": 41
          },
          {
              "line": 183,
              "column": 42
          },
          {
              "line": 183,
              "column": 50
          },
          {
              "line": 183,
              "column": 56
          },
          {
              "line": 183,
              "column": 62
          },
          {
              "line": 183,
              "column": 86
          },
          {
              "line": 184,
              "column": 21
          },
          {
              "line": 184,
              "column": 26
          },
          {
              "line": 184,
              "column": 37
          },
          {
              "line": 185,
              "column": 33
          },
          {
              "line": 185,
              "column": 38
          },
          {
              "line": 185,
              "column": 43
          },
          {
              "line": 186,
              "column": 31
          },
          {
              "line": 186,
              "column": 42
          },
          {
              "line": 187,
              "column": 25
          },
          {
              "line": 187,
              "column": 30
          },
          {
              "line": 187,
              "column": 37
          },
          {
              "line": 190,
              "column": 10
          },
          {
              "line": 190,
              "column": 17
          },
          {
              "line": 190,
              "column": 33
          },
          {
              "line": 190,
              "column": 46
          },
          {
              "line": 190,
              "column": 50
          },
          {
              "line": 194,
              "column": 28
          },
          {
              "line": 194,
              "column": 32
          },
          {
              "line": 194,
              "column": 45
          },
          {
              "line": 195,
              "column": 11
          },
          {
              "line": 195,
              "column": 23
          },
          {
              "line": 196,
              "column": 10
          },
          {
              "line": 196,
              "column": 78
          },
          {
              "line": 196,
              "column": 97
          },
          {
              "line": 196,
              "column": 107
          },
          {
              "line": 196,
              "column": 121
          },
          {
              "line": 196,
              "column": 127
          },
          {
              "line": 196,
              "column": 135
          },
          {
              "line": 197,
              "column": 9
          },
          {
              "line": 197,
              "column": 11
          },
          {
              "line": 197,
              "column": 30
          },
          {
              "line": 197,
              "column": 35
          },
          {
              "line": 199,
              "column": 19
          },
          {
              "line": 199,
              "column": 24
          },
          {
              "line": 199,
              "column": 29
          },
          {
              "line": 199,
              "column": 33
          },
          {
              "line": 199,
              "column": 38
          },
          {
              "line": 199,
              "column": 47
          },
          {
              "line": 199,
              "column": 53
          },
          {
              "line": 199,
              "column": 60
          },
          {
              "line": 200,
              "column": 17
          },
          {
              "line": 200,
              "column": 28
          },
          {
              "line": 200,
              "column": 37
          },
          {
              "line": 200,
              "column": 42
          },
          {
              "line": 200,
              "column": 61
          },
          {
              "line": 200,
              "column": 66
          },
          {
              "line": 200,
              "column": 79
          },
          {
              "line": 200,
              "column": 83
          },
          {
              "line": 200,
              "column": 91
          },
          {
              "line": 200,
              "column": 96
          },
          {
              "line": 201,
              "column": 24
          },
          {
              "line": 202,
              "column": 19
          },
          {
              "line": 202,
              "column": 24
          },
          {
              "line": 202,
              "column": 31
          },
          {
              "line": 202,
              "column": 44
          },
          {
              "line": 202,
              "column": 49
          },
          {
              "line": 202,
              "column": 56
          },
          {
              "line": 202,
              "column": 62
          },
          {
              "line": 202,
              "column": 68
          },
          {
              "line": 202,
              "column": 76
          },
          {
              "line": 202,
              "column": 83
          },
          {
              "line": 203,
              "column": 10
          },
          {
              "line": 203,
              "column": 19
          },
          {
              "line": 203,
              "column": 33
          },
          {
              "line": 203,
              "column": 41
          },
          {
              "line": 203,
              "column": 49
          },
          {
              "line": 203,
              "column": 54
          },
          {
              "line": 203,
              "column": 59
          },
          {
              "line": 205,
              "column": 16
          },
          {
              "line": 205,
              "column": 28
          },
          {
              "line": 205,
              "column": 33
          },
          {
              "line": 205,
              "column": 44
          },
          {
              "line": 206,
              "column": 22
          },
          {
              "line": 206,
              "column": 27
          },
          {
              "line": 206,
              "column": 32
          },
          {
              "line": 206,
              "column": 42
          },
          {
              "line": 206,
              "column": 53
          },
          {
              "line": 206,
              "column": 62
          },
          {
              "line": 206,
              "column": 75
          },
          {
              "line": 206,
              "column": 80
          },
          {
              "line": 206,
              "column": 87
          },
          {
              "line": 207,
              "column": 23
          },
          {
              "line": 207,
              "column": 31
          },
          {
              "line": 207,
              "column": 35
          },
          {
              "line": 209,
              "column": 15
          },
          {
              "line": 209,
              "column": 23
          },
          {
              "line": 209,
              "column": 34
          },
          {
              "line": 210,
              "column": 25
          },
          {
              "line": 210,
              "column": 38
          },
          {
              "line": 210,
              "column": 54
          },
          {
              "line": 210,
              "column": 63
          },
          {
              "line": 210,
              "column": 71
          },
          {
              "line": 210,
              "column": 82
          },
          {
              "line": 210,
              "column": 88
          },
          {
              "line": 210,
              "column": 93
          },
          {
              "line": 210,
              "column": 98
          },
          {
              "line": 211,
              "column": 16
          },
          {
              "line": 211,
              "column": 27
          },
          {
              "line": 212,
              "column": 19
          },
          {
              "line": 212,
              "column": 30
          },
          {
              "line": 212,
              "column": 39
          },
          {
              "line": 212,
              "column": 50
          },
          {
              "line": 212,
              "column": 58
          },
          {
              "line": 212,
              "column": 69
          },
          {
              "line": 212,
              "column": 75
          },
          {
              "line": 212,
              "column": 86
          },
          {
              "line": 212,
              "column": 95
          },
          {
              "line": 213,
              "column": 20
          },
          {
              "line": 214,
              "column": 25
          },
          {
              "line": 214,
              "column": 38
          },
          {
              "line": 214,
              "column": 54
          },
          {
              "line": 214,
              "column": 68
          },
          {
              "line": 215,
              "column": 29
          },
          {
              "line": 215,
              "column": 34
          },
          {
              "line": 215,
              "column": 41
          },
          {
              "line": 216,
              "column": 21
          },
          {
              "line": 216,
              "column": 34
          },
          {
              "line": 216,
              "column": 49
          },
          {
              "line": 216,
              "column": 52
          },
          {
              "line": 216,
              "column": 63
          },
          {
              "line": 216,
              "column": 67
          },
          {
              "line": 216,
              "column": 78
          },
          {
              "line": 216,
              "column": 87
          },
          {
              "line": 217,
              "column": 14
          },
          {
              "line": 217,
              "column": 23
          },
          {
              "line": 218,
              "column": 11
          },
          {
              "line": 218,
              "column": 14
          },
          {
              "line": 220,
              "column": 33
          },
          {
              "line": 220,
              "column": 38
          },
          {
              "line": 220,
              "column": 43
          },
          {
              "line": 220,
              "column": 52
          },
          {
              "line": 220,
              "column": 60
          },
          {
              "line": 220,
              "column": 68
          },
          {
              "line": 220,
              "column": 73
          },
          {
              "line": 220,
              "column": 80
          },
          {
              "line": 220,
              "column": 86
          },
          {
              "line": 220,
              "column": 97
          },
          {
              "line": 221,
              "column": 52
          },
          {
              "line": 221,
              "column": 58
          },
          {
              "line": 222,
              "column": 44
          },
          {
              "line": 222,
              "column": 46
          },
          {
              "line": 222,
              "column": 50
          },
          {
              "line": 222,
              "column": 68
          },
          {
              "line": 222,
              "column": 71
          },
          {
              "line": 222,
              "column": 83
          },
          {
              "line": 222,
              "column": 91
          },
          {
              "line": 222,
              "column": 95
          },
          {
              "line": 222,
              "column": 104
          },
          {
              "line": 223,
              "column": 53
          },
          {
              "line": 223,
              "column": 54
          },
          {
              "line": 223,
              "column": 58
          },
          {
              "line": 223,
              "column": 65
          },
          {
              "line": 223,
              "column": 67
          },
          {
              "line": 223,
              "column": 79
          },
          {
              "line": 223,
              "column": 83
          },
          {
              "line": 223,
              "column": 94
          },
          {
              "line": 223,
              "column": 100
          },
          {
              "line": 224,
              "column": 33
          },
          {
              "line": 224,
              "column": 43
          },
          {
              "line": 224,
              "column": 54
          },
          {
              "line": 224,
              "column": 67
          },
          {
              "line": 224,
              "column": 82
          },
          {
              "line": 224,
              "column": 87
          },
          {
              "line": 224,
              "column": 92
          },
          {
              "line": 224,
              "column": 102
          },
          {
              "line": 224,
              "column": 113
          },
          {
              "line": 224,
              "column": 122
          },
          {
              "line": 225,
              "column": 34
          },
          {
              "line": 225,
              "column": 42
          },
          {
              "line": 225,
              "column": 53
          },
          {
              "line": 225,
              "column": 65
          },
          {
              "line": 225,
              "column": 70
          },
          {
              "line": 225,
              "column": 77
          },
          {
              "line": 226,
              "column": 23
          },
          {
              "line": 226,
              "column": 34
          },
          {
              "line": 227,
              "column": 27
          },
          {
              "line": 228,
              "column": 25
          },
          {
              "line": 228,
              "column": 30
          },
          {
              "line": 228,
              "column": 35
          },
          {
              "line": 229,
              "column": 23
          },
          {
              "line": 229,
              "column": 34
          },
          {
              "line": 229,
              "column": 43
          },
          {
              "line": 230,
              "column": 22
          },
          {
              "line": 230,
              "column": 30
          },
          {
              "line": 230,
              "column": 41
          },
          {
              "line": 231,
              "column": 25
          },
          {
              "line": 231,
              "column": 30
          },
          {
              "line": 231,
              "column": 37
          },
          {
              "line": 232,
              "column": 14
          },
          {
              "line": 232,
              "column": 24
          },
          {
              "line": 236,
              "column": 41
          },
          {
              "line": 236,
              "column": 44
          },
          {
              "line": 237,
              "column": 90
          },
          {
              "line": 237,
              "column": 94
          },
          {
              "line": 239,
              "column": 12
          },
          {
              "line": 239,
              "column": 17
          },
          {
              "line": 239,
              "column": 25
          },
          {
              "line": 239,
              "column": 29
          },
          {
              "line": 239,
              "column": 33
          },
          {
              "line": 239,
              "column": 42
          },
          {
              "line": 239,
              "column": 45
          },
          {
              "line": 239,
              "column": 49
          },
          {
              "line": 239,
              "column": 58
          },
          {
              "line": 239,
              "column": 63
          },
          {
              "line": 239,
              "column": 68
          },
          {
              "line": 239,
              "column": 74
          },
          {
              "line": 239,
              "column": 77
          },
          {
              "line": 239,
              "column": 80
          },
          {
              "line": 240,
              "column": 10
          },
          {
              "line": 241,
              "column": 28
          },
          {
              "line": 241,
              "column": 32
          },
          {
              "line": 242,
              "column": 19
          },
          {
              "line": 242,
              "column": 22
          },
          {
              "line": 242,
              "column": 25
          },
          {
              "line": 242,
              "column": 28
          },
          {
              "line": 242,
              "column": 37
          },
          {
              "line": 245,
              "column": 11
          },
          {
              "line": 245,
              "column": 37
          },
          {
              "line": 245,
              "column": 41
          },
          {
              "line": 245,
              "column": 44
          },
          {
              "line": 246,
              "column": 26
          },
          {
              "line": 246,
              "column": 43
          },
          {
              "line": 248,
              "column": 14
          },
          {
              "line": 248,
              "column": 25
          },
          {
              "line": 248,
              "column": 28
          },
          {
              "line": 248,
              "column": 49
          },
          {
              "line": 249,
              "column": 28
          },
          {
              "line": 249,
              "column": 35
          },
          {
              "line": 250,
              "column": 25
          },
          {
              "line": 250,
              "column": 29
          },
          {
              "line": 250,
              "column": 41
          },
          {
              "line": 250,
              "column": 52
          },
          {
              "line": 251,
              "column": 20
          },
          {
              "line": 251,
              "column": 34
          },
          {
              "line": 251,
              "column": 38
          },
          {
              "line": 251,
              "column": 54
          },
          {
              "line": 251,
              "column": 78
          },
          {
              "line": 251,
              "column": 83
          },
          {
              "line": 255,
              "column": 11
          },
          {
              "line": 255,
              "column": 37
          },
          {
              "line": 255,
              "column": 41
          },
          {
              "line": 255,
              "column": 44
          },
          {
              "line": 256,
              "column": 26
          },
          {
              "line": 256,
              "column": 43
          },
          {
              "line": 258,
              "column": 33
          },
          {
              "line": 258,
              "column": 36
          },
          {
              "line": 258,
              "column": 46
          },
          {
              "line": 260,
              "column": 14
          },
          {
              "line": 260,
              "column": 25
          },
          {
              "line": 260,
              "column": 28
          },
          {
              "line": 261,
              "column": 28
          },
          {
              "line": 261,
              "column": 40
          },
          {
              "line": 261,
              "column": 73
          },
          {
              "line": 262,
              "column": 28
          },
          {
              "line": 262,
              "column": 35
          },
          {
              "line": 263,
              "column": 25
          },
          {
              "line": 263,
              "column": 29
          },
          {
              "line": 263,
              "column": 41
          },
          {
              "line": 263,
              "column": 52
          },
          {
              "line": 264,
              "column": 20
          },
          {
              "line": 264,
              "column": 34
          },
          {
              "line": 264,
              "column": 38
          },
          {
              "line": 264,
              "column": 54
          },
          {
              "line": 264,
              "column": 78
          },
          {
              "line": 264,
              "column": 83
          },
          {
              "line": 268,
              "column": 52
          },
          {
              "line": 268,
              "column": 56
          },
          {
              "line": 269,
              "column": 77
          },
          {
              "line": 269,
              "column": 96
          },
          {
              "line": 271,
              "column": 61
          },
          {
              "line": 271,
              "column": 64
          },
          {
              "line": 271,
              "column": 67
          },
          {
              "line": 271,
              "column": 91
          },
          {
              "line": 272,
              "column": 17
          },
          {
              "line": 272,
              "column": 34
          },
          {
              "line": 272,
              "column": 53
          },
          {
              "line": 272,
              "column": 60
          },
          {
              "line": 272,
              "column": 93
          },
          {
              "line": 273,
              "column": 26
          },
          {
              "line": 273,
              "column": 34
          },
          {
              "line": 273,
              "column": 37
          },
          {
              "line": 273,
              "column": 45
          },
          {
              "line": 273,
              "column": 66
          },
          {
              "line": 273,
              "column": 69
          },
          {
              "line": 273,
              "column": 71
          },
          {
              "line": 273,
              "column": 74
          },
          {
              "line": 273,
              "column": 80
          },
          {
              "line": 273,
              "column": 87
          },
          {
              "line": 274,
              "column": 17
          },
          {
              "line": 275,
              "column": 18
          },
          {
              "line": 275,
              "column": 25
          },
          {
              "line": 275,
              "column": 54
          },
          {
              "line": 275,
              "column": 62
          },
          {
              "line": 275,
              "column": 78
          },
          {
              "line": 276,
              "column": 34
          },
          {
              "line": 277,
              "column": 30
          },
          {
              "line": 277,
              "column": 53
          },
          {
              "line": 277,
              "column": 82
          },
          {
              "line": 277,
              "column": 85
          },
          {
              "line": 277,
              "column": 88
          },
          {
              "line": 278,
              "column": 34
          },
          {
              "line": 279,
              "column": 58
          },
          {
              "line": 279,
              "column": 69
          },
          {
              "line": 282,
              "column": 28
          },
          {
              "line": 282,
              "column": 35
          },
          {
              "line": 283,
              "column": 21
          },
          {
              "line": 287,
              "column": 13
          },
          {
              "line": 288,
              "column": 24
          },
          {
              "line": 288,
              "column": 26
          },
          {
              "line": 288,
              "column": 32
          },
          {
              "line": 288,
              "column": 38
          },
          {
              "line": 288,
              "column": 51
          },
          {
              "line": 288,
              "column": 54
          },
          {
              "line": 288,
              "column": 60
          },
          {
              "line": 288,
              "column": 71
          },
          {
              "line": 288,
              "column": 76
          },
          {
              "line": 288,
              "column": 82
          },
          {
              "line": 288,
              "column": 94
          },
          {
              "line": 289,
              "column": 21
          },
          {
              "line": 289,
              "column": 44
          },
          {
              "line": 290,
              "column": 21
          },
          {
              "line": 290,
              "column": 25
          },
          {
              "line": 291,
              "column": 18
          },
          {
              "line": 291,
              "column": 21
          },
          {
              "line": 292,
              "column": 17
          },
          {
              "line": 292,
              "column": 24
          },
          {
              "line": 293,
              "column": 21
          },
          {
              "line": 293,
              "column": 34
          },
          {
              "line": 293,
              "column": 50
          },
          {
              "line": 293,
              "column": 71
          },
          {
              "line": 294,
              "column": 25
          },
          {
              "line": 297,
              "column": 24
          },
          {
              "line": 297,
              "column": 27
          },
          {
              "line": 297,
              "column": 33
          },
          {
              "line": 298,
              "column": 32
          },
          {
              "line": 298,
              "column": 35
          },
          {
              "line": 298,
              "column": 41
          },
          {
              "line": 298,
              "column": 60
          },
          {
              "line": 298,
              "column": 73
          },
          {
              "line": 300,
              "column": 18
          },
          {
              "line": 303,
              "column": 14
          },
          {
              "line": 303,
              "column": 30
          },
          {
              "line": 303,
              "column": 33
          },
          {
              "line": 304,
              "column": 25
          },
          {
              "line": 304,
              "column": 38
          },
          {
              "line": 304,
              "column": 44
          },
          {
              "line": 304,
              "column": 63
          },
          {
              "line": 304,
              "column": 75
          },
          {
              "line": 306,
              "column": 21
          },
          {
              "line": 306,
              "column": 28
          },
          {
              "line": 307,
              "column": 20
          },
          {
              "line": 307,
              "column": 28
          },
          {
              "line": 307,
              "column": 40
          },
          {
              "line": 307,
              "column": 52
          },
          {
              "line": 307,
              "column": 58
          },
          {
              "line": 307,
              "column": 65
          },
          {
              "line": 307,
              "column": 68
          },
          {
              "line": 307,
              "column": 74
          },
          {
              "line": 307,
              "column": 90
          },
          {
              "line": 311,
              "column": 11
          },
          {
              "line": 311,
              "column": 33
          },
          {
              "line": 311,
              "column": 46
          },
          {
              "line": 311,
              "column": 54
          },
          {
              "line": 311,
              "column": 55
          },
          {
              "line": 311,
              "column": 57
          },
          {
              "line": 311,
              "column": 85
          },
          {
              "line": 311,
              "column": 96
          },
          {
              "line": 312,
              "column": 25
          },
          {
              "line": 313,
              "column": 19
          },
          {
              "line": 313,
              "column": 32
          },
          {
              "line": 314,
              "column": 14
          },
          {
              "line": 314,
              "column": 30
          },
          {
              "line": 314,
              "column": 58
          },
          {
              "line": 314,
              "column": 63
          },
          {
              "line": 314,
              "column": 68
          },
          {
              "line": 314,
              "column": 71
          },
          {
              "line": 314,
              "column": 94
          },
          {
              "line": 315,
              "column": 13
          },
          {
              "line": 316,
              "column": 33
          },
          {
              "line": 318,
              "column": 19
          },
          {
              "line": 318,
              "column": 43
          },
          {
              "line": 318,
              "column": 51
          },
          {
              "line": 318,
              "column": 62
          },
          {
              "line": 319,
              "column": 20
          },
          {
              "line": 319,
              "column": 28
          },
          {
              "line": 321,
              "column": 32
          },
          {
              "line": 321,
              "column": 37
          },
          {
              "line": 321,
              "column": 50
          },
          {
              "line": 321,
              "column": 68
          },
          {
              "line": 321,
              "column": 78
          },
          {
              "line": 321,
              "column": 83
          },
          {
              "line": 321,
              "column": 96
          },
          {
              "line": 322,
              "column": 35
          },
          {
              "line": 322,
              "column": 58
          },
          {
              "line": 323,
              "column": 25
          }
      ],
      "old_name": "e",
      "new_name": "ex",
      "ctx": {
          "symbolName": "e",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "RocksDBException",
          "scopeHint": "in openDB(...)",
          "filePath": "RocksDBOperationUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "              Preconditions.checkNotNull(dbOptions),\n                            Preconditions.checkNotNull(path),\n                            columnFamilyDescriptors,\n                            stateColumnFamilyHandles);\n        } catch (RocksDBException e) {\n            IOUtils.closeQuietly(columnFamilyOptions);\n            columnFamilyDescriptors.forEach((cfd) -> IOUtils.closeQuietly(cfd.getOptions()));\n\n            // improve error reporting on Windows\n            throwExceptionIfPathLeng",
          "conflictNames": [
              "path",
              "stateColumnFamilyDescriptors",
              "stateColumnFamilyHandles",
              "columnFamilyOptions",
              "dbOptions",
              "columnFamilyDescriptors",
              "dbRef"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/5495a96a38663dc04753cb6db0c100aa2bc7d297^1/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBIncrementalCheckpointUtils.java",
      "locators": [
          {
              "line": 239,
              "column": 11
          },
          {
              "line": 245,
              "column": 17
          },
          {
              "line": 246,
              "column": 17
          },
          {
              "line": 251,
              "column": 16
          }
      ],
      "old_name": "bestStateHandle",
      "new_name": "bestHandlePos",
      "ctx": {
          "symbolName": "bestStateHandle",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "T",
          "scopeHint": "in chooseTheBestStateHandleForInitial(...)",
          "filePath": "RocksDBIncrementalCheckpointUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Choose the best state handle according to the {@link #stateHandleEvaluator(KeyedStateHandle,\n     * KeyGroupRange, double)} to init the initial db.\n     *\n     * @param restoreStateHandles The candidate state handles.\n     * @param targetKeyGroupRange The target key group range.\n     * @return The best candidate or null if no candidate was a good fit.\n     */\n    @Nullable\n    public static <T extends KeyedStateHandle> T chooseTheBestStateHandleForInitial(\n            @Nonnull Collection<T> restoreStateHandles,\n            @Nonnull KeyGroupRange targetKeyGroupRange,\n            double overlapFractionThreshold) {\n\n        T bestStateHandle = null;\n        Score bestScore = Score.MIN;\n        for (T rawStateHandle : restoreStateHandles) {\n            Score handleScore =\n                    stateHandleEvaluator(\n                            rawStateHandle, targetKeyGroupRange, overlapFractionThreshold);\n            if (bestStateHandle == null || handleScore.compareTo(bestScore) > 0) {\n                bestStateHandle = rawStateHandle;\n                bestScore = handleScore;\n            }\n        }\n\n        return bestStateHandle;\n    }",
          "conflictNames": [
              "restoreStateHandles",
              "targetKeyGroupRange",
              "overlapFractionThreshold",
              "bestScore",
              "handleScore"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/54f037f9b2f08bd958d02eac2ffd018919b3f43e^1/flink-runtime/src/main/java/org/apache/flink/runtime/state/TaskExecutorFileMergingManager.java",
      "locators": [
          {
              "line": 56,
              "column": 58
          },
          {
              "line": 67,
              "column": 14
          },
          {
              "line": 77,
              "column": 49
          },
          {
              "line": 94,
              "column": 40
          },
          {
              "line": 95,
              "column": 21
          },
          {
              "line": 96,
              "column": 17
          },
          {
              "line": 114,
              "column": 17
          },
          {
              "line": 122,
              "column": 17
          },
          {
              "line": 122,
              "column": 62
          },
          {
              "line": 125,
              "column": 20
          },
          {
              "line": 140,
              "column": 25
          },
          {
              "line": 157,
              "column": 31
          },
          {
              "line": 163,
              "column": 13
          }
      ],
      "old_name": "fileMergingSnapshotManager",
      "new_name": "fileMergingSnapshotManagerAndRetainedExecutions",
      "ctx": {
          "symbolName": "fileMergingSnapshotManager",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "FileMergingSnapshotManager",
          "scopeHint": "in fileMergingSnapshotManagerForJob(...)",
          "filePath": "TaskExecutorFileMergingManager.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Initialize file merging snapshot manager for each job according configurations when {@link\n     * org.apache.flink.runtime.taskexecutor.TaskExecutor#submitTask}.\n     */\n    public @Nullable FileMergingSnapshotManager fileMergingSnapshotManagerForJob(\n            @Nonnull JobID jobId,\n            Configuration clusterConfiguration,\n            Configuration jobConfiguration) {\n        boolean mergingEnabled =\n                jobConfiguration\n                        .getOptional(FILE_MERGING_ENABLED)\n                        .orElse(clusterConfiguration.get(FILE_MERGING_ENABLED));\n        synchronized (lock) {\n            if (closed) {\n                throw new IllegalStateException(\n                        \"TaskExecutorFileMergingManager is already closed and cannot \"\n                                + \"register a new FileMergingSnapshotManager.\");\n            }\n            if (!mergingEnabled) {\n                return null;\n            }\n            FileMergingSnapshotManager fileMergingSnapshotManager =\n                    fileMergingSnapshotManagerByJobId.get(jobId);\n            if (fileMergingSnapshotManager == null) {\n                FileMergingType fileMergingType =\n                        jobConfiguration\n                                        .getOptional(FILE_MERGING_ACROSS_BOUNDARY)\n                                        .orElse(\n                                                clusterConfiguration.get(\n                                                        FILE_MERGING_ACROSS_BOUNDARY))\n                                ? FileMergingType.MERGE_ACROSS_CHECKPOINT\n                                : FileMergingType.MERGE_WITHIN_CHECKPOINT;\n                MemorySize maxFileSize =\n                        jobConfiguration\n                                .getOptional(FILE_MERGING_MAX_FILE_SIZE)\n                                .orElse(clusterConfiguration.get(FILE_MERGING_MAX_FILE_SIZE));\n                Boolean usingBlockingPool =\n                        jobConfiguration\n                                .getOptional(FILE_MERGING_POOL_BLOCKING)\n                                .orElse(clusterConfiguration.get(FILE_MERGING_POOL_BLOCKING));\n\n                fileMergingSnapshotManager =\n                        new FileMergingSnapshotManagerBuilder(jobId.toString(), fileMergingType)\n                                .setMaxFileSize(maxFileSize.getBytes())\n                                .setFilePoolType(\n                                        usingBlockingPool\n                                                ? PhysicalFilePool.Type.BLOCKING\n                                                : PhysicalFilePool.Type.NON_BLOCKING)\n                                .build();\n                fileMergingSnapshotManagerByJobId.put(jobId, fileMergingSnapshotManager);\n                LOG.info(\"Registered new file merging snapshot manager for job {}.\", jobId);\n            }\n            return fileMergingSnapshotManager;\n        }\n    }",
          "conflictNames": [
              "jobId",
              "clusterConfiguration",
              "jobConfiguration",
              "mergingEnabled",
              "fileMergingType",
              "maxFileSize",
              "usingBlockingPool"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/554810abbbd44a656a446d051b3dd199b0df9055^1/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendTestBase.java",
      "locators": [
          {
              "line": 153,
              "column": 72
          },
          {
              "line": 184,
              "column": 28
          },
          {
              "line": 227,
              "column": 44
          },
          {
              "line": 242,
              "column": 16
          },
          {
              "line": 319,
              "column": 50
          },
          {
              "line": 322,
              "column": 57
          },
          {
              "line": 324,
              "column": 34
          },
          {
              "line": 325,
              "column": 13
          },
          {
              "line": 341,
              "column": 50
          },
          {
              "line": 345,
              "column": 21
          },
          {
              "line": 390,
              "column": 34
          },
          {
              "line": 391,
              "column": 13
          },
          {
              "line": 400,
              "column": 50
          },
          {
              "line": 405,
              "column": 21
          },
          {
              "line": 411,
              "column": 17
          },
          {
              "line": 417,
              "column": 21
          },
          {
              "line": 425,
              "column": 17
          },
          {
              "line": 430,
              "column": 47
          },
          {
              "line": 443,
              "column": 47
          },
          {
              "line": 457,
              "column": 34
          },
          {
              "line": 458,
              "column": 13
          },
          {
              "line": 466,
              "column": 50
          },
          {
              "line": 471,
              "column": 21
          },
          {
              "line": 478,
              "column": 21
          },
          {
              "line": 484,
              "column": 17
          },
          {
              "line": 489,
              "column": 59
          },
          {
              "line": 505,
              "column": 34
          },
          {
              "line": 506,
              "column": 13
          },
          {
              "line": 515,
              "column": 50
          },
          {
              "line": 533,
              "column": 21
          },
          {
              "line": 540,
              "column": 13
          },
          {
              "line": 543,
              "column": 20
          },
          {
              "line": 556,
              "column": 20
          },
          {
              "line": 556,
              "column": 74
          },
          {
              "line": 558,
              "column": 25
          },
          {
              "line": 576,
              "column": 34
          },
          {
              "line": 577,
              "column": 13
          },
          {
              "line": 586,
              "column": 50
          },
          {
              "line": 606,
              "column": 21
          },
          {
              "line": 614,
              "column": 13
          },
          {
              "line": 617,
              "column": 20
          },
          {
              "line": 630,
              "column": 20
          },
          {
              "line": 630,
              "column": 74
          },
          {
              "line": 632,
              "column": 25
          },
          {
              "line": 650,
              "column": 34
          },
          {
              "line": 651,
              "column": 13
          },
          {
              "line": 670,
              "column": 50
          },
          {
              "line": 674,
              "column": 21
          },
          {
              "line": 681,
              "column": 13
          },
          {
              "line": 684,
              "column": 20
          },
          {
              "line": 697,
              "column": 20
          },
          {
              "line": 697,
              "column": 74
          },
          {
              "line": 699,
              "column": 25
          },
          {
              "line": 717,
              "column": 34
          },
          {
              "line": 718,
              "column": 13
          },
          {
              "line": 739,
              "column": 50
          },
          {
              "line": 743,
              "column": 21
          },
          {
              "line": 751,
              "column": 13
          },
          {
              "line": 754,
              "column": 20
          },
          {
              "line": 767,
              "column": 20
          },
          {
              "line": 767,
              "column": 74
          },
          {
              "line": 769,
              "column": 25
          },
          {
              "line": 787,
              "column": 34
          },
          {
              "line": 788,
              "column": 13
          },
          {
              "line": 812,
              "column": 50
          },
          {
              "line": 816,
              "column": 21
          },
          {
              "line": 824,
              "column": 13
          },
          {
              "line": 827,
              "column": 13
          },
          {
              "line": 832,
              "column": 29
          },
          {
              "line": 839,
              "column": 34
          },
          {
              "line": 840,
              "column": 13
          },
          {
              "line": 847,
              "column": 13
          },
          {
              "line": 852,
              "column": 21
          },
          {
              "line": 854,
              "column": 13
          },
          {
              "line": 857,
              "column": 13
          },
          {
              "line": 860,
              "column": 34
          },
          {
              "line": 861,
              "column": 13
          },
          {
              "line": 882,
              "column": 50
          },
          {
              "line": 894,
              "column": 21
          },
          {
              "line": 901,
              "column": 13
          },
          {
              "line": 904,
              "column": 13
          },
          {
              "line": 909,
              "column": 29
          },
          {
              "line": 916,
              "column": 13
          },
          {
              "line": 926,
              "column": 13
          },
          {
              "line": 932,
              "column": 21
          },
          {
              "line": 935,
              "column": 13
          },
          {
              "line": 937,
              "column": 37
          },
          {
              "line": 942,
              "column": 29
          },
          {
              "line": 951,
              "column": 13
          },
          {
              "line": 969,
              "column": 22
          },
          {
              "line": 969,
              "column": 83
          },
          {
              "line": 971,
              "column": 13
          },
          {
              "line": 974,
              "column": 21
          },
          {
              "line": 977,
              "column": 13
          },
          {
              "line": 978,
              "column": 22
          },
          {
              "line": 984,
              "column": 34
          },
          {
              "line": 985,
              "column": 13
          },
          {
              "line": 1006,
              "column": 50
          },
          {
              "line": 1009,
              "column": 13
          },
          {
              "line": 1019,
              "column": 21
          },
          {
              "line": 1026,
              "column": 13
          },
          {
              "line": 1029,
              "column": 13
          },
          {
              "line": 1034,
              "column": 29
          },
          {
              "line": 1041,
              "column": 13
          },
          {
              "line": 1049,
              "column": 13
          },
          {
              "line": 1055,
              "column": 21
          },
          {
              "line": 1058,
              "column": 13
          },
          {
              "line": 1060,
              "column": 37
          },
          {
              "line": 1065,
              "column": 29
          },
          {
              "line": 1074,
              "column": 13
          },
          {
              "line": 1090,
              "column": 22
          },
          {
              "line": 1090,
              "column": 83
          },
          {
              "line": 1092,
              "column": 13
          },
          {
              "line": 1095,
              "column": 21
          },
          {
              "line": 1098,
              "column": 13
          },
          {
              "line": 1099,
              "column": 22
          },
          {
              "line": 1103,
              "column": 17
          },
          {
              "line": 1104,
              "column": 17
          },
          {
              "line": 1119,
              "column": 50
          },
          {
              "line": 1132,
              "column": 21
          },
          {
              "line": 1153,
              "column": 13
          },
          {
              "line": 1161,
              "column": 13
          },
          {
              "line": 1171,
              "column": 29
          },
          {
              "line": 1178,
              "column": 13
          },
          {
              "line": 1190,
              "column": 13
          },
          {
              "line": 1196,
              "column": 21
          },
          {
              "line": 1214,
              "column": 13
          },
          {
              "line": 1216,
              "column": 37
          },
          {
              "line": 1224,
              "column": 27
          },
          {
              "line": 1224,
              "column": 80
          },
          {
              "line": 1226,
              "column": 21
          },
          {
              "line": 1235,
              "column": 13
          },
          {
              "line": 1248,
              "column": 50
          },
          {
              "line": 1261,
              "column": 21
          },
          {
              "line": 1267,
              "column": 13
          },
          {
              "line": 1275,
              "column": 13
          },
          {
              "line": 1285,
              "column": 29
          },
          {
              "line": 1292,
              "column": 13
          },
          {
              "line": 1304,
              "column": 13
          },
          {
              "line": 1310,
              "column": 21
          },
          {
              "line": 1313,
              "column": 13
          },
          {
              "line": 1315,
              "column": 37
          },
          {
              "line": 1323,
              "column": 27
          },
          {
              "line": 1323,
              "column": 80
          },
          {
              "line": 1325,
              "column": 21
          },
          {
              "line": 1334,
              "column": 13
          },
          {
              "line": 1349,
              "column": 50
          },
          {
              "line": 1353,
              "column": 21
          },
          {
              "line": 1359,
              "column": 49
          },
          {
              "line": 1363,
              "column": 13
          },
          {
              "line": 1374,
              "column": 13
          },
          {
              "line": 1385,
              "column": 13
          },
          {
              "line": 1400,
              "column": 29
          },
          {
              "line": 1408,
              "column": 13
          },
          {
              "line": 1410,
              "column": 13
          },
          {
              "line": 1412,
              "column": 13
          },
          {
              "line": 1418,
              "column": 29
          },
          {
              "line": 1426,
              "column": 13
          },
          {
              "line": 1437,
              "column": 13
          },
          {
              "line": 1448,
              "column": 13
          },
          {
              "line": 1460,
              "column": 13
          },
          {
              "line": 1461,
              "column": 13
          },
          {
              "line": 1466,
              "column": 21
          },
          {
              "line": 1472,
              "column": 13
          },
          {
              "line": 1483,
              "column": 13
          },
          {
              "line": 1495,
              "column": 13
          },
          {
              "line": 1496,
              "column": 13
          },
          {
              "line": 1501,
              "column": 21
          },
          {
              "line": 1507,
              "column": 13
          },
          {
              "line": 1518,
              "column": 13
          },
          {
              "line": 1529,
              "column": 13
          },
          {
              "line": 1541,
              "column": 34
          },
          {
              "line": 1542,
              "column": 13
          },
          {
              "line": 1548,
              "column": 50
          },
          {
              "line": 1556,
              "column": 21
          },
          {
              "line": 1558,
              "column": 13
          },
          {
              "line": 1562,
              "column": 34
          },
          {
              "line": 1563,
              "column": 13
          },
          {
              "line": 1582,
              "column": 56
          },
          {
              "line": 1586,
              "column": 21
          },
          {
              "line": 1588,
              "column": 49
          },
          {
              "line": 1602,
              "column": 13
          },
          {
              "line": 1630,
              "column": 13
          },
          {
              "line": 1696,
              "column": 34
          },
          {
              "line": 1697,
              "column": 13
          },
          {
              "line": 1712,
              "column": 50
          },
          {
              "line": 1716,
              "column": 21
          },
          {
              "line": 1719,
              "column": 21
          },
          {
              "line": 1723,
              "column": 13
          },
          {
              "line": 1740,
              "column": 29
          },
          {
              "line": 1747,
              "column": 13
          },
          {
              "line": 1748,
              "column": 13
          },
          {
              "line": 1758,
              "column": 13
          },
          {
              "line": 1761,
              "column": 21
          },
          {
              "line": 1764,
              "column": 21
          },
          {
              "line": 1772,
              "column": 34
          },
          {
              "line": 1773,
              "column": 13
          },
          {
              "line": 1798,
              "column": 50
          },
          {
              "line": 1805,
              "column": 21
          },
          {
              "line": 1809,
              "column": 13
          },
          {
              "line": 1816,
              "column": 13
          },
          {
              "line": 1819,
              "column": 13
          },
          {
              "line": 1832,
              "column": 29
          },
          {
              "line": 1839,
              "column": 13
          },
          {
              "line": 1840,
              "column": 13
          },
          {
              "line": 1844,
              "column": 13
          },
          {
              "line": 1847,
              "column": 34
          },
          {
              "line": 1848,
              "column": 13
          },
          {
              "line": 1863,
              "column": 50
          },
          {
              "line": 1867,
              "column": 21
          },
          {
              "line": 1873,
              "column": 49
          },
          {
              "line": 1879,
              "column": 13
          },
          {
              "line": 1891,
              "column": 13
          },
          {
              "line": 1903,
              "column": 13
          },
          {
              "line": 1919,
              "column": 29
          },
          {
              "line": 1927,
              "column": 13
          },
          {
              "line": 1930,
              "column": 13
          },
          {
              "line": 1933,
              "column": 13
          },
          {
              "line": 1939,
              "column": 29
          },
          {
              "line": 1947,
              "column": 13
          },
          {
              "line": 1960,
              "column": 13
          },
          {
              "line": 1973,
              "column": 13
          },
          {
              "line": 1986,
              "column": 13
          },
          {
              "line": 1988,
              "column": 13
          },
          {
              "line": 1992,
              "column": 21
          },
          {
              "line": 1998,
              "column": 13
          },
          {
              "line": 2011,
              "column": 13
          },
          {
              "line": 2024,
              "column": 13
          },
          {
              "line": 2026,
              "column": 13
          },
          {
              "line": 2030,
              "column": 21
          },
          {
              "line": 2036,
              "column": 13
          },
          {
              "line": 2049,
              "column": 13
          },
          {
              "line": 2062,
              "column": 13
          },
          {
              "line": 2075,
              "column": 34
          },
          {
              "line": 2076,
              "column": 13
          },
          {
              "line": 2291,
              "column": 28
          },
          {
              "line": 2409,
              "column": 28
          },
          {
              "line": 2430,
              "column": 50
          },
          {
              "line": 2434,
              "column": 21
          },
          {
              "line": 2440,
              "column": 49
          },
          {
              "line": 2444,
              "column": 13
          },
          {
              "line": 2455,
              "column": 13
          },
          {
              "line": 2466,
              "column": 13
          },
          {
              "line": 2481,
              "column": 29
          },
          {
              "line": 2489,
              "column": 13
          },
          {
              "line": 2491,
              "column": 13
          },
          {
              "line": 2493,
              "column": 13
          },
          {
              "line": 2499,
              "column": 29
          },
          {
              "line": 2507,
              "column": 13
          },
          {
              "line": 2518,
              "column": 13
          },
          {
              "line": 2529,
              "column": 13
          },
          {
              "line": 2541,
              "column": 13
          },
          {
              "line": 2543,
              "column": 13
          },
          {
              "line": 2547,
              "column": 21
          },
          {
              "line": 2553,
              "column": 13
          },
          {
              "line": 2564,
              "column": 13
          },
          {
              "line": 2576,
              "column": 13
          },
          {
              "line": 2578,
              "column": 13
          },
          {
              "line": 2582,
              "column": 21
          },
          {
              "line": 2588,
              "column": 13
          },
          {
              "line": 2599,
              "column": 13
          },
          {
              "line": 2610,
              "column": 13
          },
          {
              "line": 2622,
              "column": 34
          },
          {
              "line": 2623,
              "column": 13
          },
          {
              "line": 2677,
              "column": 28
          },
          {
              "line": 2799,
              "column": 28
          },
          {
              "line": 2859,
              "column": 28
          },
          {
              "line": 2982,
              "column": 28
          },
          {
              "line": 3042,
              "column": 28
          },
          {
              "line": 3165,
              "column": 28
          },
          {
              "line": 3186,
              "column": 49
          },
          {
              "line": 3190,
              "column": 21
          },
          {
              "line": 3196,
              "column": 51
          },
          {
              "line": 3201,
              "column": 13
          },
          {
              "line": 3213,
              "column": 13
          },
          {
              "line": 3227,
              "column": 13
          },
          {
              "line": 3230,
              "column": 13
          },
          {
              "line": 3266,
              "column": 29
          },
          {
              "line": 3274,
              "column": 13
          },
          {
              "line": 3276,
              "column": 13
          },
          {
              "line": 3278,
              "column": 13
          },
          {
              "line": 3291,
              "column": 29
          },
          {
              "line": 3299,
              "column": 13
          },
          {
              "line": 3315,
              "column": 13
          },
          {
              "line": 3332,
              "column": 13
          },
          {
              "line": 3369,
              "column": 13
          },
          {
              "line": 3371,
              "column": 13
          },
          {
              "line": 3373,
              "column": 13
          },
          {
              "line": 3386,
              "column": 13
          },
          {
              "line": 3387,
              "column": 13
          },
          {
              "line": 3389,
              "column": 13
          },
          {
              "line": 3395,
              "column": 13
          },
          {
              "line": 3397,
              "column": 13
          },
          {
              "line": 3401,
              "column": 21
          },
          {
              "line": 3407,
              "column": 13
          },
          {
              "line": 3423,
              "column": 13
          },
          {
              "line": 3440,
              "column": 13
          },
          {
              "line": 3442,
              "column": 13
          },
          {
              "line": 3447,
              "column": 21
          },
          {
              "line": 3453,
              "column": 13
          },
          {
              "line": 3469,
              "column": 13
          },
          {
              "line": 3486,
              "column": 13
          },
          {
              "line": 3505,
              "column": 34
          },
          {
              "line": 3506,
              "column": 13
          },
          {
              "line": 3515,
              "column": 50
          },
          {
              "line": 3520,
              "column": 21
          },
          {
              "line": 3522,
              "column": 13
          },
          {
              "line": 3538,
              "column": 34
          },
          {
              "line": 3539,
              "column": 13
          },
          {
              "line": 3552,
              "column": 50
          },
          {
              "line": 3557,
              "column": 21
          },
          {
              "line": 3559,
              "column": 13
          },
          {
              "line": 3590,
              "column": 34
          },
          {
              "line": 3591,
              "column": 13
          },
          {
              "line": 3603,
              "column": 50
          },
          {
              "line": 3608,
              "column": 21
          },
          {
              "line": 3611,
              "column": 21
          },
          {
              "line": 3615,
              "column": 13
          },
          {
              "line": 3624,
              "column": 34
          },
          {
              "line": 3625,
              "column": 13
          },
          {
              "line": 3634,
              "column": 50
          },
          {
              "line": 3638,
              "column": 21
          },
          {
              "line": 3641,
              "column": 13
          },
          {
              "line": 3651,
              "column": 34
          },
          {
              "line": 3652,
              "column": 13
          },
          {
              "line": 3662,
              "column": 50
          },
          {
              "line": 3666,
              "column": 21
          },
          {
              "line": 3669,
              "column": 13
          },
          {
              "line": 3680,
              "column": 29
          },
          {
              "line": 3687,
              "column": 34
          },
          {
              "line": 3688,
              "column": 13
          },
          {
              "line": 3692,
              "column": 13
          },
          {
              "line": 3694,
              "column": 21
          },
          {
              "line": 3697,
              "column": 13
          },
          {
              "line": 3701,
              "column": 34
          },
          {
              "line": 3702,
              "column": 13
          },
          {
              "line": 3712,
              "column": 50
          },
          {
              "line": 3716,
              "column": 21
          },
          {
              "line": 3719,
              "column": 13
          },
          {
              "line": 3728,
              "column": 34
          },
          {
              "line": 3729,
              "column": 13
          },
          {
              "line": 3738,
              "column": 50
          },
          {
              "line": 3742,
              "column": 21
          },
          {
              "line": 3745,
              "column": 13
          },
          {
              "line": 3754,
              "column": 34
          },
          {
              "line": 3755,
              "column": 13
          },
          {
              "line": 3765,
              "column": 50
          },
          {
              "line": 3769,
              "column": 21
          },
          {
              "line": 3772,
              "column": 13
          },
          {
              "line": 3787,
              "column": 34
          },
          {
              "line": 3788,
              "column": 13
          },
          {
              "line": 3798,
              "column": 49
          },
          {
              "line": 3805,
              "column": 21
          },
          {
              "line": 3809,
              "column": 13
          },
          {
              "line": 3811,
              "column": 13
          },
          {
              "line": 3813,
              "column": 13
          },
          {
              "line": 3816,
              "column": 50
          },
          {
              "line": 3819,
              "column": 29
          },
          {
              "line": 3825,
              "column": 13
          },
          {
              "line": 3827,
              "column": 13
          },
          {
              "line": 3832,
              "column": 29
          },
          {
              "line": 3838,
              "column": 13
          },
          {
              "line": 3841,
              "column": 13
          },
          {
              "line": 3843,
              "column": 21
          },
          {
              "line": 3846,
              "column": 13
          },
          {
              "line": 3848,
              "column": 13
          },
          {
              "line": 3850,
              "column": 13
          },
          {
              "line": 3855,
              "column": 34
          },
          {
              "line": 3856,
              "column": 13
          },
          {
              "line": 3862,
              "column": 39
          },
          {
              "line": 3864,
              "column": 51
          },
          {
              "line": 3865,
              "column": 46
          },
          {
              "line": 3867,
              "column": 56
          },
          {
              "line": 3868,
              "column": 82
          },
          {
              "line": 3877,
              "column": 39
          },
          {
              "line": 3879,
              "column": 50
          },
          {
              "line": 3880,
              "column": 46
          },
          {
              "line": 3882,
              "column": 56
          },
          {
              "line": 3883,
              "column": 82
          },
          {
              "line": 3892,
              "column": 39
          },
          {
              "line": 3894,
              "column": 50
          },
          {
              "line": 3895,
              "column": 46
          },
          {
              "line": 3897,
              "column": 56
          },
          {
              "line": 3898,
              "column": 82
          },
          {
              "line": 3959,
              "column": 54
          },
          {
              "line": 3964,
              "column": 29
          },
          {
              "line": 3970,
              "column": 21
          },
          {
              "line": 3980,
              "column": 33
          },
          {
              "line": 3987,
              "column": 38
          },
          {
              "line": 3988,
              "column": 17
          },
          {
              "line": 4010,
              "column": 54
          },
          {
              "line": 4021,
              "column": 29
          },
          {
              "line": 4025,
              "column": 21
          },
          {
              "line": 4029,
              "column": 38
          },
          {
              "line": 4030,
              "column": 17
          },
          {
              "line": 4046,
              "column": 50
          },
          {
              "line": 4050,
              "column": 21
          },
          {
              "line": 4054,
              "column": 13
          },
          {
              "line": 4056,
              "column": 13
          },
          {
              "line": 4062,
              "column": 29
          },
          {
              "line": 4069,
              "column": 34
          },
          {
              "line": 4070,
              "column": 13
          },
          {
              "line": 4091,
              "column": 50
          },
          {
              "line": 4098,
              "column": 21
          },
          {
              "line": 4101,
              "column": 13
          },
          {
              "line": 4103,
              "column": 13
          },
          {
              "line": 4109,
              "column": 29
          },
          {
              "line": 4116,
              "column": 13
          },
          {
              "line": 4118,
              "column": 13
          },
          {
              "line": 4129,
              "column": 25
          },
          {
              "line": 4139,
              "column": 34
          },
          {
              "line": 4140,
              "column": 13
          },
          {
              "line": 4150,
              "column": 50
          },
          {
              "line": 4156,
              "column": 21
          },
          {
              "line": 4159,
              "column": 13
          },
          {
              "line": 4161,
              "column": 13
          },
          {
              "line": 4167,
              "column": 29
          },
          {
              "line": 4174,
              "column": 13
          },
          {
              "line": 4176,
              "column": 13
          },
          {
              "line": 4187,
              "column": 25
          },
          {
              "line": 4197,
              "column": 34
          },
          {
              "line": 4198,
              "column": 13
          },
          {
              "line": 4208,
              "column": 50
          },
          {
              "line": 4216,
              "column": 21
          },
          {
              "line": 4219,
              "column": 13
          },
          {
              "line": 4221,
              "column": 13
          },
          {
              "line": 4227,
              "column": 29
          },
          {
              "line": 4234,
              "column": 13
          },
          {
              "line": 4236,
              "column": 13
          },
          {
              "line": 4249,
              "column": 25
          },
          {
              "line": 4259,
              "column": 34
          },
          {
              "line": 4260,
              "column": 13
          },
          {
              "line": 4270,
              "column": 50
          },
          {
              "line": 4278,
              "column": 21
          },
          {
              "line": 4281,
              "column": 13
          },
          {
              "line": 4283,
              "column": 13
          },
          {
              "line": 4289,
              "column": 29
          },
          {
              "line": 4296,
              "column": 13
          },
          {
              "line": 4298,
              "column": 13
          },
          {
              "line": 4311,
              "column": 25
          },
          {
              "line": 4321,
              "column": 34
          },
          {
              "line": 4322,
              "column": 13
          },
          {
              "line": 4331,
              "column": 56
          },
          {
              "line": 4335,
              "column": 21
          },
          {
              "line": 4338,
              "column": 13
          },
          {
              "line": 4341,
              "column": 13
          },
          {
              "line": 4349,
              "column": 34
          },
          {
              "line": 4350,
              "column": 13
          },
          {
              "line": 4363,
              "column": 56
          },
          {
              "line": 4367,
              "column": 17
          },
          {
              "line": 4373,
              "column": 17
          },
          {
              "line": 4379,
              "column": 17
          },
          {
              "line": 4384,
              "column": 34
          },
          {
              "line": 4385,
              "column": 13
          },
          {
              "line": 4396,
              "column": 56
          },
          {
              "line": 4411,
              "column": 25
          },
          {
              "line": 4419,
              "column": 17
          },
          {
              "line": 4433,
              "column": 25
          },
          {
              "line": 4441,
              "column": 17
          },
          {
              "line": 4464,
              "column": 25
          },
          {
              "line": 4472,
              "column": 17
          },
          {
              "line": 4486,
              "column": 25
          },
          {
              "line": 4494,
              "column": 17
          },
          {
              "line": 4502,
              "column": 34
          },
          {
              "line": 4503,
              "column": 13
          },
          {
              "line": 4514,
              "column": 50
          },
          {
              "line": 4517,
              "column": 51
          },
          {
              "line": 4526,
              "column": 13
          },
          {
              "line": 4540,
              "column": 29
          },
          {
              "line": 4547,
              "column": 13
          },
          {
              "line": 4555,
              "column": 13
          },
          {
              "line": 4557,
              "column": 13
          },
          {
              "line": 4562,
              "column": 13
          },
          {
              "line": 4574,
              "column": 34
          },
          {
              "line": 4575,
              "column": 13
          },
          {
              "line": 4582,
              "column": 50
          },
          {
              "line": 4593,
              "column": 29
          },
          {
              "line": 4600,
              "column": 13
          },
          {
              "line": 4602,
              "column": 13
          },
          {
              "line": 4607,
              "column": 34
          },
          {
              "line": 4608,
              "column": 13
          },
          {
              "line": 4617,
              "column": 50
          },
          {
              "line": 4620,
              "column": 58
          },
          {
              "line": 4623,
              "column": 21
          },
          {
              "line": 4626,
              "column": 13
          },
          {
              "line": 4630,
              "column": 58
          },
          {
              "line": 4632,
              "column": 13
          },
          {
              "line": 4635,
              "column": 58
          },
          {
              "line": 4637,
              "column": 13
          },
          {
              "line": 4640,
              "column": 58
          },
          {
              "line": 4642,
              "column": 13
          },
          {
              "line": 4645,
              "column": 58
          },
          {
              "line": 4647,
              "column": 34
          },
          {
              "line": 4648,
              "column": 13
          },
          {
              "line": 4674,
              "column": 56
          },
          {
              "line": 4683,
              "column": 40
          },
          {
              "line": 4685,
              "column": 21
          },
          {
              "line": 4692,
              "column": 17
          },
          {
              "line": 4697,
              "column": 21
          },
          {
              "line": 4710,
              "column": 17
          },
          {
              "line": 4719,
              "column": 21
          },
          {
              "line": 4736,
              "column": 34
          },
          {
              "line": 4737,
              "column": 13
          },
          {
              "line": 4745,
              "column": 50
          },
          {
              "line": 4747,
              "column": 13
          },
          {
              "line": 4748,
              "column": 46
          },
          {
              "line": 4751,
              "column": 17
          },
          {
              "line": 4752,
              "column": 38
          },
          {
              "line": 4753,
              "column": 17
          },
          {
              "line": 4766,
              "column": 50
          },
          {
              "line": 4770,
              "column": 13
          },
          {
              "line": 4772,
              "column": 21
          },
          {
              "line": 4779,
              "column": 17
          },
          {
              "line": 4784,
              "column": 21
          },
          {
              "line": 4792,
              "column": 17
          },
          {
              "line": 4805,
              "column": 17
          },
          {
              "line": 4810,
              "column": 25
          },
          {
              "line": 4811,
              "column": 38
          },
          {
              "line": 4812,
              "column": 17
          },
          {
              "line": 4818,
              "column": 9
          },
          {
              "line": 4821,
              "column": 13
          },
          {
              "line": 4824,
              "column": 21
          },
          {
              "line": 4831,
              "column": 17
          },
          {
              "line": 4835,
              "column": 13
          },
          {
              "line": 4838,
              "column": 25
          },
          {
              "line": 4839,
              "column": 38
          },
          {
              "line": 4840,
              "column": 17
          },
          {
              "line": 4848,
              "column": 74
          },
          {
              "line": 4855,
              "column": 50
          },
          {
              "line": 4863,
              "column": 21
          },
          {
              "line": 4869,
              "column": 17
          },
          {
              "line": 4874,
              "column": 13
          },
          {
              "line": 4886,
              "column": 13
          },
          {
              "line": 4898,
              "column": 13
          },
          {
              "line": 4910,
              "column": 13
          },
          {
              "line": 4924,
              "column": 13
          },
          {
              "line": 4937,
              "column": 34
          },
          {
              "line": 4938,
              "column": 13
          },
          {
              "line": 4944,
              "column": 50
          },
          {
              "line": 4952,
              "column": 21
          },
          {
              "line": 4958,
              "column": 17
          },
          {
              "line": 4963,
              "column": 13
          },
          {
              "line": 4970,
              "column": 34
          },
          {
              "line": 4971,
              "column": 13
          },
          {
              "line": 4986,
              "column": 56
          },
          {
              "line": 4996,
              "column": 21
          },
          {
              "line": 5003,
              "column": 17
          },
          {
              "line": 5008,
              "column": 21
          },
          {
              "line": 5020,
              "column": 26
          },
          {
              "line": 5021,
              "column": 34
          },
          {
              "line": 5036,
              "column": 34
          },
          {
              "line": 5037,
              "column": 13
          },
          {
              "line": 5046,
              "column": 50
          },
          {
              "line": 5051,
              "column": 21
          },
          {
              "line": 5058,
              "column": 17
          },
          {
              "line": 5065,
              "column": 21
          },
          {
              "line": 5074,
              "column": 17
          },
          {
              "line": 5080,
              "column": 47
          },
          {
              "line": 5093,
              "column": 47
          },
          {
              "line": 5107,
              "column": 34
          },
          {
              "line": 5108,
              "column": 13
          },
          {
              "line": 5116,
              "column": 50
          },
          {
              "line": 5120,
              "column": 21
          },
          {
              "line": 5127,
              "column": 17
          },
          {
              "line": 5135,
              "column": 59
          },
          {
              "line": 5151,
              "column": 34
          },
          {
              "line": 5152,
              "column": 13
          },
          {
              "line": 5160,
              "column": 50
          },
          {
              "line": 5169,
              "column": 25
          },
          {
              "line": 5171,
              "column": 17
          },
          {
              "line": 5177,
              "column": 33
          },
          {
              "line": 5190,
              "column": 34
          },
          {
              "line": 5191,
              "column": 13
          },
          {
              "line": 5547,
              "column": 14
          },
          {
              "line": 5650,
              "column": 12
          },
          {
              "line": 5664,
              "column": 31
          }
      ],
      "old_name": "backend",
      "new_name": "restoreBackend",
      "ctx": {
          "symbolName": "backend",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CheckpointableKeyedStateBackend<K>",
          "scopeHint": "in createKeyedBackend(...)",
          "filePath": "StateBackendTestBase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "protected <K> CheckpointableKeyedStateBackend<K> createKeyedBackend(\n            TypeSerializer<K> keySerializer,\n            int numberOfKeyGroups,\n            KeyGroupRange keyGroupRange,\n            Environment env)\n            throws Exception {\n\n        env.setCheckpointStorageAccess(getCheckpointStorageAccess());\n        CheckpointableKeyedStateBackend<K> backend =\n                getStateBackend()\n                        .createKeyedStateBackend(\n                                env,\n                                new JobID(),\n                                \"test_op\",\n                                keySerializer,\n                                numberOfKeyGroups,\n                                keyGroupRange,\n                                env.getTaskKvStateRegistry(),\n                                TtlTimeProvider.DEFAULT,\n                                new UnregisteredMetricsGroup(),\n                                Collections.emptyList(),\n                                new CloseableRegistry());\n\n        return backend;\n    }",
          "conflictNames": [
              "keySerializer",
              "numberOfKeyGroups",
              "keyGroupRange",
              "env"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/554810abbbd44a656a446d051b3dd199b0df9055^1/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendTestBase.java",
      "locators": [
          {
              "line": 19,
              "column": 34
          },
          {
              "line": 24,
              "column": 36
          },
          {
              "line": 25,
              "column": 36
          },
          {
              "line": 26,
              "column": 36
          },
          {
              "line": 27,
              "column": 36
          },
          {
              "line": 28,
              "column": 36
          },
          {
              "line": 29,
              "column": 36
          },
          {
              "line": 30,
              "column": 36
          },
          {
              "line": 31,
              "column": 36
          },
          {
              "line": 32,
              "column": 36
          },
          {
              "line": 33,
              "column": 36
          },
          {
              "line": 34,
              "column": 36
          },
          {
              "line": 35,
              "column": 36
          },
          {
              "line": 57,
              "column": 34
          },
          {
              "line": 58,
              "column": 34
          },
          {
              "line": 58,
              "column": 47
          },
          {
              "line": 67,
              "column": 33
          },
          {
              "line": 68,
              "column": 33
          },
          {
              "line": 69,
              "column": 33
          },
          {
              "line": 70,
              "column": 33
          },
          {
              "line": 71,
              "column": 33
          },
          {
              "line": 72,
              "column": 33
          },
          {
              "line": 73,
              "column": 33
          },
          {
              "line": 74,
              "column": 33
          },
          {
              "line": 75,
              "column": 33
          },
          {
              "line": 76,
              "column": 43
          },
          {
              "line": 153,
              "column": 66
          },
          {
              "line": 178,
              "column": 34
          },
          {
              "line": 179,
              "column": 13
          },
          {
              "line": 180,
              "column": 40
          },
          {
              "line": 184,
              "column": 22
          },
          {
              "line": 246,
              "column": 63
          },
          {
              "line": 247,
              "column": 51
          },
          {
              "line": 251,
              "column": 63
          },
          {
              "line": 254,
              "column": 87
          },
          {
              "line": 261,
              "column": 36
          },
          {
              "line": 276,
              "column": 25
          },
          {
              "line": 282,
              "column": 34
          },
          {
              "line": 286,
              "column": 17
          },
          {
              "line": 532,
              "column": 34
          },
          {
              "line": 544,
              "column": 17
          },
          {
              "line": 556,
              "column": 68
          },
          {
              "line": 605,
              "column": 34
          },
          {
              "line": 607,
              "column": 24
          },
          {
              "line": 608,
              "column": 35
          },
          {
              "line": 618,
              "column": 17
          },
          {
              "line": 630,
              "column": 68
          },
          {
              "line": 673,
              "column": 34
          },
          {
              "line": 685,
              "column": 17
          },
          {
              "line": 697,
              "column": 68
          },
          {
              "line": 742,
              "column": 34
          },
          {
              "line": 744,
              "column": 24
          },
          {
              "line": 745,
              "column": 35
          },
          {
              "line": 755,
              "column": 17
          },
          {
              "line": 767,
              "column": 68
          },
          {
              "line": 793,
              "column": 15
          },
          {
              "line": 794,
              "column": 60
          },
          {
              "line": 794,
              "column": 91
          },
          {
              "line": 797,
              "column": 73
          },
          {
              "line": 815,
              "column": 34
          },
          {
              "line": 825,
              "column": 13
          },
          {
              "line": 828,
              "column": 13
          },
          {
              "line": 851,
              "column": 13
          },
          {
              "line": 855,
              "column": 26
          },
          {
              "line": 858,
              "column": 26
          },
          {
              "line": 866,
              "column": 15
          },
          {
              "line": 867,
              "column": 60
          },
          {
              "line": 868,
              "column": 27
          },
          {
              "line": 893,
              "column": 34
          },
          {
              "line": 902,
              "column": 13
          },
          {
              "line": 905,
              "column": 13
          },
          {
              "line": 931,
              "column": 13
          },
          {
              "line": 937,
              "column": 31
          },
          {
              "line": 938,
              "column": 13
          },
          {
              "line": 969,
              "column": 16
          },
          {
              "line": 969,
              "column": 77
          },
          {
              "line": 973,
              "column": 13
          },
          {
              "line": 978,
              "column": 16
          },
          {
              "line": 979,
              "column": 13
          },
          {
              "line": 990,
              "column": 15
          },
          {
              "line": 991,
              "column": 60
          },
          {
              "line": 992,
              "column": 27
          },
          {
              "line": 1018,
              "column": 34
          },
          {
              "line": 1027,
              "column": 13
          },
          {
              "line": 1030,
              "column": 13
          },
          {
              "line": 1054,
              "column": 13
          },
          {
              "line": 1060,
              "column": 31
          },
          {
              "line": 1061,
              "column": 13
          },
          {
              "line": 1090,
              "column": 16
          },
          {
              "line": 1090,
              "column": 77
          },
          {
              "line": 1094,
              "column": 13
          },
          {
              "line": 1099,
              "column": 16
          },
          {
              "line": 1100,
              "column": 13
          },
          {
              "line": 1131,
              "column": 34
          },
          {
              "line": 1135,
              "column": 36
          },
          {
              "line": 1140,
              "column": 65
          },
          {
              "line": 1154,
              "column": 13
          },
          {
              "line": 1162,
              "column": 13
          },
          {
              "line": 1195,
              "column": 13
          },
          {
              "line": 1199,
              "column": 64
          },
          {
              "line": 1202,
              "column": 49
          },
          {
              "line": 1216,
              "column": 31
          },
          {
              "line": 1217,
              "column": 13
          },
          {
              "line": 1224,
              "column": 74
          },
          {
              "line": 1260,
              "column": 34
          },
          {
              "line": 1268,
              "column": 13
          },
          {
              "line": 1276,
              "column": 13
          },
          {
              "line": 1309,
              "column": 13
          },
          {
              "line": 1315,
              "column": 31
          },
          {
              "line": 1316,
              "column": 13
          },
          {
              "line": 1323,
              "column": 74
          },
          {
              "line": 1352,
              "column": 32
          },
          {
              "line": 1357,
              "column": 71
          },
          {
              "line": 1362,
              "column": 42
          },
          {
              "line": 1364,
              "column": 24
          },
          {
              "line": 1373,
              "column": 13
          },
          {
              "line": 1375,
              "column": 24
          },
          {
              "line": 1384,
              "column": 13
          },
          {
              "line": 1386,
              "column": 31
          },
          {
              "line": 1409,
              "column": 13
          },
          {
              "line": 1411,
              "column": 13
          },
          {
              "line": 1413,
              "column": 13
          },
          {
              "line": 1425,
              "column": 38
          },
          {
              "line": 1427,
              "column": 32
          },
          {
              "line": 1438,
              "column": 32
          },
          {
              "line": 1449,
              "column": 32
          },
          {
              "line": 1555,
              "column": 37
          },
          {
              "line": 1559,
              "column": 13
          },
          {
              "line": 1560,
              "column": 13
          },
          {
              "line": 1569,
              "column": 71
          },
          {
              "line": 1585,
              "column": 38
          },
          {
              "line": 1593,
              "column": 65
          },
          {
              "line": 1604,
              "column": 13
          },
          {
              "line": 1605,
              "column": 31
          },
          {
              "line": 1617,
              "column": 20
          },
          {
              "line": 1618,
              "column": 31
          },
          {
              "line": 1628,
              "column": 42
          },
          {
              "line": 1631,
              "column": 24
          },
          {
              "line": 1640,
              "column": 13
          },
          {
              "line": 1647,
              "column": 51
          },
          {
              "line": 1653,
              "column": 51
          },
          {
              "line": 1715,
              "column": 32
          },
          {
              "line": 1718,
              "column": 33
          },
          {
              "line": 1722,
              "column": 42
          },
          {
              "line": 1724,
              "column": 24
          },
          {
              "line": 1725,
              "column": 24
          },
          {
              "line": 1726,
              "column": 13
          },
          {
              "line": 1728,
              "column": 16
          },
          {
              "line": 1729,
              "column": 31
          },
          {
              "line": 1730,
              "column": 24
          },
          {
              "line": 1731,
              "column": 13
          },
          {
              "line": 1733,
              "column": 31
          },
          {
              "line": 1734,
              "column": 31
          },
          {
              "line": 1735,
              "column": 36
          },
          {
              "line": 1760,
              "column": 13
          },
          {
              "line": 1763,
              "column": 13
          },
          {
              "line": 1768,
              "column": 31
          },
          {
              "line": 1769,
              "column": 36
          },
          {
              "line": 1787,
              "column": 62
          },
          {
              "line": 1804,
              "column": 30
          },
          {
              "line": 1808,
              "column": 42
          },
          {
              "line": 1812,
              "column": 38
          },
          {
              "line": 1813,
              "column": 13
          },
          {
              "line": 1814,
              "column": 37
          },
          {
              "line": 1817,
              "column": 38
          },
          {
              "line": 1820,
              "column": 13
          },
          {
              "line": 1821,
              "column": 38
          },
          {
              "line": 1823,
              "column": 13
          },
          {
              "line": 1824,
              "column": 38
          },
          {
              "line": 1826,
              "column": 13
          },
          {
              "line": 1827,
              "column": 38
          },
          {
              "line": 1866,
              "column": 31
          },
          {
              "line": 1871,
              "column": 71
          },
          {
              "line": 1878,
              "column": 42
          },
          {
              "line": 1880,
              "column": 24
          },
          {
              "line": 1889,
              "column": 13
          },
          {
              "line": 1892,
              "column": 24
          },
          {
              "line": 1901,
              "column": 13
          },
          {
              "line": 1904,
              "column": 43
          },
          {
              "line": 1928,
              "column": 13
          },
          {
              "line": 1931,
              "column": 13
          },
          {
              "line": 1934,
              "column": 13
          },
          {
              "line": 1946,
              "column": 38
          },
          {
              "line": 1948,
              "column": 46
          },
          {
              "line": 1961,
              "column": 46
          },
          {
              "line": 1974,
              "column": 44
          },
          {
              "line": 2086,
              "column": 41
          },
          {
              "line": 2087,
              "column": 47
          },
          {
              "line": 2091,
              "column": 29
          },
          {
              "line": 2093,
              "column": 87
          },
          {
              "line": 2096,
              "column": 24
          },
          {
              "line": 2099,
              "column": 13
          },
          {
              "line": 2112,
              "column": 41
          },
          {
              "line": 2113,
              "column": 47
          },
          {
              "line": 2118,
              "column": 29
          },
          {
              "line": 2120,
              "column": 87
          },
          {
              "line": 2123,
              "column": 24
          },
          {
              "line": 2131,
              "column": 13
          },
          {
              "line": 2144,
              "column": 41
          },
          {
              "line": 2145,
              "column": 47
          },
          {
              "line": 2150,
              "column": 29
          },
          {
              "line": 2152,
              "column": 87
          },
          {
              "line": 2155,
              "column": 24
          },
          {
              "line": 2158,
              "column": 13
          },
          {
              "line": 2171,
              "column": 41
          },
          {
              "line": 2172,
              "column": 47
          },
          {
              "line": 2177,
              "column": 29
          },
          {
              "line": 2179,
              "column": 87
          },
          {
              "line": 2182,
              "column": 24
          },
          {
              "line": 2190,
              "column": 13
          },
          {
              "line": 2203,
              "column": 41
          },
          {
              "line": 2204,
              "column": 47
          },
          {
              "line": 2209,
              "column": 29
          },
          {
              "line": 2211,
              "column": 87
          },
          {
              "line": 2214,
              "column": 24
          },
          {
              "line": 2217,
              "column": 13
          },
          {
              "line": 2226,
              "column": 41
          },
          {
              "line": 2227,
              "column": 47
          },
          {
              "line": 2232,
              "column": 29
          },
          {
              "line": 2234,
              "column": 87
          },
          {
              "line": 2237,
              "column": 24
          },
          {
              "line": 2238,
              "column": 13
          },
          {
              "line": 2239,
              "column": 13
          },
          {
              "line": 2240,
              "column": 24
          },
          {
              "line": 2242,
              "column": 13
          },
          {
              "line": 2243,
              "column": 24
          },
          {
              "line": 2244,
              "column": 13
          },
          {
              "line": 2245,
              "column": 24
          },
          {
              "line": 2246,
              "column": 24
          },
          {
              "line": 2249,
              "column": 24
          },
          {
              "line": 2252,
              "column": 24
          },
          {
              "line": 2253,
              "column": 24
          },
          {
              "line": 2254,
              "column": 13
          },
          {
              "line": 2255,
              "column": 24
          },
          {
              "line": 2256,
              "column": 13
          },
          {
              "line": 2257,
              "column": 24
          },
          {
              "line": 2258,
              "column": 24
          },
          {
              "line": 2259,
              "column": 13
          },
          {
              "line": 2260,
              "column": 24
          },
          {
              "line": 2261,
              "column": 13
          },
          {
              "line": 2262,
              "column": 24
          },
          {
              "line": 2263,
              "column": 13
          },
          {
              "line": 2264,
              "column": 24
          },
          {
              "line": 2266,
              "column": 24
          },
          {
              "line": 2267,
              "column": 13
          },
          {
              "line": 2268,
              "column": 24
          },
          {
              "line": 2271,
              "column": 24
          },
          {
              "line": 2272,
              "column": 13
          },
          {
              "line": 2273,
              "column": 24
          },
          {
              "line": 2276,
              "column": 13
          },
          {
              "line": 2277,
              "column": 13
          },
          {
              "line": 2278,
              "column": 13
          },
          {
              "line": 2281,
              "column": 24
          },
          {
              "line": 2284,
              "column": 24
          },
          {
              "line": 2285,
              "column": 13
          },
          {
              "line": 2286,
              "column": 24
          },
          {
              "line": 2287,
              "column": 13
          },
          {
              "line": 2302,
              "column": 41
          },
          {
              "line": 2303,
              "column": 47
          },
          {
              "line": 2312,
              "column": 54
          },
          {
              "line": 2314,
              "column": 89
          },
          {
              "line": 2324,
              "column": 13
          },
          {
              "line": 2325,
              "column": 13
          },
          {
              "line": 2326,
              "column": 13
          },
          {
              "line": 2328,
              "column": 13
          },
          {
              "line": 2329,
              "column": 13
          },
          {
              "line": 2330,
              "column": 13
          },
          {
              "line": 2332,
              "column": 13
          },
          {
              "line": 2333,
              "column": 13
          },
          {
              "line": 2336,
              "column": 13
          },
          {
              "line": 2337,
              "column": 13
          },
          {
              "line": 2338,
              "column": 13
          },
          {
              "line": 2340,
              "column": 13
          },
          {
              "line": 2341,
              "column": 13
          },
          {
              "line": 2342,
              "column": 13
          },
          {
              "line": 2343,
              "column": 13
          },
          {
              "line": 2346,
              "column": 13
          },
          {
              "line": 2347,
              "column": 13
          },
          {
              "line": 2348,
              "column": 13
          },
          {
              "line": 2349,
              "column": 13
          },
          {
              "line": 2350,
              "column": 13
          },
          {
              "line": 2351,
              "column": 13
          },
          {
              "line": 2354,
              "column": 13
          },
          {
              "line": 2355,
              "column": 13
          },
          {
              "line": 2356,
              "column": 13
          },
          {
              "line": 2357,
              "column": 13
          },
          {
              "line": 2358,
              "column": 13
          },
          {
              "line": 2359,
              "column": 13
          },
          {
              "line": 2362,
              "column": 13
          },
          {
              "line": 2363,
              "column": 13
          },
          {
              "line": 2364,
              "column": 24
          },
          {
              "line": 2367,
              "column": 13
          },
          {
              "line": 2368,
              "column": 13
          },
          {
              "line": 2369,
              "column": 24
          },
          {
              "line": 2372,
              "column": 13
          },
          {
              "line": 2373,
              "column": 13
          },
          {
              "line": 2374,
              "column": 24
          },
          {
              "line": 2377,
              "column": 13
          },
          {
              "line": 2378,
              "column": 13
          },
          {
              "line": 2379,
              "column": 24
          },
          {
              "line": 2382,
              "column": 13
          },
          {
              "line": 2383,
              "column": 13
          },
          {
              "line": 2384,
              "column": 24
          },
          {
              "line": 2389,
              "column": 13
          },
          {
              "line": 2390,
              "column": 13
          },
          {
              "line": 2393,
              "column": 13
          },
          {
              "line": 2394,
              "column": 13
          },
          {
              "line": 2397,
              "column": 13
          },
          {
              "line": 2398,
              "column": 13
          },
          {
              "line": 2401,
              "column": 13
          },
          {
              "line": 2402,
              "column": 13
          },
          {
              "line": 2405,
              "column": 13
          },
          {
              "line": 2406,
              "column": 13
          },
          {
              "line": 2433,
              "column": 35
          },
          {
              "line": 2438,
              "column": 71
          },
          {
              "line": 2443,
              "column": 42
          },
          {
              "line": 2445,
              "column": 24
          },
          {
              "line": 2454,
              "column": 13
          },
          {
              "line": 2456,
              "column": 24
          },
          {
              "line": 2465,
              "column": 13
          },
          {
              "line": 2467,
              "column": 31
          },
          {
              "line": 2490,
              "column": 13
          },
          {
              "line": 2492,
              "column": 13
          },
          {
              "line": 2494,
              "column": 13
          },
          {
              "line": 2506,
              "column": 38
          },
          {
              "line": 2508,
              "column": 34
          },
          {
              "line": 2519,
              "column": 34
          },
          {
              "line": 2530,
              "column": 32
          },
          {
              "line": 2630,
              "column": 45
          },
          {
              "line": 2631,
              "column": 51
          },
          {
              "line": 2637,
              "column": 33
          },
          {
              "line": 2639,
              "column": 87
          },
          {
              "line": 2642,
              "column": 24
          },
          {
              "line": 2645,
              "column": 24
          },
          {
              "line": 2646,
              "column": 13
          },
          {
              "line": 2647,
              "column": 13
          },
          {
              "line": 2648,
              "column": 31
          },
          {
              "line": 2651,
              "column": 24
          },
          {
              "line": 2654,
              "column": 24
          },
          {
              "line": 2655,
              "column": 13
          },
          {
              "line": 2656,
              "column": 13
          },
          {
              "line": 2659,
              "column": 31
          },
          {
              "line": 2660,
              "column": 13
          },
          {
              "line": 2661,
              "column": 24
          },
          {
              "line": 2664,
              "column": 13
          },
          {
              "line": 2665,
              "column": 13
          },
          {
              "line": 2666,
              "column": 13
          },
          {
              "line": 2669,
              "column": 24
          },
          {
              "line": 2672,
              "column": 30
          },
          {
              "line": 2673,
              "column": 13
          },
          {
              "line": 2689,
              "column": 45
          },
          {
              "line": 2690,
              "column": 51
          },
          {
              "line": 2702,
              "column": 64
          },
          {
              "line": 2704,
              "column": 89
          },
          {
              "line": 2714,
              "column": 13
          },
          {
              "line": 2715,
              "column": 13
          },
          {
              "line": 2716,
              "column": 13
          },
          {
              "line": 2718,
              "column": 13
          },
          {
              "line": 2719,
              "column": 13
          },
          {
              "line": 2720,
              "column": 13
          },
          {
              "line": 2722,
              "column": 13
          },
          {
              "line": 2723,
              "column": 13
          },
          {
              "line": 2726,
              "column": 13
          },
          {
              "line": 2727,
              "column": 13
          },
          {
              "line": 2728,
              "column": 13
          },
          {
              "line": 2730,
              "column": 13
          },
          {
              "line": 2731,
              "column": 13
          },
          {
              "line": 2732,
              "column": 13
          },
          {
              "line": 2733,
              "column": 13
          },
          {
              "line": 2736,
              "column": 13
          },
          {
              "line": 2737,
              "column": 13
          },
          {
              "line": 2738,
              "column": 13
          },
          {
              "line": 2739,
              "column": 13
          },
          {
              "line": 2740,
              "column": 13
          },
          {
              "line": 2741,
              "column": 13
          },
          {
              "line": 2744,
              "column": 13
          },
          {
              "line": 2745,
              "column": 13
          },
          {
              "line": 2746,
              "column": 13
          },
          {
              "line": 2747,
              "column": 13
          },
          {
              "line": 2748,
              "column": 13
          },
          {
              "line": 2749,
              "column": 13
          },
          {
              "line": 2752,
              "column": 13
          },
          {
              "line": 2753,
              "column": 13
          },
          {
              "line": 2754,
              "column": 42
          },
          {
              "line": 2757,
              "column": 13
          },
          {
              "line": 2758,
              "column": 13
          },
          {
              "line": 2759,
              "column": 42
          },
          {
              "line": 2762,
              "column": 13
          },
          {
              "line": 2763,
              "column": 13
          },
          {
              "line": 2764,
              "column": 24
          },
          {
              "line": 2767,
              "column": 13
          },
          {
              "line": 2768,
              "column": 13
          },
          {
              "line": 2769,
              "column": 42
          },
          {
              "line": 2772,
              "column": 13
          },
          {
              "line": 2773,
              "column": 13
          },
          {
              "line": 2774,
              "column": 42
          },
          {
              "line": 2779,
              "column": 13
          },
          {
              "line": 2780,
              "column": 13
          },
          {
              "line": 2783,
              "column": 13
          },
          {
              "line": 2784,
              "column": 13
          },
          {
              "line": 2787,
              "column": 13
          },
          {
              "line": 2788,
              "column": 13
          },
          {
              "line": 2791,
              "column": 13
          },
          {
              "line": 2792,
              "column": 13
          },
          {
              "line": 2795,
              "column": 13
          },
          {
              "line": 2796,
              "column": 13
          },
          {
              "line": 2811,
              "column": 67
          },
          {
              "line": 2813,
              "column": 29
          },
          {
              "line": 2819,
              "column": 42
          },
          {
              "line": 2821,
              "column": 87
          },
          {
              "line": 2824,
              "column": 24
          },
          {
              "line": 2827,
              "column": 24
          },
          {
              "line": 2828,
              "column": 13
          },
          {
              "line": 2829,
              "column": 13
          },
          {
              "line": 2830,
              "column": 31
          },
          {
              "line": 2833,
              "column": 24
          },
          {
              "line": 2836,
              "column": 24
          },
          {
              "line": 2837,
              "column": 13
          },
          {
              "line": 2838,
              "column": 13
          },
          {
              "line": 2841,
              "column": 31
          },
          {
              "line": 2842,
              "column": 13
          },
          {
              "line": 2843,
              "column": 24
          },
          {
              "line": 2846,
              "column": 13
          },
          {
              "line": 2847,
              "column": 13
          },
          {
              "line": 2848,
              "column": 13
          },
          {
              "line": 2851,
              "column": 24
          },
          {
              "line": 2854,
              "column": 30
          },
          {
              "line": 2855,
              "column": 13
          },
          {
              "line": 2871,
              "column": 67
          },
          {
              "line": 2873,
              "column": 29
          },
          {
              "line": 2885,
              "column": 73
          },
          {
              "line": 2887,
              "column": 89
          },
          {
              "line": 2897,
              "column": 13
          },
          {
              "line": 2898,
              "column": 13
          },
          {
              "line": 2899,
              "column": 13
          },
          {
              "line": 2901,
              "column": 13
          },
          {
              "line": 2902,
              "column": 13
          },
          {
              "line": 2903,
              "column": 13
          },
          {
              "line": 2905,
              "column": 13
          },
          {
              "line": 2906,
              "column": 13
          },
          {
              "line": 2909,
              "column": 13
          },
          {
              "line": 2910,
              "column": 13
          },
          {
              "line": 2911,
              "column": 13
          },
          {
              "line": 2913,
              "column": 13
          },
          {
              "line": 2914,
              "column": 13
          },
          {
              "line": 2915,
              "column": 13
          },
          {
              "line": 2916,
              "column": 13
          },
          {
              "line": 2919,
              "column": 13
          },
          {
              "line": 2920,
              "column": 13
          },
          {
              "line": 2921,
              "column": 13
          },
          {
              "line": 2922,
              "column": 13
          },
          {
              "line": 2923,
              "column": 13
          },
          {
              "line": 2924,
              "column": 13
          },
          {
              "line": 2927,
              "column": 13
          },
          {
              "line": 2928,
              "column": 13
          },
          {
              "line": 2929,
              "column": 13
          },
          {
              "line": 2930,
              "column": 13
          },
          {
              "line": 2931,
              "column": 13
          },
          {
              "line": 2932,
              "column": 13
          },
          {
              "line": 2935,
              "column": 13
          },
          {
              "line": 2936,
              "column": 13
          },
          {
              "line": 2937,
              "column": 42
          },
          {
              "line": 2940,
              "column": 13
          },
          {
              "line": 2941,
              "column": 13
          },
          {
              "line": 2942,
              "column": 42
          },
          {
              "line": 2945,
              "column": 13
          },
          {
              "line": 2946,
              "column": 13
          },
          {
              "line": 2947,
              "column": 24
          },
          {
              "line": 2950,
              "column": 13
          },
          {
              "line": 2951,
              "column": 13
          },
          {
              "line": 2952,
              "column": 42
          },
          {
              "line": 2955,
              "column": 13
          },
          {
              "line": 2956,
              "column": 13
          },
          {
              "line": 2957,
              "column": 42
          },
          {
              "line": 2962,
              "column": 13
          },
          {
              "line": 2963,
              "column": 13
          },
          {
              "line": 2966,
              "column": 13
          },
          {
              "line": 2967,
              "column": 13
          },
          {
              "line": 2970,
              "column": 13
          },
          {
              "line": 2971,
              "column": 13
          },
          {
              "line": 2974,
              "column": 13
          },
          {
              "line": 2975,
              "column": 13
          },
          {
              "line": 2978,
              "column": 13
          },
          {
              "line": 2979,
              "column": 13
          },
          {
              "line": 2994,
              "column": 60
          },
          {
              "line": 2996,
              "column": 29
          },
          {
              "line": 3002,
              "column": 42
          },
          {
              "line": 3004,
              "column": 87
          },
          {
              "line": 3007,
              "column": 24
          },
          {
              "line": 3010,
              "column": 24
          },
          {
              "line": 3011,
              "column": 13
          },
          {
              "line": 3012,
              "column": 13
          },
          {
              "line": 3013,
              "column": 31
          },
          {
              "line": 3016,
              "column": 24
          },
          {
              "line": 3019,
              "column": 24
          },
          {
              "line": 3020,
              "column": 13
          },
          {
              "line": 3021,
              "column": 13
          },
          {
              "line": 3024,
              "column": 31
          },
          {
              "line": 3025,
              "column": 13
          },
          {
              "line": 3026,
              "column": 24
          },
          {
              "line": 3029,
              "column": 13
          },
          {
              "line": 3030,
              "column": 13
          },
          {
              "line": 3031,
              "column": 13
          },
          {
              "line": 3034,
              "column": 24
          },
          {
              "line": 3037,
              "column": 30
          },
          {
              "line": 3038,
              "column": 13
          },
          {
              "line": 3054,
              "column": 60
          },
          {
              "line": 3056,
              "column": 29
          },
          {
              "line": 3068,
              "column": 73
          },
          {
              "line": 3070,
              "column": 89
          },
          {
              "line": 3080,
              "column": 13
          },
          {
              "line": 3081,
              "column": 13
          },
          {
              "line": 3082,
              "column": 13
          },
          {
              "line": 3084,
              "column": 13
          },
          {
              "line": 3085,
              "column": 13
          },
          {
              "line": 3086,
              "column": 13
          },
          {
              "line": 3088,
              "column": 13
          },
          {
              "line": 3089,
              "column": 13
          },
          {
              "line": 3092,
              "column": 13
          },
          {
              "line": 3093,
              "column": 13
          },
          {
              "line": 3094,
              "column": 13
          },
          {
              "line": 3096,
              "column": 13
          },
          {
              "line": 3097,
              "column": 13
          },
          {
              "line": 3098,
              "column": 13
          },
          {
              "line": 3099,
              "column": 13
          },
          {
              "line": 3102,
              "column": 13
          },
          {
              "line": 3103,
              "column": 13
          },
          {
              "line": 3104,
              "column": 13
          },
          {
              "line": 3105,
              "column": 13
          },
          {
              "line": 3106,
              "column": 13
          },
          {
              "line": 3107,
              "column": 13
          },
          {
              "line": 3110,
              "column": 13
          },
          {
              "line": 3111,
              "column": 13
          },
          {
              "line": 3112,
              "column": 13
          },
          {
              "line": 3113,
              "column": 13
          },
          {
              "line": 3114,
              "column": 13
          },
          {
              "line": 3115,
              "column": 13
          },
          {
              "line": 3118,
              "column": 13
          },
          {
              "line": 3119,
              "column": 13
          },
          {
              "line": 3120,
              "column": 42
          },
          {
              "line": 3123,
              "column": 13
          },
          {
              "line": 3124,
              "column": 13
          },
          {
              "line": 3125,
              "column": 42
          },
          {
              "line": 3128,
              "column": 13
          },
          {
              "line": 3129,
              "column": 13
          },
          {
              "line": 3130,
              "column": 24
          },
          {
              "line": 3133,
              "column": 13
          },
          {
              "line": 3134,
              "column": 13
          },
          {
              "line": 3135,
              "column": 42
          },
          {
              "line": 3138,
              "column": 13
          },
          {
              "line": 3139,
              "column": 13
          },
          {
              "line": 3140,
              "column": 42
          },
          {
              "line": 3145,
              "column": 13
          },
          {
              "line": 3146,
              "column": 13
          },
          {
              "line": 3149,
              "column": 13
          },
          {
              "line": 3150,
              "column": 13
          },
          {
              "line": 3153,
              "column": 13
          },
          {
              "line": 3154,
              "column": 13
          },
          {
              "line": 3157,
              "column": 13
          },
          {
              "line": 3158,
              "column": 13
          },
          {
              "line": 3161,
              "column": 13
          },
          {
              "line": 3162,
              "column": 13
          },
          {
              "line": 3189,
              "column": 39
          },
          {
              "line": 3194,
              "column": 84
          },
          {
              "line": 3200,
              "column": 42
          },
          {
              "line": 3202,
              "column": 24
          },
          {
              "line": 3212,
              "column": 13
          },
          {
              "line": 3214,
              "column": 24
          },
          {
              "line": 3224,
              "column": 13
          },
          {
              "line": 3228,
              "column": 13
          },
          {
              "line": 3231,
              "column": 24
          },
          {
              "line": 3232,
              "column": 31
          },
          {
              "line": 3275,
              "column": 13
          },
          {
              "line": 3277,
              "column": 13
          },
          {
              "line": 3279,
              "column": 13
          },
          {
              "line": 3280,
              "column": 13
          },
          {
              "line": 3298,
              "column": 38
          },
          {
              "line": 3300,
              "column": 33
          },
          {
              "line": 3316,
              "column": 33
          },
          {
              "line": 3333,
              "column": 24
          },
          {
              "line": 3334,
              "column": 33
          },
          {
              "line": 3353,
              "column": 32
          },
          {
              "line": 3361,
              "column": 33
          },
          {
              "line": 3370,
              "column": 13
          },
          {
              "line": 3372,
              "column": 13
          },
          {
              "line": 3375,
              "column": 61
          },
          {
              "line": 3385,
              "column": 29
          },
          {
              "line": 3388,
              "column": 25
          },
          {
              "line": 3390,
              "column": 53
          },
          {
              "line": 3519,
              "column": 37
          },
          {
              "line": 3523,
              "column": 24
          },
          {
              "line": 3525,
              "column": 17
          },
          {
              "line": 3526,
              "column": 33
          },
          {
              "line": 3527,
              "column": 17
          },
          {
              "line": 3528,
              "column": 29
          },
          {
              "line": 3531,
              "column": 33
          },
          {
              "line": 3532,
              "column": 29
          },
          {
              "line": 3533,
              "column": 17
          },
          {
              "line": 3535,
              "column": 24
          },
          {
              "line": 3556,
              "column": 37
          },
          {
              "line": 3560,
              "column": 17
          },
          {
              "line": 3561,
              "column": 33
          },
          {
              "line": 3562,
              "column": 17
          },
          {
              "line": 3564,
              "column": 59
          },
          {
              "line": 3588,
              "column": 26
          },
          {
              "line": 3598,
              "column": 43
          },
          {
              "line": 3599,
              "column": 47
          },
          {
              "line": 3600,
              "column": 43
          },
          {
              "line": 3601,
              "column": 47
          },
          {
              "line": 3607,
              "column": 37
          },
          {
              "line": 3609,
              "column": 87
          },
          {
              "line": 3610,
              "column": 37
          },
          {
              "line": 3612,
              "column": 87
          },
          {
              "line": 3616,
              "column": 13
          },
          {
              "line": 3617,
              "column": 13
          },
          {
              "line": 3619,
              "column": 26
          },
          {
              "line": 3620,
              "column": 26
          },
          {
              "line": 3622,
              "column": 26
          },
          {
              "line": 3622,
              "column": 62
          },
          {
              "line": 3637,
              "column": 32
          },
          {
              "line": 3642,
              "column": 24
          },
          {
              "line": 3644,
              "column": 13
          },
          {
              "line": 3645,
              "column": 34
          },
          {
              "line": 3647,
              "column": 13
          },
          {
              "line": 3648,
              "column": 24
          },
          {
              "line": 3665,
              "column": 32
          },
          {
              "line": 3670,
              "column": 35
          },
          {
              "line": 3672,
              "column": 13
          },
          {
              "line": 3673,
              "column": 34
          },
          {
              "line": 3675,
              "column": 13
          },
          {
              "line": 3676,
              "column": 35
          },
          {
              "line": 3693,
              "column": 32
          },
          {
              "line": 3698,
              "column": 35
          },
          {
              "line": 3715,
              "column": 35
          },
          {
              "line": 3720,
              "column": 24
          },
          {
              "line": 3722,
              "column": 13
          },
          {
              "line": 3723,
              "column": 34
          },
          {
              "line": 3725,
              "column": 13
          },
          {
              "line": 3726,
              "column": 24
          },
          {
              "line": 3741,
              "column": 31
          },
          {
              "line": 3746,
              "column": 24
          },
          {
              "line": 3748,
              "column": 13
          },
          {
              "line": 3749,
              "column": 24
          },
          {
              "line": 3751,
              "column": 13
          },
          {
              "line": 3752,
              "column": 24
          },
          {
              "line": 3768,
              "column": 38
          },
          {
              "line": 3773,
              "column": 27
          },
          {
              "line": 3774,
              "column": 25
          },
          {
              "line": 3776,
              "column": 13
          },
          {
              "line": 3777,
              "column": 13
          },
          {
              "line": 3779,
              "column": 27
          },
          {
              "line": 3780,
              "column": 26
          },
          {
              "line": 3781,
              "column": 26
          },
          {
              "line": 3783,
              "column": 13
          },
          {
              "line": 3784,
              "column": 27
          },
          {
              "line": 3785,
              "column": 25
          },
          {
              "line": 3796,
              "column": 22
          },
          {
              "line": 3803,
              "column": 46
          },
          {
              "line": 3808,
              "column": 27
          },
          {
              "line": 3829,
              "column": 64
          },
          {
              "line": 3840,
              "column": 60
          },
          {
              "line": 3861,
              "column": 32
          },
          {
              "line": 3864,
              "column": 75
          },
          {
              "line": 3866,
              "column": 8
          },
          {
              "line": 3866,
              "column": 32
          },
          {
              "line": 3867,
              "column": 31
          },
          {
              "line": 3868,
              "column": 43
          },
          {
              "line": 3876,
              "column": 32
          },
          {
              "line": 3879,
              "column": 74
          },
          {
              "line": 3881,
              "column": 8
          },
          {
              "line": 3881,
              "column": 32
          },
          {
              "line": 3882,
              "column": 31
          },
          {
              "line": 3883,
              "column": 43
          },
          {
              "line": 3891,
              "column": 32
          },
          {
              "line": 3894,
              "column": 74
          },
          {
              "line": 3896,
              "column": 8
          },
          {
              "line": 3896,
              "column": 32
          },
          {
              "line": 3897,
              "column": 31
          },
          {
              "line": 3898,
              "column": 43
          },
          {
              "line": 3941,
              "column": 44
          },
          {
              "line": 3945,
              "column": 20
          },
          {
              "line": 3946,
              "column": 26
          },
          {
              "line": 3947,
              "column": 13
          },
          {
              "line": 3947,
              "column": 62
          },
          {
              "line": 3963,
              "column": 40
          },
          {
              "line": 3967,
              "column": 37
          },
          {
              "line": 3973,
              "column": 21
          },
          {
              "line": 3992,
              "column": 29
          },
          {
              "line": 4020,
              "column": 40
          },
          {
              "line": 4024,
              "column": 37
          },
          {
              "line": 4026,
              "column": 56
          },
          {
              "line": 4049,
              "column": 32
          },
          {
              "line": 4053,
              "column": 27
          },
          {
              "line": 4055,
              "column": 13
          },
          {
              "line": 4057,
              "column": 13
          },
          {
              "line": 4097,
              "column": 32
          },
          {
              "line": 4102,
              "column": 13
          },
          {
              "line": 4104,
              "column": 13
          },
          {
              "line": 4128,
              "column": 17
          },
          {
              "line": 4132,
              "column": 17
          },
          {
              "line": 4155,
              "column": 31
          },
          {
              "line": 4160,
              "column": 13
          },
          {
              "line": 4162,
              "column": 13
          },
          {
              "line": 4186,
              "column": 17
          },
          {
              "line": 4190,
              "column": 17
          },
          {
              "line": 4215,
              "column": 35
          },
          {
              "line": 4220,
              "column": 13
          },
          {
              "line": 4222,
              "column": 13
          },
          {
              "line": 4248,
              "column": 17
          },
          {
              "line": 4252,
              "column": 17
          },
          {
              "line": 4277,
              "column": 38
          },
          {
              "line": 4282,
              "column": 13
          },
          {
              "line": 4284,
              "column": 13
          },
          {
              "line": 4310,
              "column": 17
          },
          {
              "line": 4314,
              "column": 17
          },
          {
              "line": 4334,
              "column": 34
          },
          {
              "line": 4339,
              "column": 33
          },
          {
              "line": 4342,
              "column": 33
          },
          {
              "line": 4355,
              "column": 58
          },
          {
              "line": 4391,
              "column": 41
          },
          {
              "line": 4407,
              "column": 59
          },
          {
              "line": 4410,
              "column": 37
          },
          {
              "line": 4415,
              "column": 76
          },
          {
              "line": 4420,
              "column": 17
          },
          {
              "line": 4429,
              "column": 57
          },
          {
              "line": 4432,
              "column": 36
          },
          {
              "line": 4437,
              "column": 76
          },
          {
              "line": 4442,
              "column": 17
          },
          {
              "line": 4452,
              "column": 43
          },
          {
              "line": 4463,
              "column": 40
          },
          {
              "line": 4468,
              "column": 76
          },
          {
              "line": 4473,
              "column": 17
          },
          {
              "line": 4482,
              "column": 55
          },
          {
              "line": 4485,
              "column": 43
          },
          {
              "line": 4490,
              "column": 89
          },
          {
              "line": 4495,
              "column": 17
          },
          {
              "line": 4498,
              "column": 28
          },
          {
              "line": 4499,
              "column": 48
          },
          {
              "line": 4622,
              "column": 32
          },
          {
              "line": 4627,
              "column": 13
          },
          {
              "line": 4628,
              "column": 13
          },
          {
              "line": 4633,
              "column": 13
          },
          {
              "line": 4638,
              "column": 13
          },
          {
              "line": 4643,
              "column": 13
          },
          {
              "line": 4767,
              "column": 26
          },
          {
              "line": 4801,
              "column": 13
          },
          {
              "line": 4816,
              "column": 23
          },
          {
              "line": 4821,
              "column": 67
          },
          {
              "line": 4873,
              "column": 22
          },
          {
              "line": 4880,
              "column": 76
          },
          {
              "line": 4881,
              "column": 57
          },
          {
              "line": 4885,
              "column": 22
          },
          {
              "line": 4892,
              "column": 76
          },
          {
              "line": 4893,
              "column": 29
          },
          {
              "line": 4897,
              "column": 27
          },
          {
              "line": 4904,
              "column": 76
          },
          {
              "line": 4905,
              "column": 41
          },
          {
              "line": 4916,
              "column": 76
          },
          {
              "line": 4917,
              "column": 29
          },
          {
              "line": 4918,
              "column": 29
          },
          {
              "line": 4919,
              "column": 29
          },
          {
              "line": 4923,
              "column": 22
          },
          {
              "line": 4930,
              "column": 76
          },
          {
              "line": 4931,
              "column": 57
          },
          {
              "line": 4962,
              "column": 22
          },
          {
              "line": 4967,
              "column": 53
          },
          {
              "line": 4968,
              "column": 57
          },
          {
              "line": 5168,
              "column": 37
          },
          {
              "line": 5170,
              "column": 39
          },
          {
              "line": 5172,
              "column": 17
          },
          {
              "line": 5547,
              "column": 8
          },
          {
              "line": 5566,
              "column": 13
          },
          {
              "line": 5649,
              "column": 56
          },
          {
              "line": 5664,
              "column": 25
          },
          {
              "line": 5664,
              "column": 56
          }
      ],
      "old_name": "state",
      "new_name": "restoreState",
      "ctx": {
          "symbolName": "state",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "KeyedStateHandle",
          "scopeHint": "in restoreKeyedBackend(...)",
          "filePath": "StateBackendTestBase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "      Collections.emptyList(),\n                                new CloseableRegistry());\n\n        return backend;\n    }\n\n    protected <K> CheckpointableKeyedStateBackend<K> restoreKeyedBackend(\n            TypeSerializer<K> keySerializer, KeyedStateHandle state) throws Exception {\n        return restoreKeyedBackend(keySerializer, state, env);\n    }\n\n    protected <K> CheckpointableKeyedStateBackend<K> restoreKeyedBackend(\n            TypeSerializer<K> keySerializer, KeyedStateHandle state, Enviro",
          "conflictNames": [
              "keySerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/5553ea78488be0354a5746cae0e514fe4b5e57cc^1/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesLeaderElectionAndRetrievalITCase.java",
      "locators": [
          {
              "line": 127,
              "column": 37
          },
          {
              "line": 129,
              "column": 24
          },
          {
              "line": 132,
              "column": 63
          },
          {
              "line": 139,
              "column": 58
          }
      ],
      "old_name": "confirmedLeaderInformation",
      "new_name": "leaderInformation",
      "ctx": {
          "symbolName": "confirmedLeaderInformation",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "LeaderInformation",
          "scopeHint": "in testLeaderElectionAndRetrieval(...)",
          "filePath": "KubernetesLeaderElectionAndRetrievalITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testLeaderElectionAndRetrieval() throws Exception {\n        final String configMapName = LEADER_CONFIGMAP_NAME + UUID.randomUUID();\n        final FlinkKubeClient flinkKubeClient = KUBERNETES_EXTENSION.getFlinkKubeClient();\n        final Configuration configuration = KUBERNETES_EXTENSION.getConfiguration();\n\n        final String clusterId = configuration.getString(KubernetesConfigOptions.CLUSTER_ID);\n\n        // This will make the leader election retrieval time out if we won't process already\n        // existing leader information when starting it up.\n        configuration.set(\n                KubernetesHighAvailabilityOptions.KUBERNETES_LEASE_DURATION, Duration.ofHours(1));\n        configuration.set(\n                KubernetesHighAvailabilityOptions.KUBERNETES_RETRY_PERIOD, Duration.ofHours(1));\n        configuration.set(\n                KubernetesHighAvailabilityOptions.KUBERNETES_RENEW_DEADLINE, Duration.ofHours(1));\n\n        final List<AutoCloseable> closeables = new ArrayList<>();\n\n        final KubernetesConfigMapSharedWatcher configMapSharedWatcher =\n                flinkKubeClient.createConfigMapSharedWatcher(\n                        KubernetesUtils.getConfigMapLabels(\n                                clusterId, LABEL_CONFIGMAP_TYPE_HIGH_AVAILABILITY));\n        closeables.add(configMapSharedWatcher);\n\n        final TestingLeaderElectionEventHandler electionEventHandler =\n                new TestingLeaderElectionEventHandler(LEADER_ADDRESS);\n        closeables.add(electionEventHandler);\n\n        try {\n            final KubernetesLeaderElectionDriver leaderElectionDriver =\n                    new KubernetesLeaderElectionDriver(\n                            flinkKubeClient,\n                            configMapSharedWatcher,\n                            EXECUTOR_EXTENSION.getExecutor(),\n                            new KubernetesLeaderElectionConfiguration(\n                                    configMapName, UUID.randomUUID().toString(), configuration),\n                            electionEventHandler,\n                            electionEventHandler::handleError);\n            closeables.add(leaderElectionDriver);\n\n            electionEventHandler.init(leaderElectionDriver);\n\n            final Function<TestingLeaderRetrievalEventHandler, AutoCloseable>\n                    leaderRetrievalDriverFactory =\n                            leaderRetrievalEventHandler ->\n                                    new KubernetesLeaderRetrievalDriver(\n                                            configMapSharedWatcher,\n                                            EXECUTOR_EXTENSION.getExecutor(),\n                                            configMapName,\n                                            leaderRetrievalEventHandler,\n                                            KubernetesUtils::getLeaderInformationFromConfigMap,\n                                            leaderRetrievalEventHandler::handleError);\n\n            final TestingLeaderRetrievalEventHandler firstLeaderRetrievalEventHandler =\n                    new TestingLeaderRetrievalEventHandler();\n            closeables.add(leaderRetrievalDriverFactory.apply(firstLeaderRetrievalEventHandler));\n\n            // Wait for the driver to obtain leadership.\n            electionEventHandler.waitForLeader();\n            final LeaderInformation confirmedLeaderInformation =\n                    electionEventHandler.getConfirmedLeaderInformation();\n            assertThat(confirmedLeaderInformation.getLeaderAddress()).isEqualTo(LEADER_ADDRESS);\n\n            // Check if the leader retrieval driver is notified about the leader address\n            awaitLeadership(firstLeaderRetrievalEventHandler, confirmedLeaderInformation);\n\n            // Start a second leader retrieval that should be notified immediately because we\n            // already know who the leader is.\n            final TestingLeaderRetrievalEventHandler secondRetrievalEventHandler =\n                    new TestingLeaderRetrievalEventHandler();\n            closeables.add(leaderRetrievalDriverFactory.apply(secondRetrievalEventHandler));\n            awaitLeadership(secondRetrievalEventHandler, confirmedLeaderInformation);\n        } finally {\n            for (AutoCloseable closeable : closeables) {\n                closeable.close();\n            }\n            flinkKubeClient.deleteConfigMap(configMapName).get();\n        }\n    }",
          "conflictNames": [
              "configMapName",
              "flinkKubeClient",
              "configuration",
              "clusterId",
              "closeables",
              "configMapSharedWatcher",
              "electionEventHandler",
              "leaderElectionDriver",
              "leaderRetrievalDriverFactory",
              "firstLeaderRetrievalEventHandler",
              "secondRetrievalEventHandler"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/55630de18baf6345072113f587006dac94f61c78^1/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/JobMasterServiceLeadershipRunnerFactory.java",
      "locators": [
          {
              "line": 73,
              "column": 37
          },
          {
              "line": 125,
              "column": 17
          }
      ],
      "old_name": "jobManagerLeaderElectionService",
      "new_name": "jobManagerLeaderElection",
      "ctx": {
          "symbolName": "jobManagerLeaderElectionService",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "LeaderElectionService",
          "scopeHint": "in createJobManagerRunner(...)",
          "filePath": "JobMasterServiceLeadershipRunnerFactory.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public JobManagerRunner createJobManagerRunner(\n            JobGraph jobGraph,\n            Configuration configuration,\n            RpcService rpcService,\n            HighAvailabilityServices highAvailabilityServices,\n            HeartbeatServices heartbeatServices,\n            JobManagerSharedServices jobManagerServices,\n            JobManagerJobMetricGroupFactory jobManagerJobMetricGroupFactory,\n            FatalErrorHandler fatalErrorHandler,\n            Collection<FailureEnricher> failureEnrichers,\n            long initializationTimestamp)\n            throws Exception {\n\n        checkArgument(jobGraph.getNumberOfVertices() > 0, \"The given job is empty\");\n\n        final JobMasterConfiguration jobMasterConfiguration =\n                JobMasterConfiguration.fromConfiguration(configuration);\n\n        final JobResultStore jobResultStore = highAvailabilityServices.getJobResultStore();\n\n        final LeaderElectionService jobManagerLeaderElectionService =\n                highAvailabilityServices.getJobManagerLeaderElectionService(jobGraph.getJobID());\n\n        final SlotPoolServiceSchedulerFactory slotPoolServiceSchedulerFactory =\n                DefaultSlotPoolServiceSchedulerFactory.fromConfiguration(\n                        configuration, jobGraph.getJobType(), jobGraph.isDynamic());\n\n        if (jobMasterConfiguration.getConfiguration().get(JobManagerOptions.SCHEDULER_MODE)\n                == SchedulerExecutionMode.REACTIVE) {\n            Preconditions.checkState(\n                    slotPoolServiceSchedulerFactory.getSchedulerType()\n                            == JobManagerOptions.SchedulerType.Adaptive,\n                    \"Adaptive Scheduler is required for reactive mode\");\n        }\n\n        final LibraryCacheManager.ClassLoaderLease classLoaderLease =\n                jobManagerServices\n                        .getLibraryCacheManager()\n                        .registerClassLoaderLease(jobGraph.getJobID());\n\n        final ClassLoader userCodeClassLoader =\n                classLoaderLease\n                        .getOrResolveClassLoader(\n                                jobGraph.getUserJarBlobKeys(), jobGraph.getClasspaths())\n                        .asClassLoader();\n\n        final DefaultJobMasterServiceFactory jobMasterServiceFactory =\n                new DefaultJobMasterServiceFactory(\n                        jobManagerServices.getIoExecutor(),\n                        rpcService,\n                        jobMasterConfiguration,\n                        jobGraph,\n                        highAvailabilityServices,\n                        slotPoolServiceSchedulerFactory,\n                        jobManagerServices,\n                        heartbeatServices,\n                        jobManagerJobMetricGroupFactory,\n                        fatalErrorHandler,\n                        userCodeClassLoader,\n                        failureEnrichers,\n                        initializationTimestamp);\n\n        final DefaultJobMasterServiceProcessFactory jobMasterServiceProcessFactory =\n                new DefaultJobMasterServiceProcessFactory(\n                        jobGraph.getJobID(),\n                        jobGraph.getName(),\n                        jobGraph.getCheckpointingSettings(),\n                        initializationTimestamp,\n                        jobMasterServiceFactory);\n\n        return new JobMasterServiceLeadershipRunner(\n                jobMasterServiceProcessFactory,\n                jobManagerLeaderElectionService,\n                jobResultStore,\n                classLoaderLease,\n                fatalErrorHandler);\n    }",
          "conflictNames": [
              "jobGraph",
              "configuration",
              "rpcService",
              "highAvailabilityServices",
              "heartbeatServices",
              "jobManagerServices",
              "jobManagerJobMetricGroupFactory",
              "fatalErrorHandler",
              "failureEnrichers",
              "initializationTimestamp",
              "jobMasterConfiguration",
              "jobResultStore",
              "slotPoolServiceSchedulerFactory",
              "classLoaderLease",
              "userCodeClassLoader",
              "jobMasterServiceFactory",
              "jobMasterServiceProcessFactory"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/55630de18baf6345072113f587006dac94f61c78^1/flink-runtime/src/test/java/org/apache/flink/runtime/highavailability/nonha/embedded/EmbeddedHaServicesTest.java",
      "locators": [
          {
              "line": 76,
              "column": 31
          },
          {
              "line": 78,
              "column": 31
          },
          {
              "line": 80,
              "column": 31
          },
          {
              "line": 83,
              "column": 42
          },
          {
              "line": 86,
              "column": 42
          },
          {
              "line": 90,
              "column": 17
          },
          {
              "line": 111,
              "column": 31
          },
          {
              "line": 113,
              "column": 31
          },
          {
              "line": 116,
              "column": 42
          },
          {
              "line": 119,
              "column": 42
          },
          {
              "line": 137,
              "column": 31
          },
          {
              "line": 142,
              "column": 32
          },
          {
              "line": 146,
              "column": 35
          },
          {
              "line": 154,
              "column": 41
          },
          {
              "line": 171,
              "column": 31
          },
          {
              "line": 176,
              "column": 32
          }
      ],
      "old_name": "leaderElectionService",
      "new_name": "leaderElection",
      "ctx": {
          "symbolName": "leaderElectionService",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "LeaderElectionService",
          "scopeHint": "in testJobManagerLeaderRetrieval(...)",
          "filePath": "EmbeddedHaServicesTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Tests the JobManager leader retrieval for a given job. */\n    @Test\n    public void testJobManagerLeaderRetrieval() throws Exception {\n        JobID jobId = new JobID();\n\n        LeaderElectionService leaderElectionService =\n                embeddedHaServices.getJobManagerLeaderElectionService(jobId);\n        LeaderRetrievalService leaderRetrievalService =\n                embeddedHaServices.getJobManagerLeaderRetriever(jobId);\n\n        runLeaderRetrievalTest(leaderElectionService, leaderRetrievalService);\n    }",
          "conflictNames": [
              "jobId",
              "leaderRetrievalService"
          ]
      },
      "suggestions": [
          {
              "name": "leaderElection",
              "confidence": 0.8
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/55630de18baf6345072113f587006dac94f61c78^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterServiceLeadershipRunnerTest.java",
      "locators": [
          {
              "line": 172,
              "column": 52
          },
          {
              "line": 176,
              "column": 20
          },
          {
              "line": 178,
              "column": 26
          },
          {
              "line": 185,
              "column": 9
          },
          {
              "line": 541,
              "column": 52
          },
          {
              "line": 548,
              "column": 26
          }
      ],
      "old_name": "leaderFuture",
      "new_name": "confirmedLeaderInformation",
      "ctx": {
          "symbolName": "leaderFuture",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CompletableFuture<LeaderInformation>",
          "scopeHint": "in testConcurrentLeadershipOperationsBlockingClose(...)",
          "filePath": "JobMasterServiceLeadershipRunnerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Tests that the {@link JobMasterServiceLeadershipRunner} always waits for the previous\n     * leadership operation (granting or revoking leadership) to finish before starting a new\n     * leadership operation.\n     */\n    @Test\n    void testConcurrentLeadershipOperationsBlockingClose() throws Exception {\n        final CompletableFuture<Void> terminationFuture = new CompletableFuture<>();\n\n        final JobManagerRunner jobManagerRunner =\n                newJobMasterServiceLeadershipRunnerBuilder()\n                        .withJobMasterServiceProcesses(\n                                TestingJobMasterServiceProcess.newBuilder()\n                                        .setCloseAsyncSupplier(() -> terminationFuture)\n                                        .build(),\n                                TestingJobMasterServiceProcess.newBuilder().build())\n                        .build();\n\n        jobManagerRunner.start();\n\n        leaderElectionService.isLeader(UUID.randomUUID()).get();\n\n        leaderElectionService.notLeader();\n\n        final CompletableFuture<LeaderInformation> leaderFuture =\n                leaderElectionService.isLeader(UUID.randomUUID());\n\n        // the new leadership should wait first for the suspension to happen\n        assertThat(leaderFuture).isNotDone();\n\n        assertThatFuture(leaderFuture)\n                .withFailMessage(\n                        \"Granted leadership even though the JobMaster has not been suspended.\")\n                .willNotCompleteWithin(Duration.ofMillis(1));\n\n        terminationFuture.complete(null);\n\n        leaderFuture.get();\n    }",
          "conflictNames": [
              "terminationFuture",
              "jobManagerRunner"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/55630de18baf6345072113f587006dac94f61c78^1/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherCleanupITCase.java",
      "locators": [
          {
              "line": 161,
              "column": 44
          },
          {
              "line": 163,
              "column": 61
          },
          {
              "line": 186,
              "column": 17
          },
          {
              "line": 287,
              "column": 44
          },
          {
              "line": 289,
              "column": 61
          },
          {
              "line": 300,
              "column": 17
          },
          {
              "line": 336,
              "column": 9
          }
      ],
      "old_name": "leaderElectionService",
      "new_name": "leaderElection",
      "ctx": {
          "symbolName": "leaderElectionService",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestingLeaderElectionService",
          "scopeHint": "in testCleanupThroughRetries(...)",
          "filePath": "DispatcherCleanupITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testCleanupThroughRetries() throws Exception {\n        final JobGraph jobGraph = createJobGraph();\n        final JobID jobId = jobGraph.getJobID();\n\n        // JobGraphStore\n        final AtomicInteger actualGlobalCleanupCallCount = new AtomicInteger();\n        final OneShotLatch successfulCleanupLatch = new OneShotLatch();\n        final int numberOfErrors = 5;\n        final RuntimeException temporaryError =\n                new RuntimeException(\"Expected RuntimeException: Unable to remove job graph.\");\n        final AtomicInteger failureCount = new AtomicInteger(numberOfErrors);\n        final JobGraphStore jobGraphStore =\n                TestingJobGraphStore.newBuilder()\n                        .setGlobalCleanupFunction(\n                                (ignoredJobId, ignoredExecutor) -> {\n                                    actualGlobalCleanupCallCount.incrementAndGet();\n\n                                    if (failureCount.getAndDecrement() > 0) {\n                                        return FutureUtils.completedExceptionally(temporaryError);\n                                    }\n\n                                    successfulCleanupLatch.trigger();\n                                    return FutureUtils.completedVoidFuture();\n                                })\n                        .build();\n\n        jobGraphStore.start(NoOpJobGraphListener.INSTANCE);\n        haServices.setJobGraphStore(jobGraphStore);\n\n        // Construct leader election service.\n        final TestingLeaderElectionService leaderElectionService =\n                new TestingLeaderElectionService();\n        haServices.setJobMasterLeaderElectionService(jobId, leaderElectionService);\n\n        // start the dispatcher with enough retries on cleanup\n        final JobManagerRunnerRegistry jobManagerRunnerRegistry =\n                new DefaultJobManagerRunnerRegistry(2);\n        final Dispatcher dispatcher =\n                createTestingDispatcherBuilder()\n                        .setResourceCleanerFactory(\n                                new DispatcherResourceCleanerFactory(\n                                        ForkJoinPool.commonPool(),\n                                        TestingRetryStrategies.createWithNumberOfRetries(\n                                                numberOfErrors),\n                                        jobManagerRunnerRegistry,\n                                        haServices.getJobGraphStore(),\n                                        blobServer,\n                                        haServices,\n                                        UnregisteredMetricGroups\n                                                .createUnregisteredJobManagerMetricGroup()))\n                        .build(rpcService);\n        dispatcher.start();\n\n        toTerminate.add(dispatcher);\n        final CompletableFuture<LeaderInformation> confirmedLeaderInformation =\n                leaderElectionService.isLeader(UUID.randomUUID());\n        final DispatcherGateway dispatcherGateway =\n                dispatcher.getSelfGateway(DispatcherGateway.class);\n        dispatcherGateway.submitJob(jobGraph, TIMEOUT).get();\n\n        waitForJobToFinish(confirmedLeaderInformation, dispatcherGateway, jobId);\n\n        successfulCleanupLatch.await();\n\n        assertThat(actualGlobalCleanupCallCount.get(), equalTo(numberOfErrors + 1));\n\n        assertThat(\n                \"The JobGraph should be removed from JobGraphStore.\",\n                haServices.getJobGraphStore().getJobIds(),\n                IsEmptyCollection.empty());\n\n        CommonTestUtils.waitUntilCondition(\n                () -> haServices.getJobResultStore().hasJobResultEntry(jobId));\n    }",
          "conflictNames": [
              "jobGraph",
              "jobId",
              "actualGlobalCleanupCallCount",
              "successfulCleanupLatch",
              "numberOfErrors",
              "temporaryError",
              "failureCount",
              "jobGraphStore",
              "jobManagerRunnerRegistry",
              "dispatcher",
              "confirmedLeaderInformation",
              "dispatcherGateway"
          ]
      },
      "suggestions": [
          {
              "name": "leaderElection",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/55630de18baf6345072113f587006dac94f61c78^1/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java",
      "locators": [
          {
              "line": 155,
              "column": 42
          },
          {
              "line": 165,
              "column": 9
          },
          {
              "line": 166,
              "column": 61
          },
          {
              "line": 209,
              "column": 9
          },
          {
              "line": 213,
              "column": 17
          },
          {
              "line": 316,
              "column": 9
          },
          {
              "line": 374,
              "column": 9
          },
          {
              "line": 411,
              "column": 9
          },
          {
              "line": 445,
              "column": 9
          },
          {
              "line": 491,
              "column": 9
          },
          {
              "line": 522,
              "column": 9
          },
          {
              "line": 696,
              "column": 9
          },
          {
              "line": 939,
              "column": 9
          },
          {
              "line": 958,
              "column": 9
          },
          {
              "line": 976,
              "column": 9
          },
          {
              "line": 998,
              "column": 9
          },
          {
              "line": 1021,
              "column": 9
          },
          {
              "line": 1183,
              "column": 9
          },
          {
              "line": 1227,
              "column": 9
          },
          {
              "line": 1267,
              "column": 9
          },
          {
              "line": 1340,
              "column": 44
          },
          {
              "line": 1343,
              "column": 38
          },
          {
              "line": 1344,
              "column": 9
          },
          {
              "line": 1383,
              "column": 9
          }
      ],
      "old_name": "jobMasterLeaderElectionService",
      "new_name": "jobMasterLeaderElection",
      "ctx": {
          "symbolName": "jobMasterLeaderElectionService",
          "symbolKind": "field",
          "language": "JAVA",
          "type": "TestingLeaderElectionService",
          "scopeHint": "in DispatcherTest",
          "filePath": "DispatcherTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "rg.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\n/** Test for the {@link Dispatcher} component. */\npublic class DispatcherTest extends AbstractDispatcherTest {\n\n    private JobGraph jobGraph;\n\n    private JobID jobId;\n\n    private TestingLeaderElectionService jobMasterLeaderElectionService;\n\n    /** Instance under test. */\n    private TestingDispatcher dispatcher;\n\n    @Before\n    public void setUp() throws Exception {\n        super.setUp();\n        jobGraph = JobGraphTestUtils.singleNoOpJobGraph();\n        jobId = jobGraph.g",
          "conflictNames": [
              "jobGraph",
              "jobId",
              "dispatcher"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/55630de18baf6345072113f587006dac94f61c78^1/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/ZooKeeperDefaultDispatcherRunnerTest.java",
      "locators": [
          {
              "line": 154,
              "column": 44
          },
          {
              "line": 161,
              "column": 69
          },
          {
              "line": 192,
              "column": 29
          },
          {
              "line": 210,
              "column": 41
          },
          {
              "line": 216,
              "column": 17
          },
          {
              "line": 220,
              "column": 53
          },
          {
              "line": 233,
              "column": 17
          },
          {
              "line": 250,
              "column": 42
          },
          {
              "line": 256,
              "column": 17
          },
          {
              "line": 274,
              "column": 42
          },
          {
              "line": 276,
              "column": 16
          }
      ],
      "old_name": "dispatcherLeaderElectionService",
      "new_name": "dispatcherLeaderElection",
      "ctx": {
          "symbolName": "dispatcherLeaderElectionService",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestingLeaderElectionService",
          "scopeHint": "in testResourceCleanupUnderLeadershipChange(...)",
          "filePath": "ZooKeeperDefaultDispatcherRunnerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** See FLINK-11665. */\n    @Test\n    void testResourceCleanupUnderLeadershipChange() throws Exception {\n        final TestingRpcService rpcService =\n                testingRpcServiceExtensionWrapper.getCustomExtension().getTestingRpcService();\n        final TestingLeaderElectionService dispatcherLeaderElectionService =\n                new TestingLeaderElectionService();\n\n        try (final CuratorFrameworkWithUnhandledErrorListener curatorFrameworkWrapper =\n                        ZooKeeperUtils.startCuratorFramework(configuration, fatalErrorHandler);\n                final TestingHighAvailabilityServices highAvailabilityServices =\n                        new TestingHighAvailabilityServicesBuilder()\n                                .setDispatcherLeaderElectionService(dispatcherLeaderElectionService)\n                                .setJobMasterLeaderRetrieverFunction(\n                                        jobId ->\n                                                ZooKeeperUtils.createLeaderRetrievalService(\n                                                        curatorFrameworkWrapper\n                                                                .asCuratorFramework()))\n                                .build()) {\n\n            final PartialDispatcherServices partialDispatcherServices =\n                    new PartialDispatcherServices(\n                            configuration,\n                            highAvailabilityServices,\n                            CompletableFuture::new,\n                            blobServer,\n                            new TestingHeartbeatServices(),\n                            UnregisteredMetricGroups::createUnregisteredJobManagerMetricGroup,\n                            new MemoryExecutionGraphInfoStore(),\n                            fatalErrorHandler,\n                            VoidHistoryServerArchivist.INSTANCE,\n                            null,\n                            ForkJoinPool.commonPool(),\n                            new DispatcherOperationCaches(),\n                            Collections.emptySet());\n\n            final DefaultDispatcherRunnerFactory defaultDispatcherRunnerFactory =\n                    DefaultDispatcherRunnerFactory.createSessionRunner(\n                            SessionDispatcherFactory.INSTANCE);\n\n            try (final DispatcherRunner dispatcherRunner =\n                    createDispatcherRunner(\n                            rpcService,\n                            dispatcherLeaderElectionService,\n                            new JobPersistenceComponentFactory() {\n                                @Override\n                                public JobGraphStore createJobGraphStore() {\n                                    return createZooKeeperJobGraphStore(\n                                            curatorFrameworkWrapper.asCuratorFramework());\n                                }\n\n                                @Override\n                                public JobResultStore createJobResultStore() {\n                                    return new EmbeddedJobResultStore();\n                                }\n                            },\n                            partialDispatcherServices,\n                            defaultDispatcherRunnerFactory)) {\n\n                // initial run\n                DispatcherGateway dispatcherGateway =\n                        grantLeadership(dispatcherLeaderElectionService);\n\n                final JobGraph jobGraph = createJobGraphWithBlobs();\n                LOG.info(\"Initial job submission {}.\", jobGraph.getJobID());\n                dispatcherGateway.submitJob(jobGraph, TESTING_TIMEOUT).get();\n\n                dispatcherLeaderElectionService.notLeader();\n\n                // recovering submitted jobs\n                LOG.info(\"Re-grant leadership first time.\");\n                dispatcherGateway = grantLeadership(dispatcherLeaderElectionService);\n\n                LOG.info(\"Cancel recovered job {}.\", jobGraph.getJobID());\n                // cancellation of the job should remove everything\n                final CompletableFuture<JobResult> jobResultFuture =\n                        dispatcherGateway.requestJobResult(jobGraph.getJobID(), TESTING_TIMEOUT);\n                dispatcherGateway.cancelJob(jobGraph.getJobID(), TESTING_TIMEOUT).get();\n\n                // a successful cancellation should eventually remove all job information\n                final JobResult jobResult = jobResultFuture.get();\n\n                assertThat(jobResult.getApplicationStatus()).isEqualTo(ApplicationStatus.CANCELED);\n\n                dispatcherLeaderElectionService.notLeader();\n\n                // check that the job has been removed from ZooKeeper\n                final JobGraphStore submittedJobGraphStore =\n                        createZooKeeperJobGraphStore(curatorFrameworkWrapper.asCuratorFramework());\n\n                CommonTestUtils.waitUntilCondition(\n                        () -> submittedJobGraphStore.getJobIds().isEmpty(), 20L);\n            }\n        }\n\n        // check resource clean up\n        assertThat(clusterHaStorageDir).isEmptyDirectory();\n    }",
          "conflictNames": [
              "rpcService",
              "curatorFrameworkWrapper",
              "highAvailabilityServices",
              "partialDispatcherServices",
              "defaultDispatcherRunnerFactory",
              "dispatcherRunner",
              "dispatcherGateway",
              "jobGraph",
              "jobResultFuture",
              "jobResult",
              "submittedJobGraphStore"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/55630de18baf6345072113f587006dac94f61c78^1/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/nonha/embedded/EmbeddedLeaderService.java",
      "locators": [
          {
              "line": 50,
              "column": 29
          },
          {
              "line": 52,
              "column": 19
          },
          {
              "line": 53,
              "column": 15
          },
          {
              "line": 80,
              "column": 26
          },
          {
              "line": 96,
              "column": 40
          },
          {
              "line": 99,
              "column": 90
          },
          {
              "line": 104,
              "column": 63
          },
          {
              "line": 117,
              "column": 43
          },
          {
              "line": 117,
              "column": 92
          },
          {
              "line": 123,
              "column": 46
          },
          {
              "line": 139,
              "column": 48
          },
          {
              "line": 140,
              "column": 17
          },
          {
              "line": 145,
              "column": 49
          },
          {
              "line": 146,
              "column": 17
          },
          {
              "line": 159,
              "column": 48
          },
          {
              "line": 164,
              "column": 48
          },
          {
              "line": 172,
              "column": 63
          },
          {
              "line": 173,
              "column": 61
          },
          {
              "line": 175,
              "column": 52
          },
          {
              "line": 176,
              "column": 25
          },
          {
              "line": 176,
              "column": 59
          },
          {
              "line": 179,
              "column": 46
          },
          {
              "line": 181,
              "column": 46
          },
          {
              "line": 181,
              "column": 72
          },
          {
              "line": 184,
              "column": 17
          },
          {
              "line": 185,
              "column": 17
          },
          {
              "line": 200,
              "column": 62
          },
          {
              "line": 201,
              "column": 64
          },
          {
              "line": 203,
              "column": 23
          },
          {
              "line": 204,
              "column": 18
          },
          {
              "line": 209,
              "column": 49
          },
          {
              "line": 211,
              "column": 46
          },
          {
              "line": 211,
              "column": 78
          },
          {
              "line": 214,
              "column": 29
          },
          {
              "line": 215,
              "column": 21
          },
          {
              "line": 216,
              "column": 21
          },
          {
              "line": 218,
              "column": 17
          },
          {
              "line": 219,
              "column": 17
          },
          {
              "line": 220,
              "column": 17
          },
          {
              "line": 223,
              "column": 47
          },
          {
              "line": 228,
              "column": 46
          },
          {
              "line": 248,
              "column": 49
          },
          {
              "line": 252,
              "column": 23
          },
          {
              "line": 253,
              "column": 18
          },
          {
              "line": 259,
              "column": 21
          },
          {
              "line": 267,
              "column": 46
          },
          {
              "line": 335,
              "column": 44
          },
          {
              "line": 337,
              "column": 52
          },
          {
              "line": 338,
              "column": 25
          },
          {
              "line": 338,
              "column": 60
          },
          {
              "line": 341,
              "column": 36
          },
          {
              "line": 343,
              "column": 47
          },
          {
              "line": 343,
              "column": 73
          },
          {
              "line": 346,
              "column": 17
          },
          {
              "line": 347,
              "column": 17
          },
          {
              "line": 359,
              "column": 64
          },
          {
              "line": 361,
              "column": 23
          },
          {
              "line": 362,
              "column": 18
          },
          {
              "line": 367,
              "column": 39
          },
          {
              "line": 369,
              "column": 47
          },
          {
              "line": 369,
              "column": 79
          },
          {
              "line": 372,
              "column": 29
          },
          {
              "line": 373,
              "column": 17
          },
          {
              "line": 374,
              "column": 17
          },
          {
              "line": 438,
              "column": 32
          }
      ],
      "old_name": "service",
      "new_name": "leaderElection",
      "ctx": {
          "symbolName": "service",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "EmbeddedLeaderElectionService",
          "scopeHint": "in shutdownInternally(...)",
          "filePath": "EmbeddedLeaderService.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": " status\n            currentLeaderProposed = null;\n            currentLeaderConfirmed = null;\n            currentLeaderSessionId = null;\n            currentLeaderAddress = null;\n\n            // fail all registered listeners\n            for (EmbeddedLeaderElectionService service : allLeaderContenders) {\n                service.shutdown(exceptionForHandlers);\n            }\n            allLeaderContenders.clear();\n\n            // fail all registered listeners\n            for (EmbeddedLeaderRetrievalService service :",
          "conflictNames": [
              "exceptionForHandlers"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/55630de18baf6345072113f587006dac94f61c78^1/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/nonha/embedded/EmbeddedLeaderService.java",
      "locators": [
          {
              "line": 307,
              "column": 47
          },
          {
              "line": 310,
              "column": 41
          },
          {
              "line": 315,
              "column": 25
          },
          {
              "line": 318,
              "column": 49
          },
          {
              "line": 405,
              "column": 53
          },
          {
              "line": 408,
              "column": 21
          },
          {
              "line": 410,
              "column": 21
          },
          {
              "line": 413,
              "column": 56
          },
          {
              "line": 414,
              "column": 17
          },
          {
              "line": 416,
              "column": 58
          }
      ],
      "old_name": "leaderService",
      "new_name": "embeddedLeaderElection",
      "ctx": {
          "symbolName": "leaderService",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "EmbeddedLeaderElectionService",
          "scopeHint": "in updateLeader(...)",
          "filePath": "EmbeddedLeaderService.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@GuardedBy(\"lock\")\n    private CompletableFuture<Void> updateLeader() {\n        // this must be called under the lock\n        Preconditions.checkState(Thread.holdsLock(lock));\n\n        if (currentLeaderConfirmed == null && currentLeaderProposed == null) {\n            // we need a new leader\n            if (allLeaderContenders.isEmpty()) {\n                // no new leader available, tell everyone that there is no leader currently\n                return notifyAllListeners(null, null);\n            } else {\n                // propose a leader and ask it\n                final UUID leaderSessionId = UUID.randomUUID();\n                EmbeddedLeaderElectionService leaderService = allLeaderContenders.iterator().next();\n\n                currentLeaderSessionId = leaderSessionId;\n                currentLeaderProposed = leaderService;\n                currentLeaderProposed.isLeader = true;\n\n                LOG.info(\n                        \"Proposing leadership to contender {}\",\n                        leaderService.contender.getDescription());\n\n                return execute(\n                        new GrantLeadershipCall(leaderService.contender, leaderSessionId, LOG));\n            }\n        } else {\n            return CompletableFuture.completedFuture(null);\n        }\n    }",
          "conflictNames": [
              "leaderSessionId"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/55630de18baf6345072113f587006dac94f61c78^1/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerHATest.java",
      "locators": [
          {
              "line": 39,
              "column": 44
          },
          {
              "line": 44,
              "column": 53
          }
      ],
      "old_name": "leaderElectionService",
      "new_name": "leaderElection",
      "ctx": {
          "symbolName": "leaderElectionService",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestingLeaderElectionService",
          "scopeHint": "in testGrantAndRevokeLeadership(...)",
          "filePath": "ResourceManagerHATest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testGrantAndRevokeLeadership() throws Exception {\n        final TestingLeaderElectionService leaderElectionService =\n                new TestingLeaderElectionService();\n\n        final TestingResourceManagerService resourceManagerService =\n                TestingResourceManagerService.newBuilder()\n                        .setRmLeaderElectionService(leaderElectionService)\n                        .build();\n\n        try {\n            resourceManagerService.start();\n\n            final UUID leaderId = UUID.randomUUID();\n            final LeaderInformation confirmedLeaderInformation =\n                    resourceManagerService.isLeader(leaderId).join();\n\n            // after grant leadership, verify resource manager is started with the fencing token\n            assertEquals(leaderId, confirmedLeaderInformation.getLeaderSessionID());\n            assertTrue(resourceManagerService.getResourceManagerFencingToken().isPresent());\n            assertEquals(\n                    leaderId,\n                    resourceManagerService.getResourceManagerFencingToken().get().toUUID());\n\n            // then revoke leadership, verify resource manager is closed\n            final Optional<CompletableFuture<Void>> rmTerminationFutureOpt =\n                    resourceManagerService.getResourceManagerTerminationFuture();\n            assertTrue(rmTerminationFutureOpt.isPresent());\n\n            resourceManagerService.notLeader();\n            rmTerminationFutureOpt.get().get();\n\n            resourceManagerService.rethrowFatalErrorIfAny();\n        } finally {\n            resourceManagerService.cleanUp();\n        }\n    }",
          "conflictNames": [
              "resourceManagerService",
              "leaderId",
              "confirmedLeaderInformation",
              "rmTerminationFutureOpt"
          ]
      },
      "suggestions": [
          {
              "name": "leaderElection",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/55630de18baf6345072113f587006dac94f61c78^1/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerJobMasterTest.java",
      "locators": [
          {
              "line": 93,
              "column": 44
          },
          {
              "line": 107,
              "column": 53
          }
      ],
      "old_name": "leaderElectionService",
      "new_name": "leaderElection",
      "ctx": {
          "symbolName": "leaderElectionService",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestingLeaderElectionService",
          "scopeHint": "in createAndStartResourceManagerService(...)",
          "filePath": "ResourceManagerJobMasterTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void createAndStartResourceManagerService() throws Exception {\n        final TestingLeaderElectionService leaderElectionService =\n                new TestingLeaderElectionService();\n        resourceManagerService =\n                TestingResourceManagerService.newBuilder()\n                        .setRpcService(rpcService)\n                        .setJmLeaderRetrieverFunction(\n                                requestedJobId -> {\n                                    if (requestedJobId.equals(jobId)) {\n                                        return jobMasterLeaderRetrievalService;\n                                    } else {\n                                        throw new FlinkRuntimeException(\n                                                String.format(\"Unknown job id %s\", jobId));\n                                    }\n                                })\n                        .setRmLeaderElectionService(leaderElectionService)\n                        .build();\n\n        resourceManagerService.start();\n        resourceManagerService.isLeader(UUID.randomUUID()).join();\n\n        resourceManagerGateway =\n                resourceManagerService\n                        .getResourceManagerGateway()\n                        .orElseThrow(\n                                () ->\n                                        new AssertionError(\n                                                \"RM not available after confirming leadership.\"));\n    }"
      },
      "suggestions": [
          {
              "name": "leaderElection",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/55630de18baf6345072113f587006dac94f61c78^1/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerPartitionLifecycleTest.java",
      "locators": [
          {
              "line": 202,
              "column": 44
          },
          {
              "line": 208,
              "column": 53
          }
      ],
      "old_name": "leaderElectionService",
      "new_name": "leaderElection",
      "ctx": {
          "symbolName": "leaderElectionService",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestingLeaderElectionService",
          "scopeHint": "in createAndStartResourceManager(...)",
          "filePath": "ResourceManagerPartitionLifecycleTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private ResourceManagerGateway createAndStartResourceManager() throws Exception {\n        final TestingLeaderElectionService leaderElectionService =\n                new TestingLeaderElectionService();\n\n        resourceManagerService =\n                TestingResourceManagerService.newBuilder()\n                        .setRpcService(rpcService)\n                        .setRmLeaderElectionService(leaderElectionService)\n                        .build();\n        resourceManagerService.start();\n\n        // first make the ResourceManager the leader\n        resourceManagerService.isLeader(UUID.randomUUID()).join();\n\n        return resourceManagerService\n                .getResourceManagerGateway()\n                .orElseThrow(\n                        () -> new AssertionError(\"RM not available after confirming leadership.\"));\n    }"
      },
      "suggestions": [
          {
              "name": "leaderElection",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/55630de18baf6345072113f587006dac94f61c78^1/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerTaskExecutorTest.java",
      "locators": [
          {
              "line": 131,
              "column": 44
          },
          {
              "line": 136,
              "column": 53
          }
      ],
      "old_name": "leaderElectionService",
      "new_name": "leaderElection",
      "ctx": {
          "symbolName": "leaderElectionService",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestingLeaderElectionService",
          "scopeHint": "in createAndStartResourceManager(...)",
          "filePath": "ResourceManagerTaskExecutorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void createAndStartResourceManager() throws Exception {\n        final TestingLeaderElectionService leaderElectionService =\n                new TestingLeaderElectionService();\n        rmService =\n                TestingResourceManagerService.newBuilder()\n                        .setRpcService(rpcService)\n                        .setRmLeaderElectionService(leaderElectionService)\n                        .build();\n\n        rmService.start();\n        rmService.isLeader(UUID.randomUUID()).join();\n\n        rmGateway =\n                rmService\n                        .getResourceManagerGateway()\n                        .orElseThrow(\n                                () ->\n                                        new AssertionError(\n                                                \"RM not available after confirming leadership.\"));\n    }"
      },
      "suggestions": [
          {
              "name": "leaderElection",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/55de8d683cc56733c03c11f927f511b2ba712851^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/calcite/FlinkConvertletTable.java",
      "locators": [
          {
              "line": 112,
              "column": 23
          },
          {
              "line": 113,
              "column": 17
          },
          {
              "line": 113,
              "column": 39
          },
          {
              "line": 166,
              "column": 23
          },
          {
              "line": 168,
              "column": 59
          }
      ],
      "old_name": "operands",
      "new_name": "operator",
      "ctx": {
          "symbolName": "operands",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<SqlNode>",
          "scopeHint": "in isSetSemanticsWindowTableFunction(...)",
          "filePath": "FlinkConvertletTable.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private boolean isSetSemanticsWindowTableFunction(SqlCall call) {\n        if (!(call.getOperator() instanceof SqlWindowTableFunction)) {\n            return false;\n        }\n        List<SqlNode> operands = call.getOperandList();\n        return !operands.isEmpty() && operands.get(0).getKind() == SqlKind.SET_SEMANTICS_TABLE;\n    }",
          "conflictNames": [
              "call"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/55de8d683cc56733c03c11f927f511b2ba712851^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/ProjectWindowTableFunctionTransposeRule.java",
      "locators": [
          {
              "line": 181,
              "column": 38
          },
          {
              "line": 183,
              "column": 35
          },
          {
              "line": 185,
              "column": 35
          },
          {
              "line": 186,
              "column": 20
          }
      ],
      "old_name": "originalCall",
      "new_name": "tableArgCall",
      "ctx": {
          "symbolName": "originalCall",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RexSetSemanticsTableCall",
          "scopeHint": "in rewriteWindowCall(...)",
          "filePath": "ProjectWindowTableFunctionTransposeRule.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private RexNode rewriteWindowCall(\n            RexCall windowCall, Map<Integer, Integer> mapping, RelBuilder relBuilder) {\n        List<RexNode> newOperands = new ArrayList<>();\n        for (RexNode next : windowCall.getOperands()) {\n            newOperands.add(adjustInputRef(next, mapping));\n        }\n        if (windowCall instanceof RexSetSemanticsTableCall) {\n            RexSetSemanticsTableCall originalCall = (RexSetSemanticsTableCall) windowCall;\n            int[] newPartitionKeys =\n                    Arrays.stream(originalCall.getPartitionKeys()).map(mapping::get).toArray();\n            int[] newOrderKeys =\n                    Arrays.stream(originalCall.getOrderKeys()).map(mapping::get).toArray();\n            return originalCall.copy(newOperands, newPartitionKeys, newOrderKeys);\n        }\n        return relBuilder.call(windowCall.getOperator(), newOperands);\n    }",
          "conflictNames": [
              "windowCall",
              "mapping",
              "relBuilder",
              "newOperands",
              "newPartitionKeys",
              "newOrderKeys"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/5682472e4029c25d4a2651a609c999029fa3281b^1/flink-clients/src/test/java/org/apache/flink/client/program/rest/RestClusterClientTest.java",
      "locators": [
          {
              "line": 691,
              "column": 22
          },
          {
              "line": 695,
              "column": 60
          },
          {
              "line": 697,
              "column": 54
          }
      ],
      "old_name": "configuredHostname",
      "new_name": "httpProtocol",
      "ctx": {
          "symbolName": "configuredHostname",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in testRESTManualConfigurationOverride(...)",
          "filePath": "RestClusterClientTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Tests that command line options override the configuration settings. */\n    @Test\n    void testRESTManualConfigurationOverride() throws Exception {\n        final String configuredHostname = \"localhost\";\n        final int configuredPort = 1234;\n        final Configuration configuration = new Configuration();\n\n        configuration.setString(JobManagerOptions.ADDRESS, configuredHostname);\n        configuration.setInteger(JobManagerOptions.PORT, configuredPort);\n        configuration.setString(RestOptions.ADDRESS, configuredHostname);\n        configuration.setInteger(RestOptions.PORT, configuredPort);\n\n        final DefaultCLI defaultCLI = new DefaultCLI();\n\n        final String manualHostname = \"123.123.123.123\";\n        final int manualPort = 4321;\n        final String[] args = {\"-m\", manualHostname + ':' + manualPort};\n\n        CommandLine commandLine = defaultCLI.parseCommandLineOptions(args, false);\n\n        final ClusterClientServiceLoader serviceLoader = new DefaultClusterClientServiceLoader();\n        final Configuration executorConfig = defaultCLI.toConfiguration(commandLine);\n\n        final ClusterClientFactory<StandaloneClusterId> clusterFactory =\n                serviceLoader.getClusterClientFactory(executorConfig);\n        checkState(clusterFactory != null);\n\n        final ClusterDescriptor<StandaloneClusterId> clusterDescriptor =\n                clusterFactory.createClusterDescriptor(executorConfig);\n        final RestClusterClient<?> clusterClient =\n                (RestClusterClient<?>)\n                        clusterDescriptor\n                                .retrieve(clusterFactory.getClusterId(executorConfig))\n                                .getClusterClient();\n\n        URL webMonitorBaseUrl = clusterClient.getWebMonitorBaseUrl().get();\n        assertThat(webMonitorBaseUrl).hasHost(manualHostname).hasPort(manualPort);\n    }",
          "conflictNames": [
              "configuredPort",
              "configuration",
              "defaultCLI",
              "manualHostname",
              "manualPort",
              "args",
              "commandLine",
              "serviceLoader",
              "executorConfig",
              "clusterFactory",
              "clusterDescriptor",
              "clusterClient",
              "webMonitorBaseUrl"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/56c81995d3b34ed9066b6771755407b93438f5ab^1/flink-runtime/src/main/java/org/apache/flink/runtime/state/filesystem/FsCheckpointStreamFactory.java",
      "locators": [
          {
              "line": 136,
              "column": 41
          },
          {
              "line": 138,
              "column": 71
          },
          {
              "line": 140,
              "column": 72
          }
      ],
      "old_name": "duplicatingFileSystem",
      "new_name": "pathsCopyingFileSystem",
      "ctx": {
          "symbolName": "duplicatingFileSystem",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "DuplicatingFileSystem",
          "scopeHint": "in FsCheckpointStreamFactory(...)",
          "filePath": "FsCheckpointStreamFactory.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Creates a new stream factory that stores its checkpoint data in the file system and location\n     * defined by the given Path.\n     *\n     * <p><b>Important:</b> The given checkpoint directory must already exist. Refer to the\n     * class-level JavaDocs for an explanation why this factory must not try and create the\n     * checkpoints.\n     *\n     * @param fileSystem The filesystem to write to.\n     * @param checkpointDirectory The directory for checkpoint exclusive state data.\n     * @param sharedStateDirectory The directory for shared checkpoint data.\n     * @param fileStateSizeThreshold State up to this size will be stored as part of the metadata,\n     *     rather than in files\n     * @param writeBufferSize The write buffer size.\n     */\n    public FsCheckpointStreamFactory(\n            FileSystem fileSystem,\n            Path checkpointDirectory,\n            Path sharedStateDirectory,\n            int fileStateSizeThreshold,\n            int writeBufferSize) {\n\n        if (fileStateSizeThreshold < 0) {\n            throw new IllegalArgumentException(\n                    \"The threshold for file state size must be zero or larger.\");\n        }\n\n        if (writeBufferSize < 0) {\n            throw new IllegalArgumentException(\"The write buffer size must be zero or larger.\");\n        }\n\n        if (fileStateSizeThreshold > MAX_FILE_STATE_THRESHOLD) {\n            throw new IllegalArgumentException(\n                    \"The threshold for file state size cannot be larger than \"\n                            + MAX_FILE_STATE_THRESHOLD);\n        }\n\n        this.filesystem = checkNotNull(fileSystem);\n        this.checkpointDirectory = checkNotNull(checkpointDirectory);\n        this.sharedStateDirectory = checkNotNull(sharedStateDirectory);\n        this.fileStateThreshold = fileStateSizeThreshold;\n        this.writeBufferSize = writeBufferSize;\n        if (fileSystem instanceof DuplicatingFileSystem) {\n            final DuplicatingFileSystem duplicatingFileSystem = (DuplicatingFileSystem) fileSystem;\n            this.privateStateToolset =\n                    new FsCheckpointStateToolset(checkpointDirectory, duplicatingFileSystem);\n            this.sharedStateToolset =\n                    new FsCheckpointStateToolset(sharedStateDirectory, duplicatingFileSystem);\n        } else {\n            this.privateStateToolset = null;\n            this.sharedStateToolset = null;\n        }\n    }",
          "conflictNames": [
              "fileSystem",
              "checkpointDirectory",
              "sharedStateDirectory",
              "fileStateSizeThreshold",
              "writeBufferSize"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/5749a07b072803a6f106e287f40db069abc3feaf^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/physical/batch/BatchPhysicalConstantTableFunctionScanRule.java",
      "locators": [
          {
              "line": 50,
              "column": 24
          },
          {
              "line": 75,
              "column": 19
          },
          {
              "line": 87,
              "column": 32
          },
          {
              "line": 96,
              "column": 26
          }
      ],
      "old_name": "correlate",
      "new_name": "replacement",
      "ctx": {
          "symbolName": "correlate",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "BatchPhysicalCorrelate",
          "scopeHint": "in onMatch(...)",
          "filePath": "BatchPhysicalConstantTableFunctionScanRule.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public void onMatch(RelOptRuleCall call) {\n        FlinkLogicalTableFunctionScan scan = call.rel(0);\n\n        // create correlate left\n        RelOptCluster cluster = scan.getCluster();\n        RelTraitSet traitSet =\n                call.getPlanner().emptyTraitSet().replace(FlinkConventions.BATCH_PHYSICAL());\n        BatchPhysicalValues values =\n                new BatchPhysicalValues(\n                        cluster,\n                        traitSet,\n                        ImmutableList.of(ImmutableList.of()),\n                        cluster.getTypeFactory()\n                                .createStructType(ImmutableList.of(), ImmutableList.of()));\n\n        BatchPhysicalCorrelate correlate =\n                new BatchPhysicalCorrelate(\n                        cluster,\n                        traitSet,\n                        values,\n                        scan,\n                        Option.empty(),\n                        scan.getRowType(),\n                        JoinRelType.INNER);\n        call.transformTo(correlate);\n    }",
          "conflictNames": [
              "call",
              "scan",
              "cluster",
              "traitSet",
              "values"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/5749a07b072803a6f106e287f40db069abc3feaf^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/physical/stream/StreamPhysicalConstantTableFunctionScanRule.java",
      "locators": [
          {
              "line": 50,
              "column": 24
          },
          {
              "line": 77,
              "column": 19
          },
          {
              "line": 89,
              "column": 33
          },
          {
              "line": 98,
              "column": 26
          }
      ],
      "old_name": "correlate",
      "new_name": "replacement",
      "ctx": {
          "symbolName": "correlate",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "StreamPhysicalCorrelate",
          "scopeHint": "in onMatch(...)",
          "filePath": "StreamPhysicalConstantTableFunctionScanRule.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public void onMatch(RelOptRuleCall call) {\n        FlinkLogicalTableFunctionScan scan = call.rel(0);\n\n        // create correlate left\n        RelOptCluster cluster = scan.getCluster();\n        RelTraitSet traitSet =\n                call.getPlanner().emptyTraitSet().replace(FlinkConventions.STREAM_PHYSICAL());\n        StreamPhysicalValues values =\n                new StreamPhysicalValues(\n                        cluster,\n                        traitSet,\n                        ImmutableList.of(ImmutableList.of()),\n                        cluster.getTypeFactory()\n                                .createStructType(ImmutableList.of(), ImmutableList.of()));\n\n        StreamPhysicalCorrelate correlate =\n                new StreamPhysicalCorrelate(\n                        cluster,\n                        traitSet,\n                        values,\n                        scan,\n                        Option.empty(),\n                        scan.getRowType(),\n                        JoinRelType.INNER);\n        call.transformTo(correlate);\n    }",
          "conflictNames": [
              "call",
              "scan",
              "cluster",
              "traitSet",
              "values"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/575517bbb8de36b21632e54b441b7dcbc4d061c4^1/flink-runtime/src/main/java/org/apache/flink/runtime/security/modules/HadoopModule.java",
      "locators": [
          {
              "line": 85,
              "column": 33
          },
          {
              "line": 97,
              "column": 29
          }
      ],
      "old_name": "credentialsFromTokenStorageFile",
      "new_name": "credentials",
      "ctx": {
          "symbolName": "credentialsFromTokenStorageFile",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Credentials",
          "scopeHint": "in install(...)",
          "filePath": "HadoopModule.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void install() throws SecurityInstallException {\n\n        UserGroupInformation.setConfiguration(hadoopConfiguration);\n\n        UserGroupInformation loginUser;\n\n        try {\n            if (UserGroupInformation.isSecurityEnabled()\n                    && !StringUtils.isBlank(securityConfig.getKeytab())\n                    && !StringUtils.isBlank(securityConfig.getPrincipal())) {\n                String keytabPath = (new File(securityConfig.getKeytab())).getAbsolutePath();\n\n                UserGroupInformation.loginUserFromKeytab(securityConfig.getPrincipal(), keytabPath);\n\n                loginUser = UserGroupInformation.getLoginUser();\n\n                // supplement with any available tokens\n                String fileLocation =\n                        System.getenv(UserGroupInformation.HADOOP_TOKEN_FILE_LOCATION);\n                if (fileLocation != null) {\n                    Credentials credentialsFromTokenStorageFile =\n                            Credentials.readTokenStorageFile(\n                                    new File(fileLocation), hadoopConfiguration);\n\n                    // if UGI uses Kerberos keytabs for login, do not load HDFS delegation token\n                    // since\n                    // the UGI would prefer the delegation token instead, which eventually expires\n                    // and does not fallback to using Kerberos tickets\n                    Credentials credentialsToBeAdded = new Credentials();\n                    final Text hdfsDelegationTokenKind = new Text(\"HDFS_DELEGATION_TOKEN\");\n                    final Text hbaseDelegationTokenKind = new Text(\"HBASE_AUTH_TOKEN\");\n                    Collection<Token<? extends TokenIdentifier>> usrTok =\n                            credentialsFromTokenStorageFile.getAllTokens();\n                    // If UGI use keytab for login, do not load HDFS/HBase delegation token.\n                    for (Token<? extends TokenIdentifier> token : usrTok) {\n                        if (!token.getKind().equals(hdfsDelegationTokenKind)\n                                && !token.getKind().equals(hbaseDelegationTokenKind)) {\n                            credentialsToBeAdded.addToken(token.getService(), token);\n                        }\n                    }\n\n                    loginUser.addCredentials(credentialsToBeAdded);\n                }\n            } else {\n                // login with current user credentials (e.g. ticket cache, OS login)\n                // note that the stored tokens are read automatically\n                try {\n                    // Use reflection API to get the login user object\n                    // UserGroupInformation.loginUserFromSubject(null);\n                    Method loginUserFromSubjectMethod =\n                            UserGroupInformation.class.getMethod(\n                                    \"loginUserFromSubject\", Subject.class);\n                    loginUserFromSubjectMethod.invoke(null, (Subject) null);\n                } catch (NoSuchMethodException e) {\n                    LOG.warn(\"Could not find method implementations in the shaded jar.\", e);\n                } catch (InvocationTargetException e) {\n                    throw e.getTargetException();\n                }\n\n                loginUser = UserGroupInformation.getLoginUser();\n            }\n\n            LOG.info(\"Hadoop user set to {}\", loginUser);\n\n            if (HadoopUtils.isKerberosSecurityEnabled(loginUser)) {\n                boolean isCredentialsConfigured =\n                        HadoopUtils.areKerberosCredentialsValid(\n                                loginUser, securityConfig.useTicketCache());\n\n                LOG.info(\n                        \"Kerberos security is enabled and credentials are {}.\",\n                        isCredentialsConfigured ? \"valid\" : \"invalid\");\n            }\n        } catch (Throwable ex) {\n            throw new SecurityInstallException(\"Unable to set the Hadoop login user\", ex);\n        }\n    }",
          "conflictNames": [
              "loginUser",
              "keytabPath",
              "fileLocation",
              "credentialsToBeAdded",
              "hdfsDelegationTokenKind",
              "hbaseDelegationTokenKind",
              "usrTok",
              "loginUserFromSubjectMethod",
              "isCredentialsConfigured"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/575517bbb8de36b21632e54b441b7dcbc4d061c4^1/flink-runtime/src/main/java/org/apache/flink/runtime/security/modules/HadoopModule.java",
      "locators": [
          {
              "line": 130,
              "column": 25
          },
          {
              "line": 136,
              "column": 25
          }
      ],
      "old_name": "isCredentialsConfigured",
      "new_name": "isKerberosSecurityEnabled",
      "ctx": {
          "symbolName": "isCredentialsConfigured",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "boolean",
          "scopeHint": "in install(...)",
          "filePath": "HadoopModule.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void install() throws SecurityInstallException {\n\n        UserGroupInformation.setConfiguration(hadoopConfiguration);\n\n        UserGroupInformation loginUser;\n\n        try {\n            if (UserGroupInformation.isSecurityEnabled()\n                    && !StringUtils.isBlank(securityConfig.getKeytab())\n                    && !StringUtils.isBlank(securityConfig.getPrincipal())) {\n                String keytabPath = (new File(securityConfig.getKeytab())).getAbsolutePath();\n\n                UserGroupInformation.loginUserFromKeytab(securityConfig.getPrincipal(), keytabPath);\n\n                loginUser = UserGroupInformation.getLoginUser();\n\n                // supplement with any available tokens\n                String fileLocation =\n                        System.getenv(UserGroupInformation.HADOOP_TOKEN_FILE_LOCATION);\n                if (fileLocation != null) {\n                    Credentials credentialsFromTokenStorageFile =\n                            Credentials.readTokenStorageFile(\n                                    new File(fileLocation), hadoopConfiguration);\n\n                    // if UGI uses Kerberos keytabs for login, do not load HDFS delegation token\n                    // since\n                    // the UGI would prefer the delegation token instead, which eventually expires\n                    // and does not fallback to using Kerberos tickets\n                    Credentials credentialsToBeAdded = new Credentials();\n                    final Text hdfsDelegationTokenKind = new Text(\"HDFS_DELEGATION_TOKEN\");\n                    final Text hbaseDelegationTokenKind = new Text(\"HBASE_AUTH_TOKEN\");\n                    Collection<Token<? extends TokenIdentifier>> usrTok =\n                            credentialsFromTokenStorageFile.getAllTokens();\n                    // If UGI use keytab for login, do not load HDFS/HBase delegation token.\n                    for (Token<? extends TokenIdentifier> token : usrTok) {\n                        if (!token.getKind().equals(hdfsDelegationTokenKind)\n                                && !token.getKind().equals(hbaseDelegationTokenKind)) {\n                            credentialsToBeAdded.addToken(token.getService(), token);\n                        }\n                    }\n\n                    loginUser.addCredentials(credentialsToBeAdded);\n                }\n            } else {\n                // login with current user credentials (e.g. ticket cache, OS login)\n                // note that the stored tokens are read automatically\n                try {\n                    // Use reflection API to get the login user object\n                    // UserGroupInformation.loginUserFromSubject(null);\n                    Method loginUserFromSubjectMethod =\n                            UserGroupInformation.class.getMethod(\n                                    \"loginUserFromSubject\", Subject.class);\n                    loginUserFromSubjectMethod.invoke(null, (Subject) null);\n                } catch (NoSuchMethodException e) {\n                    LOG.warn(\"Could not find method implementations in the shaded jar.\", e);\n                } catch (InvocationTargetException e) {\n                    throw e.getTargetException();\n                }\n\n                loginUser = UserGroupInformation.getLoginUser();\n            }\n\n            LOG.info(\"Hadoop user set to {}\", loginUser);\n\n            if (HadoopUtils.isKerberosSecurityEnabled(loginUser)) {\n                boolean isCredentialsConfigured =\n                        HadoopUtils.areKerberosCredentialsValid(\n                                loginUser, securityConfig.useTicketCache());\n\n                LOG.info(\n                        \"Kerberos security is enabled and credentials are {}.\",\n                        isCredentialsConfigured ? \"valid\" : \"invalid\");\n            }\n        } catch (Throwable ex) {\n            throw new SecurityInstallException(\"Unable to set the Hadoop login user\", ex);\n        }\n    }",
          "conflictNames": [
              "loginUser",
              "keytabPath",
              "fileLocation",
              "credentialsFromTokenStorageFile",
              "credentialsToBeAdded",
              "hdfsDelegationTokenKind",
              "hbaseDelegationTokenKind",
              "usrTok",
              "loginUserFromSubjectMethod"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/583722e721a121fa7a6787fe5acb47949b30454a^1/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/filemerging/WithinCheckpointFileMergingSnapshotManager.java",
      "locators": [
          {
              "line": 3,
              "column": 60
          },
          {
              "line": 5,
              "column": 58
          },
          {
              "line": 7,
              "column": 37
          },
          {
              "line": 19,
              "column": 45
          },
          {
              "line": 32,
              "column": 55
          },
          {
              "line": 35,
              "column": 38
          },
          {
              "line": 39,
              "column": 43
          },
          {
              "line": 40,
              "column": 30
          },
          {
              "line": 42,
              "column": 31
          },
          {
              "line": 48,
              "column": 34
          },
          {
              "line": 71,
              "column": 15
          },
          {
              "line": 72,
              "column": 14
          },
          {
              "line": 75,
              "column": 58
          },
          {
              "line": 77,
              "column": 22
          },
          {
              "line": 79,
              "column": 13
          },
          {
              "line": 79,
              "column": 52
          },
          {
              "line": 81,
              "column": 13
          },
          {
              "line": 82,
              "column": 13
          },
          {
              "line": 85,
              "column": 9
          },
          {
              "line": 87,
              "column": 13
          },
          {
              "line": 87,
              "column": 52
          },
          {
              "line": 89,
              "column": 13
          },
          {
              "line": 90,
              "column": 13
          },
          {
              "line": 99,
              "column": 41
          },
          {
              "line": 100,
              "column": 58
          },
          {
              "line": 105,
              "column": 22
          },
          {
              "line": 107,
              "column": 13
          },
          {
              "line": 107,
              "column": 52
          },
          {
              "line": 108,
              "column": 17
          },
          {
              "line": 109,
              "column": 17
          },
          {
              "line": 112,
              "column": 16
          },
          {
              "line": 119,
              "column": 41
          },
          {
              "line": 121,
              "column": 58
          },
          {
              "line": 128,
              "column": 60
          },
          {
              "line": 130,
              "column": 30
          },
          {
              "line": 145,
              "column": 36
          }
      ],
      "old_name": "file",
      "new_name": "filePool",
      "ctx": {
          "symbolName": "file",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "PhysicalFile",
          "scopeHint": "in removeAndCloseFiles(...)",
          "filePath": "WithinCheckpointFileMergingSnapshotManager.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Remove files that belongs to specific subtask and checkpoint from the reuse pool. And close\n     * these files. TODO: Refactor this in FLINK-32076.\n     */\n    private void removeAndCloseFiles(SubtaskKey subtaskKey, long checkpointId) throws Exception {\n        Tuple3<Long, SubtaskKey, CheckpointedStateScope> fileKey =\n                Tuple3.of(checkpointId, subtaskKey, CheckpointedStateScope.SHARED);\n        PhysicalFile file;\n        synchronized (writablePhysicalFilePool) {\n            file = writablePhysicalFilePool.remove(fileKey);\n        }\n        if (file != null) {\n            file.close();\n        }\n\n        fileKey = Tuple3.of(checkpointId, DUMMY_SUBTASK_KEY, CheckpointedStateScope.EXCLUSIVE);\n        synchronized (writablePhysicalFilePool) {\n            file = writablePhysicalFilePool.remove(fileKey);\n        }\n        if (file != null) {\n            file.close();\n        }\n    }",
          "conflictNames": [
              "subtaskKey",
              "checkpointId",
              "fileKey"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/583722e721a121fa7a6787fe5acb47949b30454a^1/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManagerTest.java",
      "locators": [
          {
              "line": 142,
              "column": 26
          },
          {
              "line": 145,
              "column": 24
          },
          {
              "line": 154,
              "column": 44
          },
          {
              "line": 157,
              "column": 65
          },
          {
              "line": 165,
              "column": 44
          },
          {
              "line": 173,
              "column": 41
          }
      ],
      "old_name": "file6",
      "new_name": "file7",
      "ctx": {
          "symbolName": "file6",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "PhysicalFile",
          "scopeHint": "in testCreateAndReuseFiles(...)",
          "filePath": "FileMergingSnapshotManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testCreateAndReuseFiles() throws IOException {\n        try (FileMergingSnapshotManagerBase fmsm =\n                (FileMergingSnapshotManagerBase)\n                        createFileMergingSnapshotManager(checkpointBaseDir)) {\n            fmsm.registerSubtaskForSharedStates(subtaskKey1);\n            fmsm.registerSubtaskForSharedStates(subtaskKey2);\n            // firstly, we try shared state.\n            PhysicalFile file1 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file1.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            // allocate another\n            PhysicalFile file2 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file2.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file2).isNotEqualTo(file1);\n\n            // return for reuse\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file1);\n\n            // allocate for another subtask\n            PhysicalFile file3 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey2, 0, CheckpointedStateScope.SHARED);\n            assertThat(file3.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.SHARED));\n            assertThat(file3).isNotEqualTo(file1);\n\n            // allocate for another checkpoint\n            PhysicalFile file4 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 1, CheckpointedStateScope.SHARED);\n            assertThat(file4.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file4).isNotEqualTo(file1);\n\n            // allocate for this checkpoint\n            PhysicalFile file5 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file5.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file5).isEqualTo(file1);\n\n            // Secondly, we try private state\n            PhysicalFile file6 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file6.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n\n            // allocate another\n            PhysicalFile file7 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file7.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file7).isNotEqualTo(file6);\n\n            // return for reuse\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file6);\n\n            // allocate for another checkpoint\n            PhysicalFile file8 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 1, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file8.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file8).isNotEqualTo(file6);\n\n            // allocate for this checkpoint but another subtask\n            PhysicalFile file9 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey2, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file9.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file9).isEqualTo(file6);\n\n            assertThat(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.EXCLUSIVE))\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n        }\n    }",
          "conflictNames": [
              "fmsm",
              "file1",
              "file2",
              "file3",
              "file4",
              "file5",
              "file7",
              "file8",
              "file9"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/583722e721a121fa7a6787fe5acb47949b30454a^1/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManagerTest.java",
      "locators": [
          {
              "line": 149,
              "column": 26
          },
          {
              "line": 152,
              "column": 24
          },
          {
              "line": 154,
              "column": 24
          }
      ],
      "old_name": "file7",
      "new_name": "file8",
      "ctx": {
          "symbolName": "file7",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "PhysicalFile",
          "scopeHint": "in testCreateAndReuseFiles(...)",
          "filePath": "FileMergingSnapshotManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testCreateAndReuseFiles() throws IOException {\n        try (FileMergingSnapshotManagerBase fmsm =\n                (FileMergingSnapshotManagerBase)\n                        createFileMergingSnapshotManager(checkpointBaseDir)) {\n            fmsm.registerSubtaskForSharedStates(subtaskKey1);\n            fmsm.registerSubtaskForSharedStates(subtaskKey2);\n            // firstly, we try shared state.\n            PhysicalFile file1 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file1.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            // allocate another\n            PhysicalFile file2 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file2.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file2).isNotEqualTo(file1);\n\n            // return for reuse\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file1);\n\n            // allocate for another subtask\n            PhysicalFile file3 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey2, 0, CheckpointedStateScope.SHARED);\n            assertThat(file3.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.SHARED));\n            assertThat(file3).isNotEqualTo(file1);\n\n            // allocate for another checkpoint\n            PhysicalFile file4 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 1, CheckpointedStateScope.SHARED);\n            assertThat(file4.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file4).isNotEqualTo(file1);\n\n            // allocate for this checkpoint\n            PhysicalFile file5 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file5.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file5).isEqualTo(file1);\n\n            // Secondly, we try private state\n            PhysicalFile file6 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file6.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n\n            // allocate another\n            PhysicalFile file7 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file7.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file7).isNotEqualTo(file6);\n\n            // return for reuse\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file6);\n\n            // allocate for another checkpoint\n            PhysicalFile file8 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 1, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file8.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file8).isNotEqualTo(file6);\n\n            // allocate for this checkpoint but another subtask\n            PhysicalFile file9 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey2, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file9.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file9).isEqualTo(file6);\n\n            assertThat(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.EXCLUSIVE))\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n        }\n    }",
          "conflictNames": [
              "fmsm",
              "file1",
              "file2",
              "file3",
              "file4",
              "file5",
              "file6",
              "file8",
              "file9"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/583722e721a121fa7a6787fe5acb47949b30454a^1/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManagerTest.java",
      "locators": [
          {
              "line": 160,
              "column": 26
          },
          {
              "line": 163,
              "column": 24
          },
          {
              "line": 165,
              "column": 24
          }
      ],
      "old_name": "file8",
      "new_name": "file9",
      "ctx": {
          "symbolName": "file8",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "PhysicalFile",
          "scopeHint": "in testCreateAndReuseFiles(...)",
          "filePath": "FileMergingSnapshotManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testCreateAndReuseFiles() throws IOException {\n        try (FileMergingSnapshotManagerBase fmsm =\n                (FileMergingSnapshotManagerBase)\n                        createFileMergingSnapshotManager(checkpointBaseDir)) {\n            fmsm.registerSubtaskForSharedStates(subtaskKey1);\n            fmsm.registerSubtaskForSharedStates(subtaskKey2);\n            // firstly, we try shared state.\n            PhysicalFile file1 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file1.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            // allocate another\n            PhysicalFile file2 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file2.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file2).isNotEqualTo(file1);\n\n            // return for reuse\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file1);\n\n            // allocate for another subtask\n            PhysicalFile file3 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey2, 0, CheckpointedStateScope.SHARED);\n            assertThat(file3.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.SHARED));\n            assertThat(file3).isNotEqualTo(file1);\n\n            // allocate for another checkpoint\n            PhysicalFile file4 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 1, CheckpointedStateScope.SHARED);\n            assertThat(file4.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file4).isNotEqualTo(file1);\n\n            // allocate for this checkpoint\n            PhysicalFile file5 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file5.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file5).isEqualTo(file1);\n\n            // Secondly, we try private state\n            PhysicalFile file6 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file6.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n\n            // allocate another\n            PhysicalFile file7 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file7.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file7).isNotEqualTo(file6);\n\n            // return for reuse\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file6);\n\n            // allocate for another checkpoint\n            PhysicalFile file8 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 1, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file8.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file8).isNotEqualTo(file6);\n\n            // allocate for this checkpoint but another subtask\n            PhysicalFile file9 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey2, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file9.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file9).isEqualTo(file6);\n\n            assertThat(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.EXCLUSIVE))\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n        }\n    }",
          "conflictNames": [
              "fmsm",
              "file1",
              "file2",
              "file3",
              "file4",
              "file5",
              "file6",
              "file7",
              "file9"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/583722e721a121fa7a6787fe5acb47949b30454a^1/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManagerTest.java",
      "locators": [
          {
              "line": 168,
              "column": 26
          },
          {
              "line": 171,
              "column": 24
          },
          {
              "line": 173,
              "column": 24
          }
      ],
      "old_name": "file9",
      "new_name": "file10",
      "ctx": {
          "symbolName": "file9",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "PhysicalFile",
          "scopeHint": "in testCreateAndReuseFiles(...)",
          "filePath": "FileMergingSnapshotManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testCreateAndReuseFiles() throws IOException {\n        try (FileMergingSnapshotManagerBase fmsm =\n                (FileMergingSnapshotManagerBase)\n                        createFileMergingSnapshotManager(checkpointBaseDir)) {\n            fmsm.registerSubtaskForSharedStates(subtaskKey1);\n            fmsm.registerSubtaskForSharedStates(subtaskKey2);\n            // firstly, we try shared state.\n            PhysicalFile file1 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file1.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            // allocate another\n            PhysicalFile file2 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file2.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file2).isNotEqualTo(file1);\n\n            // return for reuse\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file1);\n\n            // allocate for another subtask\n            PhysicalFile file3 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey2, 0, CheckpointedStateScope.SHARED);\n            assertThat(file3.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.SHARED));\n            assertThat(file3).isNotEqualTo(file1);\n\n            // allocate for another checkpoint\n            PhysicalFile file4 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 1, CheckpointedStateScope.SHARED);\n            assertThat(file4.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file4).isNotEqualTo(file1);\n\n            // allocate for this checkpoint\n            PhysicalFile file5 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file5.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file5).isEqualTo(file1);\n\n            // Secondly, we try private state\n            PhysicalFile file6 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file6.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n\n            // allocate another\n            PhysicalFile file7 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file7.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file7).isNotEqualTo(file6);\n\n            // return for reuse\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file6);\n\n            // allocate for another checkpoint\n            PhysicalFile file8 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 1, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file8.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file8).isNotEqualTo(file6);\n\n            // allocate for this checkpoint but another subtask\n            PhysicalFile file9 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey2, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file9.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file9).isEqualTo(file6);\n\n            assertThat(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.EXCLUSIVE))\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n        }\n    }",
          "conflictNames": [
              "fmsm",
              "file1",
              "file2",
              "file3",
              "file4",
              "file5",
              "file6",
              "file7",
              "file8"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/584dc46b45d951c916a696db2f7a8e17af893679^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulkCheckerImplTest.java",
      "locators": [
          {
              "line": 127,
              "column": 29
          },
          {
              "line": 130,
              "column": 45
          },
          {
              "line": 133,
              "column": 57
          },
          {
              "line": 138,
              "column": 29
          },
          {
              "line": 139,
              "column": 80
          },
          {
              "line": 141,
              "column": 35
          },
          {
              "line": 201,
              "column": 29
          },
          {
              "line": 203,
              "column": 47
          },
          {
              "line": 207,
              "column": 35
          },
          {
              "line": 239,
              "column": 30
          },
          {
              "line": 242,
              "column": 55
          },
          {
              "line": 248,
              "column": 30
          },
          {
              "line": 251,
              "column": 28
          },
          {
              "line": 251,
              "column": 44
          },
          {
              "line": 252,
              "column": 39
          },
          {
              "line": 258,
              "column": 80
          },
          {
              "line": 260,
              "column": 36
          }
      ],
      "old_name": "slotRequestId",
      "new_name": "executionVertexID",
      "ctx": {
          "symbolName": "slotRequestId",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SlotRequestId",
          "scopeHint": "in testUnfulfillableBulkIsCancelled(...)",
          "filePath": "PhysicalSlotRequestBulkCheckerImplTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testUnfulfillableBulkIsCancelled() {\n        final CompletableFuture<SlotRequestId> cancellationFuture = new CompletableFuture<>();\n        final SlotRequestId slotRequestId = new SlotRequestId();\n        final PhysicalSlotRequestBulk bulk =\n                createPhysicalSlotRequestBulkWithCancellationFuture(\n                        cancellationFuture, slotRequestId);\n        bulkChecker.schedulePendingRequestBulkTimeoutCheck(bulk, TIMEOUT);\n        clock.advanceTime(TIMEOUT.toMillis() + 1L, TimeUnit.MILLISECONDS);\n        assertThat(cancellationFuture.join()).isEqualTo(slotRequestId);\n    }",
          "conflictNames": [
              "cancellationFuture",
              "bulk"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/584dc46b45d951c916a696db2f7a8e17af893679^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulkCheckerImplTest.java",
      "locators": [
          {
              "line": 127,
              "column": 29
          },
          {
              "line": 130,
              "column": 45
          },
          {
              "line": 133,
              "column": 57
          },
          {
              "line": 138,
              "column": 29
          },
          {
              "line": 139,
              "column": 80
          },
          {
              "line": 141,
              "column": 35
          },
          {
              "line": 201,
              "column": 29
          },
          {
              "line": 203,
              "column": 47
          },
          {
              "line": 207,
              "column": 35
          },
          {
              "line": 239,
              "column": 30
          },
          {
              "line": 242,
              "column": 55
          },
          {
              "line": 248,
              "column": 30
          },
          {
              "line": 251,
              "column": 28
          },
          {
              "line": 251,
              "column": 44
          },
          {
              "line": 252,
              "column": 39
          },
          {
              "line": 258,
              "column": 80
          },
          {
              "line": 260,
              "column": 36
          }
      ],
      "old_name": "slotRequestId",
      "new_name": "executionSlotSharingGroup",
      "ctx": {
          "symbolName": "slotRequestId",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SlotRequestId",
          "scopeHint": "in testUnfulfillableBulkIsCancelled(...)",
          "filePath": "PhysicalSlotRequestBulkCheckerImplTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testUnfulfillableBulkIsCancelled() {\n        final CompletableFuture<SlotRequestId> cancellationFuture = new CompletableFuture<>();\n        final SlotRequestId slotRequestId = new SlotRequestId();\n        final PhysicalSlotRequestBulk bulk =\n                createPhysicalSlotRequestBulkWithCancellationFuture(\n                        cancellationFuture, slotRequestId);\n        bulkChecker.schedulePendingRequestBulkTimeoutCheck(bulk, TIMEOUT);\n        clock.advanceTime(TIMEOUT.toMillis() + 1L, TimeUnit.MILLISECONDS);\n        assertThat(cancellationFuture.join()).isEqualTo(slotRequestId);\n    }",
          "conflictNames": [
              "cancellationFuture",
              "bulk"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/593e443cd85962ffa512e26d1a900eccf5f705ca^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/disk/DiskIOScheduler.java",
      "locators": [
          {
              "line": 93,
              "column": 8
          },
          {
              "line": 209,
              "column": 28
          },
          {
              "line": 210,
              "column": 52
          },
          {
              "line": 211,
              "column": 70
          },
          {
              "line": 310,
              "column": 59
          }
      ],
      "old_name": "exception",
      "new_name": "e",
      "ctx": {
          "symbolName": "exception",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Exception",
          "scopeHint": "in readBuffersFromFile(...)",
          "filePath": "DiskIOScheduler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "itionReader> scheduledReaders = sortScheduledReaders();\n        if (scheduledReaders.isEmpty()) {\n            return 0;\n        }\n        Queue<MemorySegment> buffers;\n        try {\n            buffers = allocateBuffers();\n        } catch (Exception exception) {\n            failScheduledReaders(scheduledReaders, exception);\n            LOG.error(\"Failed to request buffers for data reading.\", exception);\n            return 0;\n        }\n\n        int numBuffersAllocated = buffers.size();\n        i",
          "conflictNames": [
              "scheduledReaders",
              "buffers",
              "numBuffersAllocated",
              "numBuffersRead"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/593e443cd85962ffa512e26d1a900eccf5f705ca^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/disk/DiskIOScheduler.java",
      "locators": [
          {
              "line": 226,
              "column": 32
          },
          {
              "line": 227,
              "column": 82
          },
          {
              "line": 228,
              "column": 59
          },
          {
              "line": 287,
              "column": 32
          },
          {
              "line": 290,
              "column": 49
          },
          {
              "line": 308,
              "column": 52
          },
          {
              "line": 309,
              "column": 71
          },
          {
              "line": 313,
              "column": 69
          },
          {
              "line": 391,
              "column": 40
          },
          {
              "line": 393,
              "column": 31
          }
      ],
      "old_name": "throwable",
      "new_name": "e",
      "ctx": {
          "symbolName": "throwable",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Exception",
          "scopeHint": "in readBuffersFromFile(...)",
          "filePath": "DiskIOScheduler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "SubpartitionReader scheduledReader : scheduledReaders) {\n            if (buffers.isEmpty()) {\n                break;\n            }\n            try {\n                scheduledReader.loadDiskDataToBuffers(buffers, this);\n            } catch (Exception throwable) {\n                failScheduledReaders(Collections.singletonList(scheduledReader), throwable);\n                LOG.debug(\"Failed to read shuffle data.\", throwable);\n            }\n        }\n        int numBuffersRead = numBuffersAllocated ",
          "conflictNames": [
              "scheduledReaders",
              "buffers",
              "numBuffersAllocated",
              "numBuffersRead"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/593e443cd85962ffa512e26d1a900eccf5f705ca^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/disk/DiskIOScheduler.java",
      "locators": [
          {
              "line": 226,
              "column": 32
          },
          {
              "line": 227,
              "column": 82
          },
          {
              "line": 228,
              "column": 59
          },
          {
              "line": 287,
              "column": 32
          },
          {
              "line": 290,
              "column": 49
          },
          {
              "line": 308,
              "column": 52
          },
          {
              "line": 309,
              "column": 71
          },
          {
              "line": 313,
              "column": 69
          },
          {
              "line": 391,
              "column": 40
          },
          {
              "line": 393,
              "column": 31
          }
      ],
      "old_name": "throwable",
      "new_name": "t",
      "ctx": {
          "symbolName": "throwable",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Exception",
          "scopeHint": "in readBuffersFromFile(...)",
          "filePath": "DiskIOScheduler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "SubpartitionReader scheduledReader : scheduledReaders) {\n            if (buffers.isEmpty()) {\n                break;\n            }\n            try {\n                scheduledReader.loadDiskDataToBuffers(buffers, this);\n            } catch (Exception throwable) {\n                failScheduledReaders(Collections.singletonList(scheduledReader), throwable);\n                LOG.debug(\"Failed to read shuffle data.\", throwable);\n            }\n        }\n        int numBuffersRead = numBuffersAllocated ",
          "conflictNames": [
              "scheduledReaders",
              "buffers",
              "numBuffersAllocated",
              "numBuffersRead"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/593e443cd85962ffa512e26d1a900eccf5f705ca^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/disk/DiskIOScheduler.java",
      "locators": [
          {
              "line": 226,
              "column": 32
          },
          {
              "line": 227,
              "column": 82
          },
          {
              "line": 228,
              "column": 59
          },
          {
              "line": 287,
              "column": 32
          },
          {
              "line": 290,
              "column": 49
          },
          {
              "line": 308,
              "column": 52
          },
          {
              "line": 309,
              "column": 71
          },
          {
              "line": 313,
              "column": 69
          },
          {
              "line": 391,
              "column": 40
          },
          {
              "line": 393,
              "column": 31
          }
      ],
      "old_name": "throwable",
      "new_name": "exception",
      "ctx": {
          "symbolName": "throwable",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Exception",
          "scopeHint": "in readBuffersFromFile(...)",
          "filePath": "DiskIOScheduler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "SubpartitionReader scheduledReader : scheduledReaders) {\n            if (buffers.isEmpty()) {\n                break;\n            }\n            try {\n                scheduledReader.loadDiskDataToBuffers(buffers, this);\n            } catch (Exception throwable) {\n                failScheduledReaders(Collections.singletonList(scheduledReader), throwable);\n                LOG.debug(\"Failed to read shuffle data.\", throwable);\n            }\n        }\n        int numBuffersRead = numBuffersAllocated ",
          "conflictNames": [
              "scheduledReaders",
              "buffers",
              "numBuffersAllocated",
              "numBuffersRead"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/5a4e0ea31aef51dfc50b9c401c91c7b869a154c4^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptivebatch/AdaptiveBatchSchedulerTest.java",
      "locators": [
          {
              "line": 98,
              "column": 19
          },
          {
              "line": 110,
              "column": 20
          },
          {
              "line": 111,
              "column": 71
          },
          {
              "line": 129,
              "column": 19
          },
          {
              "line": 141,
              "column": 20
          },
          {
              "line": 142,
              "column": 71
          },
          {
              "line": 160,
              "column": 19
          },
          {
              "line": 184,
              "column": 34
          },
          {
              "line": 184,
              "column": 81
          },
          {
              "line": 190,
              "column": 20
          },
          {
              "line": 191,
              "column": 71
          },
          {
              "line": 193,
              "column": 80
          },
          {
              "line": 205,
              "column": 17
          },
          {
              "line": 212,
              "column": 89
          },
          {
              "line": 224,
              "column": 51
          },
          {
              "line": 379,
              "column": 25
          },
          {
              "line": 379,
              "column": 52
          },
          {
              "line": 383,
              "column": 17
          },
          {
              "line": 387,
              "column": 13
          },
          {
              "line": 389,
              "column": 54
          }
      ],
      "old_name": "source1",
      "new_name": "source",
      "ctx": {
          "symbolName": "source1",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobVertex",
          "scopeHint": "in testAdaptiveBatchScheduler(...)",
          "filePath": "AdaptiveBatchSchedulerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testAdaptiveBatchScheduler() throws Exception {\n        JobGraph jobGraph = createJobGraph(false);\n        Iterator<JobVertex> jobVertexIterator = jobGraph.getVertices().iterator();\n        JobVertex source1 = jobVertexIterator.next();\n        JobVertex source2 = jobVertexIterator.next();\n        JobVertex sink = jobVertexIterator.next();\n\n        SchedulerBase scheduler = createScheduler(jobGraph);\n\n        final DefaultExecutionGraph graph = (DefaultExecutionGraph) scheduler.getExecutionGraph();\n        final ExecutionJobVertex sinkExecutionJobVertex = graph.getJobVertex(sink.getID());\n\n        scheduler.startScheduling();\n        assertThat(sinkExecutionJobVertex.getParallelism()).isEqualTo(-1);\n\n        // trigger source1 finished.\n        transitionExecutionsState(scheduler, ExecutionState.FINISHED, source1);\n        assertThat(sinkExecutionJobVertex.getParallelism()).isEqualTo(-1);\n\n        // trigger source2 finished.\n        transitionExecutionsState(scheduler, ExecutionState.FINISHED, source2);\n        assertThat(sinkExecutionJobVertex.getParallelism()).isEqualTo(10);\n\n        // check that the jobGraph is updated\n        assertThat(sink.getParallelism()).isEqualTo(10);\n\n        // check aggregatedInputDataBytes of each ExecutionVertex calculated.\n        checkAggregatedInputDataBytesIsCalculated(sinkExecutionJobVertex);\n    }",
          "conflictNames": [
              "jobGraph",
              "jobVertexIterator",
              "source2",
              "sink",
              "scheduler",
              "graph",
              "sinkExecutionJobVertex"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/5a4e0ea31aef51dfc50b9c401c91c7b869a154c4^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptivebatch/AdaptiveBatchSchedulerTest.java",
      "locators": [
          {
              "line": 99,
              "column": 19
          },
          {
              "line": 114,
              "column": 20
          },
          {
              "line": 115,
              "column": 71
          },
          {
              "line": 130,
              "column": 19
          },
          {
              "line": 145,
              "column": 20
          },
          {
              "line": 146,
              "column": 71
          },
          {
              "line": 161,
              "column": 19
          },
          {
              "line": 196,
              "column": 20
          },
          {
              "line": 197,
              "column": 71
          },
          {
              "line": 199,
              "column": 80
          },
          {
              "line": 380,
              "column": 25
          },
          {
              "line": 380,
              "column": 52
          },
          {
              "line": 385,
              "column": 17
          },
          {
              "line": 389,
              "column": 63
          }
      ],
      "old_name": "source2",
      "new_name": "map",
      "ctx": {
          "symbolName": "source2",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobVertex",
          "scopeHint": "in testAdaptiveBatchScheduler(...)",
          "filePath": "AdaptiveBatchSchedulerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testAdaptiveBatchScheduler() throws Exception {\n        JobGraph jobGraph = createJobGraph(false);\n        Iterator<JobVertex> jobVertexIterator = jobGraph.getVertices().iterator();\n        JobVertex source1 = jobVertexIterator.next();\n        JobVertex source2 = jobVertexIterator.next();\n        JobVertex sink = jobVertexIterator.next();\n\n        SchedulerBase scheduler = createScheduler(jobGraph);\n\n        final DefaultExecutionGraph graph = (DefaultExecutionGraph) scheduler.getExecutionGraph();\n        final ExecutionJobVertex sinkExecutionJobVertex = graph.getJobVertex(sink.getID());\n\n        scheduler.startScheduling();\n        assertThat(sinkExecutionJobVertex.getParallelism()).isEqualTo(-1);\n\n        // trigger source1 finished.\n        transitionExecutionsState(scheduler, ExecutionState.FINISHED, source1);\n        assertThat(sinkExecutionJobVertex.getParallelism()).isEqualTo(-1);\n\n        // trigger source2 finished.\n        transitionExecutionsState(scheduler, ExecutionState.FINISHED, source2);\n        assertThat(sinkExecutionJobVertex.getParallelism()).isEqualTo(10);\n\n        // check that the jobGraph is updated\n        assertThat(sink.getParallelism()).isEqualTo(10);\n\n        // check aggregatedInputDataBytes of each ExecutionVertex calculated.\n        checkAggregatedInputDataBytesIsCalculated(sinkExecutionJobVertex);\n    }",
          "conflictNames": [
              "jobGraph",
              "jobVertexIterator",
              "source1",
              "sink",
              "scheduler",
              "graph",
              "sinkExecutionJobVertex"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/5a63c56ca0b38ebae9fc475708917c35a4168844^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/operators/join/stream/StreamingJoinOperator.java",
      "locators": [
          {
              "line": 212,
              "column": 17
          },
          {
              "line": 274,
              "column": 43
          },
          {
              "line": 300,
              "column": 39
          }
      ],
      "old_name": "inputRowKind",
      "new_name": "originalRowKind",
      "ctx": {
          "symbolName": "inputRowKind",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RowKind",
          "scopeHint": "in processElement(...)",
          "filePath": "StreamingJoinOperator.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Process an input element and output incremental joined records, retraction messages will be\n     * sent in some scenarios.\n     *\n     * <p>Following is the pseudo code to describe the core logic of this method. The logic of this\n     * method is too complex, so we provide the pseudo code to help understand the logic. We should\n     * keep sync the following pseudo code with the real logic of the method.\n     *\n     * <p>Note: \"+I\" represents \"INSERT\", \"-D\" represents \"DELETE\", \"+U\" represents \"UPDATE_AFTER\",\n     * \"-U\" represents \"UPDATE_BEFORE\". We forward input RowKind if it is inner join, otherwise, we\n     * always send insert and delete for simplification. We can optimize this to send -U & +U\n     * instead of D & I in the future (see FLINK-17337). They are equivalent in this join case. It\n     * may need some refactoring if we want to send -U & +U, so we still keep -D & +I for now for\n     * simplification. See {@code\n     * FlinkChangelogModeInferenceProgram.SatisfyModifyKindSetTraitVisitor}.\n     *\n     * <pre>\n     * if input record is accumulate\n     * |  if input side is outer\n     * |  |  if there is no matched rows on the other side, send +I[record+null], state.add(record, 0)\n     * |  |  if there are matched rows on the other side\n     * |  |  | if other side is outer\n     * |  |  | |  if the matched num in the matched rows == 0, send -D[null+other]\n     * |  |  | |  if the matched num in the matched rows > 0, skip\n     * |  |  | |  otherState.update(other, old + 1)\n     * |  |  | endif\n     * |  |  | send +I[record+other]s, state.add(record, other.size)\n     * |  |  endif\n     * |  endif\n     * |  if input side not outer\n     * |  |  state.add(record)\n     * |  |  if there is no matched rows on the other side, skip\n     * |  |  if there are matched rows on the other side\n     * |  |  |  if other side is outer\n     * |  |  |  |  if the matched num in the matched rows == 0, send -D[null+other]\n     * |  |  |  |  if the matched num in the matched rows > 0, skip\n     * |  |  |  |  otherState.update(other, old + 1)\n     * |  |  |  |  send +I[record+other]s\n     * |  |  |  else\n     * |  |  |  |  send +I/+U[record+other]s (using input RowKind)\n     * |  |  |  endif\n     * |  |  endif\n     * |  endif\n     * endif\n     *\n     * if input record is retract\n     * |  state.retract(record)\n     * |  if there is no matched rows on the other side\n     * |  | if input side is outer, send -D[record+null]\n     * |  endif\n     * |  if there are matched rows on the other side, send -D[record+other]s if outer, send -D/-U[record+other]s if inner.\n     * |  |  if other side is outer\n     * |  |  |  if the matched num in the matched rows == 0, this should never happen!\n     * |  |  |  if the matched num in the matched rows == 1, send +I[null+other]\n     * |  |  |  if the matched num in the matched rows > 1, skip\n     * |  |  |  otherState.update(other, old - 1)\n     * |  |  endif\n     * |  endif\n     * endif\n     * </pre>\n     *\n     * @param input the input element\n     * @param inputSideStateView state of input side\n     * @param otherSideStateView state of other side\n     * @param inputIsLeft whether input side is left side\n     * @param isSuppress whether suppress the output of redundant messages when the other side is\n     *     outer join. This only applies to the case of mini-batch.\n     */\n    protected void processElement(\n            RowData input,\n            JoinRecordStateView inputSideStateView,\n            JoinRecordStateView otherSideStateView,\n            boolean inputIsLeft,\n            boolean isSuppress)\n            throws Exception {\n        boolean inputIsOuter = inputIsLeft ? leftIsOuter : rightIsOuter;\n        boolean otherIsOuter = inputIsLeft ? rightIsOuter : leftIsOuter;\n        boolean isAccumulateMsg = RowDataUtil.isAccumulateMsg(input);\n        RowKind inputRowKind = input.getRowKind();\n        input.setRowKind(RowKind.INSERT); // erase RowKind for later state updating\n\n        AssociatedRecords associatedRecords =\n                AssociatedRecords.of(input, inputIsLeft, otherSideStateView, joinCondition);\n        if (isAccumulateMsg) { // record is accumulate\n            if (inputIsOuter) { // input side is outer\n                OuterJoinRecordStateView inputSideOuterStateView =\n                        (OuterJoinRecordStateView) inputSideStateView;\n                if (associatedRecords.isEmpty()) { // there is no matched rows on the other side\n                    // send +I[record+null]\n                    outRow.setRowKind(RowKind.INSERT);\n                    outputNullPadding(input, inputIsLeft);\n                    // state.add(record, 0)\n                    inputSideOuterStateView.addRecord(input, 0);\n                } else { // there are matched rows on the other side\n                    if (otherIsOuter) { // other side is outer\n                        OuterJoinRecordStateView otherSideOuterStateView =\n                                (OuterJoinRecordStateView) otherSideStateView;\n                        for (OuterRecord outerRecord : associatedRecords.getOuterRecords()) {\n                            RowData other = outerRecord.record;\n                            // if the matched num in the matched rows == 0\n                            if (outerRecord.numOfAssociations == 0 && !isSuppress) {\n                                // send -D[null+other]\n                                outRow.setRowKind(RowKind.DELETE);\n                                outputNullPadding(other, !inputIsLeft);\n                            } // ignore matched number > 0\n                            // otherState.update(other, old + 1)\n                            otherSideOuterStateView.updateNumOfAssociations(\n                                    other, outerRecord.numOfAssociations + 1);\n                        }\n                    }\n                    // send +I[record+other]s\n                    outRow.setRowKind(RowKind.INSERT);\n                    for (RowData other : associatedRecords.getRecords()) {\n                        output(input, other, inputIsLeft);\n                    }\n                    // state.add(record, other.size)\n                    inputSideOuterStateView.addRecord(input, associatedRecords.size());\n                }\n            } else { // input side not outer\n                // state.add(record)\n                inputSideStateView.addRecord(input);\n                if (!associatedRecords.isEmpty()) { // if there are matched rows on the other side\n                    if (otherIsOuter) { // if other side is outer\n                        OuterJoinRecordStateView otherSideOuterStateView =\n                                (OuterJoinRecordStateView) otherSideStateView;\n                        for (OuterRecord outerRecord : associatedRecords.getOuterRecords()) {\n                            if (outerRecord.numOfAssociations == 0\n                                    && !isSuppress) { // if the matched num in the matched rows == 0\n                                // send -D[null+other]\n                                outRow.setRowKind(RowKind.DELETE);\n                                outputNullPadding(outerRecord.record, !inputIsLeft);\n                            }\n                            // otherState.update(other, old + 1)\n                            otherSideOuterStateView.updateNumOfAssociations(\n                                    outerRecord.record, outerRecord.numOfAssociations + 1);\n                        }\n                        // send +I[record+other]s\n                        outRow.setRowKind(RowKind.INSERT);\n                    } else {\n                        // send +I/+U[record+other]s (using input RowKind)\n                        outRow.setRowKind(inputRowKind);\n                    }\n                    for (RowData other : associatedRecords.getRecords()) {\n                        output(input, other, inputIsLeft);\n                    }\n                }\n                // skip when there is no matched rows on the other side\n            }\n        } else { // input record is retract\n            // state.retract(record)\n            if (!isSuppress) {\n                inputSideStateView.retractRecord(input);\n            }\n            if (associatedRecords.isEmpty()) { // there is no matched rows on the other side\n                if (inputIsOuter) { // input side is outer\n                    // send -D[record+null]\n                    outRow.setRowKind(RowKind.DELETE);\n                    outputNullPadding(input, inputIsLeft);\n                }\n                // nothing to do when input side is not outer\n            } else { // there are matched rows on the other side\n                if (inputIsOuter) {\n                    // send -D[record+other]s\n                    outRow.setRowKind(RowKind.DELETE);\n                } else {\n                    // send -D/-U[record+other]s (using input RowKind)\n                    outRow.setRowKind(inputRowKind);\n                }\n                for (RowData other : associatedRecords.getRecords()) {\n                    output(input, other, inputIsLeft);\n                }\n                // if other side is outer\n                if (otherIsOuter) {\n                    OuterJoinRecordStateView otherSideOuterStateView =\n                            (OuterJoinRecordStateView) otherSideStateView;\n                    for (OuterRecord outerRecord : associatedRecords.getOuterRecords()) {\n                        if (outerRecord.numOfAssociations == 1 && !isSuppress) {\n                            // send +I[null+other]\n                            outRow.setRowKind(RowKind.INSERT);\n                            outputNullPadding(outerRecord.record, !inputIsLeft);\n                        } // nothing else to do when number of associations > 1\n                        // otherState.update(other, old - 1)\n                        otherSideOuterStateView.updateNumOfAssociations(\n                                outerRecord.record, outerRecord.numOfAssociations - 1);\n                    }\n                }\n            }\n        }\n    }",
          "conflictNames": [
              "input",
              "inputSideStateView",
              "otherSideStateView",
              "inputIsLeft",
              "isSuppress",
              "inputIsOuter",
              "otherIsOuter",
              "isAccumulateMsg",
              "associatedRecords",
              "inputSideOuterStateView",
              "otherSideOuterStateView",
              "other"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/5afc301bc6445bd5bbd9cb521dc20a808a67694e^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/operations/SqlToOperationConverter.java",
      "locators": [
          {
              "line": 1515,
              "column": 17
          },
          {
              "line": 1516,
              "column": 63
          }
      ],
      "old_name": "updateRelational",
      "new_name": "deleteRelational",
      "ctx": {
          "symbolName": "updateRelational",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RelRoot",
          "scopeHint": "in convertDelete(...)",
          "filePath": "SqlToOperationConverter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private Operation convertDelete(SqlDelete sqlDelete) {\n        // set it's delete\n        RowLevelModificationContextUtils.setModificationType(\n                SupportsRowLevelModificationScan.RowLevelModificationType.DELETE);\n        RelRoot updateRelational = flinkPlanner.rel(sqlDelete);\n        LogicalTableModify tableModify = (LogicalTableModify) updateRelational.rel;\n        UnresolvedIdentifier unresolvedTableIdentifier =\n                UnresolvedIdentifier.of(tableModify.getTable().getQualifiedName());\n        ContextResolvedTable contextResolvedTable =\n                catalogManager.getTableOrError(\n                        catalogManager.qualifyIdentifier(unresolvedTableIdentifier));\n        // try push down delete\n        Optional<DynamicTableSink> optionalDynamicTableSink =\n                DeletePushDownUtils.getDynamicTableSink(\n                        contextResolvedTable, tableModify, catalogManager);\n        if (optionalDynamicTableSink.isPresent()) {\n            DynamicTableSink dynamicTableSink = optionalDynamicTableSink.get();\n            // if the table sink supports delete push down\n            if (dynamicTableSink instanceof SupportsDeletePushDown) {\n                SupportsDeletePushDown supportsDeletePushDownSink =\n                        (SupportsDeletePushDown) dynamicTableSink;\n                // get resolved filter expression\n                Optional<List<ResolvedExpression>> filters =\n                        DeletePushDownUtils.getResolvedFilterExpressions(tableModify);\n                if (filters.isPresent()\n                        && supportsDeletePushDownSink.applyDeleteFilters(filters.get())) {\n                    return new DeleteFromFilterOperation(\n                            contextResolvedTable, supportsDeletePushDownSink, filters.get());\n                }\n            }\n        }\n        // delete push down is not applicable, use row-level delete\n        PlannerQueryOperation queryOperation = new PlannerQueryOperation(tableModify);\n        return new SinkModifyOperation(\n                contextResolvedTable, queryOperation, SinkModifyOperation.ModifyType.DELETE);\n    }",
          "conflictNames": [
              "sqlDelete",
              "tableModify",
              "unresolvedTableIdentifier",
              "contextResolvedTable",
              "optionalDynamicTableSink",
              "dynamicTableSink",
              "supportsDeletePushDownSink",
              "filters",
              "queryOperation"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/5c3658aa06b79e8039043145560a1ad2bcce68b0^1/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/operations/SqlToOperationConverterTest.java",
      "locators": [
          {
              "line": 2734,
              "column": 41
          },
          {
              "line": 2736,
              "column": 20
          },
          {
              "line": 2737,
              "column": 20
          }
      ],
      "old_name": "alterTableSchemaOperation",
      "new_name": "alterTableChangeOperation",
      "ctx": {
          "symbolName": "alterTableSchemaOperation",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "AlterTableSchemaOperation",
          "scopeHint": "in assertAlterTableSchema(...)",
          "filePath": "SqlToOperationConverterTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void assertAlterTableSchema(\n            Operation operation, ObjectIdentifier expectedIdentifier, Schema expectedSchema) {\n        assertThat(operation).isInstanceOf(AlterTableSchemaOperation.class);\n        final AlterTableSchemaOperation alterTableSchemaOperation =\n                (AlterTableSchemaOperation) operation;\n        assertThat(alterTableSchemaOperation.getTableIdentifier()).isEqualTo(expectedIdentifier);\n        assertThat(alterTableSchemaOperation.getCatalogTable().getUnresolvedSchema())\n                .isEqualTo(expectedSchema);\n    }",
          "conflictNames": [
              "operation",
              "expectedIdentifier",
              "expectedSchema"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/5c3658aa06b79e8039043145560a1ad2bcce68b0^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/operations/AlterSchemaConverter.java",
      "locators": [
          {
              "line": 248,
              "column": 49
          },
          {
              "line": 249,
              "column": 33
          },
          {
              "line": 250,
              "column": 26
          },
          {
              "line": 250,
              "column": 43
          },
          {
              "line": 251,
              "column": 72
          }
      ],
      "old_name": "alterColumnPos",
      "new_name": "sqlNode",
      "ctx": {
          "symbolName": "alterColumnPos",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "SqlNode",
          "scopeHint": "in updateColumn(...)",
          "filePath": "AlterSchemaConverter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "termarkSpecs()) {\n                watermarkSpec = sourceWatermarkSpec;\n            }\n        }\n\n        private void updateColumn(List<SqlNode> alterColumnPositions) {\n            applyColumnPosition(alterColumnPositions);\n            for (SqlNode alterColumnPos : alterColumnPositions) {\n                SqlTableColumn alterColumn = ((SqlTableColumnPosition) alterColumnPos).getColumn();\n                Schema.UnresolvedColumn newColumn;\n                if (alterColumn instanceof SqlTableColumn.SqlC",
          "conflictNames": [
              "alterColumnPositions",
              "alterColumn",
              "newColumn"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/5dcfdf7ecf5c2efc5d4549fb30eb89d78a1a21fa^1/flink-runtime/src/test/java/org/apache/flink/runtime/state/memory/MemoryCheckpointStorageAccessTest.java",
      "locators": [
          {
              "line": 84,
              "column": 28
          },
          {
              "line": 87,
              "column": 56
          },
          {
              "line": 101,
              "column": 28
          },
          {
              "line": 105,
              "column": 56
          },
          {
              "line": 118,
              "column": 28
          },
          {
              "line": 120,
              "column": 56
          },
          {
              "line": 147,
              "column": 40
          },
          {
              "line": 156,
              "column": 40
          },
          {
              "line": 165,
              "column": 25
          }
      ],
      "old_name": "backend",
      "new_name": "jobManagerCheckpointStorage",
      "ctx": {
          "symbolName": "backend",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "MemoryStateBackend",
          "scopeHint": "in testParametrizationDefault(...)",
          "filePath": "MemoryCheckpointStorageAccessTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testParametrizationDefault() throws Exception {\n        final JobID jid = new JobID();\n\n        MemoryStateBackend backend = new MemoryStateBackend();\n\n        MemoryBackendCheckpointStorageAccess storage =\n                (MemoryBackendCheckpointStorageAccess) backend.createCheckpointStorage(jid);\n\n        assertThat(storage.supportsHighlyAvailableStorage()).isFalse();\n        assertThat(storage.hasDefaultSavepointLocation()).isFalse();\n        assertThat(storage.getDefaultSavepointDirectory()).isNull();\n        assertThat(storage.getMaxStateSize()).isEqualTo(MemoryStateBackend.DEFAULT_MAX_STATE_SIZE);\n    }",
          "conflictNames": [
              "jid",
              "storage"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/615d19735b0691b57262a110e6078c3488349f5a^1/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractStreamOperator.java",
      "locators": [
          {
              "line": 212,
              "column": 25
          },
          {
              "line": 215,
              "column": 29
          }
      ],
      "old_name": "jobMetricGroup",
      "new_name": "taskMetricGroup",
      "ctx": {
          "symbolName": "jobMetricGroup",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "MetricGroup",
          "scopeHint": "in setup(...)",
          "filePath": "AbstractStreamOperator.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void setup(\n            StreamTask<?, ?> containingTask,\n            StreamConfig config,\n            Output<StreamRecord<OUT>> output) {\n        final Environment environment = containingTask.getEnvironment();\n        this.container = containingTask;\n        this.config = config;\n        this.output = output;\n        this.metrics =\n                environment\n                        .getMetricGroup()\n                        .getOrAddOperator(config.getOperatorID(), config.getOperatorName());\n        this.combinedWatermark = IndexedCombinedWatermarkStatus.forInputsCount(2);\n\n        try {\n            Configuration taskManagerConfig = environment.getTaskManagerInfo().getConfiguration();\n            int historySize = taskManagerConfig.get(MetricOptions.LATENCY_HISTORY_SIZE);\n            if (historySize <= 0) {\n                LOG.warn(\n                        \"{} has been set to a value equal or below 0: {}. Using default.\",\n                        MetricOptions.LATENCY_HISTORY_SIZE,\n                        historySize);\n                historySize = MetricOptions.LATENCY_HISTORY_SIZE.defaultValue();\n            }\n\n            final String configuredGranularity =\n                    taskManagerConfig.get(MetricOptions.LATENCY_SOURCE_GRANULARITY);\n            LatencyStats.Granularity granularity;\n            try {\n                granularity =\n                        LatencyStats.Granularity.valueOf(\n                                configuredGranularity.toUpperCase(Locale.ROOT));\n            } catch (IllegalArgumentException iae) {\n                granularity = LatencyStats.Granularity.OPERATOR;\n                LOG.warn(\n                        \"Configured value {} option for {} is invalid. Defaulting to {}.\",\n                        configuredGranularity,\n                        MetricOptions.LATENCY_SOURCE_GRANULARITY.key(),\n                        granularity);\n            }\n            MetricGroup jobMetricGroup = this.metrics.getJobMetricGroup();\n            this.latencyStats =\n                    new LatencyStats(\n                            jobMetricGroup.addGroup(\"latency\"),\n                            historySize,\n                            container.getIndexInSubtaskGroup(),\n                            getOperatorID(),\n                            granularity);\n        } catch (Exception e) {\n            LOG.warn(\"An error occurred while instantiating latency metrics.\", e);\n            this.latencyStats =\n                    new LatencyStats(\n                            UnregisteredMetricGroups.createUnregisteredTaskManagerJobMetricGroup()\n                                    .addGroup(\"latency\"),\n                            1,\n                            0,\n                            new OperatorID(),\n                            LatencyStats.Granularity.SINGLE);\n        }\n\n        this.runtimeContext =\n                new StreamingRuntimeContext(\n                        environment,\n                        environment.getAccumulatorRegistry().getUserMap(),\n                        getMetricGroup(),\n                        getOperatorID(),\n                        getProcessingTimeService(),\n                        null,\n                        environment.getExternalResourceInfoProvider());\n\n        stateKeySelector1 = config.getStatePartitioner(0, getUserCodeClassloader());\n        stateKeySelector2 = config.getStatePartitioner(1, getUserCodeClassloader());\n\n        lastRecordAttributes1 = RecordAttributes.EMPTY_RECORD_ATTRIBUTES;\n        lastRecordAttributes2 = RecordAttributes.EMPTY_RECORD_ATTRIBUTES;\n    }",
          "conflictNames": [
              "containingTask",
              "config",
              "output",
              "environment",
              "taskManagerConfig",
              "historySize",
              "configuredGranularity",
              "granularity"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/615d19735b0691b57262a110e6078c3488349f5a^1/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractStreamOperatorV2.java",
      "locators": [
          {
              "line": 176,
              "column": 25
          },
          {
              "line": 178,
              "column": 21
          }
      ],
      "old_name": "jobMetricGroup",
      "new_name": "taskMetricGroup",
      "ctx": {
          "symbolName": "jobMetricGroup",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "MetricGroup",
          "scopeHint": "in createLatencyStats(...)",
          "filePath": "AbstractStreamOperatorV2.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private LatencyStats createLatencyStats(\n            Configuration taskManagerConfig, int indexInSubtaskGroup) {\n        try {\n            int historySize = taskManagerConfig.get(MetricOptions.LATENCY_HISTORY_SIZE);\n            if (historySize <= 0) {\n                LOG.warn(\n                        \"{} has been set to a value equal or below 0: {}. Using default.\",\n                        MetricOptions.LATENCY_HISTORY_SIZE,\n                        historySize);\n                historySize = MetricOptions.LATENCY_HISTORY_SIZE.defaultValue();\n            }\n\n            final String configuredGranularity =\n                    taskManagerConfig.get(MetricOptions.LATENCY_SOURCE_GRANULARITY);\n            LatencyStats.Granularity granularity;\n            try {\n                granularity =\n                        LatencyStats.Granularity.valueOf(\n                                configuredGranularity.toUpperCase(Locale.ROOT));\n            } catch (IllegalArgumentException iae) {\n                granularity = LatencyStats.Granularity.OPERATOR;\n                LOG.warn(\n                        \"Configured value {} option for {} is invalid. Defaulting to {}.\",\n                        configuredGranularity,\n                        MetricOptions.LATENCY_SOURCE_GRANULARITY.key(),\n                        granularity);\n            }\n            MetricGroup jobMetricGroup = this.metrics.getJobMetricGroup();\n            return new LatencyStats(\n                    jobMetricGroup.addGroup(\"latency\"),\n                    historySize,\n                    indexInSubtaskGroup,\n                    getOperatorID(),\n                    granularity);\n        } catch (Exception e) {\n            LOG.warn(\"An error occurred while instantiating latency metrics.\", e);\n            return new LatencyStats(\n                    UnregisteredMetricGroups.createUnregisteredTaskManagerJobMetricGroup()\n                            .addGroup(\"latency\"),\n                    1,\n                    0,\n                    new OperatorID(),\n                    LatencyStats.Granularity.SINGLE);\n        }\n    }",
          "conflictNames": [
              "taskManagerConfig",
              "indexInSubtaskGroup",
              "historySize",
              "configuredGranularity",
              "granularity"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/61a68bc9dc74926775dd546af64fe176782f70ba^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/operations/converters/SqlCreateMaterializedTableConverter.java",
      "locators": [
          {
              "line": 80,
              "column": 16
          },
          {
              "line": 81,
              "column": 18
          },
          {
              "line": 103,
              "column": 25
          },
          {
              "line": 142,
              "column": 26
          },
          {
              "line": 142,
              "column": 36
          }
      ],
      "old_name": "freshness",
      "new_name": "intervalFreshness",
      "ctx": {
          "symbolName": "freshness",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Duration",
          "scopeHint": "in convertSqlNode(...)",
          "filePath": "SqlCreateMaterializedTableConverter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public Operation convertSqlNode(\n            SqlCreateMaterializedTable sqlCreateMaterializedTable, ConvertContext context) {\n        UnresolvedIdentifier unresolvedIdentifier =\n                UnresolvedIdentifier.of(sqlCreateMaterializedTable.fullTableName());\n        ObjectIdentifier identifier =\n                context.getCatalogManager().qualifyIdentifier(unresolvedIdentifier);\n\n        // get comment\n        String tableComment =\n                OperationConverterUtils.getTableComment(sqlCreateMaterializedTable.getComment());\n\n        // get options\n        Map<String, String> options = new HashMap<>();\n        sqlCreateMaterializedTable\n                .getPropertyList()\n                .getList()\n                .forEach(\n                        p ->\n                                options.put(\n                                        ((SqlTableOption) p).getKeyString(),\n                                        ((SqlTableOption) p).getValueString()));\n\n        // get freshness\n        Duration freshness =\n                MaterializedTableUtils.getMaterializedTableFreshness(\n                        sqlCreateMaterializedTable.getFreshness());\n\n        // get refresh mode\n        SqlRefreshMode sqlRefreshMode = null;\n        if (sqlCreateMaterializedTable.getRefreshMode().isPresent()) {\n            sqlRefreshMode =\n                    sqlCreateMaterializedTable\n                            .getRefreshMode()\n                            .get()\n                            .getValueAs(SqlRefreshMode.class);\n        }\n        CatalogMaterializedTable.LogicalRefreshMode logicalRefreshMode =\n                MaterializedTableUtils.deriveLogicalRefreshMode(sqlRefreshMode);\n        // only MATERIALIZED_TABLE_FRESHNESS_THRESHOLD configured in flink conf yaml work, so we get\n        // it from rootConfiguration instead of table config\n        CatalogMaterializedTable.RefreshMode refreshMode =\n                MaterializedTableUtils.deriveRefreshMode(\n                        context.getTableConfig()\n                                .getRootConfiguration()\n                                .get(MATERIALIZED_TABLE_FRESHNESS_THRESHOLD),\n                        freshness,\n                        logicalRefreshMode);\n\n        // get query schema and definition query\n        SqlNode validateQuery =\n                context.getSqlValidator().validate(sqlCreateMaterializedTable.getAsQuery());\n        PlannerQueryOperation queryOperation =\n                new PlannerQueryOperation(\n                        context.toRelRoot(validateQuery).project(),\n                        () -> context.toQuotedSqlString(validateQuery));\n        String definitionQuery =\n                context.expandSqlIdentifiers(queryOperation.asSerializableString());\n\n        // get schema\n        ResolvedSchema resolvedSchema = queryOperation.getResolvedSchema();\n        Schema.Builder builder = Schema.newBuilder().fromResolvedSchema(resolvedSchema);\n\n        // get and verify partition key\n        List<String> partitionKeys =\n                sqlCreateMaterializedTable.getPartitionKeyList().getList().stream()\n                        .map(p -> ((SqlIdentifier) p).getSimple())\n                        .collect(Collectors.toList());\n        verifyPartitioningColumnsExist(resolvedSchema, partitionKeys);\n\n        // verify and build primary key\n        sqlCreateMaterializedTable\n                .getTableConstraint()\n                .ifPresent(\n                        sqlTableConstraint ->\n                                verifyAndBuildPrimaryKey(\n                                        builder, resolvedSchema, sqlTableConstraint));\n\n        CatalogMaterializedTable materializedTable =\n                CatalogMaterializedTable.newBuilder()\n                        .schema(builder.build())\n                        .comment(tableComment)\n                        .partitionKeys(partitionKeys)\n                        .options(options)\n                        .definitionQuery(definitionQuery)\n                        .freshness(freshness)\n                        .logicalRefreshMode(logicalRefreshMode)\n                        .refreshMode(refreshMode)\n                        .refreshStatus(CatalogMaterializedTable.RefreshStatus.INITIALIZING)\n                        .build();\n\n        return new CreateMaterializedTableOperation(\n                identifier,\n                context.getCatalogManager().resolveCatalogMaterializedTable(materializedTable));\n    }",
          "conflictNames": [
              "sqlCreateMaterializedTable",
              "context",
              "unresolvedIdentifier",
              "identifier",
              "tableComment",
              "options",
              "sqlRefreshMode",
              "logicalRefreshMode",
              "refreshMode",
              "validateQuery",
              "queryOperation",
              "definitionQuery",
              "resolvedSchema",
              "builder",
              "partitionKeys",
              "materializedTable"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/624bc5001c831d3d04a5680c03910c634a0c988b^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/exec/stream/StreamExecLookupJoin.java",
      "locators": [
          {
              "line": 249,
              "column": 23
          },
          {
              "line": 257,
              "column": 37
          },
          {
              "line": 263,
              "column": 30
          },
          {
              "line": 267,
              "column": 29
          }
      ],
      "old_name": "refKeys",
      "new_name": "shuffleKeys",
      "ctx": {
          "symbolName": "refKeys",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<Integer>",
          "scopeHint": "in createSyncLookupJoinWithState(...)",
          "filePath": "StreamExecLookupJoin.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    protected Transformation<RowData> createSyncLookupJoinWithState(\n            Transformation<RowData> inputTransformation,\n            RelOptTable temporalTable,\n            ExecNodeConfig config,\n            ClassLoader classLoader,\n            Map<Integer, LookupJoinUtil.LookupKey> allLookupKeys,\n            TableFunction<?> syncLookupFunction,\n            RelBuilder relBuilder,\n            RowType inputRowType,\n            RowType tableSourceRowType,\n            RowType resultRowType,\n            boolean isLeftOuterJoin,\n            boolean isObjectReuseEnabled,\n            boolean lookupKeyContainsPrimaryKey) {\n\n        final long stateRetentionTime =\n                StateMetadata.getStateTtlForOneInputOperator(config, stateMetadataList);\n\n        // create lookup function first\n        ProcessFunction<RowData, RowData> processFunction =\n                createSyncLookupJoinFunction(\n                        temporalTable,\n                        config,\n                        classLoader,\n                        allLookupKeys,\n                        syncLookupFunction,\n                        relBuilder,\n                        inputRowType,\n                        tableSourceRowType,\n                        resultRowType,\n                        isLeftOuterJoin,\n                        isObjectReuseEnabled);\n\n        RowType rightRowType =\n                getRightOutputRowType(\n                        getProjectionOutputRelDataType(relBuilder), tableSourceRowType);\n\n        KeyedLookupJoinWrapper keyedLookupJoinWrapper =\n                new KeyedLookupJoinWrapper(\n                        (LookupJoinRunner) processFunction,\n                        StateConfigUtil.createTtlConfig(stateRetentionTime),\n                        InternalSerializers.create(rightRowType),\n                        lookupKeyContainsPrimaryKey);\n\n        KeyedProcessOperator<RowData, RowData, RowData> operator =\n                new KeyedProcessOperator<>(keyedLookupJoinWrapper);\n\n        List<Integer> refKeys =\n                allLookupKeys.values().stream()\n                        .filter(key -> key instanceof LookupJoinUtil.FieldRefLookupKey)\n                        .map(key -> ((LookupJoinUtil.FieldRefLookupKey) key).index)\n                        .collect(Collectors.toList());\n        RowDataKeySelector keySelector;\n\n        // use single parallelism for empty key shuffle\n        boolean singleParallelism = refKeys.isEmpty();\n        if (singleParallelism) {\n            // all lookup keys are constants, then use an empty key selector\n            keySelector = EmptyRowDataKeySelector.INSTANCE;\n        } else {\n            // make it a deterministic asc order\n            Collections.sort(refKeys);\n            keySelector =\n                    KeySelectorUtil.getRowDataSelector(\n                            classLoader,\n                            refKeys.stream().mapToInt(Integer::intValue).toArray(),\n                            InternalTypeInfo.of(inputRowType));\n        }\n        final KeyGroupStreamPartitioner<RowData, RowData> partitioner =\n                new KeyGroupStreamPartitioner<>(\n                        keySelector, KeyGroupRangeAssignment.DEFAULT_LOWER_BOUND_MAX_PARALLELISM);\n        Transformation<RowData> partitionedTransform =\n                new PartitionTransformation<>(inputTransformation, partitioner);\n        createTransformationMeta(PARTITIONER_TRANSFORMATION, \"Partitioner\", \"Partitioner\", config)\n                .fill(partitionedTransform);\n        if (singleParallelism) {\n            setSingletonParallelism(partitionedTransform);\n        } else {\n            partitionedTransform.setParallelism(inputTransformation.getParallelism(), false);\n        }\n\n        OneInputTransformation<RowData, RowData> transform =\n                ExecNodeUtil.createOneInputTransformation(\n                        partitionedTransform,\n                        createTransformationMeta(LOOKUP_JOIN_MATERIALIZE_TRANSFORMATION, config),\n                        operator,\n                        InternalTypeInfo.of(resultRowType),\n                        partitionedTransform.getParallelism(),\n                        false);\n        transform.setStateKeySelector(keySelector);\n        transform.setStateKeyType(keySelector.getProducedType());\n        if (singleParallelism) {\n            setSingletonParallelism(transform);\n        }\n        return transform;\n    }",
          "conflictNames": [
              "inputTransformation",
              "temporalTable",
              "config",
              "classLoader",
              "allLookupKeys",
              "syncLookupFunction",
              "relBuilder",
              "inputRowType",
              "tableSourceRowType",
              "resultRowType",
              "isLeftOuterJoin",
              "isObjectReuseEnabled",
              "lookupKeyContainsPrimaryKey",
              "stateRetentionTime",
              "processFunction",
              "rightRowType",
              "keyedLookupJoinWrapper",
              "operator",
              "keySelector",
              "singleParallelism",
              "partitioner",
              "partitionedTransform",
              "transform"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/62b792d58c4f8d5b494b50daad2e5fc5047af330^1/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/DefaultLeaderElectionTest.java",
      "locators": [
          {
              "line": 108,
              "column": 50
          },
          {
              "line": 112,
              "column": 44
          },
          {
              "line": 121,
              "column": 20
          },
          {
              "line": 126,
              "column": 50
          },
          {
              "line": 129,
              "column": 44
          },
          {
              "line": 135,
              "column": 20
          }
      ],
      "old_name": "actualContender",
      "new_name": "actualContenderID",
      "ctx": {
          "symbolName": "actualContender",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CompletableFuture<LeaderContender>",
          "scopeHint": "in testClose(...)",
          "filePath": "DefaultLeaderElectionTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testClose() throws Exception {\n        final CompletableFuture<LeaderContender> actualContender = new CompletableFuture<>();\n        final AbstractLeaderElectionService parentService =\n                TestingAbstractLeaderElectionService.newBuilder()\n                        .setRegisterConsumer(ignoredContender -> {})\n                        .setRemoveConsumer(actualContender::complete)\n                        .build();\n\n        final DefaultLeaderElection testInstance = new DefaultLeaderElection(parentService);\n\n        final LeaderContender contender = TestingGenericLeaderContender.newBuilder().build();\n        testInstance.startLeaderElection(contender);\n        testInstance.close();\n\n        assertThat(actualContender).isCompletedWithValue(contender);\n    }",
          "conflictNames": [
              "parentService",
              "testInstance",
              "contender"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/62b792d58c4f8d5b494b50daad2e5fc5047af330^1/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/DefaultLeaderElectionTest.java",
      "locators": [
          {
              "line": 39,
              "column": 48
          },
          {
              "line": 42,
              "column": 46
          },
          {
              "line": 46,
              "column": 35
          },
          {
              "line": 47,
              "column": 46
          },
          {
              "line": 49,
              "column": 24
          },
          {
              "line": 49,
              "column": 53
          },
          {
              "line": 66,
              "column": 58
          },
          {
              "line": 70,
              "column": 33
          },
          {
              "line": 117,
              "column": 31
          },
          {
              "line": 118,
              "column": 42
          },
          {
              "line": 121,
              "column": 58
          },
          {
              "line": 137,
              "column": 71
          },
          {
              "line": 192,
              "column": 49
          },
          {
              "line": 193,
              "column": 37
          },
          {
              "line": 197,
              "column": 47
          },
          {
              "line": 198,
              "column": 35
          },
          {
              "line": 214,
              "column": 29
          },
          {
              "line": 217,
              "column": 40
          }
      ],
      "old_name": "contender",
      "new_name": "contenderID",
      "ctx": {
          "symbolName": "contender",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "LeaderContender",
          "scopeHint": "in testContenderRegistration(...)",
          "filePath": "DefaultLeaderElectionTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testContenderRegistration() throws Exception {\n        final AtomicReference<LeaderContender> contenderRef = new AtomicReference<>();\n        final AbstractLeaderElectionService parentService =\n                TestingAbstractLeaderElectionService.newBuilder()\n                        .setRegisterConsumer(contenderRef::set)\n                        .build();\n        try (final DefaultLeaderElection testInstance = new DefaultLeaderElection(parentService)) {\n\n            final LeaderContender contender = TestingGenericLeaderContender.newBuilder().build();\n            testInstance.startLeaderElection(contender);\n\n            assertThat(contenderRef.get()).isSameAs(contender);\n        }\n    }",
          "conflictNames": [
              "contenderRef",
              "parentService",
              "testInstance"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/63443aec09ece8596321328273c1e431e5029c4d^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PartitionedFileWriteReadTest.java",
      "locators": [
          {
              "line": 66,
              "column": 35
          },
          {
              "line": 70,
              "column": 13
          },
          {
              "line": 83,
              "column": 25
          },
          {
              "line": 89,
              "column": 21
          },
          {
              "line": 96,
              "column": 41
          },
          {
              "line": 103,
              "column": 17
          }
      ],
      "old_name": "regionBuffers",
      "new_name": "bufferWithChannels",
      "ctx": {
          "symbolName": "regionBuffers",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<BufferWithChannel>[]",
          "scopeHint": "in testWriteAndReadPartitionedFile(...)",
          "filePath": "PartitionedFileWriteReadTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testWriteAndReadPartitionedFile() throws Exception {\n        int numSubpartitions = 10;\n        int bufferSize = 1024;\n        int numBuffers = 1000;\n        int numRegions = 10;\n        Random random = new Random(1111);\n\n        List<Buffer>[] buffersWritten = new List[numSubpartitions];\n        List<Buffer>[] buffersRead = new List[numSubpartitions];\n        List<BufferWithChannel>[] regionBuffers = new List[numSubpartitions];\n        for (int subpartition = 0; subpartition < numSubpartitions; ++subpartition) {\n            buffersWritten[subpartition] = new ArrayList<>();\n            buffersRead[subpartition] = new ArrayList<>();\n            regionBuffers[subpartition] = new ArrayList<>();\n        }\n\n        PartitionedFileWriter fileWriter = createPartitionedFileWriter(numSubpartitions);\n        for (int region = 0; region < numRegions; ++region) {\n            boolean isBroadcastRegion = random.nextBoolean();\n            fileWriter.startNewRegion(isBroadcastRegion);\n\n            for (int i = 0; i < numBuffers; ++i) {\n                Buffer buffer = createBuffer(random, bufferSize);\n                if (isBroadcastRegion) {\n                    for (int subpartition = 0; subpartition < numSubpartitions; ++subpartition) {\n                        buffersWritten[subpartition].add(buffer);\n                        regionBuffers[subpartition].add(\n                                new BufferWithChannel(buffer, subpartition));\n                    }\n                } else {\n                    int subpartition = random.nextInt(numSubpartitions);\n                    buffersWritten[subpartition].add(buffer);\n                    regionBuffers[subpartition].add(new BufferWithChannel(buffer, subpartition));\n                }\n            }\n\n            int[] writeOrder = DataBufferTest.getRandomSubpartitionOrder(numSubpartitions);\n            for (int index = 0; index < numSubpartitions; ++index) {\n                int subpartition = writeOrder[index];\n                fileWriter.writeBuffers(regionBuffers[subpartition]);\n                if (isBroadcastRegion) {\n                    break;\n                }\n            }\n\n            for (int index = 0; index < numSubpartitions; ++index) {\n                regionBuffers[index].clear();\n            }\n        }\n        PartitionedFile partitionedFile = fileWriter.finish();\n\n        FileChannel dataFileChannel = openFileChannel(partitionedFile.getDataFilePath());\n        FileChannel indexFileChannel = openFileChannel(partitionedFile.getIndexFilePath());\n        for (int subpartition = 0; subpartition < numSubpartitions; ++subpartition) {\n            PartitionedFileReader fileReader =\n                    new PartitionedFileReader(\n                            partitionedFile,\n                            subpartition,\n                            dataFileChannel,\n                            indexFileChannel,\n                            BufferReaderWriterUtil.allocatedHeaderBuffer(),\n                            createAndConfigIndexEntryBuffer());\n            while (fileReader.hasRemaining()) {\n                final int subIndex = subpartition;\n                fileReader.readCurrentRegion(\n                        allocateBuffers(bufferSize),\n                        FreeingBufferRecycler.INSTANCE,\n                        buffer -> addReadBuffer(buffer, buffersRead[subIndex]));\n            }\n        }\n        IOUtils.closeAllQuietly(dataFileChannel, indexFileChannel);\n\n        for (int subpartition = 0; subpartition < numSubpartitions; ++subpartition) {\n            assertThat(buffersWritten[subpartition]).hasSameSizeAs(buffersRead[subpartition]);\n            for (int i = 0; i < buffersWritten[subpartition].size(); ++i) {\n                assertBufferEquals(\n                        buffersWritten[subpartition].get(i), buffersRead[subpartition].get(i));\n            }\n        }\n    }",
          "conflictNames": [
              "numSubpartitions",
              "bufferSize",
              "numBuffers",
              "numRegions",
              "random",
              "buffersWritten",
              "buffersRead",
              "subpartition",
              "fileWriter",
              "region",
              "isBroadcastRegion",
              "i",
              "buffer",
              "writeOrder",
              "index",
              "partitionedFile",
              "dataFileChannel",
              "indexFileChannel",
              "fileReader",
              "subIndex"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/63b92bd88ac32be5b3e70550ba90d828b7b655d1^1/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/job/coordination/ClientCoordinationHandler.java",
      "locators": [
          {
              "line": 77,
              "column": 20
          },
          {
              "line": 82,
              "column": 32
          }
      ],
      "old_name": "operatorId",
      "new_name": "operatorUid",
      "ctx": {
          "symbolName": "operatorId",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "OperatorID",
          "scopeHint": "in handleRequest(...)",
          "filePath": "ClientCoordinationHandler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    protected CompletableFuture<ClientCoordinationResponseBody> handleRequest(\n            @Nonnull HandlerRequest<ClientCoordinationRequestBody> request,\n            @Nonnull RestfulGateway gateway)\n            throws RestHandlerException {\n        JobID jobId = request.getPathParameter(JobIDPathParameter.class);\n        OperatorID operatorId = request.getPathParameter(OperatorIDPathParameter.class);\n        SerializedValue<CoordinationRequest> serializedRequest =\n                request.getRequestBody().getSerializedCoordinationRequest();\n        CompletableFuture<CoordinationResponse> responseFuture =\n                gateway.deliverCoordinationRequestToCoordinator(\n                        jobId, operatorId, serializedRequest, timeout);\n        return responseFuture.thenApply(\n                coordinationResponse -> {\n                    try {\n                        return new ClientCoordinationResponseBody(\n                                new SerializedValue<>(coordinationResponse));\n                    } catch (IOException e) {\n                        throw new CompletionException(\n                                new RestHandlerException(\n                                        \"Failed to serialize coordination response\",\n                                        HttpResponseStatus.INTERNAL_SERVER_ERROR,\n                                        e));\n                    }\n                });\n    }",
          "conflictNames": [
              "request",
              "gateway",
              "jobId",
              "serializedRequest",
              "responseFuture"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/64cbcd2d4b360f03f7964edece6f3211d184fb06^1/flink-clients/src/main/java/org/apache/flink/client/deployment/application/executors/EmbeddedExecutor.java",
      "locators": [
          {
              "line": 142,
              "column": 24
          },
          {
              "line": 144,
              "column": 35
          },
          {
              "line": 154,
              "column": 61
          },
          {
              "line": 181,
              "column": 51
          }
      ],
      "old_name": "jobGraph",
      "new_name": "streamGraph",
      "ctx": {
          "symbolName": "jobGraph",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraph",
          "scopeHint": "in submitAndGetJobClientFuture(...)",
          "filePath": "EmbeddedExecutor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private CompletableFuture<JobClient> submitAndGetJobClientFuture(\n            final Pipeline pipeline,\n            final Configuration configuration,\n            final ClassLoader userCodeClassloader)\n            throws MalformedURLException {\n        final Duration timeout = configuration.get(ClientOptions.CLIENT_TIMEOUT);\n\n        final JobGraph jobGraph =\n                PipelineExecutorUtils.getJobGraph(pipeline, configuration, userCodeClassloader);\n        final JobID actualJobId = jobGraph.getJobID();\n\n        this.submittedJobIds.add(actualJobId);\n        LOG.info(\"Job {} is submitted.\", actualJobId);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Effective Configuration: {}\", configuration);\n        }\n\n        final CompletableFuture<JobID> jobSubmissionFuture =\n                submitJob(configuration, dispatcherGateway, jobGraph, timeout);\n\n        return jobSubmissionFuture\n                .thenApplyAsync(\n                        FunctionUtils.uncheckedFunction(\n                                jobId -> {\n                                    org.apache.flink.client.ClientUtils\n                                            .waitUntilJobInitializationFinished(\n                                                    () ->\n                                                            dispatcherGateway\n                                                                    .requestJobStatus(\n                                                                            jobId, timeout)\n                                                                    .get(),\n                                                    () ->\n                                                            dispatcherGateway\n                                                                    .requestJobResult(\n                                                                            jobId, timeout)\n                                                                    .get(),\n                                                    userCodeClassloader);\n                                    return jobId;\n                                }))\n                .thenApplyAsync(\n                        jobID -> jobClientCreator.getJobClient(actualJobId, userCodeClassloader))\n                .whenCompleteAsync(\n                        (jobClient, throwable) -> {\n                            if (throwable == null) {\n                                PipelineExecutorUtils.notifyJobStatusListeners(\n                                        pipeline, jobGraph, jobStatusChangedListeners);\n                            } else {\n                                LOG.error(\n                                        \"Failed to submit job graph to application cluster\",\n                                        throwable);\n                            }\n                        });\n    }",
          "conflictNames": [
              "pipeline",
              "configuration",
              "userCodeClassloader",
              "timeout",
              "actualJobId",
              "jobSubmissionFuture"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/64cbcd2d4b360f03f7964edece6f3211d184fb06^1/flink-clients/src/main/java/org/apache/flink/client/deployment/executors/AbstractSessionClusterExecutor.java",
      "locators": [
          {
              "line": 93,
              "column": 24
          },
          {
              "line": 105,
              "column": 32
          },
          {
              "line": 126,
              "column": 55
          }
      ],
      "old_name": "jobGraph",
      "new_name": "streamGraph",
      "ctx": {
          "symbolName": "jobGraph",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraph",
          "scopeHint": "in execute(...)",
          "filePath": "AbstractSessionClusterExecutor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public CompletableFuture<JobClient> execute(\n            @Nonnull final Pipeline pipeline,\n            @Nonnull final Configuration configuration,\n            @Nonnull final ClassLoader userCodeClassloader)\n            throws Exception {\n        final JobGraph jobGraph =\n                PipelineExecutorUtils.getJobGraph(pipeline, configuration, userCodeClassloader);\n\n        try (final ClusterDescriptor<ClusterID> clusterDescriptor =\n                clusterClientFactory.createClusterDescriptor(configuration)) {\n            final ClusterID clusterID = clusterClientFactory.getClusterId(configuration);\n            checkState(clusterID != null);\n\n            final ClusterClientProvider<ClusterID> clusterClientProvider =\n                    clusterDescriptor.retrieve(clusterID);\n            ClusterClient<ClusterID> clusterClient = clusterClientProvider.getClusterClient();\n            return clusterClient\n                    .submitJob(jobGraph)\n                    .thenApplyAsync(\n                            FunctionUtils.uncheckedFunction(\n                                    jobId -> {\n                                        ClientUtils.waitUntilJobInitializationFinished(\n                                                () -> clusterClient.getJobStatus(jobId).get(),\n                                                () -> clusterClient.requestJobResult(jobId).get(),\n                                                userCodeClassloader);\n                                        return jobId;\n                                    }))\n                    .thenApplyAsync(\n                            jobID ->\n                                    (JobClient)\n                                            new ClusterClientJobClientAdapter<>(\n                                                    clusterClientProvider,\n                                                    jobID,\n                                                    userCodeClassloader))\n                    .whenCompleteAsync(\n                            (jobClient, throwable) -> {\n                                if (throwable == null) {\n                                    PipelineExecutorUtils.notifyJobStatusListeners(\n                                            pipeline, jobGraph, jobStatusChangedListeners);\n                                } else {\n                                    LOG.error(\n                                            \"Failed to submit job graph to remote session cluster.\",\n                                            throwable);\n                                }\n                                clusterClient.close();\n                            });\n        }\n    }",
          "conflictNames": [
              "pipeline",
              "configuration",
              "userCodeClassloader",
              "clusterDescriptor",
              "clusterID",
              "clusterClientProvider",
              "clusterClient"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/64cbcd2d4b360f03f7964edece6f3211d184fb06^1/flink-clients/src/main/java/org/apache/flink/client/deployment/executors/LocalExecutor.java",
      "locators": [
          {
              "line": 99,
              "column": 24
          },
          {
              "line": 102,
              "column": 28
          },
          {
              "line": 107,
              "column": 51
          }
      ],
      "old_name": "jobGraph",
      "new_name": "streamGraph",
      "ctx": {
          "symbolName": "jobGraph",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraph",
          "scopeHint": "in execute(...)",
          "filePath": "LocalExecutor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public CompletableFuture<JobClient> execute(\n            Pipeline pipeline, Configuration configuration, ClassLoader userCodeClassloader)\n            throws Exception {\n        checkNotNull(pipeline);\n        checkNotNull(configuration);\n\n        Configuration effectiveConfig = new Configuration();\n        effectiveConfig.addAll(this.configuration);\n        effectiveConfig.addAll(configuration);\n\n        // we only support attached execution with the local executor.\n        checkState(configuration.get(DeploymentOptions.ATTACHED));\n\n        final JobGraph jobGraph = getJobGraph(pipeline, effectiveConfig, userCodeClassloader);\n\n        return PerJobMiniClusterFactory.createWithFactory(effectiveConfig, miniClusterFactory)\n                .submitJob(jobGraph, userCodeClassloader)\n                .whenComplete(\n                        (ignored, throwable) -> {\n                            if (throwable == null) {\n                                PipelineExecutorUtils.notifyJobStatusListeners(\n                                        pipeline, jobGraph, jobStatusChangedListeners);\n                            } else {\n                                LOG.error(\n                                        \"Failed to submit job graph to local mini cluster.\",\n                                        throwable);\n                            }\n                        });\n    }",
          "conflictNames": [
              "pipeline",
              "configuration",
              "userCodeClassloader",
              "effectiveConfig"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/64cbcd2d4b360f03f7964edece6f3211d184fb06^1/flink-test-utils-parent/flink-test-utils/src/main/java/org/apache/flink/test/util/MiniClusterPipelineExecutorServiceLoader.java",
      "locators": [
          {
              "line": 173,
              "column": 28
          },
          {
              "line": 175,
              "column": 17
          },
          {
              "line": 177,
              "column": 17
          },
          {
              "line": 181,
              "column": 32
          },
          {
              "line": 186,
              "column": 55
          }
      ],
      "old_name": "jobGraph",
      "new_name": "streamGraph",
      "ctx": {
          "symbolName": "jobGraph",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraph",
          "scopeHint": "in execute(...)",
          "filePath": "MiniClusterPipelineExecutorServiceLoader.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public CompletableFuture<JobClient> execute(\n                Pipeline pipeline, Configuration configuration, ClassLoader userCodeClassLoader)\n                throws Exception {\n            final JobGraph jobGraph =\n                    PipelineExecutorUtils.getJobGraph(pipeline, configuration, userCodeClassLoader);\n            if (jobGraph.getSavepointRestoreSettings() == SavepointRestoreSettings.none()\n                    && pipeline instanceof StreamGraph) {\n                jobGraph.setSavepointRestoreSettings(\n                        ((StreamGraph) pipeline).getSavepointRestoreSettings());\n            }\n            return miniCluster\n                    .submitJob(jobGraph)\n                    .whenComplete(\n                            (ignored, throwable) -> {\n                                if (throwable == null) {\n                                    PipelineExecutorUtils.notifyJobStatusListeners(\n                                            pipeline, jobGraph, jobStatusChangedListeners);\n                                } else {\n                                    LOG.error(\n                                            \"Failed to submit job graph to mini cluster.\",\n                                            throwable);\n                                }\n                            })\n                    .thenApply(\n                            result ->\n                                    new MiniClusterJobClient(\n                                            result.getJobID(),\n                                            miniCluster,\n                                            userCodeClassLoader,\n                                            MiniClusterJobClient.JobFinalizationBehavior.NOTHING));\n        }",
          "conflictNames": [
              "pipeline",
              "configuration",
              "userCodeClassLoader"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/64e8c349c4ee04623f2c874314a763f9fc1a3054^1/flink-table/flink-table-runtime/src/test/java/org/apache/flink/table/runtime/functions/table/fullcache/inputformat/FullCacheTestInputFormat.java",
      "locators": [
          {
              "line": 95,
              "column": 13
          },
          {
              "line": 97,
              "column": 56
          },
          {
              "line": 98,
              "column": 28
          },
          {
              "line": 102,
              "column": 66
          }
      ],
      "old_name": "numSplits",
      "new_name": "currentSplits",
      "ctx": {
          "symbolName": "numSplits",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in createInputSplits(...)",
          "filePath": "FullCacheTestInputFormat.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public QueueInputSplit[] createInputSplits(int minNumSplits) throws IOException {\n        int delta = loadCounter > 0 ? deltaNumSplits : 0;\n        int numSplits = DEFAULT_NUM_SPLITS + delta;\n        ConcurrentLinkedQueue<RowData> queue = new ConcurrentLinkedQueue<>();\n        QueueInputSplit[] splits = new QueueInputSplit[numSplits];\n        IntStream.range(0, numSplits).forEach(i -> splits[i] = new QueueInputSplit(queue, i));\n        dataRows.forEach(row -> queue.add(rowConverter.toInternal(row)));\n        // divide data evenly between InputFormat copies\n        loadCounter++;\n        maxReadRecords = (int) Math.ceil((double) queue.size() / numSplits);\n        return splits;\n    }",
          "conflictNames": [
              "minNumSplits",
              "delta",
              "queue",
              "splits"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/64e8c349c4ee04623f2c874314a763f9fc1a3054^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/functions/table/lookup/fullcache/inputformat/InputFormatCacheLoader.java",
      "locators": [
          {
              "line": 96,
              "column": 33
          },
          {
              "line": 99,
              "column": 38
          }
      ],
      "old_name": "finalCacheLoadTaskService",
      "new_name": "finalExecutor",
      "ctx": {
          "symbolName": "finalCacheLoadTaskService",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ExecutorService",
          "scopeHint": "in reloadCache(...)",
          "filePath": "InputFormatCacheLoader.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    protected void reloadCache() throws Exception {\n        InputSplit[] inputSplits = createInputSplits();\n        int numSplits = inputSplits.length;\n        // load data into the another copy of cache\n        // notice: it requires twice more memory, but on the other hand we don't need any blocking\n        // cache has default initialCapacity and loadFactor, but overridden concurrencyLevel\n        ConcurrentHashMap<RowData, Collection<RowData>> newCache =\n                new ConcurrentHashMap<>(16, 0.75f, getConcurrencyLevel(numSplits));\n        this.cacheLoadTasks =\n                Arrays.stream(inputSplits)\n                        .map(split -> createCacheLoadTask(split, newCache))\n                        .collect(Collectors.toList());\n        if (isStopped) {\n            // check for cases when #close was called during reload before creating cacheLoadTasks\n            return;\n        }\n        // run first task or create numSplits threads to run all tasks\n        ExecutorService cacheLoadTaskService = null;\n        try {\n            if (numSplits > 1) {\n                int numThreads = getConcurrencyLevel(numSplits);\n                cacheLoadTaskService = Executors.newFixedThreadPool(numThreads);\n                ExecutorService finalCacheLoadTaskService = cacheLoadTaskService;\n                List<Future<?>> futures =\n                        cacheLoadTasks.stream()\n                                .map(finalCacheLoadTaskService::submit)\n                                .collect(Collectors.toList());\n                for (Future<?> future : futures) {\n                    future.get(); // if any exception occurs it will be thrown here\n                }\n            } else {\n                cacheLoadTasks.get(0).run();\n            }\n        } catch (InterruptedException ignored) { // we use interrupt to close reload thread\n        } finally {\n            if (cacheLoadTaskService != null) {\n                cacheLoadTaskService.shutdownNow();\n            }\n        }\n        cache = newCache; // reassigning cache field is safe, because it's volatile\n    }",
          "conflictNames": [
              "inputSplits",
              "numSplits",
              "newCache",
              "cacheLoadTaskService",
              "numThreads",
              "futures"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/66913489fb380fa735e3511f5853314749445d8e^1/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/expressions/resolver/rules/ResolveCallByArgumentsRule.java",
      "locators": [
          {
              "line": 118,
              "column": 26
          },
          {
              "line": 137,
              "column": 57
          },
          {
              "line": 158,
              "column": 53
          },
          {
              "line": 167,
              "column": 63
          },
          {
              "line": 251,
              "column": 24
          },
          {
              "line": 262,
              "column": 37
          },
          {
              "line": 344,
              "column": 30
          },
          {
              "line": 354,
              "column": 24
          },
          {
              "line": 359,
              "column": 18
          },
          {
              "line": 359,
              "column": 25
          },
          {
              "line": 413,
              "column": 20
          },
          {
              "line": 438,
              "column": 38
          }
      ],
      "old_name": "name",
      "new_name": "functionName",
      "ctx": {
          "symbolName": "name",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in visit(...)",
          "filePath": "ResolveCallByArgumentsRule.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public List<ResolvedExpression> visit(UnresolvedCallExpression unresolvedCall) {\n            final FunctionDefinition definition;\n            // clean functions that were not registered in a catalog\n            if (!unresolvedCall.getFunctionIdentifier().isPresent()) {\n                definition =\n                        prepareInlineUserDefinedFunction(unresolvedCall.getFunctionDefinition());\n            } else {\n                definition = unresolvedCall.getFunctionDefinition();\n            }\n\n            final String name =\n                    unresolvedCall\n                            .getFunctionIdentifier()\n                            .map(FunctionIdentifier::toString)\n                            .orElseGet(definition::toString);\n\n            final Optional<TypeInference> typeInference = getOptionalTypeInference(definition);\n\n            // resolve the children with information from the current call\n            final List<ResolvedExpression> resolvedArgs = new ArrayList<>();\n            final int argCount = unresolvedCall.getChildren().size();\n\n            for (int i = 0; i < argCount; i++) {\n                final int currentPos = i;\n                final SurroundingInfo surroundingInfo =\n                        typeInference\n                                .map(\n                                        inference ->\n                                                SurroundingInfo.of(\n                                                        name,\n                                                        definition,\n                                                        inference,\n                                                        argCount,\n                                                        currentPos,\n                                                        resolutionContext.isGroupedAggregation()))\n                                .orElse(null);\n                final ResolvingCallVisitor childResolver =\n                        new ResolvingCallVisitor(resolutionContext, surroundingInfo);\n                resolvedArgs.addAll(unresolvedCall.getChildren().get(i).accept(childResolver));\n            }\n\n            if (definition == BuiltInFunctionDefinitions.FLATTEN) {\n                return executeFlatten(resolvedArgs);\n            }\n\n            return Collections.singletonList(\n                    typeInference\n                            .map(\n                                    newInference ->\n                                            runTypeInference(\n                                                    name,\n                                                    unresolvedCall,\n                                                    newInference,\n                                                    resolvedArgs,\n                                                    surroundingInfo))\n                            .orElseThrow(\n                                    () ->\n                                            new TableException(\n                                                    \"Could not get a type inference for function: \"\n                                                            + name)));\n        }",
          "conflictNames": [
              "unresolvedCall",
              "definition",
              "typeInference",
              "resolvedArgs",
              "argCount",
              "i",
              "currentPos",
              "surroundingInfo",
              "childResolver"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/66913489fb380fa735e3511f5853314749445d8e^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/functions/inference/TypeInferenceOperandChecker.java",
      "locators": [
          {
              "line": 206,
              "column": 27
          },
          {
              "line": 208,
              "column": 13
          },
          {
              "line": 213,
              "column": 42
          }
      ],
      "old_name": "adaptedCallContext",
      "new_name": "castCallContext",
      "ctx": {
          "symbolName": "adaptedCallContext",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CallContext",
          "scopeHint": "in checkOperandTypesOrError(...)",
          "filePath": "TypeInferenceOperandChecker.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private boolean checkOperandTypesOrError(SqlCallBinding callBinding, CallContext callContext) {\n        final CallContext adaptedCallContext;\n        try {\n            adaptedCallContext = adaptArguments(typeInference, callContext, null);\n        } catch (ValidationException e) {\n            throw createInvalidInputException(typeInference, callContext, e);\n        }\n\n        insertImplicitCasts(callBinding, adaptedCallContext.getArgumentDataTypes());\n\n        return true;\n    }",
          "conflictNames": [
              "callBinding",
              "callContext"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/66913489fb380fa735e3511f5853314749445d8e^1/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/inference/TypeInferenceUtil.java",
      "locators": [
          {
              "line": 127,
              "column": 34
          },
          {
              "line": 131,
              "column": 46
          },
          {
              "line": 147,
              "column": 16
          },
          {
              "line": 408,
              "column": 27
          },
          {
              "line": 421,
              "column": 13
          },
          {
              "line": 429,
              "column": 33
          },
          {
              "line": 432,
              "column": 33
          },
          {
              "line": 434,
              "column": 27
          },
          {
              "line": 466,
              "column": 34
          },
          {
              "line": 496,
              "column": 17
          },
          {
              "line": 507,
              "column": 42
          },
          {
              "line": 510,
              "column": 13
          },
          {
              "line": 515,
              "column": 16
          }
      ],
      "old_name": "adaptedCallContext",
      "new_name": "castCallContext",
      "ctx": {
          "symbolName": "adaptedCallContext",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "AdaptedCallContext",
          "scopeHint": "in adaptArguments(...)",
          "filePath": "TypeInferenceUtil.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static CallContext adaptArguments(\n            TypeInference typeInference,\n            CallContext callContext,\n            @Nullable DataType outputType,\n            boolean throwOnInferInputFailure) {\n        final List<DataType> actualTypes = callContext.getArgumentDataTypes();\n\n        typeInference\n                .getStaticArguments()\n                .ifPresent(\n                        staticArgs -> {\n                            if (actualTypes.size() != staticArgs.size()) {\n                                throw new ValidationException(\n                                        String.format(\n                                                \"Invalid number of arguments. %d arguments expected after argument expansion but %d passed.\",\n                                                staticArgs.size(), actualTypes.size()));\n                            }\n                        });\n\n        final AdaptedCallContext adaptedCallContext =\n                inferInputTypes(typeInference, callContext, outputType, throwOnInferInputFailure);\n\n        // final check if the call is valid after casting\n        final List<DataType> expectedTypes = adaptedCallContext.getArgumentDataTypes();\n        for (int pos = 0; pos < actualTypes.size(); pos++) {\n            final DataType expectedType = expectedTypes.get(pos);\n            final DataType actualType = actualTypes.get(pos);\n            if (!supportsImplicitCast(actualType.getLogicalType(), expectedType.getLogicalType())) {\n                if (!throwOnInferInputFailure) {\n                    // abort the adaption, e.g. if a NULL is passed for a NOT NULL argument\n                    return callContext;\n                }\n                throw new ValidationException(\n                        String.format(\n                                \"Invalid argument type at position %d. Data type %s expected but %s passed.\",\n                                pos, expectedType, actualType));\n            }\n        }\n\n        return adaptedCallContext;\n    }",
          "conflictNames": [
              "typeInference",
              "callContext",
              "outputType",
              "throwOnInferInputFailure",
              "actualTypes",
              "expectedTypes",
              "pos",
              "expectedType",
              "actualType"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6695d84dbb705640eb3b86b1ba50c4b09d4d3156^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/connectors/DynamicSinkUtils.java",
      "locators": [
          {
              "line": 630,
              "column": 23
          },
          {
              "line": 645,
              "column": 17
          },
          {
              "line": 657,
              "column": 27
          },
          {
              "line": 681,
              "column": 26
          }
      ],
      "old_name": "updatedIndexes",
      "new_name": "colIndexes",
      "ctx": {
          "symbolName": "updatedIndexes",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<Integer>",
          "scopeHint": "in convertToRowLevelUpdate(...)",
          "filePath": "DynamicSinkUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Convert tableModify node to a RelNode representing for row-level update. */\n    private static RelNode convertToRowLevelUpdate(\n            LogicalTableModify tableModify,\n            ContextResolvedTable contextResolvedTable,\n            SupportsRowLevelUpdate.RowLevelUpdateInfo rowLevelUpdateInfo,\n            String tableDebugName,\n            DataTypeFactory dataTypeFactory,\n            FlinkTypeFactory typeFactory) {\n        // get the required columns\n        ResolvedSchema resolvedSchema = contextResolvedTable.getResolvedSchema();\n        Optional<List<Column>> optionalColumns = rowLevelUpdateInfo.requiredColumns();\n        List<Column> requiredColumns = optionalColumns.orElse(resolvedSchema.getColumns());\n        // get the root table scan which we may need rewrite it\n        LogicalTableScan tableScan = getSourceTableScan(tableModify);\n        Tuple2<List<Integer>, List<MetadataColumn>> colsIndexAndExtraMetaCols =\n                getRequireColumnsIndexAndExtraMetaCols(tableScan, requiredColumns, resolvedSchema);\n        List<Integer> updatedIndexes = colsIndexAndExtraMetaCols.f0;\n        List<MetadataColumn> metadataColumns = colsIndexAndExtraMetaCols.f1;\n        // if meta columns size is greater than 0, we need to modify the underlying\n        // LogicalTableScan to make it can read meta column\n        int originColsCount = resolvedSchema.getColumnCount();\n        if (metadataColumns.size() > 0) {\n            resolvedSchema =\n                    addExtraMetaCols(\n                            tableModify, tableScan, tableDebugName, metadataColumns, typeFactory);\n        }\n\n        return projectColumnsForUpdate(\n                tableModify,\n                originColsCount,\n                resolvedSchema,\n                updatedIndexes,\n                rowLevelUpdateInfo.getRowLevelUpdateMode(),\n                tableDebugName,\n                dataTypeFactory,\n                typeFactory);\n    }",
          "conflictNames": [
              "tableModify",
              "contextResolvedTable",
              "rowLevelUpdateInfo",
              "tableDebugName",
              "dataTypeFactory",
              "typeFactory",
              "resolvedSchema",
              "optionalColumns",
              "requiredColumns",
              "tableScan",
              "colsIndexAndExtraMetaCols",
              "metadataColumns",
              "originColsCount"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6695d84dbb705640eb3b86b1ba50c4b09d4d3156^1/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/factories/TestUpdateDeleteTableFactory.java",
      "locators": [
          {
              "line": 910,
              "column": 24
          },
          {
              "line": 913,
              "column": 49
          },
          {
              "line": 919,
              "column": 24
          },
          {
              "line": 920,
              "column": 70
          },
          {
              "line": 921,
              "column": 29
          },
          {
              "line": 922,
              "column": 49
          }
      ],
      "old_name": "dataTypes",
      "new_name": "columns",
      "ctx": {
          "symbolName": "dataTypes",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<DataType>",
          "scopeHint": "in getPrimaryKeyFieldGetter(...)",
          "filePath": "TestUpdateDeleteTableFactory.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static RowData.FieldGetter[] getPrimaryKeyFieldGetter(ResolvedSchema resolvedSchema) {\n        int[] indexes = resolvedSchema.getPrimaryKeyIndexes();\n        RowData.FieldGetter[] fieldGetters = new RowData.FieldGetter[indexes.length];\n        List<DataType> dataTypes = resolvedSchema.getColumnDataTypes();\n        for (int i = 0; i < fieldGetters.length; i++) {\n            int colIndex = indexes[i];\n            fieldGetters[i] = createFieldGetter(dataTypes.get(colIndex).getLogicalType(), colIndex);\n        }\n        return fieldGetters;\n    }",
          "conflictNames": [
              "resolvedSchema",
              "indexes",
              "fieldGetters",
              "i",
              "colIndex"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6797d6f2592373b2606ddd8c8aad316d677c1cc6^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/functions/scalar/ArrayDistinctFunction.java",
      "locators": [
          {
              "line": 38,
              "column": 43
          },
          {
              "line": 45,
              "column": 9
          },
          {
              "line": 56,
              "column": 30
          },
          {
              "line": 56,
              "column": 40
          },
          {
              "line": 57,
              "column": 25
          }
      ],
      "old_name": "element",
      "new_name": "element1",
      "ctx": {
          "symbolName": "element",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Object",
          "scopeHint": "in eval(...)",
          "filePath": "ArrayDistinctFunction.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public @Nullable ArrayData eval(ArrayData haystack) {\n        try {\n            if (haystack == null) {\n                return null;\n            }\n            Set set = new LinkedHashSet<>();\n            final int size = haystack.size();\n            for (int pos = 0; pos < size; pos++) {\n                final Object element = elementGetter.getElementOrNull(haystack, pos);\n                set.add(element);\n            }\n            return new GenericArrayData(set.toArray());\n        } catch (Throwable t) {\n            throw new FlinkRuntimeException(t);\n        }\n    }",
          "conflictNames": [
              "haystack",
              "set",
              "size",
              "pos"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6797d6f2592373b2606ddd8c8aad316d677c1cc6^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/functions/scalar/ArrayDistinctFunction.java",
      "locators": [
          {
              "line": 55,
              "column": 22
          },
          {
              "line": 55,
              "column": 31
          },
          {
              "line": 55,
              "column": 43
          },
          {
              "line": 56,
              "column": 81
          }
      ],
      "old_name": "pos",
      "new_name": "i",
      "ctx": {
          "symbolName": "pos",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in eval(...)",
          "filePath": "ArrayDistinctFunction.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public @Nullable ArrayData eval(ArrayData haystack) {\n        try {\n            if (haystack == null) {\n                return null;\n            }\n            Set set = new LinkedHashSet<>();\n            final int size = haystack.size();\n            for (int pos = 0; pos < size; pos++) {\n                final Object element = elementGetter.getElementOrNull(haystack, pos);\n                set.add(element);\n            }\n            return new GenericArrayData(set.toArray());\n        } catch (Throwable t) {\n            throw new FlinkRuntimeException(t);\n        }\n    }",
          "conflictNames": [
              "haystack",
              "set",
              "size",
              "element"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6797d6f2592373b2606ddd8c8aad316d677c1cc6^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/functions/scalar/ArrayDistinctFunction.java",
      "locators": [
          {
              "line": 53,
              "column": 17
          },
          {
              "line": 57,
              "column": 17
          },
          {
              "line": 59,
              "column": 41
          }
      ],
      "old_name": "set",
      "new_name": "list",
      "ctx": {
          "symbolName": "set",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Set",
          "scopeHint": "in eval(...)",
          "filePath": "ArrayDistinctFunction.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public @Nullable ArrayData eval(ArrayData haystack) {\n        try {\n            if (haystack == null) {\n                return null;\n            }\n            Set set = new LinkedHashSet<>();\n            final int size = haystack.size();\n            for (int pos = 0; pos < size; pos++) {\n                final Object element = elementGetter.getElementOrNull(haystack, pos);\n                set.add(element);\n            }\n            return new GenericArrayData(set.toArray());\n        } catch (Throwable t) {\n            throw new FlinkRuntimeException(t);\n        }\n    }",
          "conflictNames": [
              "haystack",
              "size",
              "pos",
              "element"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/67b02e489419d6d8a55af0b8781f80eab022e650^1/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/fs/filemapping/FileMappingManager.java",
      "locators": [
          {
              "line": 105,
              "column": 22
          },
          {
              "line": 106,
              "column": 13
          },
          {
              "line": 108,
              "column": 21
          },
          {
              "line": 109,
              "column": 32
          },
          {
              "line": 114,
              "column": 57
          },
          {
              "line": 117,
              "column": 20
          }
      ],
      "old_name": "entryInTable",
      "new_name": "existingEntry",
      "ctx": {
          "symbolName": "entryInTable",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "MappingEntry",
          "scopeHint": "in getExistingMappingEntry(...)",
          "filePath": "FileMappingManager.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private @Nullable MappingEntry getExistingMappingEntry(\n            String key, MappingEntrySource source, FileOwnership fileOwnership) {\n        MappingEntry entryInTable = mappingTable.getOrDefault(key, null);\n        if (entryInTable != null) {\n            Preconditions.checkState(\n                    entryInTable.source.equals(source)\n                            && entryInTable.fileOwnership == fileOwnership,\n                    String.format(\n                            \"Try to add a file that is already in mappingTable,\"\n                                    + \" but with inconsistent entry. Key: %s, source: %s, fileOwnership: %s. \"\n                                    + \" Entry in table: %s\",\n                            key, source, fileOwnership, entryInTable));\n\n            LOG.trace(\"Skip adding a file that already exists in mapping table: {}\", key);\n            return entryInTable;\n        }\n        return null;\n    }",
          "conflictNames": [
              "key",
              "source",
              "fileOwnership"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/67be29a003dfcaa1caccee716e6860efc1ea194d^1/flink-runtime/src/main/java/org/apache/flink/streaming/api/connector/sink2/GlobalCommitterOperator.java",
      "locators": [
          {
              "line": 135,
              "column": 47
          },
          {
              "line": 136,
              "column": 40
          },
          {
              "line": 137,
              "column": 73
          },
          {
              "line": 141,
              "column": 30
          },
          {
              "line": 142,
              "column": 50
          },
          {
              "line": 143,
              "column": 68
          },
          {
              "line": 144,
              "column": 13
          }
      ],
      "old_name": "checkpoint",
      "new_name": "committable",
      "ctx": {
          "symbolName": "checkpoint",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "CheckpointCommittableManager<CommT>",
          "scopeHint": "in commit(...)",
          "filePath": "GlobalCommitterOperator.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "d);\n        lastCompletedCheckpointId = Math.max(lastCompletedCheckpointId, checkpointId);\n        commit(lastCompletedCheckpointId);\n    }\n\n    private void commit(long checkpointId) throws IOException, InterruptedException {\n        for (CheckpointCommittableManager<CommT> checkpoint :\n                committableCollector.getCheckpointCommittablesUpTo(checkpointId)) {\n            checkpoint.commit(committer);\n        }\n        committableCollector.compact();\n    }\n\n    @Override\n    public void endInput() throws Except",
          "conflictNames": [
              "checkpointId"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/67d23fc45be45c02341a9cbd7dddea18ba40bca2^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java",
      "locators": [
          {
              "line": 22,
              "column": 34
          },
          {
              "line": 386,
              "column": 47
          },
          {
              "line": 400,
              "column": 21
          },
          {
              "line": 401,
              "column": 21
          },
          {
              "line": 402,
              "column": 21
          }
      ],
      "old_name": "tuple",
      "new_name": "pair",
      "ctx": {
          "symbolName": "tuple",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Tuple3<Integer, Integer, Integer>",
          "scopeHint": "in createBufferPoolFactory(...)",
          "filePath": "ResultPartitionFactory.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * The minimum pool size should be <code>numberOfSubpartitions + 1</code> for two\n     * considerations:\n     *\n     * <p>1. StreamTask can only process input if there is at-least one available buffer on output\n     * side, so it might cause stuck problem if the minimum pool size is exactly equal to the number\n     * of subpartitions, because every subpartition might maintain a partial unfilled buffer.\n     *\n     * <p>2. Increases one more buffer for every output LocalBufferPool to avoid performance\n     * regression if processing input is based on at-least one buffer available on output side.\n     */\n    @VisibleForTesting\n    SupplierWithException<BufferPool, IOException> createBufferPoolFactory(\n            int numberOfSubpartitions, ResultPartitionType type) {\n        return () -> {\n            Tuple3<Integer, Integer, Integer> tuple =\n                    NettyShuffleUtils.getMinMaxNetworkBuffersPerResultPartition(\n                            configuredNetworkBuffersPerChannel,\n                            floatingNetworkBuffersPerGate,\n                            sortShuffleMinParallelism,\n                            sortShuffleMinBuffers,\n                            numberOfSubpartitions,\n                            tieredStorage.isPresent(),\n                            tieredStorage\n                                    .map(ResultPartitionFactory::getNumTotalGuaranteedBuffers)\n                                    .orElse(0),\n                            type);\n\n            return bufferPoolFactory.createBufferPool(\n                    tuple.f0,\n                    tuple.f1,\n                    tuple.f2,\n                    numberOfSubpartitions,\n                    maxBuffersPerChannel,\n                    isOverdraftBufferNeeded(type) ? maxOverdraftBuffersPerGate : 0);\n        };\n    }",
          "conflictNames": [
              "numberOfSubpartitions",
              "type"
          ]
      },
      "suggestions": [
          {
              "name": "minAndMax",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/67d23fc45be45c02341a9cbd7dddea18ba40bca2^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/GateBuffersSpecTest.java",
      "locators": [
          {
              "line": 48,
              "column": 13
          },
          {
              "line": 55,
              "column": 17
          },
          {
              "line": 67,
              "column": 13
          },
          {
              "line": 74,
              "column": 17
          },
          {
              "line": 86,
              "column": 13
          },
          {
              "line": 93,
              "column": 17
          },
          {
              "line": 105,
              "column": 13
          },
          {
              "line": 112,
              "column": 17
          },
          {
              "line": 125,
              "column": 13
          },
          {
              "line": 133,
              "column": 17
          },
          {
              "line": 181,
              "column": 17
          },
          {
              "line": 186,
              "column": 70
          }
      ],
      "old_name": "maxBuffersPerGate",
      "new_name": "targetTotalBuffersPerGate",
      "ctx": {
          "symbolName": "maxBuffersPerGate",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in testCalculationWithSufficientRequiredBuffers(...)",
          "filePath": "GateBuffersSpecTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@ParameterizedTest\n    @MethodSource(\"parameters\")\n    void testCalculationWithSufficientRequiredBuffers(ResultPartitionType partitionType) {\n        int numInputChannels = 499;\n        GateBuffersSpec gateBuffersSpec = createGateBuffersSpec(numInputChannels, partitionType);\n\n        int numExclusivePerChannel = 2;\n        int expectedBuffersPerGate = 999;\n        int maxBuffersPerGate = 1006;\n\n        checkBuffersInGate(\n                gateBuffersSpec,\n                numExclusivePerChannel,\n                expectedBuffersPerGate,\n                expectedBuffersPerGate,\n                maxBuffersPerGate);\n    }",
          "conflictNames": [
              "partitionType",
              "numInputChannels",
              "gateBuffersSpec",
              "numExclusivePerChannel",
              "expectedBuffersPerGate"
          ]
      },
      "suggestions": [
          {
              "name": "targetTotalBuffersPerGate",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/67d23fc45be45c02341a9cbd7dddea18ba40bca2^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/GateBuffersSpecTest.java",
      "locators": [
          {
              "line": 47,
              "column": 13
          },
          {
              "line": 53,
              "column": 17
          },
          {
              "line": 54,
              "column": 17
          },
          {
              "line": 66,
              "column": 13
          },
          {
              "line": 72,
              "column": 17
          },
          {
              "line": 73,
              "column": 17
          },
          {
              "line": 84,
              "column": 13
          },
          {
              "line": 91,
              "column": 17
          },
          {
              "line": 92,
              "column": 17
          },
          {
              "line": 104,
              "column": 13
          },
          {
              "line": 110,
              "column": 17
          },
          {
              "line": 111,
              "column": 17
          },
          {
              "line": 179,
              "column": 17
          },
          {
              "line": 184,
              "column": 75
          }
      ],
      "old_name": "expectedBuffersPerGate",
      "new_name": "maxFloating",
      "ctx": {
          "symbolName": "expectedBuffersPerGate",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in testCalculationWithSufficientRequiredBuffers(...)",
          "filePath": "GateBuffersSpecTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@ParameterizedTest\n    @MethodSource(\"parameters\")\n    void testCalculationWithSufficientRequiredBuffers(ResultPartitionType partitionType) {\n        int numInputChannels = 499;\n        GateBuffersSpec gateBuffersSpec = createGateBuffersSpec(numInputChannels, partitionType);\n\n        int numExclusivePerChannel = 2;\n        int expectedBuffersPerGate = 999;\n        int maxBuffersPerGate = 1006;\n\n        checkBuffersInGate(\n                gateBuffersSpec,\n                numExclusivePerChannel,\n                expectedBuffersPerGate,\n                expectedBuffersPerGate,\n                maxBuffersPerGate);\n    }",
          "conflictNames": [
              "partitionType",
              "numInputChannels",
              "gateBuffersSpec",
              "numExclusivePerChannel",
              "maxBuffersPerGate"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/67d23fc45be45c02341a9cbd7dddea18ba40bca2^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/GateBuffersSpecTest.java",
      "locators": [
          {
              "line": 124,
              "column": 13
          },
          {
              "line": 131,
              "column": 17
          },
          {
              "line": 132,
              "column": 17
          },
          {
              "line": 180,
              "column": 17
          },
          {
              "line": 185,
              "column": 70
          }
      ],
      "old_name": "minBuffersPerGate",
      "new_name": "minFloating",
      "ctx": {
          "symbolName": "minBuffersPerGate",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in testCalculationWithConfiguredZeroExclusiveBuffer(...)",
          "filePath": "GateBuffersSpecTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@ParameterizedTest\n    @MethodSource(\"parameters\")\n    void testCalculationWithConfiguredZeroExclusiveBuffer(ResultPartitionType partitionType) {\n        int numInputChannels = 1001;\n        int numExclusiveBuffersPerChannel = 0;\n        GateBuffersSpec gateBuffersSpec =\n                createGateBuffersSpec(\n                        numInputChannels, partitionType, numExclusiveBuffersPerChannel);\n\n        int minBuffersPerGate = 1;\n        int maxBuffersPerGate = 8;\n        int numExclusivePerChannel = 0;\n\n        checkBuffersInGate(\n                gateBuffersSpec,\n                numExclusivePerChannel,\n                minBuffersPerGate,\n                minBuffersPerGate,\n                maxBuffersPerGate);\n    }",
          "conflictNames": [
              "partitionType",
              "numInputChannels",
              "numExclusiveBuffersPerChannel",
              "gateBuffersSpec",
              "maxBuffersPerGate",
              "numExclusivePerChannel"
          ]
      },
      "suggestions": [
          {
              "name": "totalFloatingBuffers",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/67d23fc45be45c02341a9cbd7dddea18ba40bca2^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java",
      "locators": [
          {
              "line": 621,
              "column": 13
          },
          {
              "line": 625,
              "column": 13
          },
          {
              "line": 638,
              "column": 31
          },
          {
              "line": 683,
              "column": 17
          },
          {
              "line": 687,
              "column": 21
          },
          {
              "line": 692,
              "column": 52
          },
          {
              "line": 717,
              "column": 17
          },
          {
              "line": 723,
              "column": 17
          },
          {
              "line": 728,
              "column": 55
          }
      ],
      "old_name": "totalWeight",
      "new_name": "totalCapacity",
      "ctx": {
          "symbolName": "totalWeight",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in redistributeBuffers(...)",
          "filePath": "NetworkBufferPool.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "// Must be called from synchronized block\n    private void redistributeBuffers() {\n        assert Thread.holdsLock(factoryLock);\n\n        if (resizableBufferPools.isEmpty()) {\n            return;\n        }\n\n        // All buffers, which are not among the required ones\n        int numAvailableMemorySegment = totalNumberOfMemorySegments - numTotalRequiredBuffers;\n\n        if (numAvailableMemorySegment == 0) {\n            // in this case, we need to redistribute buffers so that every pool gets its minimum\n            for (LocalBufferPool bufferPool : resizableBufferPools) {\n                bufferPool.setNumBuffers(bufferPool.getMinNumberOfMemorySegments());\n            }\n            return;\n        }\n\n        // Calculates the number of buffers that can be redistributed and the total weight of buffer\n        // pools that are resizable\n        int totalWeight = 0;\n        int numBuffersToBeRedistributed = numAvailableMemorySegment;\n        for (LocalBufferPool bufferPool : resizableBufferPools) {\n            numBuffersToBeRedistributed += bufferPool.getMinNumberOfMemorySegments();\n            totalWeight += bufferPool.getExpectedNumberOfMemorySegments();\n        }\n\n        // First, all buffers are allocated proportionally according to the expected values of each\n        // pool as weights. However, due to the constraints of minimum and maximum values, the\n        // actual number of buffers distributed may be more or less than the total number of\n        // buffers.\n        int totalAllocated = 0;\n        Map<LocalBufferPool, Integer> cachedPoolSize = new HashMap<>(resizableBufferPools.size());\n        for (LocalBufferPool bufferPool : resizableBufferPools) {\n            int expectedNumBuffers =\n                    bufferPool.getExpectedNumberOfMemorySegments()\n                            * numBuffersToBeRedistributed\n                            / totalWeight;\n            int actualAllocated =\n                    Math.min(\n                            bufferPool.getMaxNumberOfMemorySegments(),\n                            Math.max(\n                                    bufferPool.getMinNumberOfMemorySegments(), expectedNumBuffers));\n            cachedPoolSize.put(bufferPool, actualAllocated);\n            totalAllocated += actualAllocated;\n        }\n\n        // Now we need to deal with this difference, which may be greater than zero or less than\n        // zero.\n        int delta = numBuffersToBeRedistributed - totalAllocated;\n\n        int remaining = Integer.MAX_VALUE;\n        while (remaining != 0) {\n            remaining = redistributeBuffers(delta, cachedPoolSize);\n\n            // Stop the loop iteration when there is no remaining segments to be redistributed\n            // or all local buffer pools have reached the max number.\n            if (remaining == delta) {\n                break;\n            }\n            delta = remaining;\n        }\n\n        for (LocalBufferPool bufferPool : resizableBufferPools) {\n            bufferPool.setNumBuffers(\n                    cachedPoolSize.getOrDefault(\n                            bufferPool, bufferPool.getMinNumberOfMemorySegments()));\n        }\n    }",
          "conflictNames": [
              "numAvailableMemorySegment",
              "numBuffersToBeRedistributed",
              "totalAllocated",
              "cachedPoolSize",
              "expectedNumBuffers",
              "actualAllocated",
              "delta",
              "remaining"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/67d23fc45be45c02341a9cbd7dddea18ba40bca2^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java",
      "locators": [
          {
              "line": 650,
              "column": 13
          },
          {
              "line": 654,
              "column": 45
          },
          {
              "line": 658,
              "column": 30
          },
          {
              "line": 661,
              "column": 13
          },
          {
              "line": 672,
              "column": 15
          },
          {
              "line": 676,
              "column": 41
          },
          {
              "line": 679,
              "column": 13
          },
          {
              "line": 692,
              "column": 43
          },
          {
              "line": 696,
              "column": 33
          },
          {
              "line": 708,
              "column": 39
          },
          {
              "line": 712,
              "column": 20
          },
          {
              "line": 713,
              "column": 20
          },
          {
              "line": 727,
              "column": 17
          },
          {
              "line": 727,
              "column": 37
          },
          {
              "line": 728,
              "column": 43
          },
          {
              "line": 732,
              "column": 33
          },
          {
              "line": 744,
              "column": 41
          },
          {
              "line": 748,
              "column": 20
          }
      ],
      "old_name": "delta",
      "new_name": "excessMax",
      "ctx": {
          "symbolName": "delta",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in redistributeBuffers(...)",
          "filePath": "NetworkBufferPool.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "// Must be called from synchronized block\n    private void redistributeBuffers() {\n        assert Thread.holdsLock(factoryLock);\n\n        if (resizableBufferPools.isEmpty()) {\n            return;\n        }\n\n        // All buffers, which are not among the required ones\n        int numAvailableMemorySegment = totalNumberOfMemorySegments - numTotalRequiredBuffers;\n\n        if (numAvailableMemorySegment == 0) {\n            // in this case, we need to redistribute buffers so that every pool gets its minimum\n            for (LocalBufferPool bufferPool : resizableBufferPools) {\n                bufferPool.setNumBuffers(bufferPool.getMinNumberOfMemorySegments());\n            }\n            return;\n        }\n\n        // Calculates the number of buffers that can be redistributed and the total weight of buffer\n        // pools that are resizable\n        int totalWeight = 0;\n        int numBuffersToBeRedistributed = numAvailableMemorySegment;\n        for (LocalBufferPool bufferPool : resizableBufferPools) {\n            numBuffersToBeRedistributed += bufferPool.getMinNumberOfMemorySegments();\n            totalWeight += bufferPool.getExpectedNumberOfMemorySegments();\n        }\n\n        // First, all buffers are allocated proportionally according to the expected values of each\n        // pool as weights. However, due to the constraints of minimum and maximum values, the\n        // actual number of buffers distributed may be more or less than the total number of\n        // buffers.\n        int totalAllocated = 0;\n        Map<LocalBufferPool, Integer> cachedPoolSize = new HashMap<>(resizableBufferPools.size());\n        for (LocalBufferPool bufferPool : resizableBufferPools) {\n            int expectedNumBuffers =\n                    bufferPool.getExpectedNumberOfMemorySegments()\n                            * numBuffersToBeRedistributed\n                            / totalWeight;\n            int actualAllocated =\n                    Math.min(\n                            bufferPool.getMaxNumberOfMemorySegments(),\n                            Math.max(\n                                    bufferPool.getMinNumberOfMemorySegments(), expectedNumBuffers));\n            cachedPoolSize.put(bufferPool, actualAllocated);\n            totalAllocated += actualAllocated;\n        }\n\n        // Now we need to deal with this difference, which may be greater than zero or less than\n        // zero.\n        int delta = numBuffersToBeRedistributed - totalAllocated;\n\n        int remaining = Integer.MAX_VALUE;\n        while (remaining != 0) {\n            remaining = redistributeBuffers(delta, cachedPoolSize);\n\n            // Stop the loop iteration when there is no remaining segments to be redistributed\n            // or all local buffer pools have reached the max number.\n            if (remaining == delta) {\n                break;\n            }\n            delta = remaining;\n        }\n\n        for (LocalBufferPool bufferPool : resizableBufferPools) {\n            bufferPool.setNumBuffers(\n                    cachedPoolSize.getOrDefault(\n                            bufferPool, bufferPool.getMinNumberOfMemorySegments()));\n        }\n    }",
          "conflictNames": [
              "numAvailableMemorySegment",
              "totalWeight",
              "numBuffersToBeRedistributed",
              "totalAllocated",
              "cachedPoolSize",
              "expectedNumBuffers",
              "actualAllocated",
              "remaining"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/67d23fc45be45c02341a9cbd7dddea18ba40bca2^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java",
      "locators": [
          {
              "line": 632,
              "column": 13
          },
          {
              "line": 645,
              "column": 13
          },
          {
              "line": 650,
              "column": 51
          },
          {
              "line": 691,
              "column": 17
          },
          {
              "line": 696,
              "column": 41
          },
          {
              "line": 706,
              "column": 17
          },
          {
              "line": 708,
              "column": 21
          },
          {
              "line": 712,
              "column": 28
          }
      ],
      "old_name": "totalAllocated",
      "new_name": "totalPartsUsed",
      "ctx": {
          "symbolName": "totalAllocated",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in redistributeBuffers(...)",
          "filePath": "NetworkBufferPool.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "// Must be called from synchronized block\n    private void redistributeBuffers() {\n        assert Thread.holdsLock(factoryLock);\n\n        if (resizableBufferPools.isEmpty()) {\n            return;\n        }\n\n        // All buffers, which are not among the required ones\n        int numAvailableMemorySegment = totalNumberOfMemorySegments - numTotalRequiredBuffers;\n\n        if (numAvailableMemorySegment == 0) {\n            // in this case, we need to redistribute buffers so that every pool gets its minimum\n            for (LocalBufferPool bufferPool : resizableBufferPools) {\n                bufferPool.setNumBuffers(bufferPool.getMinNumberOfMemorySegments());\n            }\n            return;\n        }\n\n        // Calculates the number of buffers that can be redistributed and the total weight of buffer\n        // pools that are resizable\n        int totalWeight = 0;\n        int numBuffersToBeRedistributed = numAvailableMemorySegment;\n        for (LocalBufferPool bufferPool : resizableBufferPools) {\n            numBuffersToBeRedistributed += bufferPool.getMinNumberOfMemorySegments();\n            totalWeight += bufferPool.getExpectedNumberOfMemorySegments();\n        }\n\n        // First, all buffers are allocated proportionally according to the expected values of each\n        // pool as weights. However, due to the constraints of minimum and maximum values, the\n        // actual number of buffers distributed may be more or less than the total number of\n        // buffers.\n        int totalAllocated = 0;\n        Map<LocalBufferPool, Integer> cachedPoolSize = new HashMap<>(resizableBufferPools.size());\n        for (LocalBufferPool bufferPool : resizableBufferPools) {\n            int expectedNumBuffers =\n                    bufferPool.getExpectedNumberOfMemorySegments()\n                            * numBuffersToBeRedistributed\n                            / totalWeight;\n            int actualAllocated =\n                    Math.min(\n                            bufferPool.getMaxNumberOfMemorySegments(),\n                            Math.max(\n                                    bufferPool.getMinNumberOfMemorySegments(), expectedNumBuffers));\n            cachedPoolSize.put(bufferPool, actualAllocated);\n            totalAllocated += actualAllocated;\n        }\n\n        // Now we need to deal with this difference, which may be greater than zero or less than\n        // zero.\n        int delta = numBuffersToBeRedistributed - totalAllocated;\n\n        int remaining = Integer.MAX_VALUE;\n        while (remaining != 0) {\n            remaining = redistributeBuffers(delta, cachedPoolSize);\n\n            // Stop the loop iteration when there is no remaining segments to be redistributed\n            // or all local buffer pools have reached the max number.\n            if (remaining == delta) {\n                break;\n            }\n            delta = remaining;\n        }\n\n        for (LocalBufferPool bufferPool : resizableBufferPools) {\n            bufferPool.setNumBuffers(\n                    cachedPoolSize.getOrDefault(\n                            bufferPool, bufferPool.getMinNumberOfMemorySegments()));\n        }\n    }",
          "conflictNames": [
              "numAvailableMemorySegment",
              "totalWeight",
              "numBuffersToBeRedistributed",
              "cachedPoolSize",
              "expectedNumBuffers",
              "actualAllocated",
              "delta",
              "remaining"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/67d23fc45be45c02341a9cbd7dddea18ba40bca2^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputGateSpecUtils.java",
      "locators": [
          {
              "line": 46,
              "column": 13
          },
          {
              "line": 55,
              "column": 62
          }
      ],
      "old_name": "targetExpectedBuffersPerGate",
      "new_name": "targetRequiredBuffersPerGate",
      "ctx": {
          "symbolName": "targetExpectedBuffersPerGate",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in createGateBuffersSpec(...)",
          "filePath": "InputGateSpecUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static GateBuffersSpec createGateBuffersSpec(\n            Optional<Integer> configuredMaxRequiredBuffersPerGate,\n            int configuredNetworkBuffersPerChannel,\n            int configuredFloatingNetworkBuffersPerGate,\n            ResultPartitionType partitionType,\n            int numInputChannels,\n            boolean enableTieredStorage) {\n        int maxRequiredBuffersThresholdPerGate =\n                getEffectiveMaxRequiredBuffersPerGate(\n                        partitionType, configuredMaxRequiredBuffersPerGate, enableTieredStorage);\n        int targetExpectedBuffersPerGate =\n                getExpectedBuffersTargetPerGate(\n                        numInputChannels, configuredNetworkBuffersPerChannel);\n        int maxBuffersPerGate =\n                getMaxBuffersPerGate(\n                        numInputChannels,\n                        configuredNetworkBuffersPerChannel,\n                        configuredFloatingNetworkBuffersPerGate);\n        int expectedBuffersPerGate =\n                Math.min(maxRequiredBuffersThresholdPerGate, targetExpectedBuffersPerGate);\n        int effectiveExclusiveBuffersPerChannel =\n                getExclusiveBuffersPerChannel(\n                        configuredNetworkBuffersPerChannel,\n                        numInputChannels,\n                        expectedBuffersPerGate);\n        int minBuffersPerGate =\n                partitionType.isHybridResultPartition() && enableTieredStorage\n                        ? TieredStorageUtils.getMinBuffersPerGate()\n                        : expectedBuffersPerGate;\n        expectedBuffersPerGate = Math.max(minBuffersPerGate, expectedBuffersPerGate);\n\n        return new GateBuffersSpec(\n                effectiveExclusiveBuffersPerChannel,\n                expectedBuffersPerGate,\n                minBuffersPerGate,\n                maxBuffersPerGate);\n    }",
          "conflictNames": [
              "configuredMaxRequiredBuffersPerGate",
              "configuredNetworkBuffersPerChannel",
              "configuredFloatingNetworkBuffersPerGate",
              "partitionType",
              "numInputChannels",
              "enableTieredStorage",
              "maxRequiredBuffersThresholdPerGate",
              "maxBuffersPerGate",
              "expectedBuffersPerGate",
              "effectiveExclusiveBuffersPerChannel",
              "minBuffersPerGate"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/67d23fc45be45c02341a9cbd7dddea18ba40bca2^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputGateSpecUtils.java",
      "locators": [
          {
              "line": 49,
              "column": 13
          },
          {
              "line": 71,
              "column": 17
          }
      ],
      "old_name": "maxBuffersPerGate",
      "new_name": "targetTotalBuffersPerGate",
      "ctx": {
          "symbolName": "maxBuffersPerGate",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in createGateBuffersSpec(...)",
          "filePath": "InputGateSpecUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static GateBuffersSpec createGateBuffersSpec(\n            Optional<Integer> configuredMaxRequiredBuffersPerGate,\n            int configuredNetworkBuffersPerChannel,\n            int configuredFloatingNetworkBuffersPerGate,\n            ResultPartitionType partitionType,\n            int numInputChannels,\n            boolean enableTieredStorage) {\n        int maxRequiredBuffersThresholdPerGate =\n                getEffectiveMaxRequiredBuffersPerGate(\n                        partitionType, configuredMaxRequiredBuffersPerGate, enableTieredStorage);\n        int targetExpectedBuffersPerGate =\n                getExpectedBuffersTargetPerGate(\n                        numInputChannels, configuredNetworkBuffersPerChannel);\n        int maxBuffersPerGate =\n                getMaxBuffersPerGate(\n                        numInputChannels,\n                        configuredNetworkBuffersPerChannel,\n                        configuredFloatingNetworkBuffersPerGate);\n        int expectedBuffersPerGate =\n                Math.min(maxRequiredBuffersThresholdPerGate, targetExpectedBuffersPerGate);\n        int effectiveExclusiveBuffersPerChannel =\n                getExclusiveBuffersPerChannel(\n                        configuredNetworkBuffersPerChannel,\n                        numInputChannels,\n                        expectedBuffersPerGate);\n        int minBuffersPerGate =\n                partitionType.isHybridResultPartition() && enableTieredStorage\n                        ? TieredStorageUtils.getMinBuffersPerGate()\n                        : expectedBuffersPerGate;\n        expectedBuffersPerGate = Math.max(minBuffersPerGate, expectedBuffersPerGate);\n\n        return new GateBuffersSpec(\n                effectiveExclusiveBuffersPerChannel,\n                expectedBuffersPerGate,\n                minBuffersPerGate,\n                maxBuffersPerGate);\n    }",
          "conflictNames": [
              "configuredMaxRequiredBuffersPerGate",
              "configuredNetworkBuffersPerChannel",
              "configuredFloatingNetworkBuffersPerGate",
              "partitionType",
              "numInputChannels",
              "enableTieredStorage",
              "maxRequiredBuffersThresholdPerGate",
              "targetExpectedBuffersPerGate",
              "expectedBuffersPerGate",
              "effectiveExclusiveBuffersPerChannel",
              "minBuffersPerGate"
          ]
      },
      "suggestions": [
          {
              "name": "targetTotalBuffersPerGate",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/67d23fc45be45c02341a9cbd7dddea18ba40bca2^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputGateSpecUtils.java",
      "locators": [
          {
              "line": 54,
              "column": 13
          },
          {
              "line": 60,
              "column": 25
          },
          {
              "line": 64,
              "column": 27
          },
          {
              "line": 65,
              "column": 9
          },
          {
              "line": 65,
              "column": 62
          },
          {
              "line": 69,
              "column": 17
          }
      ],
      "old_name": "expectedBuffersPerGate",
      "new_name": "requiredBuffersPerGate",
      "ctx": {
          "symbolName": "expectedBuffersPerGate",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in createGateBuffersSpec(...)",
          "filePath": "InputGateSpecUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static GateBuffersSpec createGateBuffersSpec(\n            Optional<Integer> configuredMaxRequiredBuffersPerGate,\n            int configuredNetworkBuffersPerChannel,\n            int configuredFloatingNetworkBuffersPerGate,\n            ResultPartitionType partitionType,\n            int numInputChannels,\n            boolean enableTieredStorage) {\n        int maxRequiredBuffersThresholdPerGate =\n                getEffectiveMaxRequiredBuffersPerGate(\n                        partitionType, configuredMaxRequiredBuffersPerGate, enableTieredStorage);\n        int targetExpectedBuffersPerGate =\n                getExpectedBuffersTargetPerGate(\n                        numInputChannels, configuredNetworkBuffersPerChannel);\n        int maxBuffersPerGate =\n                getMaxBuffersPerGate(\n                        numInputChannels,\n                        configuredNetworkBuffersPerChannel,\n                        configuredFloatingNetworkBuffersPerGate);\n        int expectedBuffersPerGate =\n                Math.min(maxRequiredBuffersThresholdPerGate, targetExpectedBuffersPerGate);\n        int effectiveExclusiveBuffersPerChannel =\n                getExclusiveBuffersPerChannel(\n                        configuredNetworkBuffersPerChannel,\n                        numInputChannels,\n                        expectedBuffersPerGate);\n        int minBuffersPerGate =\n                partitionType.isHybridResultPartition() && enableTieredStorage\n                        ? TieredStorageUtils.getMinBuffersPerGate()\n                        : expectedBuffersPerGate;\n        expectedBuffersPerGate = Math.max(minBuffersPerGate, expectedBuffersPerGate);\n\n        return new GateBuffersSpec(\n                effectiveExclusiveBuffersPerChannel,\n                expectedBuffersPerGate,\n                minBuffersPerGate,\n                maxBuffersPerGate);\n    }",
          "conflictNames": [
              "configuredMaxRequiredBuffersPerGate",
              "configuredNetworkBuffersPerChannel",
              "configuredFloatingNetworkBuffersPerGate",
              "partitionType",
              "numInputChannels",
              "enableTieredStorage",
              "maxRequiredBuffersThresholdPerGate",
              "targetExpectedBuffersPerGate",
              "maxBuffersPerGate",
              "effectiveExclusiveBuffersPerChannel",
              "minBuffersPerGate"
          ]
      },
      "suggestions": [
          {
              "name": "maxFloating",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/67d23fc45be45c02341a9cbd7dddea18ba40bca2^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputGateSpecUtils.java",
      "locators": [
          {
              "line": 61,
              "column": 13
          },
          {
              "line": 65,
              "column": 43
          },
          {
              "line": 70,
              "column": 17
          }
      ],
      "old_name": "minBuffersPerGate",
      "new_name": "totalFloatingBuffers",
      "ctx": {
          "symbolName": "minBuffersPerGate",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in createGateBuffersSpec(...)",
          "filePath": "InputGateSpecUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static GateBuffersSpec createGateBuffersSpec(\n            Optional<Integer> configuredMaxRequiredBuffersPerGate,\n            int configuredNetworkBuffersPerChannel,\n            int configuredFloatingNetworkBuffersPerGate,\n            ResultPartitionType partitionType,\n            int numInputChannels,\n            boolean enableTieredStorage) {\n        int maxRequiredBuffersThresholdPerGate =\n                getEffectiveMaxRequiredBuffersPerGate(\n                        partitionType, configuredMaxRequiredBuffersPerGate, enableTieredStorage);\n        int targetExpectedBuffersPerGate =\n                getExpectedBuffersTargetPerGate(\n                        numInputChannels, configuredNetworkBuffersPerChannel);\n        int maxBuffersPerGate =\n                getMaxBuffersPerGate(\n                        numInputChannels,\n                        configuredNetworkBuffersPerChannel,\n                        configuredFloatingNetworkBuffersPerGate);\n        int expectedBuffersPerGate =\n                Math.min(maxRequiredBuffersThresholdPerGate, targetExpectedBuffersPerGate);\n        int effectiveExclusiveBuffersPerChannel =\n                getExclusiveBuffersPerChannel(\n                        configuredNetworkBuffersPerChannel,\n                        numInputChannels,\n                        expectedBuffersPerGate);\n        int minBuffersPerGate =\n                partitionType.isHybridResultPartition() && enableTieredStorage\n                        ? TieredStorageUtils.getMinBuffersPerGate()\n                        : expectedBuffersPerGate;\n        expectedBuffersPerGate = Math.max(minBuffersPerGate, expectedBuffersPerGate);\n\n        return new GateBuffersSpec(\n                effectiveExclusiveBuffersPerChannel,\n                expectedBuffersPerGate,\n                minBuffersPerGate,\n                maxBuffersPerGate);\n    }",
          "conflictNames": [
              "configuredMaxRequiredBuffersPerGate",
              "configuredNetworkBuffersPerChannel",
              "configuredFloatingNetworkBuffersPerGate",
              "partitionType",
              "numInputChannels",
              "enableTieredStorage",
              "maxRequiredBuffersThresholdPerGate",
              "targetExpectedBuffersPerGate",
              "maxBuffersPerGate",
              "expectedBuffersPerGate",
              "effectiveExclusiveBuffersPerChannel"
          ]
      },
      "suggestions": [
          {
              "name": "minFloating",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/67d23fc45be45c02341a9cbd7dddea18ba40bca2^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java",
      "locators": [
          {
              "line": 1276,
              "column": 13
          },
          {
              "line": 1278,
              "column": 13
          },
          {
              "line": 1286,
              "column": 28
          }
      ],
      "old_name": "maxBuffersPerGate",
      "new_name": "targetTotalBuffersPerGate",
      "ctx": {
          "symbolName": "maxBuffersPerGate",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in verifyBuffersInBufferPool(...)",
          "filePath": "SingleInputGateTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void verifyBuffersInBufferPool(boolean isPipeline, int subpartitionRandSize)\n            throws Exception {\n        IntermediateResultPartitionID[] partitionIds =\n                new IntermediateResultPartitionID[] {\n                    new IntermediateResultPartitionID(),\n                    new IntermediateResultPartitionID(),\n                    new IntermediateResultPartitionID()\n                };\n\n        IndexRange subpartitionIndexRange = new IndexRange(0, subpartitionRandSize - 1);\n        NettyShuffleEnvironmentBuilder nettyShuffleEnvironmentBuilder =\n                new NettyShuffleEnvironmentBuilder();\n        Optional<Integer> expectMaxRequiredBuffersPerGate =\n                isPipeline\n                        ? Optional.of(\n                                InputGateSpecUtils.DEFAULT_MAX_REQUIRED_BUFFERS_PER_GATE_FOR_STREAM)\n                        : Optional.of(\n                                InputGateSpecUtils.DEFAULT_MAX_REQUIRED_BUFFERS_PER_GATE_FOR_BATCH);\n        nettyShuffleEnvironmentBuilder.setMaxRequiredBuffersPerGate(\n                expectMaxRequiredBuffersPerGate);\n        NettyShuffleEnvironment netEnv = nettyShuffleEnvironmentBuilder.build();\n\n        SingleInputGate gate =\n                createSingleInputGate(\n                        partitionIds,\n                        isPipeline ? ResultPartitionType.PIPELINED : ResultPartitionType.BLOCKING,\n                        subpartitionIndexRange,\n                        netEnv,\n                        ResourceID.generate(),\n                        new TestingConnectionManager(),\n                        new TestingResultPartitionManager(new NoOpResultSubpartitionView()));\n        gate.setup();\n\n        for (InputChannel inputChannel : gate.inputChannels()) {\n            if (inputChannel instanceof RemoteInputChannel) {\n                assertThat(((RemoteInputChannel) inputChannel).getInitialCredit()).isEqualTo(0);\n            }\n        }\n\n        int maxBuffersPerGate = 2 * partitionIds.length * subpartitionRandSize + 8;\n        int minBuffersPerGate;\n        if (maxBuffersPerGate >= expectMaxRequiredBuffersPerGate.get()) {\n            minBuffersPerGate = expectMaxRequiredBuffersPerGate.get();\n        } else {\n            minBuffersPerGate = 2 * partitionIds.length * subpartitionRandSize + 1;\n        }\n        assertThat(gate.getBufferPool().getExpectedNumberOfMemorySegments())\n                .isEqualTo(minBuffersPerGate);\n        assertThat(gate.getBufferPool().getMaxNumberOfMemorySegments())\n                .isEqualTo(maxBuffersPerGate);\n    }",
          "conflictNames": [
              "isPipeline",
              "subpartitionRandSize",
              "partitionIds",
              "subpartitionIndexRange",
              "nettyShuffleEnvironmentBuilder",
              "expectMaxRequiredBuffersPerGate",
              "netEnv",
              "gate",
              "minBuffersPerGate"
          ]
      },
      "suggestions": [
          {
              "name": "targetTotalBuffersPerGate",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/67d23fc45be45c02341a9cbd7dddea18ba40bca2^1/flink-runtime/src/main/java/org/apache/flink/runtime/shuffle/NettyShuffleUtils.java",
      "locators": [
          {
              "line": 21,
              "column": 34
          },
          {
              "line": 27,
              "column": 33
          },
          {
              "line": 67,
              "column": 24
          },
          {
              "line": 185,
              "column": 43
          },
          {
              "line": 203,
              "column": 51
          },
          {
              "line": 203,
              "column": 62
          }
      ],
      "old_name": "tuple",
      "new_name": "minAndMax",
      "ctx": {
          "symbolName": "tuple",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Tuple3<Integer, Integer, Integer>",
          "scopeHint": "in getNumBuffersToAnnounceForResultPartition(...)",
          "filePath": "NettyShuffleUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static int getNumBuffersToAnnounceForResultPartition(\n            ResultPartitionType type,\n            int configuredNetworkBuffersPerChannel,\n            int floatingBuffersPerGate,\n            int sortShuffleMinParallelism,\n            int sortShuffleMinBuffers,\n            int numSubpartitions) {\n\n        Tuple3<Integer, Integer, Integer> tuple =\n                getMinMaxNetworkBuffersPerResultPartition(\n                        configuredNetworkBuffersPerChannel,\n                        floatingBuffersPerGate,\n                        sortShuffleMinParallelism,\n                        sortShuffleMinBuffers,\n                        numSubpartitions,\n                        false,\n                        0,\n                        type);\n\n        // In order to avoid network buffer request timeout (see FLINK-12852), we announce\n        // network buffer requirement by below:\n        // 1. For canBePipelined shuffle, the floating buffers may not be returned in time due to\n        // back pressure so we need to include all the floating buffers in the announcement, i.e. we\n        // should take the max value;\n        // 2. For blocking shuffle, it is back pressure free and floating buffers can be recycled\n        // in time, so that the minimum required buffers would be enough.\n        int ret = type.canBePipelinedConsumed() ? tuple.f2 : tuple.f0;\n\n        if (ret == Integer.MAX_VALUE) {\n            // Should never reach this branch. Result partition will allocate an unbounded\n            // buffer pool only when type is ResultPartitionType.PIPELINED. But fine-grained\n            // resource management is disabled in such case.\n            throw new IllegalArgumentException(\n                    \"Illegal to announce network memory requirement as Integer.MAX_VALUE, partition type: \"\n                            + type);\n        }\n        return ret;\n    }",
          "conflictNames": [
              "type",
              "configuredNetworkBuffersPerChannel",
              "floatingBuffersPerGate",
              "sortShuffleMinParallelism",
              "sortShuffleMinBuffers",
              "numSubpartitions",
              "ret"
          ]
      },
      "suggestions": [
          {
              "name": "pair",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/67d23fc45be45c02341a9cbd7dddea18ba40bca2^1/flink-runtime/src/main/java/org/apache/flink/runtime/shuffle/NettyShuffleUtils.java",
      "locators": [
          {
              "line": 67,
              "column": 57
          },
          {
              "line": 81,
              "column": 13
          },
          {
              "line": 83,
              "column": 13
          },
          {
              "line": 85,
              "column": 13
          },
          {
              "line": 91,
              "column": 19
          },
          {
              "line": 93,
              "column": 64
          },
          {
              "line": 103,
              "column": 29
          },
          {
              "line": 109,
              "column": 26
          }
      ],
      "old_name": "expected",
      "new_name": "min",
      "ctx": {
          "symbolName": "expected",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in getMinMaxNetworkBuffersPerResultPartition(...)",
          "filePath": "NettyShuffleUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Calculates and returns local network buffer pool size used by the result partition. The value\n     * in the returned tuple respectively represent the expected, min and max buffers of the pool.\n     */\n    public static Tuple3<Integer, Integer, Integer> getMinMaxNetworkBuffersPerResultPartition(\n            final int configuredNetworkBuffersPerChannel,\n            final int numFloatingBuffersPerGate,\n            final int sortShuffleMinParallelism,\n            final int sortShuffleMinBuffers,\n            final int numSubpartitions,\n            final boolean enableTieredStorage,\n            final int tieredStoreExclusiveBuffers,\n            final ResultPartitionType type) {\n        boolean isSortShuffle =\n                type.isBlockingOrBlockingPersistentResultPartition()\n                        && numSubpartitions >= sortShuffleMinParallelism;\n        int expected;\n        if (isSortShuffle) {\n            expected = sortShuffleMinBuffers;\n        } else {\n            expected =\n                    enableTieredStorage\n                            ? Math.min(tieredStoreExclusiveBuffers, numSubpartitions + 1)\n                            : (numSubpartitions + 1);\n        }\n\n        int min = expected;\n        if (type.isHybridResultPartition()) {\n            min = Math.min(DEFAULT_HYBRID_SHUFFLE_MIN_BUFFERS, expected);\n        }\n\n        int max =\n                type.isBounded()\n                        ? numSubpartitions * configuredNetworkBuffersPerChannel\n                                + numFloatingBuffersPerGate\n                        : (isSortShuffle\n                                ? 4 * numSubpartitions\n                                : NetworkBufferPool.UNBOUNDED_POOL_SIZE);\n        max = Math.max(max, expected);\n        // for each upstream hash-based blocking/pipelined subpartition, at least one buffer is\n        // needed even the configured network buffers per channel is 0 and this behavior is for\n        // performance. If it's not guaranteed that each subpartition can get at least one buffer,\n        // more partial buffers with little data will be outputted to network/disk and recycled to\n        // be used by other subpartitions which can not get a buffer for data caching.\n        return Tuple3.of(expected, min, max);\n    }",
          "conflictNames": [
              "configuredNetworkBuffersPerChannel",
              "numFloatingBuffersPerGate",
              "sortShuffleMinParallelism",
              "sortShuffleMinBuffers",
              "numSubpartitions",
              "enableTieredStorage",
              "tieredStoreExclusiveBuffers",
              "type",
              "isSortShuffle",
              "min",
              "max"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6806f30fe234790f25b5ca83e6d2910286a76aeb^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultExecutionDeployer.java",
      "locators": [
          {
              "line": 97,
              "column": 45
          },
          {
              "line": 102,
              "column": 70
          },
          {
              "line": 133,
              "column": 49
          },
          {
              "line": 139,
              "column": 56
          }
      ],
      "old_name": "executionSlotAssignments",
      "new_name": "executionSlotAssignmentMap",
      "ctx": {
          "symbolName": "executionSlotAssignments",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<ExecutionSlotAssignment>",
          "scopeHint": "in allocateSlotsAndDeploy(...)",
          "filePath": "DefaultExecutionDeployer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void allocateSlotsAndDeploy(\n            final List<Execution> executionsToDeploy,\n            final Map<ExecutionVertexID, ExecutionVertexVersion> requiredVersionByVertex) {\n        validateExecutionStates(executionsToDeploy);\n\n        transitionToScheduled(executionsToDeploy);\n\n        final List<ExecutionSlotAssignment> executionSlotAssignments =\n                allocateSlotsFor(executionsToDeploy);\n\n        final List<ExecutionDeploymentHandle> deploymentHandles =\n                createDeploymentHandles(\n                        executionsToDeploy, requiredVersionByVertex, executionSlotAssignments);\n\n        waitForAllSlotsAndDeploy(deploymentHandles);\n    }",
          "conflictNames": [
              "executionsToDeploy",
              "requiredVersionByVertex",
              "deploymentHandles"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/69def87107a3b2faef09efaae2702a202d07a9cb^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/exec/stream/StreamExecChangelogNormalize.java",
      "locators": [
          {
              "line": 132,
              "column": 20
          },
          {
              "line": 148,
              "column": 29
          },
          {
              "line": 159,
              "column": 29
          }
      ],
      "old_name": "stateIdleTime",
      "new_name": "stateRetentionTime",
      "ctx": {
          "symbolName": "stateIdleTime",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "long",
          "scopeHint": "in translateToPlanInternal(...)",
          "filePath": "StreamExecChangelogNormalize.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@SuppressWarnings(\"unchecked\")\n    @Override\n    protected Transformation<RowData> translateToPlanInternal(\n            PlannerBase planner, ExecNodeConfig config) {\n        final ExecEdge inputEdge = getInputEdges().get(0);\n        final Transformation<RowData> inputTransform =\n                (Transformation<RowData>) inputEdge.translateToPlan(planner);\n        final InternalTypeInfo<RowData> rowTypeInfo =\n                (InternalTypeInfo<RowData>) inputTransform.getOutputType();\n\n        final OneInputStreamOperator<RowData, RowData> operator;\n        final long stateIdleTime = config.getStateRetentionTime();\n        final boolean isMiniBatchEnabled =\n                config.get(ExecutionConfigOptions.TABLE_EXEC_MINIBATCH_ENABLED);\n\n        GeneratedRecordEqualiser generatedEqualiser =\n                new EqualiserCodeGenerator(\n                                rowTypeInfo.toRowType(), planner.getFlinkContext().getClassLoader())\n                        .generateRecordEqualiser(\"DeduplicateRowEqualiser\");\n\n        if (isMiniBatchEnabled) {\n            TypeSerializer<RowData> rowSerializer =\n                    rowTypeInfo.createSerializer(planner.getExecEnv().getConfig());\n            ProcTimeMiniBatchDeduplicateKeepLastRowFunction processFunction =\n                    new ProcTimeMiniBatchDeduplicateKeepLastRowFunction(\n                            rowTypeInfo,\n                            rowSerializer,\n                            stateIdleTime,\n                            generateUpdateBefore,\n                            true, // generateInsert\n                            false, // inputInsertOnly\n                            generatedEqualiser);\n            CountBundleTrigger<RowData> trigger = AggregateUtil.createMiniBatchTrigger(config);\n            operator = new KeyedMapBundleOperator<>(processFunction, trigger);\n        } else {\n            ProcTimeDeduplicateKeepLastRowFunction processFunction =\n                    new ProcTimeDeduplicateKeepLastRowFunction(\n                            rowTypeInfo,\n                            stateIdleTime,\n                            generateUpdateBefore,\n                            true, // generateInsert\n                            false, // inputInsertOnly\n                            generatedEqualiser);\n            operator = new KeyedProcessOperator<>(processFunction);\n        }\n\n        final OneInputTransformation<RowData, RowData> transform =\n                ExecNodeUtil.createOneInputTransformation(\n                        inputTransform,\n                        createTransformationMeta(CHANGELOG_NORMALIZE_TRANSFORMATION, config),\n                        operator,\n                        rowTypeInfo,\n                        inputTransform.getParallelism(),\n                        false);\n\n        final RowDataKeySelector selector =\n                KeySelectorUtil.getRowDataSelector(\n                        planner.getFlinkContext().getClassLoader(), uniqueKeys, rowTypeInfo);\n        transform.setStateKeySelector(selector);\n        transform.setStateKeyType(selector.getProducedType());\n\n        return transform;\n    }",
          "conflictNames": [
              "planner",
              "config",
              "inputEdge",
              "inputTransform",
              "rowTypeInfo",
              "operator",
              "isMiniBatchEnabled",
              "generatedEqualiser",
              "rowSerializer",
              "processFunction",
              "trigger",
              "transform",
              "selector"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/69def87107a3b2faef09efaae2702a202d07a9cb^1/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/nodes/exec/TransformationsTest.java",
      "locators": [
          {
              "line": 52,
              "column": 42
          },
          {
              "line": 53,
              "column": 42
          },
          {
              "line": 54,
              "column": 42
          },
          {
              "line": 55,
              "column": 42
          },
          {
              "line": 56,
              "column": 42
          },
          {
              "line": 57,
              "column": 42
          },
          {
              "line": 139,
              "column": 35
          },
          {
              "line": 146,
              "column": 9
          },
          {
              "line": 205,
              "column": 17
          },
          {
              "line": 211,
              "column": 17
          },
          {
              "line": 212,
              "column": 25
          },
          {
              "line": 222,
              "column": 17
          },
          {
              "line": 235,
              "column": 35
          },
          {
              "line": 240,
              "column": 9
          }
      ],
      "old_name": "config",
      "new_name": "json",
      "ctx": {
          "symbolName": "config",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Consumer<TableConfig>",
          "scopeHint": "in checkUids(...)",
          "filePath": "TransformationsTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "   c.set(TABLE_EXEC_UID_GENERATION, PLAN_ONLY);\n                    c.set(TABLE_EXEC_LEGACY_TRANSFORMATION_UIDS, true);\n                },\n                false,\n                false);\n    }\n\n    private static void checkUids(\n            Consumer<TableConfig> config,\n            boolean expectUidWithCompilation,\n            boolean expectUidWithoutCompilation) {\n        final StreamTableEnvironment env =\n                StreamTableEnvironment.create(\n                        StreamExecutionEnvironment.",
          "conflictNames": [
              "expectUidWithCompilation",
              "expectUidWithoutCompilation",
              "env",
              "table",
              "memoryPlan",
              "memoryUids",
              "jsonPlan",
              "jsonUids",
              "inlineUids"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6ab3c3d9881b833278e29d205c0bca1acf575be5^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveScheduler.java",
      "locators": [
          {
              "line": 224,
              "column": 22
          },
          {
              "line": 229,
              "column": 17
          },
          {
              "line": 284,
              "column": 37
          }
      ],
      "old_name": "allocationTimeoutDefault",
      "new_name": "submissionResourceWaitTimeoutDefault",
      "ctx": {
          "symbolName": "allocationTimeoutDefault",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Duration",
          "scopeHint": "in of(...)",
          "filePath": "AdaptiveScheduler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static Settings of(\n                Configuration configuration,\n                @Nullable JobCheckpointingSettings checkpointingConfiguration)\n                throws ConfigurationException {\n            final SchedulerExecutionMode executionMode =\n                    configuration.get(JobManagerOptions.SCHEDULER_MODE);\n            Duration allocationTimeoutDefault =\n                    JobManagerOptions.RESOURCE_WAIT_TIMEOUT.defaultValue();\n            Duration stabilizationTimeoutDefault =\n                    JobManagerOptions.RESOURCE_STABILIZATION_TIMEOUT.defaultValue();\n            if (executionMode == SchedulerExecutionMode.REACTIVE) {\n                allocationTimeoutDefault = Duration.ofMillis(-1);\n                stabilizationTimeoutDefault = Duration.ZERO;\n            }\n\n            final Duration scalingIntervalMin =\n                    configuration.get(JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MIN);\n\n            final int rescaleOnFailedCheckpointsCount =\n                    configuration.get(\n                            JobManagerOptions.SCHEDULER_SCALE_ON_FAILED_CHECKPOINTS_COUNT);\n            if (rescaleOnFailedCheckpointsCount < 1) {\n                throw new ConfigurationException(\n                        String.format(\n                                \"%s should have a value of 1 or higher.\",\n                                JobManagerOptions.SCHEDULER_SCALE_ON_FAILED_CHECKPOINTS_COUNT\n                                        .key()));\n            }\n\n            // default value generation is documented in JobManagerOption\n            final Duration maximumDelayForRescaleTriggerDefault =\n                    checkpointingConfiguration != null\n                                    && checkpointingConfiguration\n                                            .getCheckpointCoordinatorConfiguration()\n                                            .isCheckpointingEnabled()\n                            // incrementing the rescaleOnFailedCheckpointsCount by 1 is done to\n                            // avoid introducing a race-condition between the two parameters\n                            // (SCHEDULER_SCALE_ON_FAILED_CHECKPOINTS_COUNT and\n                            // MAXIMUM_DELAY_FOR_SCALE_TRIGGER). Without the increment, we would\n                            // have two configuration parameters that result in roughly the same\n                            // timeout (with the MAXIMUM_DELAY_FOR_SCALE_TRIGGER being probably a\n                            // bit faster). The user might experience unexpected behavior if the\n                            // SCHEDULER_SCALE_ON_FAILED_CHECKPOINTS_COUNT is configured and\n                            // MAXIMUM_DELAY_FOR_SCALE_TRIGGER is kept untouched in that case.\n                            // Incrementing the default value should help avoiding causing this kind\n                            // of confusing race condition.\n                            ? Duration.ofMillis(\n                                    (rescaleOnFailedCheckpointsCount + 1)\n                                            * checkpointingConfiguration\n                                                    .getCheckpointCoordinatorConfiguration()\n                                                    .getCheckpointInterval())\n                            : Duration.ZERO;\n\n            if (configuration.getOptional(JobManagerOptions.MIN_PARALLELISM_INCREASE).isPresent()) {\n                LOG.warn(\n                        \"The configuration option {} is deprecated and will be removed in future versions. It's not used anymore. \"\n                                + \"Please use the configuration option {} and {} to control the sensitivity of a scaling operation.\",\n                        JobManagerOptions.MIN_PARALLELISM_INCREASE.key(),\n                        JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MIN.key(),\n                        JobManagerOptions.SCHEDULER_SCALING_RESOURCE_STABILIZATION_TIMEOUT.key());\n            }\n\n            return new Settings(\n                    executionMode,\n                    configuration\n                            .getOptional(JobManagerOptions.RESOURCE_WAIT_TIMEOUT)\n                            .orElse(allocationTimeoutDefault),\n                    configuration\n                            .getOptional(JobManagerOptions.RESOURCE_STABILIZATION_TIMEOUT)\n                            .orElse(stabilizationTimeoutDefault),\n                    configuration.get(JobManagerOptions.SLOT_IDLE_TIMEOUT),\n                    scalingIntervalMin,\n                    configuration.get(\n                            JobManagerOptions.SCHEDULER_SCALING_RESOURCE_STABILIZATION_TIMEOUT),\n                    configuration.get(\n                            MAXIMUM_DELAY_FOR_SCALE_TRIGGER, maximumDelayForRescaleTriggerDefault),\n                    rescaleOnFailedCheckpointsCount);\n        }",
          "conflictNames": [
              "configuration",
              "checkpointingConfiguration",
              "executionMode",
              "stabilizationTimeoutDefault",
              "scalingIntervalMin",
              "rescaleOnFailedCheckpointsCount",
              "maximumDelayForRescaleTriggerDefault"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6ab3c3d9881b833278e29d205c0bca1acf575be5^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveScheduler.java",
      "locators": [
          {
              "line": 226,
              "column": 22
          },
          {
              "line": 230,
              "column": 17
          },
          {
              "line": 287,
              "column": 37
          }
      ],
      "old_name": "stabilizationTimeoutDefault",
      "new_name": "submissionStabilizationTimeoutDefault",
      "ctx": {
          "symbolName": "stabilizationTimeoutDefault",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Duration",
          "scopeHint": "in of(...)",
          "filePath": "AdaptiveScheduler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static Settings of(\n                Configuration configuration,\n                @Nullable JobCheckpointingSettings checkpointingConfiguration)\n                throws ConfigurationException {\n            final SchedulerExecutionMode executionMode =\n                    configuration.get(JobManagerOptions.SCHEDULER_MODE);\n            Duration allocationTimeoutDefault =\n                    JobManagerOptions.RESOURCE_WAIT_TIMEOUT.defaultValue();\n            Duration stabilizationTimeoutDefault =\n                    JobManagerOptions.RESOURCE_STABILIZATION_TIMEOUT.defaultValue();\n            if (executionMode == SchedulerExecutionMode.REACTIVE) {\n                allocationTimeoutDefault = Duration.ofMillis(-1);\n                stabilizationTimeoutDefault = Duration.ZERO;\n            }\n\n            final Duration scalingIntervalMin =\n                    configuration.get(JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MIN);\n\n            final int rescaleOnFailedCheckpointsCount =\n                    configuration.get(\n                            JobManagerOptions.SCHEDULER_SCALE_ON_FAILED_CHECKPOINTS_COUNT);\n            if (rescaleOnFailedCheckpointsCount < 1) {\n                throw new ConfigurationException(\n                        String.format(\n                                \"%s should have a value of 1 or higher.\",\n                                JobManagerOptions.SCHEDULER_SCALE_ON_FAILED_CHECKPOINTS_COUNT\n                                        .key()));\n            }\n\n            // default value generation is documented in JobManagerOption\n            final Duration maximumDelayForRescaleTriggerDefault =\n                    checkpointingConfiguration != null\n                                    && checkpointingConfiguration\n                                            .getCheckpointCoordinatorConfiguration()\n                                            .isCheckpointingEnabled()\n                            // incrementing the rescaleOnFailedCheckpointsCount by 1 is done to\n                            // avoid introducing a race-condition between the two parameters\n                            // (SCHEDULER_SCALE_ON_FAILED_CHECKPOINTS_COUNT and\n                            // MAXIMUM_DELAY_FOR_SCALE_TRIGGER). Without the increment, we would\n                            // have two configuration parameters that result in roughly the same\n                            // timeout (with the MAXIMUM_DELAY_FOR_SCALE_TRIGGER being probably a\n                            // bit faster). The user might experience unexpected behavior if the\n                            // SCHEDULER_SCALE_ON_FAILED_CHECKPOINTS_COUNT is configured and\n                            // MAXIMUM_DELAY_FOR_SCALE_TRIGGER is kept untouched in that case.\n                            // Incrementing the default value should help avoiding causing this kind\n                            // of confusing race condition.\n                            ? Duration.ofMillis(\n                                    (rescaleOnFailedCheckpointsCount + 1)\n                                            * checkpointingConfiguration\n                                                    .getCheckpointCoordinatorConfiguration()\n                                                    .getCheckpointInterval())\n                            : Duration.ZERO;\n\n            if (configuration.getOptional(JobManagerOptions.MIN_PARALLELISM_INCREASE).isPresent()) {\n                LOG.warn(\n                        \"The configuration option {} is deprecated and will be removed in future versions. It's not used anymore. \"\n                                + \"Please use the configuration option {} and {} to control the sensitivity of a scaling operation.\",\n                        JobManagerOptions.MIN_PARALLELISM_INCREASE.key(),\n                        JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MIN.key(),\n                        JobManagerOptions.SCHEDULER_SCALING_RESOURCE_STABILIZATION_TIMEOUT.key());\n            }\n\n            return new Settings(\n                    executionMode,\n                    configuration\n                            .getOptional(JobManagerOptions.RESOURCE_WAIT_TIMEOUT)\n                            .orElse(allocationTimeoutDefault),\n                    configuration\n                            .getOptional(JobManagerOptions.RESOURCE_STABILIZATION_TIMEOUT)\n                            .orElse(stabilizationTimeoutDefault),\n                    configuration.get(JobManagerOptions.SLOT_IDLE_TIMEOUT),\n                    scalingIntervalMin,\n                    configuration.get(\n                            JobManagerOptions.SCHEDULER_SCALING_RESOURCE_STABILIZATION_TIMEOUT),\n                    configuration.get(\n                            MAXIMUM_DELAY_FOR_SCALE_TRIGGER, maximumDelayForRescaleTriggerDefault),\n                    rescaleOnFailedCheckpointsCount);\n        }",
          "conflictNames": [
              "configuration",
              "checkpointingConfiguration",
              "executionMode",
              "allocationTimeoutDefault",
              "scalingIntervalMin",
              "rescaleOnFailedCheckpointsCount",
              "maximumDelayForRescaleTriggerDefault"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6ab3c3d9881b833278e29d205c0bca1acf575be5^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveScheduler.java",
      "locators": [
          {
              "line": 233,
              "column": 28
          },
          {
              "line": 289,
              "column": 21
          },
          {
              "line": 301,
              "column": 32
          },
          {
              "line": 311,
              "column": 26
          },
          {
              "line": 319,
              "column": 18
          },
          {
              "line": 319,
              "column": 39
          },
          {
              "line": 342,
              "column": 20
          }
      ],
      "old_name": "scalingIntervalMin",
      "new_name": "executingCooldownTimeout",
      "ctx": {
          "symbolName": "scalingIntervalMin",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Duration",
          "scopeHint": "in of(...)",
          "filePath": "AdaptiveScheduler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static Settings of(\n                Configuration configuration,\n                @Nullable JobCheckpointingSettings checkpointingConfiguration)\n                throws ConfigurationException {\n            final SchedulerExecutionMode executionMode =\n                    configuration.get(JobManagerOptions.SCHEDULER_MODE);\n            Duration allocationTimeoutDefault =\n                    JobManagerOptions.RESOURCE_WAIT_TIMEOUT.defaultValue();\n            Duration stabilizationTimeoutDefault =\n                    JobManagerOptions.RESOURCE_STABILIZATION_TIMEOUT.defaultValue();\n            if (executionMode == SchedulerExecutionMode.REACTIVE) {\n                allocationTimeoutDefault = Duration.ofMillis(-1);\n                stabilizationTimeoutDefault = Duration.ZERO;\n            }\n\n            final Duration scalingIntervalMin =\n                    configuration.get(JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MIN);\n\n            final int rescaleOnFailedCheckpointsCount =\n                    configuration.get(\n                            JobManagerOptions.SCHEDULER_SCALE_ON_FAILED_CHECKPOINTS_COUNT);\n            if (rescaleOnFailedCheckpointsCount < 1) {\n                throw new ConfigurationException(\n                        String.format(\n                                \"%s should have a value of 1 or higher.\",\n                                JobManagerOptions.SCHEDULER_SCALE_ON_FAILED_CHECKPOINTS_COUNT\n                                        .key()));\n            }\n\n            // default value generation is documented in JobManagerOption\n            final Duration maximumDelayForRescaleTriggerDefault =\n                    checkpointingConfiguration != null\n                                    && checkpointingConfiguration\n                                            .getCheckpointCoordinatorConfiguration()\n                                            .isCheckpointingEnabled()\n                            // incrementing the rescaleOnFailedCheckpointsCount by 1 is done to\n                            // avoid introducing a race-condition between the two parameters\n                            // (SCHEDULER_SCALE_ON_FAILED_CHECKPOINTS_COUNT and\n                            // MAXIMUM_DELAY_FOR_SCALE_TRIGGER). Without the increment, we would\n                            // have two configuration parameters that result in roughly the same\n                            // timeout (with the MAXIMUM_DELAY_FOR_SCALE_TRIGGER being probably a\n                            // bit faster). The user might experience unexpected behavior if the\n                            // SCHEDULER_SCALE_ON_FAILED_CHECKPOINTS_COUNT is configured and\n                            // MAXIMUM_DELAY_FOR_SCALE_TRIGGER is kept untouched in that case.\n                            // Incrementing the default value should help avoiding causing this kind\n                            // of confusing race condition.\n                            ? Duration.ofMillis(\n                                    (rescaleOnFailedCheckpointsCount + 1)\n                                            * checkpointingConfiguration\n                                                    .getCheckpointCoordinatorConfiguration()\n                                                    .getCheckpointInterval())\n                            : Duration.ZERO;\n\n            if (configuration.getOptional(JobManagerOptions.MIN_PARALLELISM_INCREASE).isPresent()) {\n                LOG.warn(\n                        \"The configuration option {} is deprecated and will be removed in future versions. It's not used anymore. \"\n                                + \"Please use the configuration option {} and {} to control the sensitivity of a scaling operation.\",\n                        JobManagerOptions.MIN_PARALLELISM_INCREASE.key(),\n                        JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MIN.key(),\n                        JobManagerOptions.SCHEDULER_SCALING_RESOURCE_STABILIZATION_TIMEOUT.key());\n            }\n\n            return new Settings(\n                    executionMode,\n                    configuration\n                            .getOptional(JobManagerOptions.RESOURCE_WAIT_TIMEOUT)\n                            .orElse(allocationTimeoutDefault),\n                    configuration\n                            .getOptional(JobManagerOptions.RESOURCE_STABILIZATION_TIMEOUT)\n                            .orElse(stabilizationTimeoutDefault),\n                    configuration.get(JobManagerOptions.SLOT_IDLE_TIMEOUT),\n                    scalingIntervalMin,\n                    configuration.get(\n                            JobManagerOptions.SCHEDULER_SCALING_RESOURCE_STABILIZATION_TIMEOUT),\n                    configuration.get(\n                            MAXIMUM_DELAY_FOR_SCALE_TRIGGER, maximumDelayForRescaleTriggerDefault),\n                    rescaleOnFailedCheckpointsCount);\n        }",
          "conflictNames": [
              "configuration",
              "checkpointingConfiguration",
              "executionMode",
              "allocationTimeoutDefault",
              "stabilizationTimeoutDefault",
              "rescaleOnFailedCheckpointsCount",
              "maximumDelayForRescaleTriggerDefault"
          ]
      },
      "suggestions": [
          {
              "name": "executingCooldownTimeout",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/6ab3c3d9881b833278e29d205c0bca1acf575be5^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerTest.java",
      "locators": [
          {
              "line": 2202,
              "column": 24
          },
          {
              "line": 2205,
              "column": 77
          },
          {
              "line": 2211,
              "column": 64
          },
          {
              "line": 2332,
              "column": 24
          },
          {
              "line": 2336,
              "column": 77
          },
          {
              "line": 2359,
              "column": 55
          }
      ],
      "old_name": "scalingIntervalMin",
      "new_name": "executingCooldownTimeout",
      "ctx": {
          "symbolName": "scalingIntervalMin",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Duration",
          "scopeHint": "in testScalingIntervalConfigurationIsRespected(...)",
          "filePath": "AdaptiveSchedulerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testScalingIntervalConfigurationIsRespected() throws ConfigurationException {\n        final Duration scalingIntervalMin = Duration.ofMillis(1337);\n        final Duration scalingStabilizationTimeout = Duration.ofMillis(7331);\n        final Configuration configuration = createConfigurationWithNoTimeouts();\n        configuration.set(JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MIN, scalingIntervalMin);\n        configuration.set(\n                JobManagerOptions.SCHEDULER_SCALING_RESOURCE_STABILIZATION_TIMEOUT,\n                scalingStabilizationTimeout);\n\n        final AdaptiveScheduler.Settings settings = AdaptiveScheduler.Settings.of(configuration);\n        assertThat(settings.getScalingIntervalMin()).isEqualTo(scalingIntervalMin);\n        assertThat(settings.getScalingResourceStabilizationTimeout())\n                .isEqualTo(scalingStabilizationTimeout);\n    }",
          "conflictNames": [
              "scalingStabilizationTimeout",
              "configuration",
              "settings"
          ]
      },
      "suggestions": [
          {
              "name": "executingCooldownTimeout",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/6ab3c3d9881b833278e29d205c0bca1acf575be5^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerTest.java",
      "locators": [
          {
              "line": 2333,
              "column": 24
          },
          {
              "line": 2340,
              "column": 17
          },
          {
              "line": 2362,
              "column": 28
          }
      ],
      "old_name": "scalingResourceStabilizationTimeout",
      "new_name": "executingResourceStabilizationTimeout",
      "ctx": {
          "symbolName": "scalingResourceStabilizationTimeout",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Duration",
          "scopeHint": "in testGoToExecutingConfiguresStateTransitionManagerFactory(...)",
          "filePath": "AdaptiveSchedulerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testGoToExecutingConfiguresStateTransitionManagerFactory() throws Exception {\n        final OneShotLatch latch = new OneShotLatch();\n        final TestingStateTransitionManagerFactory factory =\n                new TestingStateTransitionManagerFactory(\n                        ctx ->\n                                TestingStateTransitionManager.withOnChangeEventOnly(\n                                        () -> {\n                                            if (ctx instanceof WaitingForResources) {\n                                                ctx.transitionToSubsequentState();\n                                            }\n                                            if (ctx instanceof Executing) {\n                                                latch.trigger();\n                                            }\n                                        }));\n\n        final Configuration configuration = new Configuration();\n        final Duration scalingIntervalMin = Duration.ofMillis(1L);\n        final Duration scalingResourceStabilizationTimeout = Duration.ofMillis(5L);\n        final Duration maxDelayForTrigger = Duration.ofMillis(10L);\n\n        configuration.set(JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MIN, scalingIntervalMin);\n        configuration.set(JobManagerOptions.MAXIMUM_DELAY_FOR_SCALE_TRIGGER, maxDelayForTrigger);\n        configuration.set(\n                JobManagerOptions.SCHEDULER_SCALING_RESOURCE_STABILIZATION_TIMEOUT,\n                scalingResourceStabilizationTimeout);\n\n        scheduler =\n                new AdaptiveSchedulerBuilder(\n                                createJobGraph(),\n                                singleThreadMainThreadExecutor,\n                                EXECUTOR_RESOURCE.getExecutor())\n                        .setJobMasterConfiguration(configuration)\n                        .setDeclarativeSlotPool(getSlotPoolWithFreeSlots(PARALLELISM))\n                        .setStateTransitionManagerFactory(factory)\n                        .build();\n\n        // start scheduling to reach Executing state\n        singleThreadMainThreadExecutor.execute(scheduler::startScheduling);\n\n        // let's wait for the onChange event in Executing state.\n        latch.await();\n\n        assertThat(scheduler.getState()).isInstanceOf(Executing.class);\n        assertThat(factory.cooldownTimeout).isEqualTo(scalingIntervalMin);\n        assertThat(factory.maximumDelayForTrigger).isEqualTo(maxDelayForTrigger);\n        assertThat(factory.resourceStabilizationTimeout)\n                .isEqualTo(scalingResourceStabilizationTimeout);\n    }",
          "conflictNames": [
              "latch",
              "factory",
              "configuration",
              "scalingIntervalMin",
              "maxDelayForTrigger"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6afee1de6585074e0df6205f1f52bb239dcf4a77^1/flink-connectors/flink-connector-base/src/test/java/org/apache/flink/connector/base/source/reader/fetcher/SplitFetcherManagerTest.java",
      "locators": [
          {
              "line": 77,
              "column": 75
          },
          {
              "line": 82,
              "column": 44
          },
          {
              "line": 85,
              "column": 20
          },
          {
              "line": 87,
              "column": 20
          },
          {
              "line": 91,
              "column": 9
          },
          {
              "line": 109,
              "column": 73
          },
          {
              "line": 113,
              "column": 50
          },
          {
              "line": 118,
              "column": 69
          },
          {
              "line": 120,
              "column": 16
          }
      ],
      "old_name": "queue",
      "new_name": "configuration",
      "ctx": {
          "symbolName": "queue",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "FutureCompletingBlockingQueue<RecordsWithSplitIds<Integer>>",
          "scopeHint": "in testExceptionPropagation(...)",
          "filePath": "SplitFetcherManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "// the final modifier is important so that '@SafeVarargs' is accepted on Java 8\n    @SuppressWarnings(\"FinalPrivateMethod\")\n    @SafeVarargs\n    private final void testExceptionPropagation(\n            final RecordsWithSplitIds<Integer>... fetchesBeforeError) throws Exception {\n        final IOException testingException = new IOException(\"test\");\n\n        final FutureCompletingBlockingQueue<RecordsWithSplitIds<Integer>> queue =\n                new FutureCompletingBlockingQueue<>(10);\n        final AwaitingReader<Integer, TestingSourceSplit> reader =\n                new AwaitingReader<>(testingException, fetchesBeforeError);\n        final SplitFetcherManager<Integer, TestingSourceSplit> fetcher =\n                createFetcher(\"testSplit\", queue, reader);\n\n        reader.awaitAllRecordsReturned();\n        drainQueue(queue);\n\n        assertThat(queue.getAvailabilityFuture().isDone()).isFalse();\n        reader.triggerThrowException();\n\n        // await the error propagation\n        queue.getAvailabilityFuture().get();\n\n        try {\n            fetcher.checkErrors();\n            fail(\"expected exception\");\n        } catch (Exception e) {\n            assertThat(e.getCause().getCause()).isSameAs(testingException);\n        } finally {\n            fetcher.close(20_000L);\n        }\n    }",
          "conflictNames": [
              "fetchesBeforeError",
              "testingException",
              "reader",
              "fetcher"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6d2724fa840469a5d14869628c0a89ce6b7f4cc4^1/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/PseudoRandomValueSelectorTest.java",
      "locators": [
          {
              "line": 92,
              "column": 25
          },
          {
              "line": 102,
              "column": 79
          }
      ],
      "old_name": "numbers",
      "new_name": "memorySizes",
      "ctx": {
          "symbolName": "numbers",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Integer[]",
          "scopeHint": "in testStableRandomization(...)",
          "filePath": "PseudoRandomValueSelectorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Tests that the selector produces the same value for the same seed. */\n    @Test\n    void testStableRandomization() {\n        final Double[] doubles =\n                IntStream.range(0, 1000).boxed().map(Double::valueOf).toArray(Double[]::new);\n        final Integer[] numbers = IntStream.range(0, 1000).boxed().toArray(Integer[]::new);\n        final String[] strings =\n                IntStream.range(0, 1000).mapToObj(i -> \"string\" + i).toArray(String[]::new);\n\n        final Set<Tuple3<Double, Integer, String>> uniqueValues = new HashSet<>(1);\n        for (int i = 0; i < 100; i++) {\n            final PseudoRandomValueSelector selector = PseudoRandomValueSelector.create(\"test\");\n            uniqueValues.add(\n                    new Tuple3<>(\n                            selectValue(selector, CPU_CORES, doubles),\n                            selectValue(selector, JOB_MANAGER_HEAP_MEMORY_MB, numbers),\n                            selectValue(selector, SAVEPOINT_DIRECTORY, strings)));\n        }\n        assertThat(uniqueValues).hasSize(1);\n    }",
          "conflictNames": [
              "doubles",
              "strings",
              "uniqueValues",
              "i",
              "selector"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6dcb10abf319b9e5494a82bee71f1ae1a4e4b211^1/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV2V3SerializerBase.java",
      "locators": [
          {
              "line": 127,
              "column": 27
          },
          {
              "line": 590,
              "column": 71
          },
          {
              "line": 591,
              "column": 41
          },
          {
              "line": 592,
              "column": 30
          },
          {
              "line": 594,
              "column": 67
          },
          {
              "line": 817,
              "column": 58
          },
          {
              "line": 817,
              "column": 70
          },
          {
              "line": 818,
              "column": 26
          },
          {
              "line": 819,
              "column": 40
          }
      ],
      "old_name": "entry",
      "new_name": "handleAndLocalPath",
      "ctx": {
          "symbolName": "entry",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Entry<String, StateMetaInfo>",
          "scopeHint": "in serializeOperatorStateHandle(...)",
          "filePath": "MetadataV2V3SerializerBase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "ERATOR_STATE_HANDLE);\n            Map<String, OperatorStateHandle.StateMetaInfo> partitionOffsetsMap =\n                    stateHandle.getStateNameToPartitionOffsets();\n            dos.writeInt(partitionOffsetsMap.size());\n            for (Map.Entry<String, OperatorStateHandle.StateMetaInfo> entry :\n                    partitionOffsetsMap.entrySet()) {\n                dos.writeUTF(entry.getKey());\n\n                OperatorStateHandle.StateMetaInfo stateMetaInfo = entry.getValue();\n\n                int mode = stateMetaInfo.getDistrib",
          "conflictNames": [
              "stateHandle",
              "dos",
              "partitionOffsetsMap",
              "stateMetaInfo",
              "mode",
              "offsets"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6dcb10abf319b9e5494a82bee71f1ae1a4e4b211^1/flink-runtime/src/test/java/org/apache/flink/runtime/state/IncrementalRemoteKeyedStateHandleTest.java",
      "locators": [
          {
              "line": 52,
              "column": 32
          },
          {
              "line": 53,
              "column": 20
          },
          {
              "line": 56,
              "column": 32
          },
          {
              "line": 57,
              "column": 20
          },
          {
              "line": 72,
              "column": 29
          },
          {
              "line": 76,
              "column": 17
          },
          {
              "line": 120,
              "column": 32
          },
          {
              "line": 122,
              "column": 20
          },
          {
              "line": 125,
              "column": 58
          },
          {
              "line": 127,
              "column": 20
          },
          {
              "line": 130,
              "column": 58
          },
          {
              "line": 132,
              "column": 20
          },
          {
              "line": 183,
              "column": 52
          },
          {
              "line": 204,
              "column": 31
          },
          {
              "line": 238,
              "column": 43
          },
          {
              "line": 241,
              "column": 38
          },
          {
              "line": 243,
              "column": 22
          }
      ],
      "old_name": "handle",
      "new_name": "handleAndLocalPath",
      "ctx": {
          "symbolName": "handle",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "StreamStateHandle",
          "scopeHint": "in testUnregisteredDiscarding(...)",
          "filePath": "IncrementalRemoteKeyedStateHandleTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "ding shared) is discarded.\n     */\n    @Test\n    public void testUnregisteredDiscarding() throws Exception {\n        IncrementalRemoteKeyedStateHandle stateHandle = create(new Random(42));\n\n        stateHandle.discardState();\n\n        for (StreamStateHandle handle : stateHandle.getPrivateState().values()) {\n            verify(handle).discardState();\n        }\n\n        for (StreamStateHandle handle : stateHandle.getSharedState().values()) {\n            verify(handle).discardState();\n        }\n\n      ",
          "conflictNames": [
              "stateHandle"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6dcb10abf319b9e5494a82bee71f1ae1a4e4b211^1/flink-runtime/src/test/java/org/apache/flink/runtime/state/IncrementalRemoteKeyedStateHandleTest.java",
      "locators": [
          {
              "line": 77,
              "column": 58
          },
          {
              "line": 78,
              "column": 47
          },
          {
              "line": 79,
              "column": 20
          },
          {
              "line": 81,
              "column": 58
          },
          {
              "line": 82,
              "column": 47
          },
          {
              "line": 83,
              "column": 20
          },
          {
              "line": 92,
              "column": 47
          },
          {
              "line": 102,
              "column": 47
          },
          {
              "line": 115,
              "column": 58
          },
          {
              "line": 116,
              "column": 47
          },
          {
              "line": 117,
              "column": 20
          },
          {
              "line": 126,
              "column": 48
          },
          {
              "line": 131,
              "column": 48
          },
          {
              "line": 143,
              "column": 58
          },
          {
              "line": 144,
              "column": 47
          },
          {
              "line": 145,
              "column": 20
          },
          {
              "line": 148,
              "column": 58
          },
          {
              "line": 149,
              "column": 47
          },
          {
              "line": 150,
              "column": 20
          },
          {
              "line": 270,
              "column": 58
          },
          {
              "line": 270,
              "column": 70
          },
          {
              "line": 271,
              "column": 13
          },
          {
              "line": 271,
              "column": 32
          }
      ],
      "old_name": "entry",
      "new_name": "handleAndLocalPath",
      "ctx": {
          "symbolName": "entry",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Entry<StateHandleID, StreamStateHandle>",
          "scopeHint": "in testSharedStateDeRegistration(...)",
          "filePath": "IncrementalRemoteKeyedStateHandleTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "rementalRemoteKeyedStateHandle stateHandle1 = create(new Random(42));\n        IncrementalRemoteKeyedStateHandle stateHandle2 = create(new Random(42));\n\n        // Both handles should not be registered and not discarded by now.\n        for (Map.Entry<StateHandleID, StreamStateHandle> entry :\n                stateHandle1.getSharedState().entrySet()) {\n            verify(entry.getValue(), times(0)).discardState();\n        }\n        for (Map.Entry<StateHandleID, StreamStateHandle> entry :\n                stateHandle2.getSharedS",
          "conflictNames": [
              "registry",
              "stateHandle1",
              "stateHandle2",
              "registryKey"
          ]
      },
      "suggestions": [
          {
              "name": "handleAndLocalPath",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/6dcb10abf319b9e5494a82bee71f1ae1a4e4b211^1/flink-runtime/src/test/java/org/apache/flink/runtime/state/IncrementalRemoteKeyedStateHandleTest.java",
      "locators": [
          {
              "line": 91,
              "column": 58
          },
          {
              "line": 96,
              "column": 29
          },
          {
              "line": 98,
              "column": 61
          },
          {
              "line": 101,
              "column": 58
          },
          {
              "line": 106,
              "column": 29
          },
          {
              "line": 108,
              "column": 61
          }
      ],
      "old_name": "stateHandleEntry",
      "new_name": "handleAndLocalPath",
      "ctx": {
          "symbolName": "stateHandleEntry",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Entry<StateHandleID, StreamStateHandle>",
          "scopeHint": "in testSharedStateDeRegistration(...)",
          "filePath": "IncrementalRemoteKeyedStateHandleTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "es(0)).discardState();\n        }\n\n        // Now we register both ...\n        stateHandle1.registerSharedStates(registry, 0L);\n        registry.checkpointCompleted(0L);\n        stateHandle2.registerSharedStates(registry, 0L);\n\n        for (Map.Entry<StateHandleID, StreamStateHandle> stateHandleEntry :\n                stateHandle1.getSharedState().entrySet()) {\n\n            SharedStateRegistryKey registryKey =\n                    stateHandle1.createSharedStateRegistryKeyFromFileName(\n                            stateHandleEntry.getKey(",
          "conflictNames": [
              "registry",
              "stateHandle1",
              "stateHandle2",
              "registryKey"
          ]
      },
      "suggestions": [
          {
              "name": "stateHandleAndLocalPath",
              "confidence": 0.75
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/6dcb10abf319b9e5494a82bee71f1ae1a4e4b211^1/flink-runtime/src/test/java/org/apache/flink/runtime/state/IncrementalRemoteKeyedStateHandleTest.java",
      "locators": [
          {
              "line": 125,
              "column": 58
          },
          {
              "line": 127,
              "column": 20
          },
          {
              "line": 130,
              "column": 58
          },
          {
              "line": 132,
              "column": 20
          }
      ],
      "old_name": "handleEntry",
      "new_name": "handleAndLocalPath",
      "ctx": {
          "symbolName": "handleEntry",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Entry<StateHandleID, StreamStateHandle>",
          "scopeHint": "in testSharedStateDeRegistration(...)",
          "filePath": "IncrementalRemoteKeyedStateHandleTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "()) {\n            verify(entry.getValue(), times(0)).discardState();\n        }\n\n        for (StreamStateHandle handle : stateHandle2.getSharedState().values()) {\n\n            verify(handle, times(0)).discardState();\n        }\n\n        for (Map.Entry<StateHandleID, StreamStateHandle> handleEntry :\n                stateHandle1.getPrivateState().entrySet()) {\n            verify(handleEntry.getValue(), times(1)).discardState();\n        }\n\n        for (Map.Entry<StateHandleID, StreamStateHandle> handleEntry :\n                stateHand",
          "conflictNames": [
              "registry",
              "stateHandle1",
              "stateHandle2",
              "registryKey"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6dcb10abf319b9e5494a82bee71f1ae1a4e4b211^1/flink-runtime/src/test/java/org/apache/flink/runtime/state/IncrementalRemoteKeyedStateHandleTest.java",
      "locators": [
          {
              "line": 48,
              "column": 43
          },
          {
              "line": 50,
              "column": 9
          },
          {
              "line": 52,
              "column": 41
          },
          {
              "line": 56,
              "column": 41
          },
          {
              "line": 60,
              "column": 16
          },
          {
              "line": 73,
              "column": 43
          },
          {
              "line": 74,
              "column": 43
          },
          {
              "line": 78,
              "column": 17
          },
          {
              "line": 82,
              "column": 17
          },
          {
              "line": 87,
              "column": 9
          },
          {
              "line": 89,
              "column": 9
          },
          {
              "line": 91,
              "column": 58
          },
          {
              "line": 92,
              "column": 17
          },
          {
              "line": 95,
              "column": 21
          },
          {
              "line": 96,
              "column": 29
          },
          {
              "line": 98,
              "column": 61
          },
          {
              "line": 101,
              "column": 58
          },
          {
              "line": 102,
              "column": 17
          },
          {
              "line": 105,
              "column": 21
          },
          {
              "line": 106,
              "column": 29
          },
          {
              "line": 108,
              "column": 61
          },
          {
              "line": 112,
              "column": 9
          },
          {
              "line": 116,
              "column": 17
          },
          {
              "line": 120,
              "column": 41
          },
          {
              "line": 126,
              "column": 17
          },
          {
              "line": 131,
              "column": 17
          },
          {
              "line": 135,
              "column": 16
          },
          {
              "line": 136,
              "column": 16
          },
          {
              "line": 139,
              "column": 9
          },
          {
              "line": 144,
              "column": 17
          },
          {
              "line": 149,
              "column": 17
          },
          {
              "line": 153,
              "column": 16
          },
          {
              "line": 154,
              "column": 16
          },
          {
              "line": 167,
              "column": 43
          },
          {
              "line": 168,
              "column": 43
          },
          {
              "line": 169,
              "column": 43
          },
          {
              "line": 172,
              "column": 9
          },
          {
              "line": 173,
              "column": 9
          },
          {
              "line": 174,
              "column": 9
          },
          {
              "line": 178,
              "column": 13
          },
          {
              "line": 184,
              "column": 9
          },
          {
              "line": 185,
              "column": 16
          },
          {
              "line": 198,
              "column": 9
          },
          {
              "line": 199,
              "column": 16
          },
          {
              "line": 202,
              "column": 16
          },
          {
              "line": 206,
              "column": 9
          },
          {
              "line": 207,
              "column": 9
          },
          {
              "line": 208,
              "column": 16
          },
          {
              "line": 213,
              "column": 32
          },
          {
              "line": 213,
              "column": 46
          },
          {
              "line": 214,
              "column": 20
          },
          {
              "line": 216,
              "column": 32
          },
          {
              "line": 216,
              "column": 46
          },
          {
              "line": 217,
              "column": 20
          },
          {
              "line": 219,
              "column": 32
          },
          {
              "line": 219,
              "column": 46
          },
          {
              "line": 220,
              "column": 20
          },
          {
              "line": 227,
              "column": 43
          },
          {
              "line": 228,
              "column": 29
          },
          {
              "line": 228,
              "column": 58
          },
          {
              "line": 231,
              "column": 43
          },
          {
              "line": 233,
              "column": 47
          }
      ],
      "old_name": "stateHandle",
      "new_name": "handleAndLocalPath",
      "ctx": {
          "symbolName": "stateHandle",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "IncrementalRemoteKeyedStateHandle",
          "scopeHint": "in testUnregisteredDiscarding(...)",
          "filePath": "IncrementalRemoteKeyedStateHandleTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * This test checks, that for an unregistered {@link IncrementalRemoteKeyedStateHandle} all\n     * state (including shared) is discarded.\n     */\n    @Test\n    public void testUnregisteredDiscarding() throws Exception {\n        IncrementalRemoteKeyedStateHandle stateHandle = create(new Random(42));\n\n        stateHandle.discardState();\n\n        for (StreamStateHandle handle : stateHandle.getPrivateState().values()) {\n            verify(handle).discardState();\n        }\n\n        for (StreamStateHandle handle : stateHandle.getSharedState().values()) {\n            verify(handle).discardState();\n        }\n\n        verify(stateHandle.getMetaStateHandle()).discardState();\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6dcb10abf319b9e5494a82bee71f1ae1a4e4b211^1/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTest.java",
      "locators": [
          {
              "line": 2936,
              "column": 52
          },
          {
              "line": 2939,
              "column": 49
          },
          {
              "line": 2942,
              "column": 40
          },
          {
              "line": 2946,
              "column": 52
          },
          {
              "line": 2948,
              "column": 40
          },
          {
              "line": 2971,
              "column": 40
          },
          {
              "line": 2972,
              "column": 28
          }
      ],
      "old_name": "streamStateHandle",
      "new_name": "handleAndLocalPath",
      "ctx": {
          "symbolName": "streamStateHandle",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "StreamStateHandle",
          "scopeHint": "in testSharedStateRegistrationOnRestore(...)",
          "filePath": "CheckpointCoordinatorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "edStateHandle;\n\n                            sharedHandlesByCheckpoint\n                                    .get(cp)\n                                    .putAll(incrementalKeyedStateHandle.getSharedState());\n\n                            for (StreamStateHandle streamStateHandle :\n                                    incrementalKeyedStateHandle.getSharedState().values()) {\n                                assertThat(\n                                                streamStateHandle\n                                  ",
          "conflictNames": [
              "jobVertexID1",
              "parallelism1",
              "maxParallelism1",
              "graph",
              "jobVertex1",
              "checkpoints",
              "firstInstance",
              "store",
              "coordinatorBuilder",
              "coordinator",
              "numCheckpoints",
              "keyGroupPartitions1",
              "i",
              "completedCheckpoints",
              "sharedHandleCount",
              "sharedHandlesByCheckpoint",
              "cp",
              "incrementalKeyedStateHandle",
              "tasks",
              "secondInstance",
              "secondStore",
              "secondCoordinator",
              "verificationMode"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6dcb10abf319b9e5494a82bee71f1ae1a4e4b211^1/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTest.java",
      "locators": [
          {
              "line": 4237,
              "column": 47
          },
          {
              "line": 4258,
              "column": 65
          }
      ],
      "old_name": "sharedStateMap",
      "new_name": "sharedStateList",
      "ctx": {
          "symbolName": "sharedStateMap",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Map<StateHandleID, StreamStateHandle>",
          "scopeHint": "in ackCheckpoint(...)",
          "filePath": "CheckpointCoordinatorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void ackCheckpoint(\n            long checkpointId,\n            CheckpointCoordinator coordinator,\n            JobVertexID ackVertexID,\n            ExecutionGraph graph,\n            TestingStreamStateHandle metaState,\n            TestingStreamStateHandle privateState,\n            TestingStreamStateHandle sharedState)\n            throws CheckpointException {\n        Map<StateHandleID, StreamStateHandle> sharedStateMap =\n                new HashMap<>(singletonMap(new StateHandleID(\"shared-state-key\"), sharedState));\n        Map<StateHandleID, StreamStateHandle> privateStateMap =\n                new HashMap<>(singletonMap(new StateHandleID(\"private-state-key\"), privateState));\n        ExecutionJobVertex jobVertex = graph.getJobVertex(ackVertexID);\n        OperatorID operatorID = jobVertex.getOperatorIDs().get(0).getGeneratedOperatorID();\n        coordinator.receiveAcknowledgeMessage(\n                new AcknowledgeCheckpoint(\n                        graph.getJobID(),\n                        jobVertex.getTaskVertices()[0].getCurrentExecutionAttempt().getAttemptId(),\n                        checkpointId,\n                        new CheckpointMetrics(),\n                        new TaskStateSnapshot(\n                                singletonMap(\n                                        operatorID,\n                                        OperatorSubtaskState.builder()\n                                                .setManagedKeyedState(\n                                                        new IncrementalRemoteKeyedStateHandle(\n                                                                UUID.randomUUID(),\n                                                                KeyGroupRange.of(0, 9),\n                                                                checkpointId,\n                                                                sharedStateMap,\n                                                                privateStateMap,\n                                                                metaState))\n                                                .build()))),\n                \"test\");\n    }",
          "conflictNames": [
              "checkpointId",
              "coordinator",
              "ackVertexID",
              "graph",
              "metaState",
              "privateState",
              "sharedState",
              "privateStateMap",
              "jobVertex",
              "operatorID"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6dcb10abf319b9e5494a82bee71f1ae1a4e4b211^1/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTest.java",
      "locators": [
          {
              "line": 4239,
              "column": 47
          },
          {
              "line": 4259,
              "column": 65
          }
      ],
      "old_name": "privateStateMap",
      "new_name": "privateStateList",
      "ctx": {
          "symbolName": "privateStateMap",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Map<StateHandleID, StreamStateHandle>",
          "scopeHint": "in ackCheckpoint(...)",
          "filePath": "CheckpointCoordinatorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void ackCheckpoint(\n            long checkpointId,\n            CheckpointCoordinator coordinator,\n            JobVertexID ackVertexID,\n            ExecutionGraph graph,\n            TestingStreamStateHandle metaState,\n            TestingStreamStateHandle privateState,\n            TestingStreamStateHandle sharedState)\n            throws CheckpointException {\n        Map<StateHandleID, StreamStateHandle> sharedStateMap =\n                new HashMap<>(singletonMap(new StateHandleID(\"shared-state-key\"), sharedState));\n        Map<StateHandleID, StreamStateHandle> privateStateMap =\n                new HashMap<>(singletonMap(new StateHandleID(\"private-state-key\"), privateState));\n        ExecutionJobVertex jobVertex = graph.getJobVertex(ackVertexID);\n        OperatorID operatorID = jobVertex.getOperatorIDs().get(0).getGeneratedOperatorID();\n        coordinator.receiveAcknowledgeMessage(\n                new AcknowledgeCheckpoint(\n                        graph.getJobID(),\n                        jobVertex.getTaskVertices()[0].getCurrentExecutionAttempt().getAttemptId(),\n                        checkpointId,\n                        new CheckpointMetrics(),\n                        new TaskStateSnapshot(\n                                singletonMap(\n                                        operatorID,\n                                        OperatorSubtaskState.builder()\n                                                .setManagedKeyedState(\n                                                        new IncrementalRemoteKeyedStateHandle(\n                                                                UUID.randomUUID(),\n                                                                KeyGroupRange.of(0, 9),\n                                                                checkpointId,\n                                                                sharedStateMap,\n                                                                privateStateMap,\n                                                                metaState))\n                                                .build()))),\n                \"test\");\n    }",
          "conflictNames": [
              "checkpointId",
              "coordinator",
              "ackVertexID",
              "graph",
              "metaState",
              "privateState",
              "sharedState",
              "sharedStateMap",
              "jobVertex",
              "operatorID"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6dcb10abf319b9e5494a82bee71f1ae1a4e4b211^1/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTest.java",
      "locators": [
          {
              "line": 647,
              "column": 30
          },
          {
              "line": 897,
              "column": 63
          },
          {
              "line": 1018,
              "column": 63
          },
          {
              "line": 1079,
              "column": 63
          },
          {
              "line": 1161,
              "column": 63
          },
          {
              "line": 1264,
              "column": 63
          },
          {
              "line": 2035,
              "column": 63
          },
          {
              "line": 2698,
              "column": 87
          },
          {
              "line": 2757,
              "column": 61
          },
          {
              "line": 3223,
              "column": 30
          },
          {
              "line": 3899,
              "column": 63
          },
          {
              "line": 3914,
              "column": 63
          },
          {
              "line": 4007,
              "column": 53
          },
          {
              "line": 4198,
              "column": 62
          },
          {
              "line": 4198,
              "column": 77
          },
          {
              "line": 4199,
              "column": 30
          },
          {
              "line": 4202,
              "column": 24
          }
      ],
      "old_name": "entry",
      "new_name": "handleAndLocalPath",
      "ctx": {
          "symbolName": "entry",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Entry<StateHandleID, StreamStateHandle>",
          "scopeHint": "in verifyDiscard(...)",
          "filePath": "CheckpointCoordinatorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "andle>> sharedHandlesByCheckpoint1,\n            Function<Integer, VerificationMode> checkpointVerify)\n            throws Exception {\n        for (Map<StateHandleID, StreamStateHandle> cpList : sharedHandlesByCheckpoint1) {\n            for (Map.Entry<StateHandleID, StreamStateHandle> entry : cpList.entrySet()) {\n                String key = entry.getKey().getKeyString();\n                int checkpointID = Integer.parseInt(String.valueOf(key.charAt(key.length() - 1)));\n                VerificationMode verificationMode = check",
          "conflictNames": [
              "sharedHandlesByCheckpoint1",
              "checkpointVerify",
              "key",
              "checkpointID",
              "verificationMode"
          ]
      },
      "suggestions": [
          {
              "name": "handleAndLocalPath",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/6dcb10abf319b9e5494a82bee71f1ae1a4e4b211^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/SchedulerUtilsTest.java",
      "locators": [
          {
              "line": 165,
              "column": 47
          },
          {
              "line": 166,
              "column": 9
          },
          {
              "line": 171,
              "column": 17
          }
      ],
      "old_name": "sharedStateMap",
      "new_name": "sharedState",
      "ctx": {
          "symbolName": "sharedStateMap",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Map<StateHandleID, StreamStateHandle>",
          "scopeHint": "in buildIncrementalHandle(...)",
          "filePath": "SchedulerUtilsTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private IncrementalRemoteKeyedStateHandle buildIncrementalHandle(\n            StateHandleID key, StreamStateHandle shared, UUID backendIdentifier) {\n        StreamStateHandle meta = new ByteStreamStateHandle(\"meta\", new byte[] {1, 2, 3});\n        Map<StateHandleID, StreamStateHandle> sharedStateMap = new HashMap<>();\n        sharedStateMap.put(key, shared);\n        return new IncrementalRemoteKeyedStateHandle(\n                backendIdentifier,\n                KeyGroupRange.EMPTY_KEY_GROUP_RANGE,\n                1,\n                sharedStateMap,\n                emptyMap(),\n                meta);\n    }",
          "conflictNames": [
              "key",
              "shared",
              "backendIdentifier",
              "meta"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6dcb10abf319b9e5494a82bee71f1ae1a4e4b211^1/flink-runtime/src/main/java/org/apache/flink/runtime/state/IncrementalRemoteKeyedStateHandle.java",
      "locators": [
          {
              "line": 284,
              "column": 32
          },
          {
              "line": 285,
              "column": 21
          },
          {
              "line": 324,
              "column": 58
          },
          {
              "line": 327,
              "column": 62
          },
          {
              "line": 331,
              "column": 42
          },
          {
              "line": 345,
              "column": 13
          }
      ],
      "old_name": "sharedStateHandle",
      "new_name": "handleAndLocalPath",
      "ctx": {
          "symbolName": "sharedStateHandle",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "StreamStateHandle",
          "scopeHint": "in getStateSize(...)",
          "filePath": "IncrementalRemoteKeyedStateHandle.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "n e) {\n                LOG.warn(\"Could not properly discard new sst file states.\", e);\n            }\n        }\n    }\n\n    @Override\n    public long getStateSize() {\n        long size = StateUtil.getStateSize(metaStateHandle);\n\n        for (StreamStateHandle sharedStateHandle : sharedState.values()) {\n            size += sharedStateHandle.getStateSize();\n        }\n\n        for (StreamStateHandle privateStateHandle : privateState.values()) {\n            size += privateStateHandle.getStateSize();\n        }\n\n     ",
          "conflictNames": [
              "size"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6dcb10abf319b9e5494a82bee71f1ae1a4e4b211^1/flink-runtime/src/main/java/org/apache/flink/runtime/state/IncrementalRemoteKeyedStateHandle.java",
      "locators": [
          {
              "line": 288,
              "column": 32
          },
          {
              "line": 289,
              "column": 21
          }
      ],
      "old_name": "privateStateHandle",
      "new_name": "handleAndLocalPath",
      "ctx": {
          "symbolName": "privateStateHandle",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "StreamStateHandle",
          "scopeHint": "in getStateSize(...)",
          "filePath": "IncrementalRemoteKeyedStateHandle.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "ic long getStateSize() {\n        long size = StateUtil.getStateSize(metaStateHandle);\n\n        for (StreamStateHandle sharedStateHandle : sharedState.values()) {\n            size += sharedStateHandle.getStateSize();\n        }\n\n        for (StreamStateHandle privateStateHandle : privateState.values()) {\n            size += privateStateHandle.getStateSize();\n        }\n\n        return size;\n    }\n\n    @Override\n    public long getCheckpointedSize() {\n        return persistedSizeOfThisCheckpoint;\n    }\n\n    @Overri",
          "conflictNames": [
              "size"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6dcb10abf319b9e5494a82bee71f1ae1a4e4b211^1/flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/EmbeddedRocksDBStateBackendTest.java",
      "locators": [
          {
              "line": 2,
              "column": 7
          },
          {
              "line": 2,
              "column": 10
          },
          {
              "line": 2,
              "column": 18
          },
          {
              "line": 2,
              "column": 25
          },
          {
              "line": 2,
              "column": 34
          },
          {
              "line": 2,
              "column": 56
          },
          {
              "line": 2,
              "column": 61
          },
          {
              "line": 3,
              "column": 10
          },
          {
              "line": 3,
              "column": 27
          },
          {
              "line": 3,
              "column": 30
          },
          {
              "line": 3,
              "column": 35
          },
          {
              "line": 3,
              "column": 36
          },
          {
              "line": 3,
              "column": 38
          },
          {
              "line": 3,
              "column": 46
          },
          {
              "line": 3,
              "column": 47
          },
          {
              "line": 3,
              "column": 51
          },
          {
              "line": 3,
              "column": 63
          },
          {
              "line": 4,
              "column": 13
          },
          {
              "line": 5,
              "column": 5
          },
          {
              "line": 5,
              "column": 27
          },
          {
              "line": 5,
              "column": 38
          },
          {
              "line": 5,
              "column": 47
          },
          {
              "line": 5,
              "column": 50
          },
          {
              "line": 5,
              "column": 61
          },
          {
              "line": 6,
              "column": 14
          },
          {
              "line": 6,
              "column": 19
          },
          {
              "line": 6,
              "column": 26
          },
          {
              "line": 6,
              "column": 31
          },
          {
              "line": 6,
              "column": 34
          },
          {
              "line": 6,
              "column": 38
          },
          {
              "line": 6,
              "column": 52
          },
          {
              "line": 7,
              "column": 8
          },
          {
              "line": 7,
              "column": 11
          },
          {
              "line": 7,
              "column": 30
          },
          {
              "line": 7,
              "column": 40
          },
          {
              "line": 7,
              "column": 42
          },
          {
              "line": 7,
              "column": 45
          },
          {
              "line": 7,
              "column": 61
          },
          {
              "line": 8,
              "column": 11
          },
          {
              "line": 8,
              "column": 16
          },
          {
              "line": 8,
              "column": 19
          },
          {
              "line": 8,
              "column": 50
          },
          {
              "line": 8,
              "column": 55
          },
          {
              "line": 8,
              "column": 58
          },
          {
              "line": 10,
              "column": 24
          },
          {
              "line": 10,
              "column": 33
          },
          {
              "line": 10,
              "column": 36
          },
          {
              "line": 12,
              "column": 7
          },
          {
              "line": 12,
              "column": 12
          },
          {
              "line": 12,
              "column": 17
          },
          {
              "line": 12,
              "column": 32
          },
          {
              "line": 12,
              "column": 44
          },
          {
              "line": 12,
              "column": 45
          },
          {
              "line": 12,
              "column": 70
          },
          {
              "line": 13,
              "column": 13
          },
          {
              "line": 13,
              "column": 19
          },
          {
              "line": 13,
              "column": 24
          },
          {
              "line": 13,
              "column": 29
          },
          {
              "line": 13,
              "column": 32
          },
          {
              "line": 13,
              "column": 46
          },
          {
              "line": 14,
              "column": 50
          },
          {
              "line": 14,
              "column": 54
          },
          {
              "line": 14,
              "column": 57
          },
          {
              "line": 14,
              "column": 61
          },
          {
              "line": 14,
              "column": 73
          },
          {
              "line": 15,
              "column": 5
          },
          {
              "line": 15,
              "column": 6
          },
          {
              "line": 15,
              "column": 10
          },
          {
              "line": 15,
              "column": 15
          },
          {
              "line": 15,
              "column": 18
          },
          {
              "line": 15,
              "column": 26
          },
          {
              "line": 15,
              "column": 30
          },
          {
              "line": 15,
              "column": 44
          },
          {
              "line": 15,
              "column": 49
          },
          {
              "line": 15,
              "column": 57
          },
          {
              "line": 16,
              "column": 19
          },
          {
              "line": 16,
              "column": 24
          },
          {
              "line": 16,
              "column": 29
          },
          {
              "line": 16,
              "column": 32
          },
          {
              "line": 19,
              "column": 7
          },
          {
              "line": 19,
              "column": 18
          },
          {
              "line": 19,
              "column": 37
          },
          {
              "line": 19,
              "column": 48
          },
          {
              "line": 21,
              "column": 17
          },
          {
              "line": 21,
              "column": 38
          },
          {
              "line": 22,
              "column": 17
          },
          {
              "line": 22,
              "column": 40
          },
          {
              "line": 22,
              "column": 44
          },
          {
              "line": 22,
              "column": 56
          },
          {
              "line": 22,
              "column": 58
          },
          {
              "line": 23,
              "column": 17
          },
          {
              "line": 23,
              "column": 40
          },
          {
              "line": 23,
              "column": 49
          },
          {
              "line": 24,
              "column": 17
          },
          {
              "line": 24,
              "column": 40
          },
          {
              "line": 24,
              "column": 49
          },
          {
              "line": 24,
              "column": 51
          },
          {
              "line": 25,
              "column": 17
          },
          {
              "line": 25,
              "column": 40
          },
          {
              "line": 25,
              "column": 46
          },
          {
              "line": 25,
              "column": 51
          },
          {
              "line": 26,
              "column": 17
          },
          {
              "line": 26,
              "column": 40
          },
          {
              "line": 26,
              "column": 46
          },
          {
              "line": 26,
              "column": 51
          },
          {
              "line": 26,
              "column": 53
          },
          {
              "line": 27,
              "column": 17
          },
          {
              "line": 27,
              "column": 39
          },
          {
              "line": 27,
              "column": 49
          },
          {
              "line": 27,
              "column": 55
          },
          {
              "line": 27,
              "column": 62
          },
          {
              "line": 28,
              "column": 17
          },
          {
              "line": 28,
              "column": 39
          },
          {
              "line": 28,
              "column": 49
          },
          {
              "line": 28,
              "column": 58
          },
          {
              "line": 28,
              "column": 65
          },
          {
              "line": 29,
              "column": 17
          },
          {
              "line": 30,
              "column": 17
          },
          {
              "line": 30,
              "column": 28
          },
          {
              "line": 31,
              "column": 17
          },
          {
              "line": 31,
              "column": 28
          },
          {
              "line": 31,
              "column": 31
          },
          {
              "line": 31,
              "column": 42
          },
          {
              "line": 32,
              "column": 17
          },
          {
              "line": 32,
              "column": 31
          },
          {
              "line": 32,
              "column": 35
          },
          {
              "line": 32,
              "column": 46
          },
          {
              "line": 33,
              "column": 17
          },
          {
              "line": 33,
              "column": 31
          },
          {
              "line": 33,
              "column": 37
          },
          {
              "line": 33,
              "column": 41
          },
          {
              "line": 33,
              "column": 55
          },
          {
              "line": 34,
              "column": 17
          },
          {
              "line": 34,
              "column": 31
          },
          {
              "line": 34,
              "column": 37
          },
          {
              "line": 34,
              "column": 41
          },
          {
              "line": 34,
              "column": 52
          },
          {
              "line": 34,
              "column": 54
          },
          {
              "line": 34,
              "column": 56
          },
          {
              "line": 34,
              "column": 62
          },
          {
              "line": 34,
              "column": 67
          },
          {
              "line": 35,
              "column": 17
          },
          {
              "line": 35,
              "column": 31
          },
          {
              "line": 35,
              "column": 37
          },
          {
              "line": 35,
              "column": 50
          },
          {
              "line": 35,
              "column": 55
          },
          {
              "line": 35,
              "column": 60
          },
          {
              "line": 36,
              "column": 17
          },
          {
              "line": 36,
              "column": 31
          },
          {
              "line": 36,
              "column": 37
          },
          {
              "line": 36,
              "column": 43
          },
          {
              "line": 36,
              "column": 45
          },
          {
              "line": 36,
              "column": 51
          },
          {
              "line": 36,
              "column": 55
          },
          {
              "line": 36,
              "column": 57
          },
          {
              "line": 36,
              "column": 59
          },
          {
              "line": 36,
              "column": 65
          },
          {
              "line": 36,
              "column": 71
          },
          {
              "line": 37,
              "column": 17
          },
          {
              "line": 37,
              "column": 31
          },
          {
              "line": 37,
              "column": 37
          },
          {
              "line": 37,
              "column": 40
          },
          {
              "line": 37,
              "column": 42
          },
          {
              "line": 37,
              "column": 48
          },
          {
              "line": 37,
              "column": 54
          },
          {
              "line": 38,
              "column": 17
          },
          {
              "line": 38,
              "column": 31
          },
          {
              "line": 38,
              "column": 37
          },
          {
              "line": 38,
              "column": 43
          },
          {
              "line": 38,
              "column": 49
          },
          {
              "line": 38,
              "column": 51
          },
          {
              "line": 39,
              "column": 17
          },
          {
              "line": 39,
              "column": 31
          },
          {
              "line": 39,
              "column": 37
          },
          {
              "line": 39,
              "column": 43
          },
          {
              "line": 39,
              "column": 49
          },
          {
              "line": 39,
              "column": 51
          },
          {
              "line": 40,
              "column": 17
          },
          {
              "line": 40,
              "column": 31
          },
          {
              "line": 40,
              "column": 37
          },
          {
              "line": 40,
              "column": 48
          },
          {
              "line": 41,
              "column": 17
          },
          {
              "line": 41,
              "column": 31
          },
          {
              "line": 41,
              "column": 37
          },
          {
              "line": 41,
              "column": 43
          },
          {
              "line": 41,
              "column": 48
          },
          {
              "line": 41,
              "column": 52
          },
          {
              "line": 41,
              "column": 58
          },
          {
              "line": 42,
              "column": 17
          },
          {
              "line": 42,
              "column": 31
          },
          {
              "line": 42,
              "column": 37
          },
          {
              "line": 42,
              "column": 43
          },
          {
              "line": 42,
              "column": 49
          },
          {
              "line": 43,
              "column": 17
          },
          {
              "line": 43,
              "column": 31
          },
          {
              "line": 43,
              "column": 37
          },
          {
              "line": 43,
              "column": 42
          },
          {
              "line": 43,
              "column": 49
          },
          {
              "line": 43,
              "column": 55
          },
          {
              "line": 44,
              "column": 17
          },
          {
              "line": 44,
              "column": 31
          },
          {
              "line": 44,
              "column": 37
          },
          {
              "line": 44,
              "column": 46
          },
          {
              "line": 44,
              "column": 51
          },
          {
              "line": 45,
              "column": 17
          },
          {
              "line": 45,
              "column": 31
          },
          {
              "line": 45,
              "column": 37
          },
          {
              "line": 45,
              "column": 46
          },
          {
              "line": 45,
              "column": 51
          },
          {
              "line": 45,
              "column": 53
          },
          {
              "line": 45,
              "column": 60
          },
          {
              "line": 46,
              "column": 17
          },
          {
              "line": 46,
              "column": 31
          },
          {
              "line": 46,
              "column": 37
          },
          {
              "line": 46,
              "column": 45
          },
          {
              "line": 46,
              "column": 50
          },
          {
              "line": 46,
              "column": 55
          },
          {
              "line": 46,
              "column": 59
          },
          {
              "line": 46,
              "column": 73
          },
          {
              "line": 47,
              "column": 17
          },
          {
              "line": 47,
              "column": 31
          },
          {
              "line": 47,
              "column": 37
          },
          {
              "line": 47,
              "column": 45
          },
          {
              "line": 47,
              "column": 55
          },
          {
              "line": 47,
              "column": 59
          },
          {
              "line": 47,
              "column": 73
          },
          {
              "line": 48,
              "column": 17
          },
          {
              "line": 48,
              "column": 31
          },
          {
              "line": 48,
              "column": 43
          },
          {
              "line": 48,
              "column": 47
          },
          {
              "line": 48,
              "column": 58
          },
          {
              "line": 49,
              "column": 17
          },
          {
              "line": 49,
              "column": 31
          },
          {
              "line": 49,
              "column": 48
          },
          {
              "line": 49,
              "column": 65
          },
          {
              "line": 50,
              "column": 17
          },
          {
              "line": 50,
              "column": 41
          },
          {
              "line": 50,
              "column": 45
          },
          {
              "line": 51,
              "column": 17
          },
          {
              "line": 52,
              "column": 17
          },
          {
              "line": 52,
              "column": 45
          },
          {
              "line": 52,
              "column": 54
          },
          {
              "line": 54,
              "column": 17
          },
          {
              "line": 54,
              "column": 33
          },
          {
              "line": 55,
              "column": 17
          },
          {
              "line": 55,
              "column": 33
          },
          {
              "line": 55,
              "column": 38
          },
          {
              "line": 55,
              "column": 46
          },
          {
              "line": 55,
              "column": 51
          },
          {
              "line": 56,
              "column": 21
          },
          {
              "line": 57,
              "column": 26
          },
          {
              "line": 58,
              "column": 19
          },
          {
              "line": 59,
              "column": 21
          },
          {
              "line": 59,
              "column": 25
          },
          {
              "line": 59,
              "column": 37
          },
          {
              "line": 60,
              "column": 22
          },
          {
              "line": 61,
              "column": 22
          },
          {
              "line": 61,
              "column": 31
          },
          {
              "line": 61,
              "column": 33
          },
          {
              "line": 61,
              "column": 37
          },
          {
              "line": 64,
              "column": 33
          },
          {
              "line": 65,
              "column": 33
          },
          {
              "line": 66,
              "column": 37
          },
          {
              "line": 68,
              "column": 21
          },
          {
              "line": 70,
              "column": 30
          },
          {
              "line": 71,
              "column": 27
          },
          {
              "line": 72,
              "column": 28
          },
          {
              "line": 75,
              "column": 19
          },
          {
              "line": 76,
              "column": 21
          },
          {
              "line": 79,
              "column": 22
          },
          {
              "line": 80,
              "column": 22
          },
          {
              "line": 82,
              "column": 22
          },
          {
              "line": 85,
              "column": 20
          },
          {
              "line": 85,
              "column": 22
          },
          {
              "line": 86,
              "column": 25
          },
          {
              "line": 86,
              "column": 36
          },
          {
              "line": 86,
              "column": 42
          },
          {
              "line": 88,
              "column": 25
          },
          {
              "line": 88,
              "column": 32
          },
          {
              "line": 88,
              "column": 38
          },
          {
              "line": 88,
              "column": 43
          },
          {
              "line": 89,
              "column": 28
          },
          {
              "line": 89,
              "column": 35
          },
          {
              "line": 90,
              "column": 28
          },
          {
              "line": 90,
              "column": 35
          },
          {
              "line": 90,
              "column": 41
          },
          {
              "line": 91,
              "column": 28
          },
          {
              "line": 92,
              "column": 32
          },
          {
              "line": 93,
              "column": 41
          },
          {
              "line": 94,
              "column": 36
          },
          {
              "line": 94,
              "column": 38
          },
          {
              "line": 96,
              "column": 36
          },
          {
              "line": 97,
              "column": 30
          },
          {
              "line": 97,
              "column": 37
          },
          {
              "line": 97,
              "column": 50
          },
          {
              "line": 97,
              "column": 64
          },
          {
              "line": 97,
              "column": 76
          },
          {
              "line": 99,
              "column": 6
          },
          {
              "line": 99,
              "column": 17
          },
          {
              "line": 99,
              "column": 28
          },
          {
              "line": 99,
              "column": 35
          },
          {
              "line": 99,
              "column": 55
          },
          {
              "line": 99,
              "column": 58
          },
          {
              "line": 99,
              "column": 71
          },
          {
              "line": 99,
              "column": 76
          },
          {
              "line": 100,
              "column": 15
          },
          {
              "line": 100,
              "column": 17
          },
          {
              "line": 100,
              "column": 21
          },
          {
              "line": 101,
              "column": 17
          },
          {
              "line": 101,
              "column": 20
          },
          {
              "line": 101,
              "column": 33
          },
          {
              "line": 101,
              "column": 38
          },
          {
              "line": 101,
              "column": 42
          },
          {
              "line": 102,
              "column": 9
          },
          {
              "line": 102,
              "column": 12
          },
          {
              "line": 102,
              "column": 21
          },
          {
              "line": 102,
              "column": 26
          },
          {
              "line": 102,
              "column": 30
          },
          {
              "line": 102,
              "column": 36
          },
          {
              "line": 102,
              "column": 41
          },
          {
              "line": 102,
              "column": 44
          },
          {
              "line": 102,
              "column": 57
          },
          {
              "line": 102,
              "column": 62
          },
          {
              "line": 104,
              "column": 11
          },
          {
              "line": 104,
              "column": 15
          },
          {
              "line": 104,
              "column": 31
          },
          {
              "line": 105,
              "column": 11
          },
          {
              "line": 105,
              "column": 15
          },
          {
              "line": 105,
              "column": 30
          },
          {
              "line": 106,
              "column": 11
          },
          {
              "line": 106,
              "column": 18
          },
          {
              "line": 106,
              "column": 22
          },
          {
              "line": 106,
              "column": 33
          },
          {
              "line": 106,
              "column": 45
          },
          {
              "line": 106,
              "column": 51
          },
          {
              "line": 107,
              "column": 11
          },
          {
              "line": 107,
              "column": 21
          },
          {
              "line": 107,
              "column": 23
          },
          {
              "line": 107,
              "column": 29
          },
          {
              "line": 107,
              "column": 34
          },
          {
              "line": 107,
              "column": 41
          },
          {
              "line": 107,
              "column": 43
          },
          {
              "line": 107,
              "column": 48
          },
          {
              "line": 107,
              "column": 50
          },
          {
              "line": 107,
              "column": 56
          },
          {
              "line": 107,
              "column": 61
          },
          {
              "line": 108,
              "column": 11
          },
          {
              "line": 108,
              "column": 26
          },
          {
              "line": 108,
              "column": 36
          },
          {
              "line": 108,
              "column": 39
          },
          {
              "line": 108,
              "column": 45
          },
          {
              "line": 108,
              "column": 49
          },
          {
              "line": 109,
              "column": 11
          },
          {
              "line": 109,
              "column": 17
          },
          {
              "line": 109,
              "column": 22
          },
          {
              "line": 109,
              "column": 27
          },
          {
              "line": 109,
              "column": 29
          },
          {
              "line": 109,
              "column": 34
          },
          {
              "line": 109,
              "column": 41
          },
          {
              "line": 110,
              "column": 11
          },
          {
              "line": 110,
              "column": 17
          },
          {
              "line": 110,
              "column": 22
          },
          {
              "line": 110,
              "column": 33
          },
          {
              "line": 110,
              "column": 40
          },
          {
              "line": 112,
              "column": 14
          },
          {
              "line": 112,
              "column": 37
          },
          {
              "line": 112,
              "column": 49
          },
          {
              "line": 112,
              "column": 67
          },
          {
              "line": 112,
              "column": 71
          },
          {
              "line": 112,
              "column": 83
          },
          {
              "line": 114,
              "column": 11
          },
          {
              "line": 114,
              "column": 13
          },
          {
              "line": 114,
              "column": 17
          },
          {
              "line": 114,
              "column": 25
          },
          {
              "line": 114,
              "column": 27
          },
          {
              "line": 115,
              "column": 27
          },
          {
              "line": 115,
              "column": 37
          },
          {
              "line": 116,
              "column": 10
          },
          {
              "line": 117,
              "column": 18
          },
          {
              "line": 117,
              "column": 24
          },
          {
              "line": 119,
              "column": 28
          },
          {
              "line": 120,
              "column": 32
          },
          {
              "line": 120,
              "column": 41
          },
          {
              "line": 120,
              "column": 50
          },
          {
              "line": 120,
              "column": 64
          },
          {
              "line": 120,
              "column": 72
          },
          {
              "line": 121,
              "column": 41
          },
          {
              "line": 121,
              "column": 45
          },
          {
              "line": 121,
              "column": 59
          },
          {
              "line": 121,
              "column": 63
          },
          {
              "line": 124,
              "column": 29
          },
          {
              "line": 125,
              "column": 32
          },
          {
              "line": 125,
              "column": 41
          },
          {
              "line": 125,
              "column": 50
          },
          {
              "line": 125,
              "column": 64
          },
          {
              "line": 125,
              "column": 72
          },
          {
              "line": 127,
              "column": 46
          },
          {
              "line": 128,
              "column": 58
          },
          {
              "line": 128,
              "column": 64
          },
          {
              "line": 129,
              "column": 38
          },
          {
              "line": 129,
              "column": 45
          },
          {
              "line": 129,
              "column": 51
          },
          {
              "line": 129,
              "column": 56
          },
          {
              "line": 129,
              "column": 60
          },
          {
              "line": 129,
              "column": 74
          },
          {
              "line": 130,
              "column": 46
          },
          {
              "line": 130,
              "column": 56
          },
          {
              "line": 136,
              "column": 11
          },
          {
              "line": 136,
              "column": 13
          },
          {
              "line": 136,
              "column": 17
          },
          {
              "line": 136,
              "column": 25
          },
          {
              "line": 136,
              "column": 27
          },
          {
              "line": 136,
              "column": 34
          },
          {
              "line": 137,
              "column": 16
          },
          {
              "line": 137,
              "column": 20
          },
          {
              "line": 137,
              "column": 25
          },
          {
              "line": 137,
              "column": 30
          },
          {
              "line": 137,
              "column": 32
          },
          {
              "line": 137,
              "column": 39
          },
          {
              "line": 139,
              "column": 11
          },
          {
              "line": 139,
              "column": 13
          },
          {
              "line": 139,
              "column": 17
          },
          {
              "line": 139,
              "column": 25
          },
          {
              "line": 139,
              "column": 27
          },
          {
              "line": 139,
              "column": 34
          },
          {
              "line": 140,
              "column": 18
          },
          {
              "line": 140,
              "column": 27
          },
          {
              "line": 140,
              "column": 36
          },
          {
              "line": 140,
              "column": 50
          },
          {
              "line": 140,
              "column": 58
          },
          {
              "line": 140,
              "column": 72
          },
          {
              "line": 140,
              "column": 79
          },
          {
              "line": 142,
              "column": 12
          },
          {
              "line": 142,
              "column": 18
          },
          {
              "line": 142,
              "column": 23
          },
          {
              "line": 142,
              "column": 26
          },
          {
              "line": 142,
              "column": 29
          },
          {
              "line": 142,
              "column": 30
          },
          {
              "line": 142,
              "column": 42
          },
          {
              "line": 142,
              "column": 46
          },
          {
              "line": 142,
              "column": 53
          },
          {
              "line": 143,
              "column": 11
          },
          {
              "line": 144,
              "column": 11
          },
          {
              "line": 145,
              "column": 11
          },
          {
              "line": 145,
              "column": 30
          },
          {
              "line": 145,
              "column": 33
          },
          {
              "line": 145,
              "column": 46
          },
          {
              "line": 146,
              "column": 11
          },
          {
              "line": 146,
              "column": 24
          },
          {
              "line": 146,
              "column": 31
          },
          {
              "line": 146,
              "column": 45
          },
          {
              "line": 146,
              "column": 52
          },
          {
              "line": 147,
              "column": 11
          },
          {
              "line": 147,
              "column": 27
          },
          {
              "line": 147,
              "column": 33
          },
          {
              "line": 147,
              "column": 41
          },
          {
              "line": 147,
              "column": 58
          },
          {
              "line": 147,
              "column": 64
          },
          {
              "line": 147,
              "column": 75
          },
          {
              "line": 147,
              "column": 81
          },
          {
              "line": 147,
              "column": 89
          },
          {
              "line": 149,
              "column": 19
          },
          {
              "line": 149,
              "column": 23
          },
          {
              "line": 149,
              "column": 44
          },
          {
              "line": 151,
              "column": 25
          },
          {
              "line": 151,
              "column": 27
          },
          {
              "line": 151,
              "column": 33
          },
          {
              "line": 151,
              "column": 38
          },
          {
              "line": 151,
              "column": 46
          },
          {
              "line": 151,
              "column": 50
          },
          {
              "line": 151,
              "column": 59
          },
          {
              "line": 151,
              "column": 85
          },
          {
              "line": 151,
              "column": 91
          },
          {
              "line": 152,
              "column": 27
          },
          {
              "line": 152,
              "column": 36
          },
          {
              "line": 153,
              "column": 59
          },
          {
              "line": 153,
              "column": 63
          },
          {
              "line": 155,
              "column": 36
          },
          {
              "line": 155,
              "column": 56
          },
          {
              "line": 155,
              "column": 62
          },
          {
              "line": 157,
              "column": 26
          },
          {
              "line": 157,
              "column": 41
          },
          {
              "line": 159,
              "column": 29
          },
          {
              "line": 159,
              "column": 37
          },
          {
              "line": 160,
              "column": 42
          },
          {
              "line": 162,
              "column": 39
          },
          {
              "line": 162,
              "column": 43
          },
          {
              "line": 163,
              "column": 10
          },
          {
              "line": 163,
              "column": 23
          },
          {
              "line": 163,
              "column": 44
          },
          {
              "line": 163,
              "column": 48
          },
          {
              "line": 163,
              "column": 52
          },
          {
              "line": 166,
              "column": 8
          },
          {
              "line": 166,
              "column": 13
          },
          {
              "line": 167,
              "column": 9
          },
          {
              "line": 167,
              "column": 12
          },
          {
              "line": 167,
              "column": 26
          },
          {
              "line": 167,
              "column": 31
          },
          {
              "line": 167,
              "column": 36
          },
          {
              "line": 167,
              "column": 41
          },
          {
              "line": 167,
              "column": 47
          },
          {
              "line": 167,
              "column": 52
          },
          {
              "line": 167,
              "column": 70
          },
          {
              "line": 168,
              "column": 31
          },
          {
              "line": 168,
              "column": 37
          },
          {
              "line": 168,
              "column": 43
          },
          {
              "line": 168,
              "column": 52
          },
          {
              "line": 169,
              "column": 12
          },
          {
              "line": 169,
              "column": 15
          },
          {
              "line": 169,
              "column": 28
          },
          {
              "line": 169,
              "column": 33
          },
          {
              "line": 169,
              "column": 41
          },
          {
              "line": 170,
              "column": 18
          },
          {
              "line": 170,
              "column": 24
          },
          {
              "line": 170,
              "column": 27
          },
          {
              "line": 170,
              "column": 40
          },
          {
              "line": 170,
              "column": 45
          },
          {
              "line": 170,
              "column": 49
          },
          {
              "line": 170,
              "column": 54
          },
          {
              "line": 170,
              "column": 59
          },
          {
              "line": 170,
              "column": 61
          },
          {
              "line": 170,
              "column": 68
          },
          {
              "line": 171,
              "column": 40
          },
          {
              "line": 172,
              "column": 24
          },
          {
              "line": 174,
              "column": 20
          },
          {
              "line": 174,
              "column": 23
          },
          {
              "line": 174,
              "column": 36
          },
          {
              "line": 174,
              "column": 41
          },
          {
              "line": 174,
              "column": 55
          },
          {
              "line": 174,
              "column": 57
          },
          {
              "line": 174,
              "column": 62
          },
          {
              "line": 174,
              "column": 66
          },
          {
              "line": 175,
              "column": 13
          },
          {
              "line": 175,
              "column": 23
          },
          {
              "line": 175,
              "column": 35
          },
          {
              "line": 175,
              "column": 55
          },
          {
              "line": 175,
              "column": 63
          },
          {
              "line": 175,
              "column": 69
          },
          {
              "line": 175,
              "column": 76
          },
          {
              "line": 175,
              "column": 82
          },
          {
              "line": 175,
              "column": 94
          },
          {
              "line": 176,
              "column": 13
          },
          {
              "line": 176,
              "column": 18
          },
          {
              "line": 176,
              "column": 28
          },
          {
              "line": 177,
              "column": 10
          },
          {
              "line": 177,
              "column": 20
          },
          {
              "line": 180,
              "column": 8
          },
          {
              "line": 180,
              "column": 13
          },
          {
              "line": 181,
              "column": 9
          },
          {
              "line": 181,
              "column": 12
          },
          {
              "line": 181,
              "column": 17
          },
          {
              "line": 181,
              "column": 31
          },
          {
              "line": 181,
              "column": 34
          },
          {
              "line": 181,
              "column": 38
          },
          {
              "line": 181,
              "column": 52
          },
          {
              "line": 181,
              "column": 66
          },
          {
              "line": 182,
              "column": 10
          },
          {
              "line": 182,
              "column": 22
          },
          {
              "line": 182,
              "column": 29
          },
          {
              "line": 182,
              "column": 33
          },
          {
              "line": 185,
              "column": 8
          },
          {
              "line": 185,
              "column": 13
          },
          {
              "line": 186,
              "column": 9
          },
          {
              "line": 186,
              "column": 12
          },
          {
              "line": 186,
              "column": 19
          },
          {
              "line": 186,
              "column": 26
          },
          {
              "line": 186,
              "column": 33
          },
          {
              "line": 186,
              "column": 37
          },
          {
              "line": 186,
              "column": 39
          },
          {
              "line": 186,
              "column": 42
          },
          {
              "line": 186,
              "column": 44
          },
          {
              "line": 186,
              "column": 49
          },
          {
              "line": 186,
              "column": 54
          },
          {
              "line": 186,
              "column": 59
          },
          {
              "line": 187,
              "column": 10
          },
          {
              "line": 187,
              "column": 20
          },
          {
              "line": 190,
              "column": 8
          },
          {
              "line": 190,
              "column": 13
          },
          {
              "line": 191,
              "column": 9
          },
          {
              "line": 191,
              "column": 12
          },
          {
              "line": 191,
              "column": 19
          },
          {
              "line": 192,
              "column": 10
          },
          {
              "line": 192,
              "column": 19
          },
          {
              "line": 195,
              "column": 8
          },
          {
              "line": 195,
              "column": 13
          },
          {
              "line": 196,
              "column": 9
          },
          {
              "line": 196,
              "column": 12
          },
          {
              "line": 196,
              "column": 19
          },
          {
              "line": 196,
              "column": 28
          },
          {
              "line": 196,
              "column": 32
          },
          {
              "line": 196,
              "column": 35
          },
          {
              "line": 196,
              "column": 42
          },
          {
              "line": 197,
              "column": 10
          },
          {
              "line": 197,
              "column": 19
          },
          {
              "line": 200,
              "column": 17
          },
          {
              "line": 200,
              "column": 22
          },
          {
              "line": 200,
              "column": 36
          },
          {
              "line": 200,
              "column": 40
          },
          {
              "line": 200,
              "column": 64
          },
          {
              "line": 200,
              "column": 69
          },
          {
              "line": 200,
              "column": 76
          },
          {
              "line": 200,
              "column": 79
          },
          {
              "line": 201,
              "column": 9
          },
          {
              "line": 202,
              "column": 19
          },
          {
              "line": 203,
              "column": 14
          },
          {
              "line": 203,
              "column": 16
          },
          {
              "line": 203,
              "column": 22
          },
          {
              "line": 203,
              "column": 27
          },
          {
              "line": 204,
              "column": 25
          },
          {
              "line": 204,
              "column": 29
          },
          {
              "line": 204,
              "column": 35
          },
          {
              "line": 204,
              "column": 37
          },
          {
              "line": 204,
              "column": 43
          },
          {
              "line": 204,
              "column": 48
          },
          {
              "line": 205,
              "column": 14
          },
          {
              "line": 205,
              "column": 16
          },
          {
              "line": 205,
              "column": 22
          },
          {
              "line": 205,
              "column": 27
          },
          {
              "line": 205,
              "column": 37
          },
          {
              "line": 207,
              "column": 21
          },
          {
              "line": 207,
              "column": 25
          },
          {
              "line": 207,
              "column": 31
          },
          {
              "line": 207,
              "column": 44
          },
          {
              "line": 208,
              "column": 21
          },
          {
              "line": 208,
              "column": 25
          },
          {
              "line": 209,
              "column": 21
          },
          {
              "line": 209,
              "column": 25
          },
          {
              "line": 209,
              "column": 44
          },
          {
              "line": 211,
              "column": 18
          },
          {
              "line": 211,
              "column": 21
          },
          {
              "line": 211,
              "column": 27
          },
          {
              "line": 211,
              "column": 31
          },
          {
              "line": 212,
              "column": 26
          },
          {
              "line": 212,
              "column": 39
          },
          {
              "line": 212,
              "column": 43
          },
          {
              "line": 212,
              "column": 52
          },
          {
              "line": 212,
              "column": 55
          },
          {
              "line": 212,
              "column": 61
          },
          {
              "line": 212,
              "column": 65
          },
          {
              "line": 213,
              "column": 18
          },
          {
              "line": 213,
              "column": 33
          },
          {
              "line": 213,
              "column": 37
          },
          {
              "line": 213,
              "column": 43
          },
          {
              "line": 213,
              "column": 54
          },
          {
              "line": 215,
              "column": 18
          },
          {
              "line": 215,
              "column": 21
          },
          {
              "line": 215,
              "column": 27
          },
          {
              "line": 215,
              "column": 31
          },
          {
              "line": 219,
              "column": 18
          },
          {
              "line": 219,
              "column": 28
          },
          {
              "line": 219,
              "column": 30
          },
          {
              "line": 219,
              "column": 36
          },
          {
              "line": 219,
              "column": 41
          },
          {
              "line": 219,
              "column": 57
          },
          {
              "line": 221,
              "column": 14
          },
          {
              "line": 221,
              "column": 20
          },
          {
              "line": 221,
              "column": 25
          },
          {
              "line": 222,
              "column": 13
          },
          {
              "line": 222,
              "column": 19
          },
          {
              "line": 222,
              "column": 24
          },
          {
              "line": 223,
              "column": 10
          },
          {
              "line": 223,
              "column": 16
          },
          {
              "line": 223,
              "column": 30
          },
          {
              "line": 223,
              "column": 38
          },
          {
              "line": 223,
              "column": 42
          },
          {
              "line": 223,
              "column": 53
          },
          {
              "line": 224,
              "column": 10
          },
          {
              "line": 224,
              "column": 16
          },
          {
              "line": 224,
              "column": 28
          },
          {
              "line": 224,
              "column": 35
          },
          {
              "line": 224,
              "column": 48
          },
          {
              "line": 225,
              "column": 10
          },
          {
              "line": 225,
              "column": 16
          },
          {
              "line": 225,
              "column": 28
          },
          {
              "line": 225,
              "column": 34
          },
          {
              "line": 225,
              "column": 46
          },
          {
              "line": 226,
              "column": 10
          },
          {
              "line": 226,
              "column": 16
          },
          {
              "line": 226,
              "column": 28
          },
          {
              "line": 226,
              "column": 33
          },
          {
              "line": 226,
              "column": 39
          },
          {
              "line": 227,
              "column": 11
          },
          {
              "line": 227,
              "column": 15
          },
          {
              "line": 229,
              "column": 17
          },
          {
              "line": 229,
              "column": 19
          },
          {
              "line": 229,
              "column": 25
          },
          {
              "line": 229,
              "column": 30
          },
          {
              "line": 229,
              "column": 38
          },
          {
              "line": 229,
              "column": 42
          },
          {
              "line": 229,
              "column": 44
          },
          {
              "line": 229,
              "column": 50
          },
          {
              "line": 229,
              "column": 55
          },
          {
              "line": 229,
              "column": 63
          },
          {
              "line": 230,
              "column": 25
          },
          {
              "line": 230,
              "column": 39
          },
          {
              "line": 230,
              "column": 45
          },
          {
              "line": 232,
              "column": 43
          },
          {
              "line": 232,
              "column": 49
          },
          {
              "line": 232,
              "column": 72
          },
          {
              "line": 232,
              "column": 84
          },
          {
              "line": 232,
              "column": 89
          },
          {
              "line": 232,
              "column": 93
          },
          {
              "line": 233,
              "column": 39
          },
          {
              "line": 233,
              "column": 42
          },
          {
              "line": 234,
              "column": 37
          },
          {
              "line": 234,
              "column": 44
          },
          {
              "line": 236,
              "column": 34
          },
          {
              "line": 236,
              "column": 47
          },
          {
              "line": 237,
              "column": 47
          },
          {
              "line": 237,
              "column": 51
          },
          {
              "line": 238,
              "column": 27
          },
          {
              "line": 238,
              "column": 34
          },
          {
              "line": 238,
              "column": 39
          },
          {
              "line": 238,
              "column": 41
          },
          {
              "line": 238,
              "column": 48
          },
          {
              "line": 238,
              "column": 60
          },
          {
              "line": 238,
              "column": 65
          },
          {
              "line": 238,
              "column": 70
          },
          {
              "line": 238,
              "column": 72
          },
          {
              "line": 238,
              "column": 79
          },
          {
              "line": 240,
              "column": 13
          },
          {
              "line": 240,
              "column": 18
          },
          {
              "line": 240,
              "column": 23
          },
          {
              "line": 240,
              "column": 25
          },
          {
              "line": 240,
              "column": 32
          },
          {
              "line": 241,
              "column": 24
          },
          {
              "line": 241,
              "column": 31
          },
          {
              "line": 243,
              "column": 30
          },
          {
              "line": 243,
              "column": 44
          },
          {
              "line": 243,
              "column": 51
          },
          {
              "line": 244,
              "column": 84
          },
          {
              "line": 244,
              "column": 94
          },
          {
              "line": 245,
              "column": 14
          },
          {
              "line": 245,
              "column": 16
          },
          {
              "line": 245,
              "column": 22
          },
          {
              "line": 245,
              "column": 27
          },
          {
              "line": 245,
              "column": 35
          },
          {
              "line": 245,
              "column": 39
          },
          {
              "line": 245,
              "column": 52
          },
          {
              "line": 245,
              "column": 59
          },
          {
              "line": 245,
              "column": 73
          },
          {
              "line": 245,
              "column": 80
          },
          {
              "line": 248,
              "column": 10
          },
          {
              "line": 248,
              "column": 12
          },
          {
              "line": 248,
              "column": 18
          },
          {
              "line": 248,
              "column": 23
          },
          {
              "line": 248,
              "column": 30
          },
          {
              "line": 248,
              "column": 32
          },
          {
              "line": 248,
              "column": 38
          },
          {
              "line": 248,
              "column": 43
          },
          {
              "line": 248,
              "column": 51
          },
          {
              "line": 250,
              "column": 10
          },
          {
              "line": 250,
              "column": 17
          },
          {
              "line": 251,
              "column": 18
          },
          {
              "line": 251,
              "column": 20
          },
          {
              "line": 251,
              "column": 26
          },
          {
              "line": 251,
              "column": 31
          },
          {
              "line": 251,
              "column": 36
          },
          {
              "line": 251,
              "column": 47
          },
          {
              "line": 251,
              "column": 53
          },
          {
              "line": 252,
              "column": 32
          },
          {
              "line": 252,
              "column": 37
          },
          {
              "line": 253,
              "column": 32
          },
          {
              "line": 253,
              "column": 37
          },
          {
              "line": 253,
              "column": 39
          },
          {
              "line": 253,
              "column": 46
          },
          {
              "line": 254,
              "column": 26
          },
          {
              "line": 254,
              "column": 33
          },
          {
              "line": 254,
              "column": 38
          },
          {
              "line": 254,
              "column": 40
          },
          {
              "line": 254,
              "column": 54
          },
          {
              "line": 254,
              "column": 61
          },
          {
              "line": 254,
              "column": 70
          },
          {
              "line": 254,
              "column": 72
          },
          {
              "line": 256,
              "column": 10
          },
          {
              "line": 256,
              "column": 17
          },
          {
              "line": 257,
              "column": 18
          },
          {
              "line": 257,
              "column": 20
          },
          {
              "line": 257,
              "column": 26
          },
          {
              "line": 257,
              "column": 31
          },
          {
              "line": 257,
              "column": 36
          },
          {
              "line": 257,
              "column": 47
          },
          {
              "line": 257,
              "column": 53
          },
          {
              "line": 258,
              "column": 32
          },
          {
              "line": 258,
              "column": 37
          },
          {
              "line": 259,
              "column": 32
          },
          {
              "line": 259,
              "column": 37
          },
          {
              "line": 259,
              "column": 39
          },
          {
              "line": 259,
              "column": 46
          },
          {
              "line": 260,
              "column": 26
          },
          {
              "line": 260,
              "column": 33
          },
          {
              "line": 260,
              "column": 38
          },
          {
              "line": 260,
              "column": 40
          },
          {
              "line": 260,
              "column": 54
          },
          {
              "line": 260,
              "column": 61
          },
          {
              "line": 262,
              "column": 14
          },
          {
              "line": 262,
              "column": 17
          },
          {
              "line": 262,
              "column": 23
          },
          {
              "line": 262,
              "column": 27
          },
          {
              "line": 262,
              "column": 33
          },
          {
              "line": 264,
              "column": 15
          },
          {
              "line": 265,
              "column": 26
          },
          {
              "line": 265,
              "column": 33
          },
          {
              "line": 265,
              "column": 39
          },
          {
              "line": 267,
              "column": 32
          },
          {
              "line": 267,
              "column": 37
          },
          {
              "line": 268,
              "column": 39
          },
          {
              "line": 268,
              "column": 47
          },
          {
              "line": 269,
              "column": 52
          },
          {
              "line": 270,
              "column": 40
          },
          {
              "line": 270,
              "column": 54
          },
          {
              "line": 271,
              "column": 53
          },
          {
              "line": 271,
              "column": 83
          },
          {
              "line": 271,
              "column": 87
          },
          {
              "line": 272,
              "column": 38
          },
          {
              "line": 272,
              "column": 41
          },
          {
              "line": 272,
              "column": 47
          },
          {
              "line": 272,
              "column": 51
          },
          {
              "line": 272,
              "column": 65
          },
          {
              "line": 273,
              "column": 34
          },
          {
              "line": 273,
              "column": 47
          },
          {
              "line": 276,
              "column": 20
          },
          {
              "line": 276,
              "column": 24
          },
          {
              "line": 276,
              "column": 26
          },
          {
              "line": 276,
              "column": 32
          },
          {
              "line": 276,
              "column": 37
          },
          {
              "line": 277,
              "column": 19
          },
          {
              "line": 277,
              "column": 23
          },
          {
              "line": 277,
              "column": 51
          },
          {
              "line": 277,
              "column": 66
          },
          {
              "line": 279,
              "column": 15
          },
          {
              "line": 280,
              "column": 26
          },
          {
              "line": 280,
              "column": 33
          },
          {
              "line": 280,
              "column": 39
          },
          {
              "line": 282,
              "column": 32
          },
          {
              "line": 282,
              "column": 37
          },
          {
              "line": 283,
              "column": 39
          },
          {
              "line": 283,
              "column": 47
          },
          {
              "line": 284,
              "column": 52
          },
          {
              "line": 286,
              "column": 78
          },
          {
              "line": 286,
              "column": 82
          },
          {
              "line": 287,
              "column": 38
          },
          {
              "line": 287,
              "column": 41
          },
          {
              "line": 287,
              "column": 47
          },
          {
              "line": 287,
              "column": 51
          },
          {
              "line": 288,
              "column": 34
          },
          {
              "line": 291,
              "column": 20
          },
          {
              "line": 291,
              "column": 24
          },
          {
              "line": 291,
              "column": 26
          },
          {
              "line": 291,
              "column": 32
          },
          {
              "line": 291,
              "column": 37
          },
          {
              "line": 292,
              "column": 19
          },
          {
              "line": 294,
              "column": 15
          },
          {
              "line": 295,
              "column": 26
          },
          {
              "line": 295,
              "column": 33
          },
          {
              "line": 295,
              "column": 39
          },
          {
              "line": 297,
              "column": 32
          },
          {
              "line": 297,
              "column": 37
          },
          {
              "line": 298,
              "column": 39
          },
          {
              "line": 298,
              "column": 47
          },
          {
              "line": 299,
              "column": 52
          },
          {
              "line": 300,
              "column": 50
          },
          {
              "line": 301,
              "column": 63
          },
          {
              "line": 301,
              "column": 88
          },
          {
              "line": 301,
              "column": 92
          },
          {
              "line": 302,
              "column": 38
          },
          {
              "line": 302,
              "column": 41
          },
          {
              "line": 302,
              "column": 47
          },
          {
              "line": 302,
              "column": 51
          },
          {
              "line": 303,
              "column": 34
          },
          {
              "line": 306,
              "column": 20
          },
          {
              "line": 306,
              "column": 24
          },
          {
              "line": 306,
              "column": 26
          },
          {
              "line": 306,
              "column": 32
          },
          {
              "line": 306,
              "column": 37
          },
          {
              "line": 307,
              "column": 20
          },
          {
              "line": 307,
              "column": 23
          },
          {
              "line": 307,
              "column": 54
          },
          {
              "line": 310,
              "column": 14
          },
          {
              "line": 310,
              "column": 16
          },
          {
              "line": 310,
              "column": 22
          },
          {
              "line": 310,
              "column": 27
          },
          {
              "line": 310,
              "column": 32
          },
          {
              "line": 310,
              "column": 38
          },
          {
              "line": 310,
              "column": 42
          },
          {
              "line": 311,
              "column": 14
          },
          {
              "line": 311,
              "column": 21
          },
          {
              "line": 311,
              "column": 29
          },
          {
              "line": 312,
              "column": 14
          },
          {
              "line": 312,
              "column": 21
          },
          {
              "line": 312,
              "column": 29
          },
          {
              "line": 316,
              "column": 7
          },
          {
              "line": 317,
              "column": 18
          },
          {
              "line": 317,
              "column": 25
          },
          {
              "line": 317,
              "column": 29
          },
          {
              "line": 317,
              "column": 32
          },
          {
              "line": 317,
              "column": 35
          },
          {
              "line": 317,
              "column": 42
          },
          {
              "line": 317,
              "column": 57
          },
          {
              "line": 318,
              "column": 11
          },
          {
              "line": 318,
              "column": 15
          },
          {
              "line": 319,
              "column": 62
          },
          {
              "line": 320,
              "column": 17
          },
          {
              "line": 320,
              "column": 19
          },
          {
              "line": 320,
              "column": 25
          },
          {
              "line": 320,
              "column": 30
          },
          {
              "line": 320,
              "column": 37
          },
          {
              "line": 320,
              "column": 39
          },
          {
              "line": 320,
              "column": 44
          },
          {
              "line": 323,
              "column": 14
          },
          {
              "line": 324,
              "column": 29
          },
          {
              "line": 324,
              "column": 43
          },
          {
              "line": 324,
              "column": 49
          },
          {
              "line": 325,
              "column": 50
          },
          {
              "line": 325,
              "column": 56
          },
          {
              "line": 326,
              "column": 41
          },
          {
              "line": 326,
              "column": 48
          },
          {
              "line": 328,
              "column": 38
          },
          {
              "line": 328,
              "column": 51
          },
          {
              "line": 330,
              "column": 31
          },
          {
              "line": 330,
              "column": 38
          },
          {
              "line": 330,
              "column": 43
          },
          {
              "line": 330,
              "column": 45
          },
          {
              "line": 330,
              "column": 52
          },
          {
              "line": 330,
              "column": 64
          },
          {
              "line": 330,
              "column": 69
          },
          {
              "line": 330,
              "column": 74
          },
          {
              "line": 330,
              "column": 76
          },
          {
              "line": 330,
              "column": 83
          },
          {
              "line": 333,
              "column": 17
          },
          {
              "line": 333,
              "column": 22
          },
          {
              "line": 333,
              "column": 24
          },
          {
              "line": 333,
              "column": 50
          },
          {
              "line": 334,
              "column": 22
          },
          {
              "line": 334,
              "column": 29
          },
          {
              "line": 334,
              "column": 34
          },
          {
              "line": 334,
              "column": 36
          },
          {
              "line": 334,
              "column": 57
          },
          {
              "line": 334,
              "column": 70
          },
          {
              "line": 334,
              "column": 77
          },
          {
              "line": 335,
              "column": 14
          },
          {
              "line": 335,
              "column": 20
          },
          {
              "line": 335,
              "column": 23
          },
          {
              "line": 335,
              "column": 31
          },
          {
              "line": 335,
              "column": 35
          },
          {
              "line": 335,
              "column": 44
          },
          {
              "line": 335,
              "column": 53
          },
          {
              "line": 335,
              "column": 60
          },
          {
              "line": 335,
              "column": 81
          },
          {
              "line": 336,
              "column": 17
          },
          {
              "line": 336,
              "column": 22
          },
          {
              "line": 336,
              "column": 24
          },
          {
              "line": 336,
              "column": 50
          },
          {
              "line": 337,
              "column": 22
          },
          {
              "line": 337,
              "column": 29
          },
          {
              "line": 337,
              "column": 34
          },
          {
              "line": 337,
              "column": 36
          },
          {
              "line": 337,
              "column": 57
          },
          {
              "line": 337,
              "column": 70
          },
          {
              "line": 337,
              "column": 77
          },
          {
              "line": 338,
              "column": 14
          },
          {
              "line": 338,
              "column": 20
          },
          {
              "line": 338,
              "column": 23
          },
          {
              "line": 338,
              "column": 31
          },
          {
              "line": 338,
              "column": 35
          },
          {
              "line": 338,
              "column": 44
          },
          {
              "line": 338,
              "column": 53
          },
          {
              "line": 338,
              "column": 60
          },
          {
              "line": 338,
              "column": 81
          },
          {
              "line": 340,
              "column": 18
          },
          {
              "line": 340,
              "column": 21
          },
          {
              "line": 340,
              "column": 36
          },
          {
              "line": 340,
              "column": 40
          },
          {
              "line": 340,
              "column": 43
          },
          {
              "line": 340,
              "column": 64
          },
          {
              "line": 340,
              "column": 71
          },
          {
              "line": 340,
              "column": 77
          },
          {
              "line": 340,
              "column": 91
          },
          {
              "line": 341,
              "column": 14
          },
          {
              "line": 341,
              "column": 52
          },
          {
              "line": 342,
              "column": 23
          },
          {
              "line": 342,
              "column": 26
          },
          {
              "line": 342,
              "column": 29
          },
          {
              "line": 342,
              "column": 32
          },
          {
              "line": 342,
              "column": 41
          },
          {
              "line": 342,
              "column": 51
          },
          {
              "line": 342,
              "column": 53
          },
          {
              "line": 342,
              "column": 59
          },
          {
              "line": 342,
              "column": 64
          },
          {
              "line": 344,
              "column": 18
          },
          {
              "line": 345,
              "column": 29
          },
          {
              "line": 345,
              "column": 33
          },
          {
              "line": 345,
              "column": 39
          },
          {
              "line": 346,
              "column": 18
          },
          {
              "line": 346,
              "column": 28
          },
          {
              "line": 348,
              "column": 37
          },
          {
              "line": 352,
              "column": 7
          },
          {
              "line": 353,
              "column": 18
          },
          {
              "line": 353,
              "column": 22
          },
          {
              "line": 353,
              "column": 24
          },
          {
              "line": 353,
              "column": 41
          },
          {
              "line": 353,
              "column": 47
          },
          {
              "line": 353,
              "column": 54
          },
          {
              "line": 353,
              "column": 69
          },
          {
              "line": 354,
              "column": 10
          },
          {
              "line": 354,
              "column": 20
          },
          {
              "line": 354,
              "column": 22
          },
          {
              "line": 354,
              "column": 28
          },
          {
              "line": 354,
              "column": 33
          },
          {
              "line": 357,
              "column": 20
          },
          {
              "line": 357,
              "column": 26
          },
          {
              "line": 357,
              "column": 37
          },
          {
              "line": 357,
              "column": 44
          },
          {
              "line": 357,
              "column": 46
          },
          {
              "line": 357,
              "column": 52
          },
          {
              "line": 357,
              "column": 58
          },
          {
              "line": 358,
              "column": 22
          },
          {
              "line": 358,
              "column": 24
          },
          {
              "line": 358,
              "column": 30
          },
          {
              "line": 358,
              "column": 35
          },
          {
              "line": 361,
              "column": 30
          },
          {
              "line": 361,
              "column": 36
          },
          {
              "line": 362,
              "column": 31
          },
          {
              "line": 362,
              "column": 52
          },
          {
              "line": 362,
              "column": 65
          },
          {
              "line": 364,
              "column": 30
          },
          {
              "line": 364,
              "column": 32
          },
          {
              "line": 364,
              "column": 38
          },
          {
              "line": 364,
              "column": 43
          },
          {
              "line": 366,
              "column": 21
          },
          {
              "line": 366,
              "column": 23
          },
          {
              "line": 366,
              "column": 25
          },
          {
              "line": 366,
              "column": 37
          },
          {
              "line": 366,
              "column": 50
          },
          {
              "line": 366,
              "column": 54
          },
          {
              "line": 367,
              "column": 26
          },
          {
              "line": 367,
              "column": 39
          },
          {
              "line": 367,
              "column": 43
          },
          {
              "line": 367,
              "column": 52
          },
          {
              "line": 367,
              "column": 55
          },
          {
              "line": 367,
              "column": 61
          },
          {
              "line": 367,
              "column": 65
          },
          {
              "line": 368,
              "column": 18
          },
          {
              "line": 368,
              "column": 33
          },
          {
              "line": 368,
              "column": 37
          },
          {
              "line": 368,
              "column": 43
          },
          {
              "line": 368,
              "column": 54
          },
          {
              "line": 371,
              "column": 26
          },
          {
              "line": 371,
              "column": 32
          },
          {
              "line": 373,
              "column": 19
          },
          {
              "line": 373,
              "column": 21
          },
          {
              "line": 373,
              "column": 27
          },
          {
              "line": 373,
              "column": 32
          },
          {
              "line": 373,
              "column": 42
          },
          {
              "line": 375,
              "column": 14
          },
          {
              "line": 375,
              "column": 30
          },
          {
              "line": 375,
              "column": 41
          },
          {
              "line": 376,
              "column": 16
          },
          {
              "line": 376,
              "column": 29
          },
          {
              "line": 376,
              "column": 33
          },
          {
              "line": 376,
              "column": 35
          },
          {
              "line": 376,
              "column": 41
          },
          {
              "line": 376,
              "column": 46
          },
          {
              "line": 376,
              "column": 58
          },
          {
              "line": 378,
              "column": 21
          },
          {
              "line": 378,
              "column": 23
          },
          {
              "line": 378,
              "column": 25
          },
          {
              "line": 378,
              "column": 37
          },
          {
              "line": 378,
              "column": 50
          },
          {
              "line": 378,
              "column": 53
          },
          {
              "line": 378,
              "column": 64
          },
          {
              "line": 379,
              "column": 26
          },
          {
              "line": 379,
              "column": 39
          },
          {
              "line": 379,
              "column": 43
          },
          {
              "line": 379,
              "column": 52
          },
          {
              "line": 379,
              "column": 55
          },
          {
              "line": 379,
              "column": 61
          },
          {
              "line": 379,
              "column": 65
          },
          {
              "line": 380,
              "column": 18
          },
          {
              "line": 380,
              "column": 33
          },
          {
              "line": 380,
              "column": 37
          },
          {
              "line": 380,
              "column": 43
          },
          {
              "line": 380,
              "column": 54
          },
          {
              "line": 384,
              "column": 14
          },
          {
              "line": 384,
              "column": 16
          },
          {
              "line": 384,
              "column": 22
          },
          {
              "line": 384,
              "column": 27
          },
          {
              "line": 384,
              "column": 37
          },
          {
              "line": 385,
              "column": 14
          },
          {
              "line": 385,
              "column": 16
          },
          {
              "line": 385,
              "column": 22
          },
          {
              "line": 385,
              "column": 27
          },
          {
              "line": 387,
              "column": 10
          },
          {
              "line": 387,
              "column": 26
          },
          {
              "line": 387,
              "column": 33
          },
          {
              "line": 387,
              "column": 39
          },
          {
              "line": 390,
              "column": 7
          },
          {
              "line": 391,
              "column": 18
          },
          {
              "line": 391,
              "column": 52
          },
          {
              "line": 392,
              "column": 10
          },
          {
              "line": 392,
              "column": 20
          },
          {
              "line": 392,
              "column": 22
          },
          {
              "line": 392,
              "column": 28
          },
          {
              "line": 392,
              "column": 33
          },
          {
              "line": 394,
              "column": 20
          },
          {
              "line": 394,
              "column": 26
          },
          {
              "line": 394,
              "column": 37
          },
          {
              "line": 394,
              "column": 44
          },
          {
              "line": 394,
              "column": 46
          },
          {
              "line": 394,
              "column": 52
          },
          {
              "line": 394,
              "column": 58
          },
          {
              "line": 395,
              "column": 22
          },
          {
              "line": 395,
              "column": 24
          },
          {
              "line": 395,
              "column": 30
          },
          {
              "line": 395,
              "column": 35
          },
          {
              "line": 398,
              "column": 30
          },
          {
              "line": 398,
              "column": 36
          },
          {
              "line": 399,
              "column": 31
          },
          {
              "line": 399,
              "column": 52
          },
          {
              "line": 399,
              "column": 65
          },
          {
              "line": 400,
              "column": 26
          },
          {
              "line": 400,
              "column": 32
          },
          {
              "line": 401,
              "column": 14
          },
          {
              "line": 401,
              "column": 27
          },
          {
              "line": 401,
              "column": 32
          },
          {
              "line": 401,
              "column": 34
          },
          {
              "line": 401,
              "column": 37
          },
          {
              "line": 403,
              "column": 19
          },
          {
              "line": 403,
              "column": 21
          },
          {
              "line": 403,
              "column": 27
          },
          {
              "line": 403,
              "column": 32
          },
          {
              "line": 403,
              "column": 42
          },
          {
              "line": 404,
              "column": 19
          },
          {
              "line": 404,
              "column": 21
          },
          {
              "line": 404,
              "column": 27
          },
          {
              "line": 404,
              "column": 32
          },
          {
              "line": 406,
              "column": 10
          },
          {
              "line": 406,
              "column": 26
          },
          {
              "line": 406,
              "column": 33
          },
          {
              "line": 406,
              "column": 39
          },
          {
              "line": 409,
              "column": 7
          },
          {
              "line": 410,
              "column": 18
          },
          {
              "line": 410,
              "column": 49
          },
          {
              "line": 410,
              "column": 63
          },
          {
              "line": 411,
              "column": 10
          },
          {
              "line": 411,
              "column": 20
          },
          {
              "line": 411,
              "column": 22
          },
          {
              "line": 411,
              "column": 28
          },
          {
              "line": 411,
              "column": 33
          },
          {
              "line": 413,
              "column": 20
          },
          {
              "line": 413,
              "column": 26
          },
          {
              "line": 413,
              "column": 37
          },
          {
              "line": 413,
              "column": 44
          },
          {
              "line": 413,
              "column": 46
          },
          {
              "line": 413,
              "column": 52
          },
          {
              "line": 413,
              "column": 58
          },
          {
              "line": 414,
              "column": 22
          },
          {
              "line": 414,
              "column": 24
          },
          {
              "line": 414,
              "column": 30
          },
          {
              "line": 414,
              "column": 35
          },
          {
              "line": 417,
              "column": 30
          },
          {
              "line": 417,
              "column": 36
          },
          {
              "line": 418,
              "column": 31
          },
          {
              "line": 418,
              "column": 52
          },
          {
              "line": 418,
              "column": 65
          },
          {
              "line": 419,
              "column": 26
          },
          {
              "line": 419,
              "column": 32
          },
          {
              "line": 420,
              "column": 16
          },
          {
              "line": 420,
              "column": 36
          },
          {
              "line": 420,
              "column": 43
          },
          {
              "line": 420,
              "column": 49
          },
          {
              "line": 421,
              "column": 29
          },
          {
              "line": 423,
              "column": 27
          },
          {
              "line": 425,
              "column": 25
          },
          {
              "line": 425,
              "column": 37
          },
          {
              "line": 428,
              "column": 29
          },
          {
              "line": 429,
              "column": 14
          },
          {
              "line": 429,
              "column": 27
          },
          {
              "line": 429,
              "column": 32
          },
          {
              "line": 429,
              "column": 34
          },
          {
              "line": 429,
              "column": 37
          },
          {
              "line": 431,
              "column": 19
          },
          {
              "line": 431,
              "column": 21
          },
          {
              "line": 431,
              "column": 27
          },
          {
              "line": 431,
              "column": 32
          },
          {
              "line": 431,
              "column": 42
          },
          {
              "line": 432,
              "column": 19
          },
          {
              "line": 432,
              "column": 21
          },
          {
              "line": 432,
              "column": 27
          },
          {
              "line": 432,
              "column": 32
          },
          {
              "line": 434,
              "column": 10
          },
          {
              "line": 434,
              "column": 26
          },
          {
              "line": 434,
              "column": 33
          },
          {
              "line": 434,
              "column": 39
          },
          {
              "line": 437,
              "column": 7
          },
          {
              "line": 438,
              "column": 18
          },
          {
              "line": 438,
              "column": 26
          },
          {
              "line": 438,
              "column": 52
          },
          {
              "line": 439,
              "column": 10
          },
          {
              "line": 439,
              "column": 20
          },
          {
              "line": 439,
              "column": 22
          },
          {
              "line": 439,
              "column": 28
          },
          {
              "line": 439,
              "column": 33
          },
          {
              "line": 441,
              "column": 20
          },
          {
              "line": 441,
              "column": 26
          },
          {
              "line": 441,
              "column": 37
          },
          {
              "line": 441,
              "column": 44
          },
          {
              "line": 441,
              "column": 46
          },
          {
              "line": 441,
              "column": 52
          },
          {
              "line": 441,
              "column": 58
          },
          {
              "line": 442,
              "column": 22
          },
          {
              "line": 442,
              "column": 24
          },
          {
              "line": 442,
              "column": 30
          },
          {
              "line": 442,
              "column": 35
          },
          {
              "line": 445,
              "column": 30
          },
          {
              "line": 445,
              "column": 36
          },
          {
              "line": 446,
              "column": 31
          },
          {
              "line": 446,
              "column": 52
          },
          {
              "line": 446,
              "column": 65
          },
          {
              "line": 447,
              "column": 16
          },
          {
              "line": 447,
              "column": 36
          },
          {
              "line": 447,
              "column": 43
          },
          {
              "line": 447,
              "column": 49
          },
          {
              "line": 448,
              "column": 29
          },
          {
              "line": 449,
              "column": 17
          },
          {
              "line": 450,
              "column": 17
          },
          {
              "line": 450,
              "column": 21
          },
          {
              "line": 450,
              "column": 23
          },
          {
              "line": 451,
              "column": 20
          },
          {
              "line": 451,
              "column": 26
          },
          {
              "line": 452,
              "column": 18
          },
          {
              "line": 452,
              "column": 26
          },
          {
              "line": 452,
              "column": 43
          },
          {
              "line": 453,
              "column": 17
          },
          {
              "line": 453,
              "column": 53
          },
          {
              "line": 455,
              "column": 22
          },
          {
              "line": 455,
              "column": 29
          },
          {
              "line": 455,
              "column": 31
          },
          {
              "line": 455,
              "column": 37
          },
          {
              "line": 455,
              "column": 43
          },
          {
              "line": 455,
              "column": 55
          },
          {
              "line": 455,
              "column": 73
          },
          {
              "line": 456,
              "column": 14
          },
          {
              "line": 456,
              "column": 16
          },
          {
              "line": 456,
              "column": 22
          },
          {
              "line": 456,
              "column": 28
          },
          {
              "line": 456,
              "column": 31
          },
          {
              "line": 456,
              "column": 33
          },
          {
              "line": 456,
              "column": 39
          },
          {
              "line": 456,
              "column": 45
          },
          {
              "line": 456,
              "column": 58
          },
          {
              "line": 456,
              "column": 65
          },
          {
              "line": 456,
              "column": 75
          },
          {
              "line": 456,
              "column": 80
          },
          {
              "line": 457,
              "column": 16
          },
          {
              "line": 457,
              "column": 28
          },
          {
              "line": 457,
              "column": 30
          },
          {
              "line": 457,
              "column": 36
          },
          {
              "line": 457,
              "column": 42
          },
          {
              "line": 458,
              "column": 16
          },
          {
              "line": 458,
              "column": 22
          },
          {
              "line": 458,
              "column": 25
          },
          {
              "line": 458,
              "column": 27
          },
          {
              "line": 458,
              "column": 33
          },
          {
              "line": 458,
              "column": 39
          },
          {
              "line": 458,
              "column": 42
          },
          {
              "line": 458,
              "column": 48
          },
          {
              "line": 458,
              "column": 52
          },
          {
              "line": 459,
              "column": 16
          },
          {
              "line": 459,
              "column": 30
          },
          {
              "line": 459,
              "column": 32
          },
          {
              "line": 459,
              "column": 38
          },
          {
              "line": 459,
              "column": 44
          },
          {
              "line": 459,
              "column": 47
          },
          {
              "line": 459,
              "column": 50
          },
          {
              "line": 459,
              "column": 61
          },
          {
              "line": 459,
              "column": 66
          },
          {
              "line": 459,
              "column": 72
          },
          {
              "line": 459,
              "column": 77
          },
          {
              "line": 461,
              "column": 28
          },
          {
              "line": 461,
              "column": 45
          },
          {
              "line": 461,
              "column": 52
          },
          {
              "line": 461,
              "column": 59
          },
          {
              "line": 461,
              "column": 65
          },
          {
              "line": 461,
              "column": 77
          },
          {
              "line": 461,
              "column": 84
          },
          {
              "line": 461,
              "column": 87
          },
          {
              "line": 461,
              "column": 92
          },
          {
              "line": 462,
              "column": 20
          },
          {
              "line": 462,
              "column": 26
          },
          {
              "line": 462,
              "column": 31
          },
          {
              "line": 462,
              "column": 41
          },
          {
              "line": 465,
              "column": 29
          },
          {
              "line": 466,
              "column": 14
          },
          {
              "line": 466,
              "column": 27
          },
          {
              "line": 466,
              "column": 32
          },
          {
              "line": 466,
              "column": 34
          },
          {
              "line": 466,
              "column": 37
          },
          {
              "line": 468,
              "column": 19
          },
          {
              "line": 468,
              "column": 21
          },
          {
              "line": 468,
              "column": 27
          },
          {
              "line": 468,
              "column": 32
          },
          {
              "line": 468,
              "column": 42
          },
          {
              "line": 469,
              "column": 19
          },
          {
              "line": 469,
              "column": 21
          },
          {
              "line": 469,
              "column": 27
          },
          {
              "line": 469,
              "column": 32
          },
          {
              "line": 471,
              "column": 10
          },
          {
              "line": 471,
              "column": 26
          },
          {
              "line": 471,
              "column": 33
          },
          {
              "line": 471,
              "column": 39
          },
          {
              "line": 474,
              "column": 7
          },
          {
              "line": 475,
              "column": 18
          },
          {
              "line": 475,
              "column": 25
          },
          {
              "line": 475,
              "column": 55
          },
          {
              "line": 476,
              "column": 10
          },
          {
              "line": 476,
              "column": 20
          },
          {
              "line": 476,
              "column": 22
          },
          {
              "line": 476,
              "column": 28
          },
          {
              "line": 476,
              "column": 33
          },
          {
              "line": 478,
              "column": 20
          },
          {
              "line": 478,
              "column": 26
          },
          {
              "line": 478,
              "column": 37
          },
          {
              "line": 478,
              "column": 44
          },
          {
              "line": 478,
              "column": 46
          },
          {
              "line": 478,
              "column": 52
          },
          {
              "line": 478,
              "column": 58
          },
          {
              "line": 479,
              "column": 22
          },
          {
              "line": 479,
              "column": 24
          },
          {
              "line": 479,
              "column": 30
          },
          {
              "line": 479,
              "column": 35
          },
          {
              "line": 482,
              "column": 30
          },
          {
              "line": 482,
              "column": 36
          },
          {
              "line": 483,
              "column": 31
          },
          {
              "line": 483,
              "column": 52
          },
          {
              "line": 483,
              "column": 65
          },
          {
              "line": 484,
              "column": 16
          },
          {
              "line": 484,
              "column": 36
          },
          {
              "line": 484,
              "column": 43
          },
          {
              "line": 484,
              "column": 49
          },
          {
              "line": 485,
              "column": 29
          },
          {
              "line": 486,
              "column": 17
          },
          {
              "line": 487,
              "column": 17
          },
          {
              "line": 487,
              "column": 21
          },
          {
              "line": 487,
              "column": 23
          },
          {
              "line": 488,
              "column": 20
          },
          {
              "line": 488,
              "column": 26
          },
          {
              "line": 489,
              "column": 26
          },
          {
              "line": 489,
              "column": 32
          },
          {
              "line": 490,
              "column": 18
          },
          {
              "line": 490,
              "column": 26
          },
          {
              "line": 490,
              "column": 43
          },
          {
              "line": 492,
              "column": 28
          },
          {
              "line": 492,
              "column": 45
          },
          {
              "line": 492,
              "column": 52
          },
          {
              "line": 492,
              "column": 59
          },
          {
              "line": 492,
              "column": 65
          },
          {
              "line": 492,
              "column": 77
          },
          {
              "line": 492,
              "column": 84
          },
          {
              "line": 492,
              "column": 87
          },
          {
              "line": 492,
              "column": 92
          },
          {
              "line": 493,
              "column": 20
          },
          {
              "line": 493,
              "column": 26
          },
          {
              "line": 493,
              "column": 31
          },
          {
              "line": 493,
              "column": 41
          },
          {
              "line": 496,
              "column": 17
          },
          {
              "line": 496,
              "column": 53
          },
          {
              "line": 498,
              "column": 27
          },
          {
              "line": 500,
              "column": 25
          },
          {
              "line": 500,
              "column": 37
          },
          {
              "line": 503,
              "column": 29
          },
          {
              "line": 504,
              "column": 14
          },
          {
              "line": 504,
              "column": 27
          },
          {
              "line": 504,
              "column": 32
          },
          {
              "line": 504,
              "column": 34
          },
          {
              "line": 504,
              "column": 37
          },
          {
              "line": 506,
              "column": 19
          },
          {
              "line": 506,
              "column": 21
          },
          {
              "line": 506,
              "column": 27
          },
          {
              "line": 506,
              "column": 32
          },
          {
              "line": 506,
              "column": 42
          },
          {
              "line": 507,
              "column": 19
          },
          {
              "line": 507,
              "column": 21
          },
          {
              "line": 507,
              "column": 27
          },
          {
              "line": 507,
              "column": 32
          },
          {
              "line": 509,
              "column": 10
          },
          {
              "line": 509,
              "column": 26
          },
          {
              "line": 509,
              "column": 33
          },
          {
              "line": 509,
              "column": 39
          },
          {
              "line": 512,
              "column": 7
          },
          {
              "line": 513,
              "column": 18
          },
          {
              "line": 513,
              "column": 27
          },
          {
              "line": 513,
              "column": 29
          },
          {
              "line": 513,
              "column": 31
          },
          {
              "line": 513,
              "column": 33
          },
          {
              "line": 513,
              "column": 41
          },
          {
              "line": 513,
              "column": 47
          },
          {
              "line": 513,
              "column": 62
          },
          {
              "line": 514,
              "column": 11
          },
          {
              "line": 514,
              "column": 22
          },
          {
              "line": 514,
              "column": 24
          },
          {
              "line": 514,
              "column": 26
          },
          {
              "line": 514,
              "column": 32
          },
          {
              "line": 514,
              "column": 37
          },
          {
              "line": 514,
              "column": 44
          },
          {
              "line": 514,
              "column": 46
          },
          {
              "line": 514,
              "column": 54
          },
          {
              "line": 515,
              "column": 19
          },
          {
              "line": 515,
              "column": 22
          },
          {
              "line": 515,
              "column": 24
          },
          {
              "line": 515,
              "column": 26
          },
          {
              "line": 515,
              "column": 32
          },
          {
              "line": 515,
              "column": 40
          },
          {
              "line": 515,
              "column": 47
          },
          {
              "line": 516,
              "column": 13
          },
          {
              "line": 516,
              "column": 23
          },
          {
              "line": 516,
              "column": 32
          },
          {
              "line": 517,
              "column": 20
          },
          {
              "line": 517,
              "column": 34
          },
          {
              "line": 518,
              "column": 26
          },
          {
              "line": 518,
              "column": 32
          },
          {
              "line": 518,
              "column": 44
          },
          {
              "line": 518,
              "column": 50
          },
          {
              "line": 518,
              "column": 60
          },
          {
              "line": 518,
              "column": 67
          },
          {
              "line": 518,
              "column": 73
          },
          {
              "line": 518,
              "column": 83
          },
          {
              "line": 520,
              "column": 17
          },
          {
              "line": 520,
              "column": 22
          },
          {
              "line": 520,
              "column": 24
          },
          {
              "line": 521,
              "column": 22
          },
          {
              "line": 521,
              "column": 29
          },
          {
              "line": 521,
              "column": 34
          },
          {
              "line": 521,
              "column": 36
          },
          {
              "line": 523,
              "column": 27
          },
          {
              "line": 523,
              "column": 29
          },
          {
              "line": 523,
              "column": 36
          },
          {
              "line": 523,
              "column": 41
          },
          {
              "line": 523,
              "column": 45
          },
          {
              "line": 523,
              "column": 49
          },
          {
              "line": 523,
              "column": 54
          },
          {
              "line": 525,
              "column": 17
          },
          {
              "line": 525,
              "column": 22
          },
          {
              "line": 525,
              "column": 36
          },
          {
              "line": 526,
              "column": 25
          },
          {
              "line": 526,
              "column": 30
          },
          {
              "line": 526,
              "column": 41
          },
          {
              "line": 526,
              "column": 47
          },
          {
              "line": 527,
              "column": 36
          },
          {
              "line": 527,
              "column": 41
          },
          {
              "line": 527,
              "column": 60
          },
          {
              "line": 527,
              "column": 65
          },
          {
              "line": 527,
              "column": 67
          },
          {
              "line": 527,
              "column": 74
          },
          {
              "line": 529,
              "column": 17
          },
          {
              "line": 529,
              "column": 22
          },
          {
              "line": 529,
              "column": 28
          },
          {
              "line": 529,
              "column": 32
          },
          {
              "line": 530,
              "column": 17
          },
          {
              "line": 530,
              "column": 24
          },
          {
              "line": 530,
              "column": 28
          },
          {
              "line": 532,
              "column": 19
          },
          {
              "line": 532,
              "column": 33
          },
          {
              "line": 532,
              "column": 43
          },
          {
              "line": 533,
              "column": 16
          },
          {
              "line": 533,
              "column": 22
          },
          {
              "line": 533,
              "column": 30
          },
          {
              "line": 533,
              "column": 43
          },
          {
              "line": 535,
              "column": 25
          },
          {
              "line": 535,
              "column": 29
          },
          {
              "line": 535,
              "column": 38
          },
          {
              "line": 536,
              "column": 17
          },
          {
              "line": 536,
              "column": 27
          },
          {
              "line": 538,
              "column": 15
          },
          {
              "line": 539,
              "column": 20
          },
          {
              "line": 539,
              "column": 34
          },
          {
              "line": 540,
              "column": 26
          },
          {
              "line": 540,
              "column": 32
          },
          {
              "line": 540,
              "column": 44
          },
          {
              "line": 540,
              "column": 50
          },
          {
              "line": 540,
              "column": 60
          },
          {
              "line": 540,
              "column": 67
          },
          {
              "line": 540,
              "column": 73
          },
          {
              "line": 540,
              "column": 83
          },
          {
              "line": 542,
              "column": 19
          },
          {
              "line": 542,
              "column": 29
          },
          {
              "line": 542,
              "column": 37
          },
          {
              "line": 543,
              "column": 12
          },
          {
              "line": 543,
              "column": 31
          },
          {
              "line": 543,
              "column": 44
          },
          {
              "line": 546,
              "column": 7
          },
          {
              "line": 547,
              "column": 18
          },
          {
              "line": 547,
              "column": 25
          },
          {
              "line": 547,
              "column": 31
          },
          {
              "line": 547,
              "column": 33
          },
          {
              "line": 547,
              "column": 42
          },
          {
              "line": 547,
              "column": 44
          },
          {
              "line": 547,
              "column": 46
          },
          {
              "line": 547,
              "column": 70
          },
          {
              "line": 548,
              "column": 13
          },
          {
              "line": 548,
              "column": 18
          },
          {
              "line": 548,
              "column": 23
          },
          {
              "line": 548,
              "column": 25
          },
          {
              "line": 548,
              "column": 32
          },
          {
              "line": 549,
              "column": 15
          },
          {
              "line": 549,
              "column": 26
          },
          {
              "line": 549,
              "column": 28
          },
          {
              "line": 549,
              "column": 30
          },
          {
              "line": 549,
              "column": 36
          },
          {
              "line": 549,
              "column": 41
          },
          {
              "line": 549,
              "column": 48
          },
          {
              "line": 549,
              "column": 50
          },
          {
              "line": 549,
              "column": 58
          },
          {
              "line": 550,
              "column": 23
          },
          {
              "line": 550,
              "column": 26
          },
          {
              "line": 550,
              "column": 28
          },
          {
              "line": 550,
              "column": 30
          },
          {
              "line": 550,
              "column": 36
          },
          {
              "line": 550,
              "column": 44
          },
          {
              "line": 550,
              "column": 51
          },
          {
              "line": 552,
              "column": 21
          },
          {
              "line": 552,
              "column": 26
          },
          {
              "line": 552,
              "column": 28
          },
          {
              "line": 553,
              "column": 26
          },
          {
              "line": 553,
              "column": 33
          },
          {
              "line": 553,
              "column": 38
          },
          {
              "line": 553,
              "column": 40
          },
          {
              "line": 555,
              "column": 31
          },
          {
              "line": 555,
              "column": 33
          },
          {
              "line": 555,
              "column": 40
          },
          {
              "line": 555,
              "column": 45
          },
          {
              "line": 555,
              "column": 49
          },
          {
              "line": 555,
              "column": 53
          },
          {
              "line": 555,
              "column": 58
          },
          {
              "line": 557,
              "column": 21
          },
          {
              "line": 557,
              "column": 26
          },
          {
              "line": 557,
              "column": 40
          },
          {
              "line": 558,
              "column": 29
          },
          {
              "line": 558,
              "column": 34
          },
          {
              "line": 558,
              "column": 45
          },
          {
              "line": 558,
              "column": 51
          },
          {
              "line": 559,
              "column": 40
          },
          {
              "line": 559,
              "column": 45
          },
          {
              "line": 559,
              "column": 64
          },
          {
              "line": 559,
              "column": 69
          },
          {
              "line": 559,
              "column": 71
          },
          {
              "line": 559,
              "column": 78
          },
          {
              "line": 561,
              "column": 19
          },
          {
              "line": 561,
              "column": 21
          },
          {
              "line": 561,
              "column": 27
          },
          {
              "line": 561,
              "column": 29
          },
          {
              "line": 561,
              "column": 35
          },
          {
              "line": 561,
              "column": 39
          },
          {
              "line": 561,
              "column": 41
          },
          {
              "line": 561,
              "column": 43
          },
          {
              "line": 561,
              "column": 49
          },
          {
              "line": 561,
              "column": 55
          },
          {
              "line": 561,
              "column": 60
          },
          {
              "line": 561,
              "column": 70
          },
          {
              "line": 561,
              "column": 76
          },
          {
              "line": 561,
              "column": 82
          },
          {
              "line": 561,
              "column": 89
          },
          {
              "line": 562,
              "column": 21
          },
          {
              "line": 562,
              "column": 27
          },
          {
              "line": 562,
              "column": 29
          },
          {
              "line": 562,
              "column": 41
          },
          {
              "line": 562,
              "column": 47
          },
          {
              "line": 562,
              "column": 49
          },
          {
              "line": 562,
              "column": 64
          },
          {
              "line": 562,
              "column": 71
          },
          {
              "line": 562,
              "column": 77
          },
          {
              "line": 562,
              "column": 79
          },
          {
              "line": 563,
              "column": 28
          },
          {
              "line": 563,
              "column": 46
          },
          {
              "line": 563,
              "column": 66
          },
          {
              "line": 565,
              "column": 22
          },
          {
              "line": 565,
              "column": 24
          },
          {
              "line": 565,
              "column": 31
          },
          {
              "line": 565,
              "column": 37
          },
          {
              "line": 565,
              "column": 39
          },
          {
              "line": 567,
              "column": 25
          },
          {
              "line": 567,
              "column": 30
          },
          {
              "line": 567,
              "column": 36
          },
          {
              "line": 567,
              "column": 40
          },
          {
              "line": 567,
              "column": 45
          },
          {
              "line": 568,
              "column": 25
          },
          {
              "line": 568,
              "column": 32
          },
          {
              "line": 568,
              "column": 36
          },
          {
              "line": 568,
              "column": 47
          },
          {
              "line": 570,
              "column": 28
          },
          {
              "line": 570,
              "column": 34
          },
          {
              "line": 570,
              "column": 45
          },
          {
              "line": 570,
              "column": 52
          },
          {
              "line": 570,
              "column": 54
          },
          {
              "line": 570,
              "column": 60
          },
          {
              "line": 570,
              "column": 66
          },
          {
              "line": 571,
              "column": 33
          },
          {
              "line": 572,
              "column": 39
          },
          {
              "line": 573,
              "column": 39
          },
          {
              "line": 574,
              "column": 39
          },
          {
              "line": 574,
              "column": 42
          },
          {
              "line": 574,
              "column": 46
          },
          {
              "line": 575,
              "column": 39
          },
          {
              "line": 575,
              "column": 60
          },
          {
              "line": 575,
              "column": 73
          },
          {
              "line": 579,
              "column": 30
          },
          {
              "line": 579,
              "column": 37
          },
          {
              "line": 579,
              "column": 39
          },
          {
              "line": 579,
              "column": 45
          },
          {
              "line": 579,
              "column": 51
          },
          {
              "line": 579,
              "column": 63
          },
          {
              "line": 579,
              "column": 81
          },
          {
              "line": 581,
              "column": 25
          },
          {
              "line": 581,
              "column": 27
          },
          {
              "line": 581,
              "column": 33
          },
          {
              "line": 581,
              "column": 37
          },
          {
              "line": 581,
              "column": 39
          },
          {
              "line": 581,
              "column": 41
          },
          {
              "line": 581,
              "column": 47
          },
          {
              "line": 581,
              "column": 53
          },
          {
              "line": 581,
              "column": 59
          },
          {
              "line": 581,
              "column": 65
          },
          {
              "line": 582,
              "column": 34
          },
          {
              "line": 582,
              "column": 36
          },
          {
              "line": 582,
              "column": 42
          },
          {
              "line": 582,
              "column": 46
          },
          {
              "line": 582,
              "column": 48
          },
          {
              "line": 582,
              "column": 50
          },
          {
              "line": 582,
              "column": 56
          },
          {
              "line": 582,
              "column": 62
          },
          {
              "line": 583,
              "column": 46
          },
          {
              "line": 583,
              "column": 53
          },
          {
              "line": 583,
              "column": 63
          },
          {
              "line": 583,
              "column": 68
          },
          {
              "line": 585,
              "column": 29
          },
          {
              "line": 585,
              "column": 35
          },
          {
              "line": 585,
              "column": 43
          },
          {
              "line": 585,
              "column": 50
          },
          {
              "line": 585,
              "column": 56
          },
          {
              "line": 585,
              "column": 63
          },
          {
              "line": 585,
              "column": 69
          },
          {
              "line": 586,
              "column": 30
          },
          {
              "line": 586,
              "column": 47
          },
          {
              "line": 586,
              "column": 53
          },
          {
              "line": 586,
              "column": 56
          },
          {
              "line": 586,
              "column": 62
          },
          {
              "line": 586,
              "column": 68
          },
          {
              "line": 588,
              "column": 25
          },
          {
              "line": 588,
              "column": 31
          },
          {
              "line": 588,
              "column": 34
          },
          {
              "line": 588,
              "column": 39
          },
          {
              "line": 588,
              "column": 45
          },
          {
              "line": 588,
              "column": 51
          },
          {
              "line": 588,
              "column": 58
          },
          {
              "line": 588,
              "column": 64
          },
          {
              "line": 588,
              "column": 66
          },
          {
              "line": 588,
              "column": 77
          },
          {
              "line": 590,
              "column": 40
          },
          {
              "line": 590,
              "column": 46
          },
          {
              "line": 590,
              "column": 54
          },
          {
              "line": 590,
              "column": 61
          },
          {
              "line": 590,
              "column": 67
          },
          {
              "line": 590,
              "column": 70
          },
          {
              "line": 590,
              "column": 78
          },
          {
              "line": 590,
              "column": 84
          },
          {
              "line": 590,
              "column": 86
          },
          {
              "line": 590,
              "column": 92
          },
          {
              "line": 591,
              "column": 26
          },
          {
              "line": 591,
              "column": 36
          },
          {
              "line": 591,
              "column": 42
          },
          {
              "line": 591,
              "column": 44
          },
          {
              "line": 592,
              "column": 35
          },
          {
              "line": 592,
              "column": 40
          },
          {
              "line": 592,
              "column": 43
          },
          {
              "line": 592,
              "column": 45
          },
          {
              "line": 592,
              "column": 47
          },
          {
              "line": 592,
              "column": 50
          },
          {
              "line": 593,
              "column": 45
          },
          {
              "line": 593,
              "column": 51
          },
          {
              "line": 593,
              "column": 55
          },
          {
              "line": 593,
              "column": 58
          },
          {
              "line": 593,
              "column": 63
          },
          {
              "line": 593,
              "column": 69
          },
          {
              "line": 593,
              "column": 71
          },
          {
              "line": 593,
              "column": 79
          },
          {
              "line": 593,
              "column": 88
          },
          {
              "line": 593,
              "column": 92
          },
          {
              "line": 594,
              "column": 49
          },
          {
              "line": 594,
              "column": 52
          },
          {
              "line": 594,
              "column": 55
          },
          {
              "line": 595,
              "column": 41
          },
          {
              "line": 595,
              "column": 44
          },
          {
              "line": 595,
              "column": 50
          },
          {
              "line": 596,
              "column": 43
          },
          {
              "line": 599,
              "column": 23
          },
          {
              "line": 599,
              "column": 33
          },
          {
              "line": 599,
              "column": 39
          },
          {
              "line": 599,
              "column": 50
          },
          {
              "line": 599,
              "column": 56
          },
          {
              "line": 600,
              "column": 25
          },
          {
              "line": 600,
              "column": 37
          },
          {
              "line": 600,
              "column": 39
          },
          {
              "line": 600,
              "column": 47
          },
          {
              "line": 600,
              "column": 60
          },
          {
              "line": 600,
              "column": 73
          },
          {
              "line": 600,
              "column": 75
          },
          {
              "line": 600,
              "column": 79
          },
          {
              "line": 604,
              "column": 27
          },
          {
              "line": 604,
              "column": 37
          },
          {
              "line": 604,
              "column": 43
          },
          {
              "line": 604,
              "column": 49
          },
          {
              "line": 605,
              "column": 27
          },
          {
              "line": 605,
              "column": 37
          },
          {
              "line": 605,
              "column": 43
          },
          {
              "line": 605,
              "column": 47
          },
          {
              "line": 605,
              "column": 51
          },
          {
              "line": 605,
              "column": 66
          },
          {
              "line": 609,
              "column": 21
          },
          {
              "line": 609,
              "column": 27
          },
          {
              "line": 609,
              "column": 37
          },
          {
              "line": 609,
              "column": 43
          },
          {
              "line": 611,
              "column": 22
          },
          {
              "line": 611,
              "column": 24
          },
          {
              "line": 611,
              "column": 31
          },
          {
              "line": 611,
              "column": 37
          },
          {
              "line": 611,
              "column": 39
          },
          {
              "line": 613,
              "column": 23
          },
          {
              "line": 613,
              "column": 33
          },
          {
              "line": 613,
              "column": 39
          },
          {
              "line": 613,
              "column": 43
          },
          {
              "line": 613,
              "column": 47
          },
          {
              "line": 613,
              "column": 62
          },
          {
              "line": 616,
              "column": 29
          },
          {
              "line": 616,
              "column": 33
          },
          {
              "line": 616,
              "column": 42
          },
          {
              "line": 617,
              "column": 21
          },
          {
              "line": 617,
              "column": 31
          },
          {
              "line": 622,
              "column": 7
          },
          {
              "line": 622,
              "column": 11
          },
          {
              "line": 622,
              "column": 14
          },
          {
              "line": 622,
              "column": 17
          },
          {
              "line": 622,
              "column": 33
          },
          {
              "line": 622,
              "column": 37
          },
          {
              "line": 623,
              "column": 18
          },
          {
              "line": 623,
              "column": 28
          },
          {
              "line": 623,
              "column": 31
          },
          {
              "line": 623,
              "column": 47
          },
          {
              "line": 624,
              "column": 10
          },
          {
              "line": 624,
              "column": 20
          },
          {
              "line": 624,
              "column": 22
          },
          {
              "line": 624,
              "column": 28
          },
          {
              "line": 624,
              "column": 33
          },
          {
              "line": 625,
              "column": 16
          },
          {
              "line": 625,
              "column": 18
          },
          {
              "line": 625,
              "column": 31
          },
          {
              "line": 625,
              "column": 33
          },
          {
              "line": 626,
              "column": 18
          },
          {
              "line": 626,
              "column": 28
          },
          {
              "line": 626,
              "column": 30
          },
          {
              "line": 626,
              "column": 51
          },
          {
              "line": 626,
              "column": 53
          },
          {
              "line": 627,
              "column": 16
          },
          {
              "line": 627,
              "column": 21
          },
          {
              "line": 627,
              "column": 23
          },
          {
              "line": 627,
              "column": 39
          },
          {
              "line": 628,
              "column": 18
          },
          {
              "line": 628,
              "column": 20
          },
          {
              "line": 628,
              "column": 26
          },
          {
              "line": 628,
              "column": 31
          },
          {
              "line": 628,
              "column": 36
          },
          {
              "line": 628,
              "column": 47
          },
          {
              "line": 628,
              "column": 53
          },
          {
              "line": 629,
              "column": 32
          },
          {
              "line": 629,
              "column": 37
          },
          {
              "line": 629,
              "column": 56
          },
          {
              "line": 629,
              "column": 61
          },
          {
              "line": 629,
              "column": 63
          },
          {
              "line": 629,
              "column": 70
          },
          {
              "line": 631,
              "column": 15
          },
          {
              "line": 633,
              "column": 36
          },
          {
              "line": 633,
              "column": 49
          },
          {
              "line": 633,
              "column": 74
          },
          {
              "line": 635,
              "column": 20
          },
          {
              "line": 635,
              "column": 24
          },
          {
              "line": 635,
              "column": 26
          },
          {
              "line": 635,
              "column": 32
          },
          {
              "line": 635,
              "column": 37
          },
          {
              "line": 636,
              "column": 19
          },
          {
              "line": 636,
              "column": 23
          },
          {
              "line": 636,
              "column": 51
          },
          {
              "line": 636,
              "column": 66
          },
          {
              "line": 638,
              "column": 13
          },
          {
              "line": 638,
              "column": 17
          },
          {
              "line": 641,
              "column": 11
          },
          {
              "line": 641,
              "column": 25
          },
          {
              "line": 641,
              "column": 31
          },
          {
              "line": 641,
              "column": 46
          },
          {
              "line": 644,
              "column": 20
          },
          {
              "line": 644,
              "column": 26
          },
          {
              "line": 644,
              "column": 27
          },
          {
              "line": 646,
              "column": 14
          },
          {
              "line": 646,
              "column": 16
          },
          {
              "line": 646,
              "column": 22
          },
          {
              "line": 646,
              "column": 27
          },
          {
              "line": 646,
              "column": 32
          },
          {
              "line": 646,
              "column": 38
          },
          {
              "line": 646,
              "column": 42
          },
          {
              "line": 647,
              "column": 14
          },
          {
              "line": 647,
              "column": 21
          },
          {
              "line": 647,
              "column": 29
          },
          {
              "line": 648,
              "column": 14
          },
          {
              "line": 648,
              "column": 21
          },
          {
              "line": 648,
              "column": 29
          },
          {
              "line": 652,
              "column": 11
          },
          {
              "line": 652,
              "column": 19
          },
          {
              "line": 652,
              "column": 32
          },
          {
              "line": 652,
              "column": 37
          },
          {
              "line": 652,
              "column": 39
          },
          {
              "line": 652,
              "column": 42
          },
          {
              "line": 653,
              "column": 17
          },
          {
              "line": 653,
              "column": 19
          },
          {
              "line": 653,
              "column": 21
          },
          {
              "line": 653,
              "column": 33
          },
          {
              "line": 653,
              "column": 45
          },
          {
              "line": 653,
              "column": 48
          },
          {
              "line": 653,
              "column": 59
          },
          {
              "line": 654,
              "column": 22
          },
          {
              "line": 654,
              "column": 35
          },
          {
              "line": 654,
              "column": 39
          },
          {
              "line": 654,
              "column": 48
          },
          {
              "line": 654,
              "column": 51
          },
          {
              "line": 654,
              "column": 57
          },
          {
              "line": 654,
              "column": 61
          },
          {
              "line": 655,
              "column": 14
          },
          {
              "line": 655,
              "column": 29
          },
          {
              "line": 655,
              "column": 33
          },
          {
              "line": 655,
              "column": 39
          },
          {
              "line": 655,
              "column": 50
          },
          {
              "line": 658,
              "column": 12
          },
          {
              "line": 658,
              "column": 30
          },
          {
              "line": 658,
              "column": 32
          },
          {
              "line": 658,
              "column": 38
          },
          {
              "line": 658,
              "column": 43
          },
          {
              "line": 659,
              "column": 26
          },
          {
              "line": 659,
              "column": 28
          },
          {
              "line": 659,
              "column": 34
          },
          {
              "line": 659,
              "column": 39
          },
          {
              "line": 661,
              "column": 10
          },
          {
              "line": 661,
              "column": 12
          },
          {
              "line": 661,
              "column": 18
          },
          {
              "line": 661,
              "column": 23
          },
          {
              "line": 661,
              "column": 33
          },
          {
              "line": 662,
              "column": 10
          },
          {
              "line": 662,
              "column": 26
          },
          {
              "line": 662,
              "column": 37
          },
          {
              "line": 663,
              "column": 12
          },
          {
              "line": 663,
              "column": 25
          },
          {
              "line": 663,
              "column": 29
          },
          {
              "line": 663,
              "column": 31
          },
          {
              "line": 663,
              "column": 37
          },
          {
              "line": 663,
              "column": 42
          },
          {
              "line": 663,
              "column": 54
          },
          {
              "line": 666,
              "column": 11
          },
          {
              "line": 666,
              "column": 19
          },
          {
              "line": 666,
              "column": 35
          },
          {
              "line": 666,
              "column": 42
          },
          {
              "line": 666,
              "column": 48
          },
          {
              "line": 667,
              "column": 13
          },
          {
              "line": 667,
              "column": 18
          },
          {
              "line": 667,
              "column": 23
          },
          {
              "line": 667,
              "column": 25
          },
          {
              "line": 667,
              "column": 32
          },
          {
              "line": 668,
              "column": 14
          },
          {
              "line": 668,
              "column": 31
          },
          {
              "line": 668,
              "column": 38
          },
          {
              "line": 668,
              "column": 45
          },
          {
              "line": 668,
              "column": 56
          },
          {
              "line": 672,
              "column": 11
          },
          {
              "line": 672,
              "column": 29
          },
          {
              "line": 672,
              "column": 39
          },
          {
              "line": 672,
              "column": 46
          },
          {
              "line": 672,
              "column": 48
          },
          {
              "line": 672,
              "column": 58
          },
          {
              "line": 672,
              "column": 63
          },
          {
              "line": 673,
              "column": 12
          },
          {
              "line": 673,
              "column": 17
          },
          {
              "line": 674,
              "column": 20
          },
          {
              "line": 674,
              "column": 27
          },
          {
              "line": 674,
              "column": 34
          },
          {
              "line": 674,
              "column": 39
          },
          {
              "line": 675,
              "column": 14
          },
          {
              "line": 675,
              "column": 23
          },
          {
              "line": 678,
              "column": 12
          },
          {
              "line": 678,
              "column": 17
          },
          {
              "line": 679,
              "column": 20
          },
          {
              "line": 679,
              "column": 27
          },
          {
              "line": 679,
              "column": 34
          },
          {
              "line": 679,
              "column": 39
          },
          {
              "line": 680,
              "column": 14
          },
          {
              "line": 680,
              "column": 23
          }
      ],
      "old_name": "e",
      "new_name": "handleAndLocalPath",
      "ctx": {
          "symbolName": "e",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Entry<StateHandleID, StreamStateHandle>",
          "scopeHint": "in testSharedIncrementalStateDeRegistration(...)",
          "filePath": "EmbeddedRocksDBStateBackendTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "ap<StateHandleID, StreamStateHandle> sharedState =\n                            new HashMap<>(stateHandle.getSharedState());\n\n                    stateHandle.registerSharedStates(sharedStateRegistry, checkpointId);\n\n                    for (Map.Entry<StateHandleID, StreamStateHandle> e : sharedState.entrySet()) {\n                        verify(sharedStateRegistry)\n                                .registerReference(\n                                        stateHandle.createSharedStateRegistryKeyFromFileName(\n             ",
          "conflictNames": [
              "backend",
              "kvId",
              "state",
              "previousStateHandles",
              "sharedStateRegistry",
              "checkpointId",
              "snapshot",
              "snapshotResult",
              "stateHandle",
              "sharedState"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6dcb10abf319b9e5494a82bee71f1ae1a4e4b211^1/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBStateDownloader.java",
      "locators": [
          {
              "line": 107,
              "column": 67
          },
          {
              "line": 114,
              "column": 77
          }
      ],
      "old_name": "stateHandleID",
      "new_name": "localPath",
      "ctx": {
          "symbolName": "stateHandleID",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "StateHandleID",
          "scopeHint": "in transferAllStateDataToDirectoryAsync(...)",
          "filePath": "RocksDBStateDownloader.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Asynchronously runs the specified download requests on executorService. */\n    private Stream<CompletableFuture<Void>> transferAllStateDataToDirectoryAsync(\n            Collection<StateHandleDownloadSpec> handleWithPaths,\n            CloseableRegistry closeableRegistry) {\n        return handleWithPaths.stream()\n                .flatMap(\n                        downloadRequest ->\n                                // Take all files from shared and private state.\n                                Streams.concat(\n                                                downloadRequest.getStateHandle().getSharedState()\n                                                        .entrySet().stream(),\n                                                downloadRequest.getStateHandle().getPrivateState()\n                                                        .entrySet().stream())\n                                        .map(\n                                                // Create one runnable for each StreamStateHandle\n                                                entry -> {\n                                                    StateHandleID stateHandleID = entry.getKey();\n                                                    StreamStateHandle remoteFileHandle =\n                                                            entry.getValue();\n                                                    Path downloadDest =\n                                                            downloadRequest\n                                                                    .getDownloadDestination()\n                                                                    .resolve(\n                                                                            stateHandleID\n                                                                                    .toString());\n                                                    return ThrowingRunnable.unchecked(\n                                                            () ->\n                                                                    downloadDataForStateHandle(\n                                                                            downloadDest,\n                                                                            remoteFileHandle,\n                                                                            closeableRegistry));\n                                                }))\n                .map(runnable -> CompletableFuture.runAsync(runnable, executorService));\n    }",
          "conflictNames": [
              "handleWithPaths",
              "closeableRegistry",
              "remoteFileHandle",
              "downloadDest"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6e138f1a4832bd4379fa6289f0445f1ede9b5a54^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/RemoteStorageScanner.java",
      "locators": [
          {
              "line": 2,
              "column": 7
          },
          {
              "line": 2,
              "column": 10
          },
          {
              "line": 2,
              "column": 18
          },
          {
              "line": 2,
              "column": 25
          },
          {
              "line": 2,
              "column": 34
          },
          {
              "line": 2,
              "column": 56
          },
          {
              "line": 2,
              "column": 61
          },
          {
              "line": 3,
              "column": 10
          },
          {
              "line": 3,
              "column": 27
          },
          {
              "line": 3,
              "column": 30
          },
          {
              "line": 3,
              "column": 35
          },
          {
              "line": 3,
              "column": 36
          },
          {
              "line": 3,
              "column": 38
          },
          {
              "line": 3,
              "column": 46
          },
          {
              "line": 3,
              "column": 47
          },
          {
              "line": 3,
              "column": 51
          },
          {
              "line": 3,
              "column": 63
          },
          {
              "line": 4,
              "column": 13
          },
          {
              "line": 5,
              "column": 5
          },
          {
              "line": 5,
              "column": 27
          },
          {
              "line": 5,
              "column": 38
          },
          {
              "line": 5,
              "column": 47
          },
          {
              "line": 5,
              "column": 50
          },
          {
              "line": 5,
              "column": 61
          },
          {
              "line": 6,
              "column": 14
          },
          {
              "line": 6,
              "column": 19
          },
          {
              "line": 6,
              "column": 26
          },
          {
              "line": 6,
              "column": 31
          },
          {
              "line": 6,
              "column": 34
          },
          {
              "line": 6,
              "column": 38
          },
          {
              "line": 6,
              "column": 52
          },
          {
              "line": 7,
              "column": 8
          },
          {
              "line": 7,
              "column": 11
          },
          {
              "line": 7,
              "column": 30
          },
          {
              "line": 7,
              "column": 40
          },
          {
              "line": 7,
              "column": 42
          },
          {
              "line": 7,
              "column": 45
          },
          {
              "line": 7,
              "column": 61
          },
          {
              "line": 8,
              "column": 11
          },
          {
              "line": 8,
              "column": 16
          },
          {
              "line": 8,
              "column": 19
          },
          {
              "line": 8,
              "column": 50
          },
          {
              "line": 8,
              "column": 55
          },
          {
              "line": 8,
              "column": 58
          },
          {
              "line": 10,
              "column": 24
          },
          {
              "line": 10,
              "column": 33
          },
          {
              "line": 10,
              "column": 36
          },
          {
              "line": 12,
              "column": 7
          },
          {
              "line": 12,
              "column": 12
          },
          {
              "line": 12,
              "column": 17
          },
          {
              "line": 12,
              "column": 32
          },
          {
              "line": 12,
              "column": 44
          },
          {
              "line": 12,
              "column": 45
          },
          {
              "line": 12,
              "column": 70
          },
          {
              "line": 13,
              "column": 13
          },
          {
              "line": 13,
              "column": 19
          },
          {
              "line": 13,
              "column": 24
          },
          {
              "line": 13,
              "column": 29
          },
          {
              "line": 13,
              "column": 32
          },
          {
              "line": 13,
              "column": 46
          },
          {
              "line": 14,
              "column": 50
          },
          {
              "line": 14,
              "column": 54
          },
          {
              "line": 14,
              "column": 57
          },
          {
              "line": 14,
              "column": 61
          },
          {
              "line": 14,
              "column": 73
          },
          {
              "line": 15,
              "column": 5
          },
          {
              "line": 15,
              "column": 6
          },
          {
              "line": 15,
              "column": 10
          },
          {
              "line": 15,
              "column": 15
          },
          {
              "line": 15,
              "column": 18
          },
          {
              "line": 15,
              "column": 26
          },
          {
              "line": 15,
              "column": 30
          },
          {
              "line": 15,
              "column": 44
          },
          {
              "line": 15,
              "column": 49
          },
          {
              "line": 15,
              "column": 57
          },
          {
              "line": 16,
              "column": 19
          },
          {
              "line": 16,
              "column": 24
          },
          {
              "line": 16,
              "column": 29
          },
          {
              "line": 16,
              "column": 32
          },
          {
              "line": 19,
              "column": 7
          },
          {
              "line": 19,
              "column": 18
          },
          {
              "line": 19,
              "column": 32
          },
          {
              "line": 19,
              "column": 38
          },
          {
              "line": 19,
              "column": 64
          },
          {
              "line": 19,
              "column": 66
          },
          {
              "line": 19,
              "column": 71
          },
          {
              "line": 19,
              "column": 75
          },
          {
              "line": 19,
              "column": 79
          },
          {
              "line": 21,
              "column": 17
          },
          {
              "line": 21,
              "column": 38
          },
          {
              "line": 21,
              "column": 44
          },
          {
              "line": 22,
              "column": 17
          },
          {
              "line": 22,
              "column": 28
          },
          {
              "line": 22,
              "column": 36
          },
          {
              "line": 23,
              "column": 17
          },
          {
              "line": 23,
              "column": 28
          },
          {
              "line": 23,
              "column": 36
          },
          {
              "line": 23,
              "column": 41
          },
          {
              "line": 24,
              "column": 17
          },
          {
              "line": 24,
              "column": 28
          },
          {
              "line": 25,
              "column": 17
          },
          {
              "line": 25,
              "column": 31
          },
          {
              "line": 25,
              "column": 37
          },
          {
              "line": 25,
              "column": 63
          },
          {
              "line": 25,
              "column": 65
          },
          {
              "line": 25,
              "column": 77
          },
          {
              "line": 25,
              "column": 79
          },
          {
              "line": 25,
              "column": 87
          },
          {
              "line": 26,
              "column": 17
          },
          {
              "line": 26,
              "column": 31
          },
          {
              "line": 26,
              "column": 37
          },
          {
              "line": 26,
              "column": 63
          },
          {
              "line": 26,
              "column": 65
          },
          {
              "line": 26,
              "column": 77
          },
          {
              "line": 26,
              "column": 79
          },
          {
              "line": 26,
              "column": 87
          },
          {
              "line": 27,
              "column": 17
          },
          {
              "line": 27,
              "column": 31
          },
          {
              "line": 27,
              "column": 37
          },
          {
              "line": 27,
              "column": 63
          },
          {
              "line": 27,
              "column": 65
          },
          {
              "line": 27,
              "column": 74
          },
          {
              "line": 27,
              "column": 94
          },
          {
              "line": 28,
              "column": 17
          },
          {
              "line": 28,
              "column": 33
          },
          {
              "line": 29,
              "column": 17
          },
          {
              "line": 29,
              "column": 42
          },
          {
              "line": 29,
              "column": 53
          },
          {
              "line": 30,
              "column": 17
          },
          {
              "line": 30,
              "column": 37
          },
          {
              "line": 30,
              "column": 43
          },
          {
              "line": 30,
              "column": 52
          },
          {
              "line": 32,
              "column": 32
          },
          {
              "line": 34,
              "column": 21
          },
          {
              "line": 35,
              "column": 20
          },
          {
              "line": 37,
              "column": 25
          },
          {
              "line": 37,
              "column": 36
          },
          {
              "line": 38,
              "column": 25
          },
          {
              "line": 38,
              "column": 31
          },
          {
              "line": 39,
              "column": 25
          },
          {
              "line": 39,
              "column": 32
          },
          {
              "line": 39,
              "column": 36
          },
          {
              "line": 39,
              "column": 40
          },
          {
              "line": 39,
              "column": 47
          },
          {
              "line": 39,
              "column": 52
          },
          {
              "line": 40,
              "column": 25
          },
          {
              "line": 40,
              "column": 32
          },
          {
              "line": 42,
              "column": 24
          },
          {
              "line": 42,
              "column": 38
          },
          {
              "line": 42,
              "column": 44
          },
          {
              "line": 42,
              "column": 70
          },
          {
              "line": 42,
              "column": 72
          },
          {
              "line": 42,
              "column": 78
          },
          {
              "line": 42,
              "column": 81
          },
          {
              "line": 42,
              "column": 84
          },
          {
              "line": 42,
              "column": 99
          },
          {
              "line": 42,
              "column": 102
          },
          {
              "line": 42,
              "column": 105
          },
          {
              "line": 42,
              "column": 108
          },
          {
              "line": 43,
              "column": 24
          },
          {
              "line": 43,
              "column": 38
          },
          {
              "line": 43,
              "column": 44
          },
          {
              "line": 43,
              "column": 70
          },
          {
              "line": 43,
              "column": 72
          },
          {
              "line": 43,
              "column": 78
          },
          {
              "line": 43,
              "column": 81
          },
          {
              "line": 43,
              "column": 84
          },
          {
              "line": 43,
              "column": 99
          },
          {
              "line": 43,
              "column": 102
          },
          {
              "line": 43,
              "column": 105
          },
          {
              "line": 43,
              "column": 108
          },
          {
              "line": 44,
              "column": 24
          },
          {
              "line": 44,
              "column": 39
          },
          {
              "line": 44,
              "column": 53
          },
          {
              "line": 44,
              "column": 61
          },
          {
              "line": 45,
              "column": 24
          },
          {
              "line": 45,
              "column": 39
          },
          {
              "line": 45,
              "column": 53
          },
          {
              "line": 46,
              "column": 24
          },
          {
              "line": 46,
              "column": 39
          },
          {
              "line": 46,
              "column": 53
          },
          {
              "line": 46,
              "column": 60
          },
          {
              "line": 49,
              "column": 6
          },
          {
              "line": 49,
              "column": 16
          },
          {
              "line": 49,
              "column": 20
          },
          {
              "line": 49,
              "column": 27
          },
          {
              "line": 49,
              "column": 33
          },
          {
              "line": 49,
              "column": 48
          },
          {
              "line": 49,
              "column": 83
          },
          {
              "line": 49,
              "column": 86
          },
          {
              "line": 50,
              "column": 5
          },
          {
              "line": 50,
              "column": 9
          },
          {
              "line": 50,
              "column": 17
          },
          {
              "line": 50,
              "column": 54
          },
          {
              "line": 50,
              "column": 56
          },
          {
              "line": 50,
              "column": 68
          },
          {
              "line": 50,
              "column": 72
          },
          {
              "line": 50,
              "column": 75
          },
          {
              "line": 50,
              "column": 83
          },
          {
              "line": 50,
              "column": 87
          },
          {
              "line": 51,
              "column": 5
          },
          {
              "line": 51,
              "column": 7
          },
          {
              "line": 51,
              "column": 10
          },
          {
              "line": 51,
              "column": 18
          },
          {
              "line": 51,
              "column": 30
          },
          {
              "line": 51,
              "column": 35
          },
          {
              "line": 51,
              "column": 39
          },
          {
              "line": 51,
              "column": 44
          },
          {
              "line": 51,
              "column": 52
          },
          {
              "line": 51,
              "column": 56
          },
          {
              "line": 53,
              "column": 16
          },
          {
              "line": 53,
              "column": 23
          },
          {
              "line": 53,
              "column": 37
          },
          {
              "line": 53,
              "column": 41
          },
          {
              "line": 53,
              "column": 44
          },
          {
              "line": 53,
              "column": 52
          },
          {
              "line": 53,
              "column": 56
          },
          {
              "line": 53,
              "column": 72
          },
          {
              "line": 53,
              "column": 75
          },
          {
              "line": 53,
              "column": 80
          },
          {
              "line": 53,
              "column": 84
          },
          {
              "line": 53,
              "column": 87
          },
          {
              "line": 54,
              "column": 6
          },
          {
              "line": 54,
              "column": 8
          },
          {
              "line": 54,
              "column": 13
          },
          {
              "line": 54,
              "column": 16
          },
          {
              "line": 54,
              "column": 30
          },
          {
              "line": 54,
              "column": 33
          },
          {
              "line": 54,
              "column": 36
          },
          {
              "line": 54,
              "column": 47
          },
          {
              "line": 54,
              "column": 50
          },
          {
              "line": 54,
              "column": 53
          },
          {
              "line": 54,
              "column": 60
          },
          {
              "line": 54,
              "column": 89
          },
          {
              "line": 55,
              "column": 21
          },
          {
              "line": 55,
              "column": 24
          },
          {
              "line": 55,
              "column": 31
          },
          {
              "line": 57,
              "column": 15
          },
          {
              "line": 57,
              "column": 19
          },
          {
              "line": 57,
              "column": 26
          },
          {
              "line": 57,
              "column": 32
          },
          {
              "line": 57,
              "column": 39
          },
          {
              "line": 57,
              "column": 41
          },
          {
              "line": 57,
              "column": 53
          },
          {
              "line": 59,
              "column": 11
          },
          {
              "line": 59,
              "column": 29
          },
          {
              "line": 60,
              "column": 11
          },
          {
              "line": 62,
              "column": 11
          },
          {
              "line": 62,
              "column": 25
          },
          {
              "line": 63,
              "column": 11
          },
          {
              "line": 65,
              "column": 11
          },
          {
              "line": 65,
              "column": 28
          },
          {
              "line": 65,
              "column": 30
          },
          {
              "line": 65,
              "column": 35
          },
          {
              "line": 65,
              "column": 38
          },
          {
              "line": 65,
              "column": 51
          },
          {
              "line": 65,
              "column": 54
          },
          {
              "line": 65,
              "column": 61
          },
          {
              "line": 65,
              "column": 68
          },
          {
              "line": 65,
              "column": 72
          },
          {
              "line": 65,
              "column": 80
          },
          {
              "line": 66,
              "column": 11
          },
          {
              "line": 66,
              "column": 22
          },
          {
              "line": 66,
              "column": 26
          },
          {
              "line": 66,
              "column": 30
          },
          {
              "line": 66,
              "column": 37
          },
          {
              "line": 66,
              "column": 42
          },
          {
              "line": 66,
              "column": 49
          },
          {
              "line": 66,
              "column": 53
          },
          {
              "line": 67,
              "column": 15
          },
          {
              "line": 67,
              "column": 24
          },
          {
              "line": 67,
              "column": 29
          },
          {
              "line": 67,
              "column": 33
          },
          {
              "line": 67,
              "column": 38
          },
          {
              "line": 68,
              "column": 25
          },
          {
              "line": 68,
              "column": 30
          },
          {
              "line": 68,
              "column": 39
          },
          {
              "line": 68,
              "column": 52
          },
          {
              "line": 68,
              "column": 56
          },
          {
              "line": 68,
              "column": 64
          },
          {
              "line": 68,
              "column": 71
          },
          {
              "line": 70,
              "column": 11
          },
          {
              "line": 70,
              "column": 14
          },
          {
              "line": 70,
              "column": 56
          },
          {
              "line": 70,
              "column": 62
          },
          {
              "line": 70,
              "column": 68
          },
          {
              "line": 70,
              "column": 73
          },
          {
              "line": 70,
              "column": 77
          },
          {
              "line": 70,
              "column": 80
          },
          {
              "line": 71,
              "column": 11
          },
          {
              "line": 71,
              "column": 27
          },
          {
              "line": 71,
              "column": 32
          },
          {
              "line": 71,
              "column": 34
          },
          {
              "line": 71,
              "column": 42
          },
          {
              "line": 71,
              "column": 58
          },
          {
              "line": 71,
              "column": 60
          },
          {
              "line": 71,
              "column": 68
          },
          {
              "line": 71,
              "column": 89
          },
          {
              "line": 71,
              "column": 91
          },
          {
              "line": 72,
              "column": 14
          },
          {
              "line": 72,
              "column": 19
          },
          {
              "line": 72,
              "column": 22
          },
          {
              "line": 72,
              "column": 25
          },
          {
              "line": 75,
              "column": 10
          },
          {
              "line": 75,
              "column": 13
          },
          {
              "line": 75,
              "column": 55
          },
          {
              "line": 75,
              "column": 61
          },
          {
              "line": 75,
              "column": 81
          },
          {
              "line": 75,
              "column": 85
          },
          {
              "line": 75,
              "column": 88
          },
          {
              "line": 75,
              "column": 95
          },
          {
              "line": 76,
              "column": 10
          },
          {
              "line": 78,
              "column": 11
          },
          {
              "line": 78,
              "column": 27
          },
          {
              "line": 78,
              "column": 32
          },
          {
              "line": 78,
              "column": 34
          },
          {
              "line": 78,
              "column": 42
          },
          {
              "line": 78,
              "column": 58
          },
          {
              "line": 78,
              "column": 60
          },
          {
              "line": 78,
              "column": 68
          },
          {
              "line": 78,
              "column": 89
          },
          {
              "line": 78,
              "column": 91
          },
          {
              "line": 79,
              "column": 18
          },
          {
              "line": 79,
              "column": 24
          },
          {
              "line": 79,
              "column": 27
          },
          {
              "line": 81,
              "column": 11
          },
          {
              "line": 81,
              "column": 29
          },
          {
              "line": 81,
              "column": 31
          },
          {
              "line": 81,
              "column": 35
          },
          {
              "line": 81,
              "column": 42
          },
          {
              "line": 83,
              "column": 11
          },
          {
              "line": 83,
              "column": 28
          },
          {
              "line": 83,
              "column": 41
          },
          {
              "line": 85,
              "column": 11
          },
          {
              "line": 85,
              "column": 22
          },
          {
              "line": 85,
              "column": 27
          },
          {
              "line": 85,
              "column": 31
          },
          {
              "line": 85,
              "column": 35
          },
          {
              "line": 85,
              "column": 39
          },
          {
              "line": 85,
              "column": 44
          },
          {
              "line": 87,
              "column": 13
          },
          {
              "line": 87,
              "column": 21
          },
          {
              "line": 87,
              "column": 41
          },
          {
              "line": 87,
              "column": 50
          },
          {
              "line": 89,
              "column": 11
          },
          {
              "line": 89,
              "column": 24
          },
          {
              "line": 91,
              "column": 13
          },
          {
              "line": 91,
              "column": 17
          },
          {
              "line": 91,
              "column": 24
          },
          {
              "line": 91,
              "column": 30
          },
          {
              "line": 91,
              "column": 43
          },
          {
              "line": 91,
              "column": 45
          },
          {
              "line": 91,
              "column": 49
          },
          {
              "line": 91,
              "column": 56
          },
          {
              "line": 92,
              "column": 17
          },
          {
              "line": 92,
              "column": 19
          },
          {
              "line": 92,
              "column": 23
          },
          {
              "line": 92,
              "column": 30
          },
          {
              "line": 92,
              "column": 41
          },
          {
              "line": 92,
              "column": 43
          },
          {
              "line": 92,
              "column": 47
          },
          {
              "line": 92,
              "column": 54
          },
          {
              "line": 93,
              "column": 15
          },
          {
              "line": 93,
              "column": 20
          },
          {
              "line": 93,
              "column": 23
          },
          {
              "line": 93,
              "column": 26
          },
          {
              "line": 93,
              "column": 36
          },
          {
              "line": 93,
              "column": 46
          },
          {
              "line": 94,
              "column": 19
          },
          {
              "line": 94,
              "column": 25
          },
          {
              "line": 94,
              "column": 28
          },
          {
              "line": 94,
              "column": 38
          },
          {
              "line": 94,
              "column": 48
          },
          {
              "line": 95,
              "column": 23
          },
          {
              "line": 95,
              "column": 30
          },
          {
              "line": 95,
              "column": 42
          },
          {
              "line": 96,
              "column": 15
          },
          {
              "line": 96,
              "column": 19
          },
          {
              "line": 96,
              "column": 23
          },
          {
              "line": 96,
              "column": 28
          },
          {
              "line": 96,
              "column": 35
          },
          {
              "line": 96,
              "column": 38
          },
          {
              "line": 96,
              "column": 42
          },
          {
              "line": 96,
              "column": 47
          },
          {
              "line": 99,
              "column": 11
          },
          {
              "line": 99,
              "column": 16
          },
          {
              "line": 99,
              "column": 21
          },
          {
              "line": 99,
              "column": 26
          },
          {
              "line": 99,
              "column": 29
          },
          {
              "line": 99,
              "column": 33
          },
          {
              "line": 99,
              "column": 38
          },
          {
              "line": 100,
              "column": 12
          },
          {
              "line": 100,
              "column": 17
          },
          {
              "line": 100,
              "column": 23
          },
          {
              "line": 100,
              "column": 28
          },
          {
              "line": 102,
              "column": 16
          },
          {
              "line": 102,
              "column": 21
          },
          {
              "line": 102,
              "column": 27
          },
          {
              "line": 102,
              "column": 38
          },
          {
              "line": 102,
              "column": 40
          },
          {
              "line": 102,
              "column": 44
          },
          {
              "line": 102,
              "column": 51
          },
          {
              "line": 102,
              "column": 59
          },
          {
              "line": 102,
              "column": 64
          },
          {
              "line": 102,
              "column": 69
          },
          {
              "line": 103,
              "column": 23
          },
          {
              "line": 103,
              "column": 30
          },
          {
              "line": 104,
              "column": 16
          },
          {
              "line": 104,
              "column": 29
          },
          {
              "line": 105,
              "column": 21
          },
          {
              "line": 105,
              "column": 29
          },
          {
              "line": 105,
              "column": 44
          },
          {
              "line": 105,
              "column": 49
          },
          {
              "line": 105,
              "column": 55
          },
          {
              "line": 105,
              "column": 63
          },
          {
              "line": 105,
              "column": 78
          },
          {
              "line": 105,
              "column": 80
          },
          {
              "line": 105,
              "column": 84
          },
          {
              "line": 105,
              "column": 91
          },
          {
              "line": 107,
              "column": 10
          },
          {
              "line": 107,
              "column": 19
          },
          {
              "line": 107,
              "column": 24
          },
          {
              "line": 110,
              "column": 17
          },
          {
              "line": 110,
              "column": 19
          },
          {
              "line": 110,
              "column": 21
          },
          {
              "line": 112,
              "column": 14
          },
          {
              "line": 112,
              "column": 18
          },
          {
              "line": 112,
              "column": 28
          },
          {
              "line": 112,
              "column": 32
          },
          {
              "line": 112,
              "column": 47
          },
          {
              "line": 112,
              "column": 57
          },
          {
              "line": 116,
              "column": 16
          },
          {
              "line": 116,
              "column": 19
          },
          {
              "line": 116,
              "column": 22
          },
          {
              "line": 116,
              "column": 34
          },
          {
              "line": 116,
              "column": 59
          },
          {
              "line": 116,
              "column": 69
          },
          {
              "line": 116,
              "column": 73
          },
          {
              "line": 116,
              "column": 80
          },
          {
              "line": 116,
              "column": 86
          },
          {
              "line": 118,
              "column": 17
          },
          {
              "line": 118,
              "column": 20
          },
          {
              "line": 118,
              "column": 35
          },
          {
              "line": 118,
              "column": 41
          },
          {
              "line": 118,
              "column": 53
          },
          {
              "line": 118,
              "column": 58
          },
          {
              "line": 118,
              "column": 68
          },
          {
              "line": 118,
              "column": 74
          },
          {
              "line": 118,
              "column": 79
          },
          {
              "line": 118,
              "column": 82
          },
          {
              "line": 118,
              "column": 93
          },
          {
              "line": 119,
              "column": 13
          },
          {
              "line": 121,
              "column": 17
          },
          {
              "line": 121,
              "column": 20
          },
          {
              "line": 121,
              "column": 36
          },
          {
              "line": 121,
              "column": 40
          },
          {
              "line": 121,
              "column": 43
          },
          {
              "line": 121,
              "column": 60
          },
          {
              "line": 121,
              "column": 70
          },
          {
              "line": 121,
              "column": 76
          },
          {
              "line": 121,
              "column": 82
          },
          {
              "line": 121,
              "column": 87
          },
          {
              "line": 121,
              "column": 90
          },
          {
              "line": 122,
              "column": 9
          },
          {
              "line": 122,
              "column": 14
          },
          {
              "line": 122,
              "column": 20
          },
          {
              "line": 122,
              "column": 25
          },
          {
              "line": 122,
              "column": 29
          },
          {
              "line": 122,
              "column": 36
          },
          {
              "line": 122,
              "column": 40
          },
          {
              "line": 122,
              "column": 43
          },
          {
              "line": 122,
              "column": 57
          },
          {
              "line": 122,
              "column": 60
          },
          {
              "line": 122,
              "column": 61
          },
          {
              "line": 122,
              "column": 70
          },
          {
              "line": 122,
              "column": 80
          },
          {
              "line": 122,
              "column": 86
          },
          {
              "line": 122,
              "column": 91
          },
          {
              "line": 123,
              "column": 15
          },
          {
              "line": 123,
              "column": 18
          },
          {
              "line": 123,
              "column": 21
          },
          {
              "line": 123,
              "column": 28
          },
          {
              "line": 123,
              "column": 35
          },
          {
              "line": 123,
              "column": 42
          },
          {
              "line": 123,
              "column": 49
          },
          {
              "line": 125,
              "column": 32
          },
          {
              "line": 126,
              "column": 35
          },
          {
              "line": 127,
              "column": 16
          },
          {
              "line": 127,
              "column": 19
          },
          {
              "line": 127,
              "column": 30
          },
          {
              "line": 127,
              "column": 39
          },
          {
              "line": 127,
              "column": 42
          },
          {
              "line": 129,
              "column": 23
          },
          {
              "line": 129,
              "column": 26
          },
          {
              "line": 130,
              "column": 15
          },
          {
              "line": 130,
              "column": 17
          },
          {
              "line": 130,
              "column": 25
          },
          {
              "line": 131,
              "column": 15
          },
          {
              "line": 131,
              "column": 17
          },
          {
              "line": 131,
              "column": 25
          },
          {
              "line": 132,
              "column": 18
          },
          {
              "line": 132,
              "column": 21
          },
          {
              "line": 133,
              "column": 13
          },
          {
              "line": 133,
              "column": 18
          },
          {
              "line": 133,
              "column": 20
          },
          {
              "line": 133,
              "column": 28
          },
          {
              "line": 133,
              "column": 44
          },
          {
              "line": 133,
              "column": 46
          },
          {
              "line": 133,
              "column": 54
          },
          {
              "line": 133,
              "column": 72
          },
          {
              "line": 134,
              "column": 21
          },
          {
              "line": 135,
              "column": 14
          },
          {
              "line": 135,
              "column": 20
          },
          {
              "line": 135,
              "column": 23
          },
          {
              "line": 135,
              "column": 36
          },
          {
              "line": 136,
              "column": 18
          },
          {
              "line": 137,
              "column": 19
          },
          {
              "line": 137,
              "column": 22
          },
          {
              "line": 137,
              "column": 26
          },
          {
              "line": 137,
              "column": 34
          },
          {
              "line": 137,
              "column": 37
          },
          {
              "line": 138,
              "column": 29
          },
          {
              "line": 138,
              "column": 32
          },
          {
              "line": 138,
              "column": 53
          },
          {
              "line": 138,
              "column": 56
          },
          {
              "line": 138,
              "column": 65
          },
          {
              "line": 138,
              "column": 68
          },
          {
              "line": 139,
              "column": 26
          },
          {
              "line": 139,
              "column": 31
          },
          {
              "line": 139,
              "column": 34
          },
          {
              "line": 139,
              "column": 37
          },
          {
              "line": 139,
              "column": 49
          },
          {
              "line": 139,
              "column": 52
          },
          {
              "line": 139,
              "column": 56
          },
          {
              "line": 139,
              "column": 61
          },
          {
              "line": 139,
              "column": 64
          },
          {
              "line": 141,
              "column": 22
          },
          {
              "line": 141,
              "column": 32
          },
          {
              "line": 141,
              "column": 35
          },
          {
              "line": 145,
              "column": 13
          },
          {
              "line": 145,
              "column": 17
          },
          {
              "line": 145,
              "column": 19
          },
          {
              "line": 145,
              "column": 21
          },
          {
              "line": 146,
              "column": 21
          },
          {
              "line": 147,
              "column": 14
          },
          {
              "line": 147,
              "column": 18
          },
          {
              "line": 150,
              "column": 11
          },
          {
              "line": 150,
              "column": 15
          },
          {
              "line": 150,
              "column": 19
          },
          {
              "line": 150,
              "column": 26
          },
          {
              "line": 150,
              "column": 30
          },
          {
              "line": 150,
              "column": 33
          },
          {
              "line": 150,
              "column": 47
          },
          {
              "line": 150,
              "column": 52
          },
          {
              "line": 150,
              "column": 56
          },
          {
              "line": 150,
              "column": 62
          },
          {
              "line": 151,
              "column": 8
          },
          {
              "line": 151,
              "column": 13
          },
          {
              "line": 154,
              "column": 15
          },
          {
              "line": 156,
              "column": 41
          },
          {
              "line": 156,
              "column": 46
          },
          {
              "line": 156,
              "column": 48
          },
          {
              "line": 156,
              "column": 56
          },
          {
              "line": 156,
              "column": 72
          },
          {
              "line": 156,
              "column": 74
          },
          {
              "line": 156,
              "column": 82
          },
          {
              "line": 157,
              "column": 40
          },
          {
              "line": 157,
              "column": 42
          },
          {
              "line": 158,
              "column": 23
          },
          {
              "line": 158,
              "column": 33
          },
          {
              "line": 158,
              "column": 38
          },
          {
              "line": 158,
              "column": 41
          },
          {
              "line": 158,
              "column": 44
          },
          {
              "line": 158,
              "column": 51
          },
          {
              "line": 158,
              "column": 57
          },
          {
              "line": 158,
              "column": 64
          },
          {
              "line": 159,
              "column": 17
          },
          {
              "line": 159,
              "column": 26
          },
          {
              "line": 159,
              "column": 35
          },
          {
              "line": 160,
              "column": 17
          },
          {
              "line": 160,
              "column": 22
          },
          {
              "line": 160,
              "column": 33
          },
          {
              "line": 161,
              "column": 31
          },
          {
              "line": 161,
              "column": 36
          },
          {
              "line": 161,
              "column": 38
          },
          {
              "line": 161,
              "column": 46
          },
          {
              "line": 161,
              "column": 62
          },
          {
              "line": 161,
              "column": 64
          },
          {
              "line": 161,
              "column": 72
          },
          {
              "line": 161,
              "column": 93
          },
          {
              "line": 161,
              "column": 95
          },
          {
              "line": 162,
              "column": 33
          },
          {
              "line": 162,
              "column": 41
          },
          {
              "line": 163,
              "column": 19
          },
          {
              "line": 163,
              "column": 21
          },
          {
              "line": 163,
              "column": 29
          },
          {
              "line": 163,
              "column": 61
          },
          {
              "line": 163,
              "column": 64
          },
          {
              "line": 164,
              "column": 19
          },
          {
              "line": 164,
              "column": 21
          },
          {
              "line": 164,
              "column": 29
          },
          {
              "line": 164,
              "column": 67
          },
          {
              "line": 164,
              "column": 70
          },
          {
              "line": 165,
              "column": 22
          },
          {
              "line": 165,
              "column": 27
          },
          {
              "line": 165,
              "column": 30
          },
          {
              "line": 165,
              "column": 33
          },
          {
              "line": 165,
              "column": 46
          },
          {
              "line": 165,
              "column": 52
          },
          {
              "line": 166,
              "column": 25
          },
          {
              "line": 166,
              "column": 28
          },
          {
              "line": 166,
              "column": 41
          },
          {
              "line": 166,
              "column": 47
          },
          {
              "line": 166,
              "column": 50
          },
          {
              "line": 166,
              "column": 58
          },
          {
              "line": 166,
              "column": 63
          },
          {
              "line": 166,
              "column": 75
          },
          {
              "line": 166,
              "column": 78
          },
          {
              "line": 167,
              "column": 25
          },
          {
              "line": 167,
              "column": 28
          },
          {
              "line": 167,
              "column": 38
          },
          {
              "line": 167,
              "column": 43
          },
          {
              "line": 167,
              "column": 46
          },
          {
              "line": 167,
              "column": 49
          },
          {
              "line": 168,
              "column": 30
          },
          {
              "line": 168,
              "column": 34
          },
          {
              "line": 168,
              "column": 37
          },
          {
              "line": 168,
              "column": 76
          },
          {
              "line": 168,
              "column": 81
          },
          {
              "line": 168,
              "column": 84
          },
          {
              "line": 168,
              "column": 87
          },
          {
              "line": 169,
              "column": 26
          },
          {
              "line": 169,
              "column": 34
          },
          {
              "line": 170,
              "column": 23
          },
          {
              "line": 170,
              "column": 31
          },
          {
              "line": 170,
              "column": 35
          },
          {
              "line": 171,
              "column": 23
          },
          {
              "line": 171,
              "column": 40
          },
          {
              "line": 171,
              "column": 58
          },
          {
              "line": 172,
              "column": 19
          },
          {
              "line": 172,
              "column": 22
          },
          {
              "line": 173,
              "column": 26
          },
          {
              "line": 173,
              "column": 29
          },
          {
              "line": 173,
              "column": 32
          },
          {
              "line": 173,
              "column": 44
          },
          {
              "line": 173,
              "column": 51
          },
          {
              "line": 173,
              "column": 61
          },
          {
              "line": 173,
              "column": 66
          },
          {
              "line": 174,
              "column": 29
          },
          {
              "line": 174,
              "column": 32
          },
          {
              "line": 174,
              "column": 35
          },
          {
              "line": 174,
              "column": 40
          },
          {
              "line": 174,
              "column": 53
          },
          {
              "line": 174,
              "column": 58
          },
          {
              "line": 174,
              "column": 71
          },
          {
              "line": 174,
              "column": 72
          },
          {
              "line": 174,
              "column": 81
          },
          {
              "line": 174,
              "column": 87
          },
          {
              "line": 174,
              "column": 90
          },
          {
              "line": 174,
              "column": 93
          },
          {
              "line": 175,
              "column": 25
          },
          {
              "line": 175,
              "column": 28
          },
          {
              "line": 175,
              "column": 33
          },
          {
              "line": 175,
              "column": 40
          },
          {
              "line": 175,
              "column": 50
          },
          {
              "line": 175,
              "column": 54
          },
          {
              "line": 175,
              "column": 57
          },
          {
              "line": 175,
              "column": 70
          },
          {
              "line": 175,
              "column": 74
          },
          {
              "line": 175,
              "column": 77
          },
          {
              "line": 176,
              "column": 24
          },
          {
              "line": 176,
              "column": 29
          },
          {
              "line": 176,
              "column": 37
          },
          {
              "line": 176,
              "column": 40
          },
          {
              "line": 176,
              "column": 51
          },
          {
              "line": 176,
              "column": 59
          },
          {
              "line": 176,
              "column": 62
          },
          {
              "line": 177,
              "column": 29
          },
          {
              "line": 177,
              "column": 32
          },
          {
              "line": 180,
              "column": 20
          },
          {
              "line": 181,
              "column": 26
          },
          {
              "line": 181,
              "column": 67
          },
          {
              "line": 181,
              "column": 72
          },
          {
              "line": 181,
              "column": 77
          },
          {
              "line": 181,
              "column": 90
          },
          {
              "line": 183,
              "column": 26
          },
          {
              "line": 183,
              "column": 36
          },
          {
              "line": 184,
              "column": 21
          },
          {
              "line": 184,
              "column": 26
          },
          {
              "line": 184,
              "column": 29
          },
          {
              "line": 184,
              "column": 32
          },
          {
              "line": 184,
              "column": 35
          },
          {
              "line": 184,
              "column": 38
          },
          {
              "line": 184,
              "column": 55
          },
          {
              "line": 184,
              "column": 60
          },
          {
              "line": 184,
              "column": 71
          },
          {
              "line": 185,
              "column": 20
          },
          {
              "line": 185,
              "column": 30
          },
          {
              "line": 185,
              "column": 34
          },
          {
              "line": 185,
              "column": 38
          },
          {
              "line": 185,
              "column": 45
          },
          {
              "line": 185,
              "column": 50
          },
          {
              "line": 186,
              "column": 25
          },
          {
              "line": 186,
              "column": 36
          },
          {
              "line": 186,
              "column": 59
          },
          {
              "line": 186,
              "column": 69
          },
          {
              "line": 186,
              "column": 77
          },
          {
              "line": 186,
              "column": 83
          },
          {
              "line": 186,
              "column": 98
          },
          {
              "line": 190,
              "column": 18
          },
          {
              "line": 190,
              "column": 23
          },
          {
              "line": 190,
              "column": 54
          },
          {
              "line": 190,
              "column": 75
          },
          {
              "line": 190,
              "column": 79
          },
          {
              "line": 190,
              "column": 83
          },
          {
              "line": 190,
              "column": 85
          },
          {
              "line": 191,
              "column": 20
          },
          {
              "line": 191,
              "column": 26
          },
          {
              "line": 191,
              "column": 30
          },
          {
              "line": 191,
              "column": 32
          },
          {
              "line": 195,
              "column": 12
          },
          {
              "line": 195,
              "column": 19
          },
          {
              "line": 199,
              "column": 15
          },
          {
              "line": 199,
              "column": 22
          },
          {
              "line": 199,
              "column": 25
          },
          {
              "line": 199,
              "column": 36
          },
          {
              "line": 199,
              "column": 39
          },
          {
              "line": 199,
              "column": 46
          },
          {
              "line": 199,
              "column": 55
          },
          {
              "line": 199,
              "column": 59
          },
          {
              "line": 199,
              "column": 96
          },
          {
              "line": 200,
              "column": 9
          },
          {
              "line": 200,
              "column": 12
          },
          {
              "line": 200,
              "column": 24
          },
          {
              "line": 200,
              "column": 32
          },
          {
              "line": 200,
              "column": 45
          },
          {
              "line": 200,
              "column": 50
          },
          {
              "line": 200,
              "column": 61
          },
          {
              "line": 200,
              "column": 64
          },
          {
              "line": 202,
              "column": 29
          },
          {
              "line": 203,
              "column": 32
          },
          {
              "line": 205,
              "column": 11
          },
          {
              "line": 205,
              "column": 26
          },
          {
              "line": 205,
              "column": 29
          },
          {
              "line": 206,
              "column": 15
          },
          {
              "line": 206,
              "column": 17
          },
          {
              "line": 206,
              "column": 25
          },
          {
              "line": 206,
              "column": 53
          },
          {
              "line": 206,
              "column": 55
          },
          {
              "line": 206,
              "column": 63
          },
          {
              "line": 207,
              "column": 15
          },
          {
              "line": 207,
              "column": 18
          },
          {
              "line": 208,
              "column": 18
          },
          {
              "line": 208,
              "column": 21
          },
          {
              "line": 208,
              "column": 24
          },
          {
              "line": 209,
              "column": 28
          },
          {
              "line": 209,
              "column": 30
          },
          {
              "line": 209,
              "column": 34
          },
          {
              "line": 209,
              "column": 41
          },
          {
              "line": 209,
              "column": 77
          },
          {
              "line": 210,
              "column": 12
          },
          {
              "line": 210,
              "column": 25
          },
          {
              "line": 210,
              "column": 32
          },
          {
              "line": 212,
              "column": 19
          },
          {
              "line": 212,
              "column": 23
          },
          {
              "line": 212,
              "column": 27
          },
          {
              "line": 212,
              "column": 32
          },
          {
              "line": 212,
              "column": 35
          },
          {
              "line": 212,
              "column": 43
          },
          {
              "line": 212,
              "column": 46
          },
          {
              "line": 213,
              "column": 18
          },
          {
              "line": 215,
              "column": 16
          },
          {
              "line": 215,
              "column": 23
          },
          {
              "line": 215,
              "column": 29
          },
          {
              "line": 215,
              "column": 33
          },
          {
              "line": 215,
              "column": 37
          },
          {
              "line": 215,
              "column": 42
          },
          {
              "line": 215,
              "column": 57
          },
          {
              "line": 215,
              "column": 60
          },
          {
              "line": 216,
              "column": 23
          },
          {
              "line": 216,
              "column": 30
          },
          {
              "line": 217,
              "column": 20
          },
          {
              "line": 217,
              "column": 29
          },
          {
              "line": 217,
              "column": 33
          },
          {
              "line": 218,
              "column": 26
          },
          {
              "line": 218,
              "column": 39
          },
          {
              "line": 218,
              "column": 42
          },
          {
              "line": 218,
              "column": 45
          },
          {
              "line": 218,
              "column": 59
          },
          {
              "line": 218,
              "column": 67
          },
          {
              "line": 218,
              "column": 70
          },
          {
              "line": 218,
              "column": 84
          },
          {
              "line": 220,
              "column": 16
          },
          {
              "line": 220,
              "column": 23
          },
          {
              "line": 220,
              "column": 27
          },
          {
              "line": 221,
              "column": 14
          },
          {
              "line": 223,
              "column": 11
          },
          {
              "line": 223,
              "column": 18
          },
          {
              "line": 223,
              "column": 23
          },
          {
              "line": 223,
              "column": 30
          },
          {
              "line": 223,
              "column": 34
          },
          {
              "line": 224,
              "column": 14
          },
          {
              "line": 224,
              "column": 20
          },
          {
              "line": 224,
              "column": 23
          },
          {
              "line": 225,
              "column": 21
          },
          {
              "line": 226,
              "column": 20
          },
          {
              "line": 226,
              "column": 22
          },
          {
              "line": 226,
              "column": 29
          },
          {
              "line": 226,
              "column": 37
          },
          {
              "line": 226,
              "column": 44
          },
          {
              "line": 226,
              "column": 51
          },
          {
              "line": 226,
              "column": 61
          },
          {
              "line": 226,
              "column": 66
          },
          {
              "line": 229,
              "column": 11
          },
          {
              "line": 229,
              "column": 17
          },
          {
              "line": 229,
              "column": 23
          },
          {
              "line": 229,
              "column": 27
          },
          {
              "line": 229,
              "column": 30
          },
          {
              "line": 230,
              "column": 15
          },
          {
              "line": 230,
              "column": 17
          },
          {
              "line": 230,
              "column": 25
          },
          {
              "line": 231,
              "column": 15
          },
          {
              "line": 231,
              "column": 17
          },
          {
              "line": 231,
              "column": 25
          },
          {
              "line": 232,
              "column": 18
          },
          {
              "line": 232,
              "column": 21
          },
          {
              "line": 233,
              "column": 15
          },
          {
              "line": 233,
              "column": 18
          },
          {
              "line": 234,
              "column": 18
          },
          {
              "line": 234,
              "column": 21
          },
          {
              "line": 234,
              "column": 24
          },
          {
              "line": 235,
              "column": 28
          },
          {
              "line": 235,
              "column": 30
          },
          {
              "line": 235,
              "column": 34
          },
          {
              "line": 235,
              "column": 41
          },
          {
              "line": 237,
              "column": 41
          },
          {
              "line": 238,
              "column": 26
          },
          {
              "line": 238,
              "column": 29
          },
          {
              "line": 239,
              "column": 13
          },
          {
              "line": 241,
              "column": 24
          },
          {
              "line": 241,
              "column": 28
          },
          {
              "line": 241,
              "column": 32
          },
          {
              "line": 241,
              "column": 37
          },
          {
              "line": 241,
              "column": 40
          },
          {
              "line": 241,
              "column": 48
          },
          {
              "line": 241,
              "column": 51
          },
          {
              "line": 242,
              "column": 23
          },
          {
              "line": 242,
              "column": 30
          },
          {
              "line": 243,
              "column": 20
          },
          {
              "line": 243,
              "column": 29
          },
          {
              "line": 243,
              "column": 33
          },
          {
              "line": 243,
              "column": 45
          },
          {
              "line": 243,
              "column": 53
          },
          {
              "line": 243,
              "column": 58
          },
          {
              "line": 243,
              "column": 61
          },
          {
              "line": 243,
              "column": 68
          },
          {
              "line": 243,
              "column": 76
          },
          {
              "line": 243,
              "column": 79
          },
          {
              "line": 243,
              "column": 88
          },
          {
              "line": 245,
              "column": 10
          },
          {
              "line": 249,
              "column": 10
          },
          {
              "line": 249,
              "column": 17
          },
          {
              "line": 249,
              "column": 26
          },
          {
              "line": 249,
              "column": 33
          },
          {
              "line": 249,
              "column": 37
          },
          {
              "line": 249,
              "column": 41
          },
          {
              "line": 249,
              "column": 51
          },
          {
              "line": 249,
              "column": 68
          },
          {
              "line": 249,
              "column": 72
          },
          {
              "line": 249,
              "column": 79
          },
          {
              "line": 249,
              "column": 85
          },
          {
              "line": 249,
              "column": 92
          },
          {
              "line": 250,
              "column": 11
          },
          {
              "line": 250,
              "column": 23
          },
          {
              "line": 250,
              "column": 30
          },
          {
              "line": 250,
              "column": 43
          },
          {
              "line": 250,
              "column": 48
          },
          {
              "line": 250,
              "column": 55
          },
          {
              "line": 250,
              "column": 62
          },
          {
              "line": 250,
              "column": 76
          },
          {
              "line": 252,
              "column": 27
          },
          {
              "line": 254,
              "column": 15
          },
          {
              "line": 254,
              "column": 37
          },
          {
              "line": 256,
              "column": 18
          },
          {
              "line": 256,
              "column": 36
          },
          {
              "line": 257,
              "column": 15
          },
          {
              "line": 257,
              "column": 23
          },
          {
              "line": 258,
              "column": 31
          },
          {
              "line": 259,
              "column": 32
          },
          {
              "line": 259,
              "column": 44
          },
          {
              "line": 259,
              "column": 53
          },
          {
              "line": 260,
              "column": 31
          },
          {
              "line": 261,
              "column": 28
          },
          {
              "line": 261,
              "column": 46
          },
          {
              "line": 264,
              "column": 14
          },
          {
              "line": 264,
              "column": 19
          },
          {
              "line": 264,
              "column": 36
          },
          {
              "line": 265,
              "column": 14
          },
          {
              "line": 265,
              "column": 36
          },
          {
              "line": 265,
              "column": 57
          }
      ],
      "old_name": "e",
      "new_name": "t",
      "ctx": {
          "symbolName": "e",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "IOException",
          "scopeHint": "in createFileSystem(...)",
          "filePath": "RemoteStorageScanner.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "  this.remoteFileSystem = createFileSystem();\n    }\n\n    private FileSystem createFileSystem() {\n        FileSystem fileSystem = null;\n        try {\n            fileSystem = new Path(baseRemoteStoragePath).getFileSystem();\n        } catch (IOException e) {\n            ExceptionUtils.rethrow(\n                    e, \"Failed to initialize file system on the path: \" + baseRemoteStoragePath);\n        }\n        return fileSystem;\n    }\n\n    /** Start the executor. */\n    public void start() {\n ",
          "conflictNames": [
              "fileSystem"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6e5f8694b66d8dea8ae2926adafdb610c09d9b88^1/flink-runtime/src/main/java/org/apache/flink/runtime/security/token/hadoop/KerberosDelegationTokenManager.java",
      "locators": [
          {
              "line": 56,
              "column": 23
          },
          {
              "line": 151,
              "column": 52
          },
          {
              "line": 153,
              "column": 49
          },
          {
              "line": 157,
              "column": 82
          },
          {
              "line": 168,
              "column": 82
          },
          {
              "line": 189,
              "column": 52
          },
          {
              "line": 220,
              "column": 25
          },
          {
              "line": 221,
              "column": 82
          },
          {
              "line": 223,
              "column": 17
          },
          {
              "line": 224,
              "column": 24
          },
          {
              "line": 224,
              "column": 84
          },
          {
              "line": 226,
              "column": 72
          },
          {
              "line": 230,
              "column": 61
          }
      ],
      "old_name": "credentials",
      "new_name": "container",
      "ctx": {
          "symbolName": "credentials",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Credentials",
          "scopeHint": "in obtainDelegationTokens(...)",
          "filePath": "KerberosDelegationTokenManager.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "       return delegationTokenProviders.containsKey(serviceName);\n    }\n\n    /**\n     * Obtains new tokens in a one-time fashion and leaves it up to the caller to distribute them.\n     */\n    @Override\n    public void obtainDelegationTokens(Credentials credentials) throws Exception {\n        LOG.info(\"Obtaining delegation tokens\");\n        obtainDelegationTokensAndGetNextRenewal(credentials);\n        LOG.info(\"Delegation tokens obtained successfully\");\n    }\n\n    protected Optional<Long> obtainDeleg"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6e5f8694b66d8dea8ae2926adafdb610c09d9b88^1/flink-runtime/src/main/java/org/apache/flink/runtime/security/token/hadoop/KerberosDelegationTokenManager.java",
      "locators": [
          {
              "line": 224,
              "column": 24
          },
          {
              "line": 226,
              "column": 72
          },
          {
              "line": 230,
              "column": 61
          }
      ],
      "old_name": "credentialsBytes",
      "new_name": "containerBytes",
      "ctx": {
          "symbolName": "credentialsBytes",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "byte[]",
          "scopeHint": "in startTokensUpdate(...)",
          "filePath": "KerberosDelegationTokenManager.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@VisibleForTesting\n    void startTokensUpdate() {\n        try {\n            LOG.info(\"Starting tokens update task\");\n            Credentials credentials = new Credentials();\n            Optional<Long> nextRenewal = obtainDelegationTokensAndGetNextRenewal(credentials);\n\n            if (credentials.numberOfTokens() > 0) {\n                byte[] credentialsBytes = HadoopDelegationTokenConverter.serialize(credentials);\n\n                HadoopDelegationTokenUpdater.addCurrentUserCredentials(credentialsBytes);\n\n                LOG.info(\"Notifying listener about new tokens\");\n                checkNotNull(delegationTokenListener, \"Listener must not be null\");\n                delegationTokenListener.onNewTokensObtained(credentialsBytes);\n                LOG.info(\"Listener notified successfully\");\n            } else {\n                LOG.warn(\"No tokens obtained so skipping listener notification\");\n            }\n\n            if (nextRenewal.isPresent()) {\n                long renewalDelay =\n                        calculateRenewalDelay(Clock.systemDefaultZone(), nextRenewal.get());\n                synchronized (tokensUpdateFutureLock) {\n                    tokensUpdateFuture =\n                            scheduledExecutor.schedule(\n                                    () -> ioExecutor.execute(this::startTokensUpdate),\n                                    renewalDelay,\n                                    TimeUnit.MILLISECONDS);\n                }\n                LOG.info(\"Tokens update task started with {} ms delay\", renewalDelay);\n            } else {\n                LOG.warn(\n                        \"Tokens update task not started because either no tokens obtained or none of the tokens specified its renewal date\");\n            }\n        } catch (InterruptedException e) {\n            // Ignore, may happen if shutting down.\n            LOG.debug(\"Interrupted\", e);\n        } catch (Exception e) {\n            synchronized (tokensUpdateFutureLock) {\n                tokensUpdateFuture =\n                        scheduledExecutor.schedule(\n                                () -> ioExecutor.execute(this::startTokensUpdate),\n                                renewalRetryBackoffPeriod,\n                                TimeUnit.MILLISECONDS);\n            }\n            LOG.warn(\n                    \"Failed to update tokens, will try again in {} ms\",\n                    renewalRetryBackoffPeriod,\n                    e);\n        }\n    }",
          "conflictNames": [
              "credentials",
              "nextRenewal",
              "renewalDelay"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6e5f8694b66d8dea8ae2926adafdb610c09d9b88^1/flink-runtime/src/main/java/org/apache/flink/runtime/security/token/hadoop/KerberosDelegationTokenManager.java",
      "locators": [
          {
              "line": 101,
              "column": 44
          },
          {
              "line": 106,
              "column": 52
          },
          {
              "line": 107,
              "column": 44
          },
          {
              "line": 109,
              "column": 39
          },
          {
              "line": 110,
              "column": 21
          },
          {
              "line": 112,
              "column": 47
          },
          {
              "line": 113,
              "column": 29
          },
          {
              "line": 114,
              "column": 21
          },
          {
              "line": 114,
              "column": 35
          },
          {
              "line": 114,
              "column": 59
          },
          {
              "line": 117,
              "column": 47
          },
          {
              "line": 118,
              "column": 29
          },
          {
              "line": 122,
              "column": 64
          },
          {
              "line": 123,
              "column": 25
          },
          {
              "line": 131,
              "column": 36
          },
          {
              "line": 133,
              "column": 16
          },
          {
              "line": 139,
              "column": 56
          },
          {
              "line": 161,
              "column": 33
          },
          {
              "line": 164,
              "column": 45
          },
          {
              "line": 167,
              "column": 53
          },
          {
              "line": 168,
              "column": 50
          },
          {
              "line": 171,
              "column": 53
          },
          {
              "line": 175,
              "column": 53
          },
          {
              "line": 180,
              "column": 88
          },
          {
              "line": 181,
              "column": 49
          }
      ],
      "old_name": "provider",
      "new_name": "p",
      "ctx": {
          "symbolName": "provider",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "HadoopDelegationTokenProvider",
          "scopeHint": "in loadProviders(...)",
          "filePath": "KerberosDelegationTokenManager.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": ");\n\n        ServiceLoader<HadoopDelegationTokenProvider> serviceLoader =\n                ServiceLoader.load(HadoopDelegationTokenProvider.class);\n\n        Map<String, HadoopDelegationTokenProvider> providers = new HashMap<>();\n        for (HadoopDelegationTokenProvider provider : serviceLoader) {\n            try {\n                if (isProviderEnabled(provider.serviceName())) {\n                    provider.init(configuration);\n                    LOG.info(\n                            \"Delegation token provider {}",
          "conflictNames": [
              "serviceLoader",
              "providers"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6f0d07633a5c8e6511f3d16e04561cb277b65407^1/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/compiler/NFACompiler.java",
      "locators": [
          {
              "line": 147,
              "column": 41
          },
          {
              "line": 149,
              "column": 32
          },
          {
              "line": 160,
              "column": 13
          },
          {
              "line": 188,
              "column": 26
          },
          {
              "line": 189,
              "column": 32
          },
          {
              "line": 192,
              "column": 65
          },
          {
              "line": 205,
              "column": 20
          },
          {
              "line": 209,
              "column": 20
          },
          {
              "line": 214,
              "column": 13
          },
          {
              "line": 215,
              "column": 21
          },
          {
              "line": 216,
              "column": 29
          },
          {
              "line": 216,
              "column": 83
          },
          {
              "line": 321,
              "column": 13
          },
          {
              "line": 375,
              "column": 65
          },
          {
              "line": 377,
              "column": 21
          },
          {
              "line": 425,
              "column": 22
          },
          {
              "line": 426,
              "column": 38
          },
          {
              "line": 427,
              "column": 21
          },
          {
              "line": 427,
              "column": 54
          },
          {
              "line": 431,
              "column": 21
          },
          {
              "line": 1059,
              "column": 28
          },
          {
              "line": 1060,
              "column": 41
          },
          {
              "line": 1065,
              "column": 22
          },
          {
              "line": 1066,
              "column": 35
          },
          {
              "line": 1070,
              "column": 18
          },
          {
              "line": 1070,
              "column": 31
          },
          {
              "line": 1071,
              "column": 18
          },
          {
              "line": 1071,
              "column": 32
          },
          {
              "line": 1078,
              "column": 38
          },
          {
              "line": 1078,
              "column": 51
          }
      ],
      "old_name": "windowTime",
      "new_name": "windowSize",
      "ctx": {
          "symbolName": "windowTime",
          "symbolKind": "field",
          "language": "JAVA",
          "type": "Optional<Long>",
          "scopeHint": "in NFAFactoryCompiler",
          "filePath": "NFACompiler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "AStateNameHandler();\n        private final Map<String, State<T>> stopStates = new HashMap<>();\n        private final List<State<T>> states = new ArrayList<>();\n        private final Map<String, Long> windowTimes = new HashMap<>();\n\n        private Optional<Long> windowTime;\n        private GroupPattern<T, ?> currentGroupPattern;\n        private Map<GroupPattern<T, ?>, Boolean> firstOfLoopMap = new HashMap<>();\n        private Pattern<T, ?> currentPattern;\n        private Pattern<T, ?> followingPattern;\n      ",
          "conflictNames": [
              "stateNameHandler",
              "stopStates",
              "states",
              "windowTimes",
              "currentGroupPattern",
              "firstOfLoopMap",
              "currentPattern",
              "followingPattern",
              "afterMatchSkipStrategy",
              "originalStateMap"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6f7b24817a81995e90cfc2cd77efadb41be8cddc^1/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/collect/CollectResultBufferTest.java",
      "locators": [
          {
              "line": 45,
              "column": 18
          },
          {
              "line": 46,
              "column": 37
          },
          {
              "line": 48,
              "column": 33
          },
          {
              "line": 51,
              "column": 9
          },
          {
              "line": 52,
              "column": 33
          },
          {
              "line": 60,
              "column": 9
          },
          {
              "line": 63,
              "column": 33
          },
          {
              "line": 76,
              "column": 18
          },
          {
              "line": 77,
              "column": 37
          },
          {
              "line": 79,
              "column": 33
          },
          {
              "line": 82,
              "column": 9
          },
          {
              "line": 83,
              "column": 33
          },
          {
              "line": 90,
              "column": 9
          },
          {
              "line": 91,
              "column": 33
          },
          {
              "line": 94,
              "column": 9
          },
          {
              "line": 95,
              "column": 33
          },
          {
              "line": 107,
              "column": 18
          },
          {
              "line": 108,
              "column": 37
          },
          {
              "line": 110,
              "column": 33
          },
          {
              "line": 113,
              "column": 9
          },
          {
              "line": 114,
              "column": 33
          },
          {
              "line": 121,
              "column": 9
          },
          {
              "line": 122,
              "column": 33
          },
          {
              "line": 131,
              "column": 18
          },
          {
              "line": 132,
              "column": 37
          },
          {
              "line": 134,
              "column": 33
          },
          {
              "line": 137,
              "column": 9
          },
          {
              "line": 138,
              "column": 33
          },
          {
              "line": 142,
              "column": 9
          },
          {
              "line": 145,
              "column": 33
          },
          {
              "line": 153,
              "column": 9
          },
          {
              "line": 156,
              "column": 33
          },
          {
              "line": 163,
              "column": 9
          },
          {
              "line": 166,
              "column": 33
          },
          {
              "line": 169,
              "column": 9
          },
          {
              "line": 172,
              "column": 33
          },
          {
              "line": 192,
              "column": 18
          },
          {
              "line": 193,
              "column": 37
          },
          {
              "line": 195,
              "column": 33
          },
          {
              "line": 197,
              "column": 9
          },
          {
              "line": 200,
              "column": 33
          },
          {
              "line": 206,
              "column": 9
          },
          {
              "line": 207,
              "column": 33
          },
          {
              "line": 211,
              "column": 9
          },
          {
              "line": 212,
              "column": 33
          },
          {
              "line": 217,
              "column": 9
          },
          {
              "line": 218,
              "column": 33
          },
          {
              "line": 232,
              "column": 34
          },
          {
              "line": 234,
              "column": 37
          },
          {
              "line": 236,
              "column": 33
          }
      ],
      "old_name": "response",
      "new_name": "anotherResponse",
      "ctx": {
          "symbolName": "response",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CollectCoordinationResponse",
          "scopeHint": "in testUncheckpointedValidResponse(...)",
          "filePath": "CollectResultBufferTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testUncheckpointedValidResponse() throws Exception {\n        String version = \"version\";\n        AbstractCollectResultBuffer<Integer> buffer =\n                new UncheckpointedCollectResultBuffer<>(serializer, false);\n\n        // first response to sync version, no data\n        CollectCoordinationResponse response =\n                new CollectCoordinationResponse(version, 0, Collections.emptyList());\n        buffer.dealWithResponse(response, 0);\n\n        List<Integer> expected = Arrays.asList(1, 2, 3);\n        response = new CollectCoordinationResponse(version, 0, createSerializedResults(expected));\n        buffer.dealWithResponse(response, 0);\n        // for uncheckpointed buffer, results can be instantly seen by user\n        for (Integer expectedValue : expected) {\n            Assert.assertEquals(expectedValue, buffer.next());\n        }\n\n        expected = Arrays.asList(4, 5);\n        // 3 is a retransmitted value, it should be skipped\n        response =\n                new CollectCoordinationResponse(\n                        version, 0, createSerializedResults(Arrays.asList(3, 4, 5)));\n        buffer.dealWithResponse(response, 2);\n        for (Integer expectedValue : expected) {\n            Assert.assertEquals(expectedValue, buffer.next());\n        }\n        Assert.assertNull(buffer.next());\n    }",
          "conflictNames": [
              "version",
              "buffer",
              "expected"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/6fb65a0f9dd1fe4a985a994424f6cd2026d40504^1/flink-runtime/src/test/java/org/apache/flink/runtime/state/InternalPriorityQueueTestBase.java",
      "locators": [
          {
              "line": 537,
              "column": 39
          },
          {
              "line": 538,
              "column": 37
          }
      ],
      "old_name": "testElementSerializer",
      "new_name": "snapshot",
      "ctx": {
          "symbolName": "testElementSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestElementSerializer",
          "scopeHint": "in resolveSchemaCompatibility(...)",
          "filePath": "InternalPriorityQueueTestBase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n            public TypeSerializerSchemaCompatibility<TestElement> resolveSchemaCompatibility(\n                    TypeSerializer<TestElement> newSerializer) {\n                if (!(newSerializer instanceof TestElementSerializer)) {\n                    return TypeSerializerSchemaCompatibility.incompatible();\n                }\n\n                TestElementSerializer testElementSerializer = (TestElementSerializer) newSerializer;\n                return (revision <= testElementSerializer.getRevision())\n                        ? TypeSerializerSchemaCompatibility.compatibleAsIs()\n                        : TypeSerializerSchemaCompatibility.incompatible();\n            }",
          "conflictNames": [
              "newSerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/707bae0fb118cbe2b95bfad7a516bf19421f40d9^1/flink-state-backends/flink-statebackend-forst/src/test/java/org/apache/flink/state/forst/ForStAsyncAndSyncCompatibilityTest.java",
      "locators": [
          {
              "line": 88,
              "column": 45
          },
          {
              "line": 93,
              "column": 69
          },
          {
              "line": 128,
              "column": 70
          },
          {
              "line": 152,
              "column": 79
          },
          {
              "line": 156,
              "column": 76
          }
      ],
      "old_name": "descriptor",
      "new_name": "mapDescriptor",
      "ctx": {
          "symbolName": "descriptor",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "MapStateDescriptor<Integer, String>",
          "scopeHint": "in testForStTransFromAsyncToSync(...)",
          "filePath": "ForStAsyncAndSyncCompatibilityTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testForStTransFromAsyncToSync() throws Exception {\n        ForStKeyedStateBackend<String> keyedBackend =\n                setUpAsyncKeyedStateBackend(Collections.emptyList());\n        MapStateDescriptor<Integer, String> descriptor =\n                new MapStateDescriptor<>(\n                        \"testState\", IntSerializer.INSTANCE, StringSerializer.INSTANCE);\n\n        MapState<Integer, String> asyncMapState =\n                keyedBackend.createState(1, IntSerializer.INSTANCE, descriptor);\n\n        context = aec.buildContext(\"testRecord\", \"testKey\");\n        context.retain();\n        aec.setCurrentContext(context);\n        asyncMapState.asyncPut(1, \"1\");\n        context.release();\n        aec.drainInflightRecords(0);\n\n        RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot =\n                keyedBackend.snapshot(\n                        1L,\n                        System.currentTimeMillis(),\n                        env.getCheckpointStorageAccess()\n                                .resolveCheckpointStorageLocation(\n                                        1L, CheckpointStorageLocationReference.getDefault()),\n                        CheckpointOptions.forCheckpointWithDefaultLocation());\n\n        if (!snapshot.isDone()) {\n            snapshot.run();\n        }\n        SnapshotResult<KeyedStateHandle> snapshotResult = snapshot.get();\n        KeyedStateHandle stateHandle = snapshotResult.getJobManagerOwnedSnapshot();\n        IOUtils.closeQuietly(keyedBackend);\n        ForStSyncKeyedStateBackend<String> syncKeyedStateBackend =\n                createSyncKeyedStateBackend(\n                        forStStateBackend,\n                        env,\n                        StringSerializer.INSTANCE,\n                        Collections.singletonList(stateHandle));\n\n        try {\n            org.apache.flink.api.common.state.MapState<Integer, String> syncMapState =\n                    syncKeyedStateBackend.getOrCreateKeyedState(\n                            IntSerializer.INSTANCE,\n                            StateDescriptorUtils.transformFromV2ToV1(descriptor));\n            fail();\n\n            syncKeyedStateBackend.setCurrentKey(\"testKey\");\n            ((InternalKvState) syncKeyedStateBackend).setCurrentNamespace(1);\n            assertThat(syncMapState.get(1)).isEqualTo(\"1\");\n        } catch (Exception e) {\n            // Currently, ForStStateBackend does not support switching from Async to Sync, so this\n            // exception will be caught here\n            assertThat(e).isInstanceOf(ClassCastException.class);\n            assertThat(e.getMessage())\n                    .contains(\n                            \"org.apache.flink.runtime.state.v2.RegisteredKeyAndUserKeyValueStateBackendMetaInfo cannot be cast to class org.apache.flink.runtime.state.RegisteredKeyValueStateBackendMetaInfo\");\n\n        } finally {\n            IOUtils.closeQuietly(syncKeyedStateBackend);\n        }\n    }",
          "conflictNames": [
              "keyedBackend",
              "asyncMapState",
              "snapshot",
              "snapshotResult",
              "stateHandle",
              "syncKeyedStateBackend",
              "syncMapState"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/707bae0fb118cbe2b95bfad7a516bf19421f40d9^1/flink-state-backends/flink-statebackend-forst/src/test/java/org/apache/flink/state/forst/ForStAsyncAndSyncCompatibilityTest.java",
      "locators": [
          {
              "line": 180,
              "column": 45
          },
          {
              "line": 186,
              "column": 56
          }
      ],
      "old_name": "newStateDescriptor",
      "new_name": "newMapDescriptor",
      "ctx": {
          "symbolName": "newStateDescriptor",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "MapStateDescriptor<Integer, String>",
          "scopeHint": "in testForStTransFromSyncToAsync(...)",
          "filePath": "ForStAsyncAndSyncCompatibilityTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testForStTransFromSyncToAsync() throws Exception {\n        ForStSyncKeyedStateBackend<String> keyedBackend =\n                createSyncKeyedStateBackend(\n                        forStStateBackend, env, StringSerializer.INSTANCE, Collections.emptyList());\n        org.apache.flink.api.common.state.MapStateDescriptor<Integer, String> descriptor =\n                new org.apache.flink.api.common.state.MapStateDescriptor<>(\n                        \"testState\", IntSerializer.INSTANCE, StringSerializer.INSTANCE);\n        org.apache.flink.api.common.state.MapState<Integer, String> mapState =\n                keyedBackend.getOrCreateKeyedState(IntSerializer.INSTANCE, descriptor);\n        keyedBackend.setCurrentKey(\"testKey\");\n        ((InternalKvState) mapState).setCurrentNamespace(1);\n        mapState.put(1, \"1\");\n\n        RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot =\n                keyedBackend.snapshot(\n                        1L,\n                        System.currentTimeMillis(),\n                        env.getCheckpointStorageAccess()\n                                .resolveCheckpointStorageLocation(\n                                        1L, CheckpointStorageLocationReference.getDefault()),\n                        CheckpointOptions.forCheckpointWithDefaultLocation());\n\n        if (!snapshot.isDone()) {\n            snapshot.run();\n        }\n        SnapshotResult<KeyedStateHandle> snapshotResult = snapshot.get();\n        KeyedStateHandle stateHandle = snapshotResult.getJobManagerOwnedSnapshot();\n        IOUtils.closeQuietly(keyedBackend);\n\n        ForStKeyedStateBackend<String> asyncKeyedStateBackend =\n                setUpAsyncKeyedStateBackend(Collections.singletonList(stateHandle));\n\n        MapStateDescriptor<Integer, String> newStateDescriptor =\n                new MapStateDescriptor<>(\n                        \"testState\", IntSerializer.INSTANCE, StringSerializer.INSTANCE);\n        try {\n            MapState<Integer, String> asyncMapState =\n                    asyncKeyedStateBackend.createState(\n                            1, IntSerializer.INSTANCE, newStateDescriptor);\n            fail();\n\n            context = aec.buildContext(\"testRecord\", \"testKey\");\n            context.retain();\n            aec.setCurrentContext(context);\n            asyncMapState\n                    .asyncGet(1)\n                    .thenAccept(\n                            value -> {\n                                assertThat(value).isEqualTo(\"1\");\n                            });\n            context.release();\n            aec.drainInflightRecords(0);\n        } catch (Exception e) {\n            // Currently, ForStStateBackend does not support switching from Sync to Async, so this\n            // exception will be caught here\n            assertThat(e).isInstanceOf(ClassCastException.class);\n            assertThat(e.getMessage())\n                    .contains(\n                            \"org.apache.flink.runtime.state.RegisteredKeyValueStateBackendMetaInfo cannot be cast to class org.apache.flink.runtime.state.v2.RegisteredKeyValueStateBackendMetaInfo\");\n        } finally {\n            IOUtils.closeQuietly(asyncKeyedStateBackend);\n        }\n    }",
          "conflictNames": [
              "keyedBackend",
              "descriptor",
              "mapState",
              "snapshot",
              "snapshotResult",
              "stateHandle",
              "asyncKeyedStateBackend",
              "asyncMapState"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/72240726a936e38e4de3fdcae162af3bbec1fcfe^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SsgNetworkMemoryCalculationUtils.java",
      "locators": [
          {
              "line": 193,
              "column": 28
          },
          {
              "line": 200,
              "column": 25
          }
      ],
      "old_name": "subpartitionIndexRange",
      "new_name": "consumedSubpartitionGroups",
      "ctx": {
          "symbolName": "subpartitionIndexRange",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "IndexRange",
          "scopeHint": "in getMaxInputChannelInfoForDynamicGraph(...)",
          "filePath": "SsgNetworkMemoryCalculationUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@VisibleForTesting\n    static void getMaxInputChannelInfoForDynamicGraph(\n            ExecutionJobVertex ejv,\n            Map<IntermediateDataSetID, Integer> maxInputChannelNums,\n            Map<IntermediateDataSetID, ResultPartitionType> inputPartitionTypes) {\n\n        for (ExecutionVertex vertex : ejv.getTaskVertices()) {\n            for (ConsumedPartitionGroup partitionGroup : vertex.getAllConsumedPartitionGroups()) {\n\n                IntermediateResultPartition resultPartition =\n                        ejv.getGraph().getResultPartitionOrThrow((partitionGroup.getFirst()));\n                IndexRange subpartitionIndexRange =\n                        vertex.getExecutionVertexInputInfo(\n                                        resultPartition.getIntermediateResult().getId())\n                                .getSubpartitionIndexRange();\n\n                maxInputChannelNums.merge(\n                        partitionGroup.getIntermediateDataSetID(),\n                        subpartitionIndexRange.size() * partitionGroup.size(),\n                        Integer::max);\n                inputPartitionTypes.putIfAbsent(\n                        partitionGroup.getIntermediateDataSetID(),\n                        partitionGroup.getResultPartitionType());\n            }\n        }\n    }",
          "conflictNames": [
              "ejv",
              "maxInputChannelNums",
              "inputPartitionTypes",
              "resultPartition"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/728e679d354c2c120afe7091f42a91b2e4701036^1/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/DefaultLeaderElectionServiceTest.java",
      "locators": [
          {
              "line": 97,
              "column": 78
          },
          {
              "line": 113,
              "column": 25
          },
          {
              "line": 117,
              "column": 43
          },
          {
              "line": 117,
              "column": 52
          },
          {
              "line": 118,
              "column": 20
          },
          {
              "line": 135,
              "column": 47
          },
          {
              "line": 138,
              "column": 12
          },
          {
              "line": 160,
              "column": 55
          },
          {
              "line": 166,
              "column": 44
          },
          {
              "line": 256,
              "column": 78
          },
          {
              "line": 262,
              "column": 25
          },
          {
              "line": 265,
              "column": 47
          },
          {
              "line": 265,
              "column": 56
          },
          {
              "line": 266,
              "column": 24
          },
          {
              "line": 268,
              "column": 13
          },
          {
              "line": 286,
              "column": 78
          },
          {
              "line": 291,
              "column": 25
          },
          {
              "line": 294,
              "column": 47
          },
          {
              "line": 294,
              "column": 56
          },
          {
              "line": 295,
              "column": 24
          },
          {
              "line": 297,
              "column": 13
          },
          {
              "line": 334,
              "column": 114
          },
          {
              "line": 737,
              "column": 50
          },
          {
              "line": 753,
              "column": 71
          },
          {
              "line": 774,
              "column": 78
          },
          {
              "line": 804,
              "column": 17
          },
          {
              "line": 805,
              "column": 21
          },
          {
              "line": 807,
              "column": 21
          },
          {
              "line": 813,
              "column": 51
          },
          {
              "line": 818,
              "column": 78
          },
          {
              "line": 823,
              "column": 25
          },
          {
              "line": 829,
              "column": 43
          },
          {
              "line": 829,
              "column": 52
          },
          {
              "line": 830,
              "column": 20
          },
          {
              "line": 832,
              "column": 9
          },
          {
              "line": 832,
              "column": 29
          },
          {
              "line": 871,
              "column": 86
          },
          {
              "line": 875,
              "column": 33
          },
          {
              "line": 885,
              "column": 47
          }
      ],
      "old_name": "driver",
      "new_name": "leadershipGranted",
      "ctx": {
          "symbolName": "driver",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestingLeaderElectionDriver",
          "scopeHint": "in testCloseGrantDeadlock(...)",
          "filePath": "DefaultLeaderElectionServiceTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testCloseGrantDeadlock() throws Exception {\n        final OneShotLatch closeReachedLatch = new OneShotLatch();\n        final OneShotLatch closeContinueLatch = new OneShotLatch();\n        final OneShotLatch grantReachedLatch = new OneShotLatch();\n        final OneShotLatch grantContinueLatch = new OneShotLatch();\n\n        final TestingLeaderElectionDriver.TestingLeaderElectionDriverFactory driverFactory =\n                new TestingLeaderElectionDriver.TestingLeaderElectionDriverFactory(\n                        eventHandler -> {},\n                        eventHandler -> {\n                            closeReachedLatch.trigger();\n                            closeContinueLatch.await();\n                        },\n                        leaderElectionEventHandler -> {\n                            grantReachedLatch.trigger();\n                            grantContinueLatch.awaitQuietly();\n                        });\n\n        final ManuallyTriggeredScheduledExecutorService executorService =\n                new ManuallyTriggeredScheduledExecutorService();\n        final DefaultLeaderElectionService testInstance =\n                new DefaultLeaderElectionService(\n                        driverFactory,\n                        fatalErrorHandlerExtension.getTestingFatalErrorHandler(),\n                        executorService);\n        testInstance.startLeaderElectionBackend();\n        final TestingLeaderElectionDriver driver = driverFactory.getCurrentLeaderDriver();\n        assertThat(driver).isNotNull();\n\n        final Thread closeThread =\n                new Thread(\n                        () -> {\n                            try {\n                                testInstance.close();\n                            } catch (Exception e) {\n                                throw new RuntimeException(e);\n                            }\n                        },\n                        \"CloseThread\");\n\n        // triggers close that acquires the DefaultLeaderElectionService lock\n        closeThread.start();\n        closeReachedLatch.await();\n\n        final Thread grantThread = new Thread(driver::isLeader, \"GrantThread\");\n\n        // triggers the service acquiring the leadership and, as a consequence, acquiring the\n        // driver's lock\n        grantThread.start();\n        grantReachedLatch.await();\n\n        // continue both processes which shouldn't result in a deadlock\n        grantContinueLatch.trigger();\n        closeContinueLatch.trigger();\n\n        closeThread.join();\n        grantThread.join();\n    }",
          "conflictNames": [
              "closeReachedLatch",
              "closeContinueLatch",
              "grantReachedLatch",
              "grantContinueLatch",
              "driverFactory",
              "executorService",
              "testInstance",
              "closeThread",
              "grantThread"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/728e679d354c2c120afe7091f42a91b2e4701036^1/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/DefaultMultipleComponentLeaderElectionServiceTest.java",
      "locators": [
          {
              "line": 50,
              "column": 60
          },
          {
              "line": 54,
              "column": 64
          },
          {
              "line": 69,
              "column": 13
          },
          {
              "line": 81,
              "column": 66
          },
          {
              "line": 85,
              "column": 73
          },
          {
              "line": 91,
              "column": 60
          },
          {
              "line": 95,
              "column": 64
          },
          {
              "line": 110,
              "column": 13
          },
          {
              "line": 111,
              "column": 13
          },
          {
              "line": 123,
              "column": 60
          },
          {
              "line": 127,
              "column": 64
          },
          {
              "line": 133,
              "column": 13
          },
          {
              "line": 149,
              "column": 60
          },
          {
              "line": 153,
              "column": 64
          },
          {
              "line": 163,
              "column": 13
          },
          {
              "line": 173,
              "column": 60
          },
          {
              "line": 176,
              "column": 64
          },
          {
              "line": 179,
              "column": 13
          },
          {
              "line": 194,
              "column": 60
          },
          {
              "line": 197,
              "column": 64
          },
          {
              "line": 215,
              "column": 13
          },
          {
              "line": 239,
              "column": 60
          },
          {
              "line": 242,
              "column": 64
          },
          {
              "line": 245,
              "column": 13
          },
          {
              "line": 278,
              "column": 60
          },
          {
              "line": 284,
              "column": 33
          },
          {
              "line": 287,
              "column": 13
          }
      ],
      "old_name": "leaderElectionDriver",
      "new_name": "driverFactory",
      "ctx": {
          "symbolName": "leaderElectionDriver",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestingMultipleComponentLeaderElectionDriver",
          "scopeHint": "in isLeaderInformsAllRegisteredLeaderElectionEventHandlers(...)",
          "filePath": "DefaultMultipleComponentLeaderElectionServiceTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void isLeaderInformsAllRegisteredLeaderElectionEventHandlers() throws Exception {\n        final TestingMultipleComponentLeaderElectionDriver leaderElectionDriver =\n                TestingMultipleComponentLeaderElectionDriver.newBuilder().build();\n\n        final DefaultMultipleComponentLeaderElectionService leaderElectionService =\n                createDefaultMultiplexingLeaderElectionService(leaderElectionDriver);\n\n        try {\n            final Collection<SimpleTestingLeaderElectionEventListener> eventListeners =\n                    Stream.generate(SimpleTestingLeaderElectionEventListener::new)\n                            .limit(4)\n                            .collect(Collectors.toList());\n\n            int counter = 0;\n            for (SimpleTestingLeaderElectionEventListener eventListener : eventListeners) {\n                leaderElectionService.registerLeaderElectionEventHandler(\n                        String.valueOf(counter), eventListener);\n                counter++;\n            }\n\n            leaderElectionDriver.grantLeadership();\n\n            for (SimpleTestingLeaderElectionEventListener eventListener : eventListeners) {\n                assertThat(eventListener.hasLeadership()).isTrue();\n            }\n        } finally {\n            leaderElectionService.close();\n        }\n    }",
          "conflictNames": [
              "leaderElectionService",
              "eventListeners",
              "counter"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/728e679d354c2c120afe7091f42a91b2e4701036^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterServiceLeadershipRunnerTest.java",
      "locators": [
          {
              "line": 680,
              "column": 17
          },
          {
              "line": 687,
              "column": 25
          },
          {
              "line": 764,
              "column": 29
          }
      ],
      "old_name": "testingLeaderElectionDriverFactory",
      "new_name": "driverFactory",
      "ctx": {
          "symbolName": "testingLeaderElectionDriverFactory",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestingLeaderElectionDriverFactory",
          "scopeHint": "in testJobMasterServiceLeadershipRunnerCloseWhenElectionServiceGrantLeaderShip(...)",
          "filePath": "JobMasterServiceLeadershipRunnerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testJobMasterServiceLeadershipRunnerCloseWhenElectionServiceGrantLeaderShip()\n            throws Exception {\n        final TestingLeaderElectionDriver.TestingLeaderElectionDriverFactory\n                testingLeaderElectionDriverFactory =\n                        new TestingLeaderElectionDriver.TestingLeaderElectionDriverFactory();\n\n        // we need to use DefaultLeaderElectionService here because JobMasterServiceLeadershipRunner\n        // in connection with the DefaultLeaderElectionService generates the nested locking\n        final DefaultLeaderElectionService defaultLeaderElectionService =\n                new DefaultLeaderElectionService(\n                        testingLeaderElectionDriverFactory, fatalErrorHandler);\n        defaultLeaderElectionService.startLeaderElectionBackend();\n\n        // latch to detect when we reached the first synchronized section having a lock on the\n        // JobMasterServiceProcess#stop side\n        final OneShotLatch closeAsyncCalledTrigger = new OneShotLatch();\n        // latch to halt the JobMasterServiceProcess#stop before calling stop on the\n        // DefaultLeaderElectionService instance (and entering the LeaderElectionService's\n        // synchronized block)\n        final OneShotLatch triggerClassLoaderLeaseRelease = new OneShotLatch();\n\n        final JobMasterServiceProcess jobMasterServiceProcess =\n                TestingJobMasterServiceProcess.newBuilder()\n                        .setGetJobMasterGatewayFutureSupplier(CompletableFuture::new)\n                        .setGetResultFutureSupplier(CompletableFuture::new)\n                        .setGetLeaderAddressFutureSupplier(\n                                () -> CompletableFuture.completedFuture(\"unused address\"))\n                        .setCloseAsyncSupplier(\n                                () -> {\n                                    closeAsyncCalledTrigger.trigger();\n                                    // we have to return a completed future because we need the\n                                    // follow-up task to run in the calling thread to make the\n                                    // follow-up code block being executed in the synchronized block\n                                    return CompletableFuture.completedFuture(null);\n                                })\n                        .build();\n        try (final JobMasterServiceLeadershipRunner jobManagerRunner =\n                newJobMasterServiceLeadershipRunnerBuilder()\n                        .setClassLoaderLease(\n                                TestingClassLoaderLease.newBuilder()\n                                        .setCloseRunnable(\n                                                () -> {\n                                                    try {\n                                                        // we want to wait with releasing to halt\n                                                        // before calling stop on the\n                                                        // DefaultLeaderElectionService\n                                                        triggerClassLoaderLeaseRelease.await();\n                                                        // In order to reproduce the deadlock, we\n                                                        // need to ensure that\n                                                        // leaderContender#grantLeadership can be\n                                                        // called after\n                                                        // JobMasterServiceLeadershipRunner obtains\n                                                        // its own lock. Unfortunately, This will\n                                                        // change the running status of\n                                                        // DefaultLeaderElectionService\n                                                        // to false, which will cause the\n                                                        // notification of leadership to be\n                                                        // ignored. The issue is that we\n                                                        // don't have any means of verify that we're\n                                                        // in the synchronized block of\n                                                        // DefaultLeaderElectionService#lock in\n                                                        // DefaultLeaderElectionService#onGrantLeadership,\n                                                        // but we trigger this implicitly through\n                                                        // TestingLeaderElectionDriver#isLeader().\n                                                        // Adding a short sleep can ensure that\n                                                        // another thread successfully receives the\n                                                        // leadership notification, so that the\n                                                        // deadlock problem can recur.\n                                                        Thread.sleep(5);\n                                                    } catch (InterruptedException e) {\n                                                        ExceptionUtils.checkInterrupted(e);\n                                                    }\n                                                })\n                                        .build())\n                        .setJobMasterServiceProcessFactory(\n                                TestingJobMasterServiceProcessFactory.newBuilder()\n                                        .setJobMasterServiceProcessFunction(\n                                                ignoredSessionId -> jobMasterServiceProcess)\n                                        .build())\n                        .setLeaderElection(\n                                defaultLeaderElectionService.createLeaderElection(\n                                        \"random-contender-id\"))\n                        .build()) {\n            jobManagerRunner.start();\n\n            final TestingLeaderElectionDriver currentLeaderDriver =\n                    Preconditions.checkNotNull(\n                            testingLeaderElectionDriverFactory.getCurrentLeaderDriver());\n            // grant leadership to create jobMasterServiceProcess\n            currentLeaderDriver.isLeader();\n\n            while (currentLeaderDriver.getLeaderInformation().getLeaderSessionID() == null\n                    || !jobManagerRunner\n                            .getLeaderElection()\n                            .hasLeadership(\n                                    currentLeaderDriver\n                                            .getLeaderInformation()\n                                            .getLeaderSessionID())) {\n                Thread.sleep(100);\n            }\n\n            final CheckedThread contenderCloseThread = createCheckedThread(jobManagerRunner::close);\n            contenderCloseThread.start();\n\n            // waiting for the contender reaching the synchronized section of the stop call\n            closeAsyncCalledTrigger.await();\n\n            final CheckedThread grantLeadershipThread =\n                    createCheckedThread(\n                            () -> {\n                                // DefaultLeaderElectionService enforces a proper event handling\n                                // order (i.e. no two grant or revoke events should appear after\n                                // each other). This requires the leadership to be revoked before\n                                // regaining leadership in this test.\n                                currentLeaderDriver.notLeader();\n                                currentLeaderDriver.isLeader();\n                            });\n            grantLeadershipThread.start();\n\n            // finalize ClassloaderLease release to trigger DefaultLeaderElectionService#stop\n            triggerClassLoaderLeaseRelease.trigger();\n\n            contenderCloseThread.sync();\n            grantLeadershipThread.sync();\n        }\n    }",
          "conflictNames": [
              "defaultLeaderElectionService",
              "closeAsyncCalledTrigger",
              "triggerClassLoaderLeaseRelease",
              "jobMasterServiceProcess",
              "jobManagerRunner",
              "currentLeaderDriver",
              "contenderCloseThread",
              "grantLeadershipThread"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/728e679d354c2c120afe7091f42a91b2e4701036^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterServiceLeadershipRunnerTest.java",
      "locators": [
          {
              "line": 762,
              "column": 47
          },
          {
              "line": 766,
              "column": 13
          },
          {
              "line": 768,
              "column": 20
          },
          {
              "line": 772,
              "column": 37
          },
          {
              "line": 791,
              "column": 33
          },
          {
              "line": 792,
              "column": 33
          }
      ],
      "old_name": "currentLeaderDriver",
      "new_name": "lock",
      "ctx": {
          "symbolName": "currentLeaderDriver",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestingLeaderElectionDriver",
          "scopeHint": "in testJobMasterServiceLeadershipRunnerCloseWhenElectionServiceGrantLeaderShip(...)",
          "filePath": "JobMasterServiceLeadershipRunnerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testJobMasterServiceLeadershipRunnerCloseWhenElectionServiceGrantLeaderShip()\n            throws Exception {\n        final TestingLeaderElectionDriver.TestingLeaderElectionDriverFactory\n                testingLeaderElectionDriverFactory =\n                        new TestingLeaderElectionDriver.TestingLeaderElectionDriverFactory();\n\n        // we need to use DefaultLeaderElectionService here because JobMasterServiceLeadershipRunner\n        // in connection with the DefaultLeaderElectionService generates the nested locking\n        final DefaultLeaderElectionService defaultLeaderElectionService =\n                new DefaultLeaderElectionService(\n                        testingLeaderElectionDriverFactory, fatalErrorHandler);\n        defaultLeaderElectionService.startLeaderElectionBackend();\n\n        // latch to detect when we reached the first synchronized section having a lock on the\n        // JobMasterServiceProcess#stop side\n        final OneShotLatch closeAsyncCalledTrigger = new OneShotLatch();\n        // latch to halt the JobMasterServiceProcess#stop before calling stop on the\n        // DefaultLeaderElectionService instance (and entering the LeaderElectionService's\n        // synchronized block)\n        final OneShotLatch triggerClassLoaderLeaseRelease = new OneShotLatch();\n\n        final JobMasterServiceProcess jobMasterServiceProcess =\n                TestingJobMasterServiceProcess.newBuilder()\n                        .setGetJobMasterGatewayFutureSupplier(CompletableFuture::new)\n                        .setGetResultFutureSupplier(CompletableFuture::new)\n                        .setGetLeaderAddressFutureSupplier(\n                                () -> CompletableFuture.completedFuture(\"unused address\"))\n                        .setCloseAsyncSupplier(\n                                () -> {\n                                    closeAsyncCalledTrigger.trigger();\n                                    // we have to return a completed future because we need the\n                                    // follow-up task to run in the calling thread to make the\n                                    // follow-up code block being executed in the synchronized block\n                                    return CompletableFuture.completedFuture(null);\n                                })\n                        .build();\n        try (final JobMasterServiceLeadershipRunner jobManagerRunner =\n                newJobMasterServiceLeadershipRunnerBuilder()\n                        .setClassLoaderLease(\n                                TestingClassLoaderLease.newBuilder()\n                                        .setCloseRunnable(\n                                                () -> {\n                                                    try {\n                                                        // we want to wait with releasing to halt\n                                                        // before calling stop on the\n                                                        // DefaultLeaderElectionService\n                                                        triggerClassLoaderLeaseRelease.await();\n                                                        // In order to reproduce the deadlock, we\n                                                        // need to ensure that\n                                                        // leaderContender#grantLeadership can be\n                                                        // called after\n                                                        // JobMasterServiceLeadershipRunner obtains\n                                                        // its own lock. Unfortunately, This will\n                                                        // change the running status of\n                                                        // DefaultLeaderElectionService\n                                                        // to false, which will cause the\n                                                        // notification of leadership to be\n                                                        // ignored. The issue is that we\n                                                        // don't have any means of verify that we're\n                                                        // in the synchronized block of\n                                                        // DefaultLeaderElectionService#lock in\n                                                        // DefaultLeaderElectionService#onGrantLeadership,\n                                                        // but we trigger this implicitly through\n                                                        // TestingLeaderElectionDriver#isLeader().\n                                                        // Adding a short sleep can ensure that\n                                                        // another thread successfully receives the\n                                                        // leadership notification, so that the\n                                                        // deadlock problem can recur.\n                                                        Thread.sleep(5);\n                                                    } catch (InterruptedException e) {\n                                                        ExceptionUtils.checkInterrupted(e);\n                                                    }\n                                                })\n                                        .build())\n                        .setJobMasterServiceProcessFactory(\n                                TestingJobMasterServiceProcessFactory.newBuilder()\n                                        .setJobMasterServiceProcessFunction(\n                                                ignoredSessionId -> jobMasterServiceProcess)\n                                        .build())\n                        .setLeaderElection(\n                                defaultLeaderElectionService.createLeaderElection(\n                                        \"random-contender-id\"))\n                        .build()) {\n            jobManagerRunner.start();\n\n            final TestingLeaderElectionDriver currentLeaderDriver =\n                    Preconditions.checkNotNull(\n                            testingLeaderElectionDriverFactory.getCurrentLeaderDriver());\n            // grant leadership to create jobMasterServiceProcess\n            currentLeaderDriver.isLeader();\n\n            while (currentLeaderDriver.getLeaderInformation().getLeaderSessionID() == null\n                    || !jobManagerRunner\n                            .getLeaderElection()\n                            .hasLeadership(\n                                    currentLeaderDriver\n                                            .getLeaderInformation()\n                                            .getLeaderSessionID())) {\n                Thread.sleep(100);\n            }\n\n            final CheckedThread contenderCloseThread = createCheckedThread(jobManagerRunner::close);\n            contenderCloseThread.start();\n\n            // waiting for the contender reaching the synchronized section of the stop call\n            closeAsyncCalledTrigger.await();\n\n            final CheckedThread grantLeadershipThread =\n                    createCheckedThread(\n                            () -> {\n                                // DefaultLeaderElectionService enforces a proper event handling\n                                // order (i.e. no two grant or revoke events should appear after\n                                // each other). This requires the leadership to be revoked before\n                                // regaining leadership in this test.\n                                currentLeaderDriver.notLeader();\n                                currentLeaderDriver.isLeader();\n                            });\n            grantLeadershipThread.start();\n\n            // finalize ClassloaderLease release to trigger DefaultLeaderElectionService#stop\n            triggerClassLoaderLeaseRelease.trigger();\n\n            contenderCloseThread.sync();\n            grantLeadershipThread.sync();\n        }\n    }",
          "conflictNames": [
              "testingLeaderElectionDriverFactory",
              "defaultLeaderElectionService",
              "closeAsyncCalledTrigger",
              "triggerClassLoaderLeaseRelease",
              "jobMasterServiceProcess",
              "jobManagerRunner",
              "contenderCloseThread",
              "grantLeadershipThread"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/7299da4cf688a2d87fd918b6327a0573bc88cbd8^1/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/FineGrainedSlotManager.java",
      "locators": [
          {
              "line": 823,
              "column": 31
          },
          {
              "line": 826,
              "column": 9
          },
          {
              "line": 830,
              "column": 53
          },
          {
              "line": 837,
              "column": 16
          }
      ],
      "old_name": "releaseResult",
      "new_name": "reconcileResult",
      "ctx": {
          "symbolName": "releaseResult",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ResourceReleaseResult",
          "scopeHint": "in checkTaskManagerReleasable(...)",
          "filePath": "FineGrainedSlotManager.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private boolean checkTaskManagerReleasable() {\n        ResourceReleaseResult releaseResult =\n                resourceAllocationStrategy.tryReleaseUnusedResources(taskManagerTracker);\n\n        releaseResult.getPendingTaskManagersToRelease().stream()\n                .map(PendingTaskManager::getPendingTaskManagerId)\n                .forEach(taskManagerTracker::removePendingTaskManager);\n\n        for (TaskManagerInfo taskManagerToRelease : releaseResult.getTaskManagersToRelease()) {\n            if (waitResultConsumedBeforeRelease) {\n                releaseIdleTaskExecutorIfPossible(taskManagerToRelease);\n            } else {\n                releaseIdleTaskExecutor(taskManagerToRelease.getInstanceId());\n            }\n        }\n        return releaseResult.needRelease();\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/72bff2a2d0072602e4e625476bf5480dc50dc76c^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultAllocatedSlotPoolTest.java",
      "locators": [
          {
              "line": 189,
              "column": 45
          },
          {
              "line": 191,
              "column": 17
          },
          {
              "line": 197,
              "column": 24
          },
          {
              "line": 210,
              "column": 46
          },
          {
              "line": 213,
              "column": 20
          },
          {
              "line": 226,
              "column": 25
          },
          {
              "line": 229,
              "column": 57
          },
          {
              "line": 240,
              "column": 49
          },
          {
              "line": 244,
              "column": 41
          },
          {
              "line": 320,
              "column": 25
          },
          {
              "line": 322,
              "column": 58
          },
          {
              "line": 324,
              "column": 49
          }
      ],
      "old_name": "freeSlotInfo",
      "new_name": "allocationId",
      "ctx": {
          "symbolName": "freeSlotInfo",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "FreeSlotInfo",
          "scopeHint": "in testFreeingOfReservedSlot(...)",
          "filePath": "DefaultAllocatedSlotPoolTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "veFreeSlot(slot.getAllocationId());\n\n        final int releaseTime = 1;\n        assertThat(slotPool.freeReservedSlot(slot.getAllocationId(), releaseTime)).isPresent();\n        assertSlotPoolContainsFreeSlots(slotPool, slots);\n\n        for (AllocatedSlotPool.FreeSlotInfo freeSlotInfo : slotPool.getFreeSlotsInformation()) {\n            final long time;\n            if (freeSlotInfo.getAllocationId().equals(slot.getAllocationId())) {\n                time = releaseTime;\n            } else {\n                time = initialTi",
          "conflictNames": [
              "slotPool",
              "slots",
              "initialTime",
              "slot",
              "releaseTime",
              "time"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/7341b6ef05090b0c0fb7034bad6033066f78de05^1/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/snapshot/ForStSnapshotStrategyBase.java",
      "locators": [
          {
              "line": 159,
              "column": 20
          },
          {
              "line": 176,
              "column": 21
          },
          {
              "line": 305,
              "column": 41
          },
          {
              "line": 315,
              "column": 33
          },
          {
              "line": 321,
              "column": 18
          },
          {
              "line": 321,
              "column": 37
          },
          {
              "line": 333,
              "column": 20
          }
      ],
      "old_name": "manifestFileName",
      "new_name": "manifestFile",
      "ctx": {
          "symbolName": "manifestFileName",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in syncPrepareResources(...)",
          "filePath": "ForStSnapshotStrategyBase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public ForStNativeSnapshotResources syncPrepareResources(long checkpointId) throws Exception {\n\n        final List<StateMetaInfoSnapshot> stateMetaInfoSnapshots =\n                new ArrayList<>(kvStateInformation.size());\n        final PreviousSnapshot previousSnapshot =\n                snapshotMetaData(checkpointId, stateMetaInfoSnapshots);\n\n        // Disable file deletion for file transformation. ForSt will decide whether to allow file\n        // deletion based on the number of calls to disableFileDeletions() and\n        // enableFileDeletions(), so disableFileDeletions() should be call only once.\n        db.disableFileDeletions();\n\n        try {\n            // get live files with flush memtable\n            RocksDB.LiveFiles liveFiles = db.getLiveFiles(true);\n            List<Path> liveFilesPath =\n                    liveFiles.files.stream()\n                            .map(file -> new Path(resourceContainer.getDbPath(), file))\n                            // Use manifest file name write CURRENT file to checkpoint directly.\n                            .filter(\n                                    file ->\n                                            !file.getName()\n                                                    .equals(ForStSnapshotUtil.CURRENT_FILE_NAME))\n                            .collect(Collectors.toList());\n\n            String manifestFileName =\n                    liveFilesPath.stream()\n                            .filter(\n                                    file ->\n                                            file.getName()\n                                                    .startsWith(\n                                                            ForStSnapshotUtil.MANIFEST_FILE_PREFIX))\n                            .findAny()\n                            .get() // there must be a manifest file.\n                            .getName();\n\n            logLiveFiles(checkpointId, liveFiles.manifestFileSize, liveFilesPath);\n\n            return new ForStNativeSnapshotResources(\n                    stateMetaInfoSnapshots,\n                    liveFiles.manifestFileSize,\n                    liveFilesPath,\n                    manifestFileName,\n                    previousSnapshot,\n                    () -> {\n                        try {\n                            db.enableFileDeletions(false);\n                            LOG.info(\n                                    \"Release one file deletion lock with ForStNativeSnapshotResources, backendUID:{}, checkpointId:{}.\",\n                                    backendUID,\n                                    checkpointId);\n                        } catch (RocksDBException e) {\n                            LOG.error(\n                                    \"Enable file deletion failed, backendUID:{}, checkpointId:{}.\",\n                                    backendUID,\n                                    checkpointId,\n                                    e);\n                        }\n                    });\n        } catch (Exception e) {\n            LOG.error(\n                    \"Exception thrown when prepare snapshot resources, enable file deletion and rethrow the exception, backendUID:{}, checkpointId:{}\",\n                    backendUID,\n                    checkpointId);\n            db.enableFileDeletions(false);\n            throw e;\n        }\n    }",
          "conflictNames": [
              "checkpointId",
              "stateMetaInfoSnapshots",
              "previousSnapshot",
              "liveFiles",
              "liveFilesPath"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/734e736a429089f3cd4ff66c7e774e735c035555^1/flink-runtime/src/main/java/org/apache/flink/streaming/api/operators/StreamingRuntimeContext.java",
      "locators": [
          {
              "line": 75,
              "column": 41
          },
          {
              "line": 124,
              "column": 66
          },
          {
              "line": 125,
              "column": 13
          },
          {
              "line": 126,
              "column": 28
          },
          {
              "line": 127,
              "column": 18
          },
          {
              "line": 127,
              "column": 38
          },
          {
              "line": 273,
              "column": 27
          },
          {
              "line": 275,
              "column": 16
          },
          {
              "line": 280,
              "column": 27
          },
          {
              "line": 282,
              "column": 16
          },
          {
              "line": 287,
              "column": 27
          },
          {
              "line": 289,
              "column": 16
          },
          {
              "line": 294,
              "column": 27
          },
          {
              "line": 296,
              "column": 16
          },
          {
              "line": 303,
              "column": 27
          },
          {
              "line": 305,
              "column": 16
          },
          {
              "line": 318,
              "column": 17
          },
          {
              "line": 322,
              "column": 16
          }
      ],
      "old_name": "keyedStateStoreV2",
      "new_name": "keyedStateStore",
      "ctx": {
          "symbolName": "keyedStateStoreV2",
          "symbolKind": "field",
          "language": "JAVA",
          "type": "KeyedStateStoreV2",
          "scopeHint": "in StreamingRuntimeContext",
          "filePath": "StreamingRuntimeContext.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "Environment taskEnvironment;\n\n    private final StreamConfig streamConfig;\n    private final String operatorUniqueID;\n    private final ProcessingTimeService processingTimeService;\n    private @Nullable KeyedStateStore keyedStateStore;\n    private @Nullable KeyedStateStoreV2 keyedStateStoreV2;\n    private SupportKeyedStateApiSet supportKeyedStateApiSet;\n    private final ExternalResourceInfoProvider externalResourceInfoProvider;\n\n    @VisibleForTesting\n    public StreamingRuntimeContext(\n            AbstractStreamOperator<?> ope",
          "conflictNames": [
              "taskEnvironment",
              "streamConfig",
              "operatorUniqueID",
              "processingTimeService",
              "keyedStateStore",
              "supportKeyedStateApiSet",
              "externalResourceInfoProvider"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/741ff29b67535427eedb7b8a757b6acbd12c40e5^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptivebatch/util/PointwiseVertexInputInfoComputer.java",
      "locators": [
          {
              "line": 62,
              "column": 56
          },
          {
              "line": 73,
              "column": 13
          },
          {
              "line": 83,
              "column": 16
          }
      ],
      "old_name": "vertexInputInfos",
      "new_name": "subpartitionSlices",
      "ctx": {
          "symbolName": "vertexInputInfos",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Map<IntermediateDataSetID, JobVertexInputInfo>",
          "scopeHint": "in compute(...)",
          "filePath": "PointwiseVertexInputInfoComputer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Computes the input information for a job vertex based on the provided blocking input\n     * information and parallelism.\n     *\n     * @param inputInfos List of blocking input information for the job vertex.\n     * @param parallelism Parallelism of the job vertex.\n     * @param dataVolumePerTask Proposed data volume per task for this set of inputInfo.\n     * @return A map of intermediate data set IDs to their corresponding job vertex input\n     *     information.\n     */\n    public Map<IntermediateDataSetID, JobVertexInputInfo> compute(\n            List<BlockingInputInfo> inputInfos, int parallelism, long dataVolumePerTask) {\n        long totalDataBytes =\n                inputInfos.stream().mapToLong(BlockingInputInfo::getNumBytesProduced).sum();\n        Map<IntermediateDataSetID, JobVertexInputInfo> vertexInputInfos = new HashMap<>();\n        for (BlockingInputInfo inputInfo : inputInfos) {\n            // Currently, we consider all inputs in this method must don't have inter-inputs key\n            // correlation. If other possibilities are introduced in the future, please add new\n            // branches to this method.\n            checkState(!inputInfo.areInterInputsKeysCorrelated());\n            if (inputInfo.isIntraInputKeyCorrelated()) {\n                // In this case, we won't split subpartitions within the same partition, so need\n                // to ensure NumPartitions >= parallelism.\n                checkState(parallelism <= inputInfo.getNumPartitions());\n            }\n            vertexInputInfos.put(\n                    inputInfo.getResultId(),\n                    computeVertexInputInfo(\n                            inputInfo,\n                            parallelism,\n                            calculateDataVolumePerTaskForInput(\n                                    dataVolumePerTask,\n                                    inputInfo.getNumBytesProduced(),\n                                    totalDataBytes)));\n        }\n        return vertexInputInfos;\n    }",
          "conflictNames": [
              "inputInfos",
              "parallelism",
              "dataVolumePerTask",
              "totalDataBytes"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/75fff378f809f2e49a55e03d11977d9bd2e33d5a^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptivebatch/DefaultVertexParallelismDecider.java",
      "locators": [
          {
              "line": 120,
              "column": 13
          },
          {
              "line": 122,
              "column": 48
          },
          {
              "line": 129,
              "column": 17
          }
      ],
      "old_name": "initialParallelism",
      "new_name": "initiallyDecidedParallelism",
      "ctx": {
          "symbolName": "initialParallelism",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in calculateParallelism(...)",
          "filePath": "DefaultVertexParallelismDecider.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private int calculateParallelism(List<BlockingResultInfo> consumedResults) {\n\n        long broadcastBytes =\n                consumedResults.stream()\n                        .filter(BlockingResultInfo::isBroadcast)\n                        .mapToLong(BlockingResultInfo::getNumBytesProduced)\n                        .sum();\n\n        long nonBroadcastBytes =\n                consumedResults.stream()\n                        .filter(consumedResult -> !consumedResult.isBroadcast())\n                        .mapToLong(BlockingResultInfo::getNumBytesProduced)\n                        .sum();\n\n        long expectedMaxBroadcastBytes =\n                (long) Math.ceil((dataVolumePerTask * CAP_RATIO_OF_BROADCAST));\n\n        if (broadcastBytes > expectedMaxBroadcastBytes) {\n            LOG.info(\n                    \"The size of broadcast data {} is larger than the expected maximum value {} ('{}' * {}).\"\n                            + \" Use {} as the size of broadcast data to decide the parallelism.\",\n                    new MemorySize(broadcastBytes),\n                    new MemorySize(expectedMaxBroadcastBytes),\n                    JobManagerOptions.ADAPTIVE_BATCH_SCHEDULER_AVG_DATA_VOLUME_PER_TASK.key(),\n                    CAP_RATIO_OF_BROADCAST,\n                    new MemorySize(expectedMaxBroadcastBytes));\n\n            broadcastBytes = expectedMaxBroadcastBytes;\n        }\n\n        int initialParallelism =\n                (int) Math.ceil((double) nonBroadcastBytes / (dataVolumePerTask - broadcastBytes));\n        int parallelism = normalizeParallelism(initialParallelism);\n\n        LOG.debug(\n                \"The size of broadcast data is {}, the size of non-broadcast data is {}, \"\n                        + \"the initially decided parallelism is {}, after normalize is {}\",\n                new MemorySize(broadcastBytes),\n                new MemorySize(nonBroadcastBytes),\n                initialParallelism,\n                parallelism);\n\n        if (parallelism < minParallelism) {\n            LOG.info(\n                    \"The initially normalized parallelism {} is smaller than the normalized minimum parallelism {}. \"\n                            + \"Use {} as the finally decided parallelism.\",\n                    parallelism,\n                    minParallelism,\n                    minParallelism);\n            parallelism = minParallelism;\n        } else if (parallelism > maxParallelism) {\n            LOG.info(\n                    \"The initially normalized parallelism {} is larger than the normalized maximum parallelism {}. \"\n                            + \"Use {} as the finally decided parallelism.\",\n                    parallelism,\n                    maxParallelism,\n                    maxParallelism);\n            parallelism = maxParallelism;\n        }\n\n        return parallelism;\n    }",
          "conflictNames": [
              "consumedResults",
              "broadcastBytes",
              "nonBroadcastBytes",
              "expectedMaxBroadcastBytes",
              "parallelism"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/76049d09e40a82f1222ed8a2e8279eda183f43f5^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/SlotSharingExecutionSlotAllocatorTest.java",
      "locators": [
          {
              "line": 74,
              "column": 35
          },
          {
              "line": 84,
              "column": 34
          },
          {
              "line": 621,
              "column": 73
          },
          {
              "line": 624,
              "column": 67
          },
          {
              "line": 625,
              "column": 18
          },
          {
              "line": 625,
              "column": 47
          },
          {
              "line": 631,
              "column": 20
          },
          {
              "line": 636,
              "column": 34
          },
          {
              "line": 641,
              "column": 63
          },
          {
              "line": 645,
              "column": 43
          },
          {
              "line": 647,
              "column": 17
          },
          {
              "line": 649,
              "column": 21
          },
          {
              "line": 650,
              "column": 21
          },
          {
              "line": 650,
              "column": 71
          },
          {
              "line": 653,
              "column": 51
          }
      ],
      "old_name": "executionSlotSharingGroup",
      "new_name": "slotSharingGroup",
      "ctx": {
          "symbolName": "executionSlotSharingGroup",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ExecutionSlotSharingGroup",
          "scopeHint": "in testSlotProfileRequestAskedBulkAndGroup(...)",
          "filePath": "SlotSharingExecutionSlotAllocatorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testSlotProfileRequestAskedBulkAndGroup() {\n        AllocationContext context = AllocationContext.newBuilder().addGroup(EV1, EV2).build();\n        ExecutionSlotSharingGroup executionSlotSharingGroup =\n                context.getSlotSharingStrategy().getExecutionSlotSharingGroup(EV1);\n\n        context.allocateSlotsFor(EV1, EV2);\n\n        List<Set<ExecutionVertexID>> askedBulks =\n                context.getSlotProfileRetrieverFactory().getAskedBulks();\n        assertThat(askedBulks).hasSize(1);\n        assertThat(askedBulks.get(0)).containsExactlyInAnyOrder(EV1, EV2);\n        assertThat(context.getSlotProfileRetrieverFactory().getAskedGroups())\n                .containsExactly(executionSlotSharingGroup);\n    }",
          "conflictNames": [
              "context",
              "askedBulks"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/763b30f4093ca93e49262a63e39fdb09e6a431a3^1/flink-python/src/main/java/org/apache/flink/table/runtime/typeutils/serializers/python/ArrayDataSerializer.java",
      "locators": [
          {
              "line": 183,
              "column": 33
          },
          {
              "line": 184,
              "column": 38
          },
          {
              "line": 185,
              "column": 47
          }
      ],
      "old_name": "newArrayDataSerializer",
      "new_name": "oldArrayDataSerializerSnapshot",
      "ctx": {
          "symbolName": "newArrayDataSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ArrayDataSerializer",
          "scopeHint": "in resolveSchemaCompatibility(...)",
          "filePath": "ArrayDataSerializer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public TypeSerializerSchemaCompatibility<ArrayData> resolveSchemaCompatibility(\n                TypeSerializer<ArrayData> newSerializer) {\n            if (!(newSerializer instanceof ArrayDataSerializer)) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            }\n\n            ArrayDataSerializer newArrayDataSerializer = (ArrayDataSerializer) newSerializer;\n            if (!previousType.equals(newArrayDataSerializer.elementType)\n                    || !previousEleSer.equals(newArrayDataSerializer.elementTypeSerializer)) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            } else {\n                return TypeSerializerSchemaCompatibility.compatibleAsIs();\n            }\n        }",
          "conflictNames": [
              "newSerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/763b30f4093ca93e49262a63e39fdb09e6a431a3^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/typeutils/ArrayDataSerializer.java",
      "locators": [
          {
              "line": 334,
              "column": 33
          },
          {
              "line": 335,
              "column": 38
          },
          {
              "line": 336,
              "column": 47
          }
      ],
      "old_name": "newArrayDataSerializer",
      "new_name": "oldArrayDataSerializerSnapshot",
      "ctx": {
          "symbolName": "newArrayDataSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ArrayDataSerializer",
          "scopeHint": "in resolveSchemaCompatibility(...)",
          "filePath": "ArrayDataSerializer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public TypeSerializerSchemaCompatibility<ArrayData> resolveSchemaCompatibility(\n                TypeSerializer<ArrayData> newSerializer) {\n            if (!(newSerializer instanceof ArrayDataSerializer)) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            }\n\n            ArrayDataSerializer newArrayDataSerializer = (ArrayDataSerializer) newSerializer;\n            if (!previousType.equals(newArrayDataSerializer.eleType)\n                    || !previousEleSer.equals(newArrayDataSerializer.eleSer)) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            } else {\n                return TypeSerializerSchemaCompatibility.compatibleAsIs();\n            }\n        }",
          "conflictNames": [
              "newSerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/76ebeb93257369c136a9eeabd5bacb71a9699968^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/AvailableInputsLocationsRetrieverTest.java",
      "locators": [
          {
              "line": 75,
              "column": 51
          },
          {
              "line": 77,
              "column": 20
          },
          {
              "line": 78,
              "column": 57
          }
      ],
      "old_name": "producers",
      "new_name": "consumedPartitionGroup",
      "ctx": {
          "symbolName": "producers",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Collection<Collection<ExecutionVertexID>>",
          "scopeHint": "in testConsumedResultPartitionsProducers(...)",
          "filePath": "AvailableInputsLocationsRetrieverTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testConsumedResultPartitionsProducers() {\n        TestingInputsLocationsRetriever originalLocationRetriever = getOriginalLocationRetriever();\n        InputsLocationsRetriever availableInputsLocationsRetriever =\n                new AvailableInputsLocationsRetriever(originalLocationRetriever);\n        Collection<Collection<ExecutionVertexID>> producers =\n                availableInputsLocationsRetriever.getConsumedResultPartitionsProducers(EV2);\n        assertThat(producers).hasSize(1);\n        Collection<ExecutionVertexID> resultProducers = producers.iterator().next();\n        assertThat(resultProducers).containsExactly(EV1);\n    }",
          "conflictNames": [
              "originalLocationRetriever",
              "availableInputsLocationsRetriever",
              "resultProducers"
          ]
      },
      "suggestions": [
          {
              "name": "consumedPartitionGroup",
              "confidence": 0.8
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/76ebeb93257369c136a9eeabd5bacb71a9699968^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetrieverTest.java",
      "locators": [
          {
              "line": 162,
              "column": 33
          },
          {
              "line": 163,
              "column": 72
          },
          {
              "line": 171,
              "column": 48
          },
          {
              "line": 174,
              "column": 60
          },
          {
              "line": 183,
              "column": 59
          }
      ],
      "old_name": "producerId1",
      "new_name": "producerIds",
      "ctx": {
          "symbolName": "producerId1",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ExecutionVertexID",
          "scopeHint": "in testInputLocationsIgnoresExcludedProducers(...)",
          "filePath": "DefaultPreferredLocationsRetrieverTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testInputLocationsIgnoresExcludedProducers() {\n        final TestingInputsLocationsRetriever.Builder locationRetrieverBuilder =\n                new TestingInputsLocationsRetriever.Builder();\n\n        final ExecutionVertexID consumerId = new ExecutionVertexID(new JobVertexID(), 0);\n\n        final JobVertexID producerJobVertexId = new JobVertexID();\n\n        final ExecutionVertexID producerId1 = new ExecutionVertexID(producerJobVertexId, 0);\n        locationRetrieverBuilder.connectConsumerToProducer(consumerId, producerId1);\n\n        final ExecutionVertexID producerId2 = new ExecutionVertexID(producerJobVertexId, 1);\n        locationRetrieverBuilder.connectConsumerToProducer(consumerId, producerId2);\n\n        final TestingInputsLocationsRetriever inputsLocationsRetriever =\n                locationRetrieverBuilder.build();\n\n        inputsLocationsRetriever.markScheduled(producerId1);\n        inputsLocationsRetriever.markScheduled(producerId2);\n\n        inputsLocationsRetriever.assignTaskManagerLocation(producerId1);\n        inputsLocationsRetriever.assignTaskManagerLocation(producerId2);\n\n        final PreferredLocationsRetriever locationsRetriever =\n                new DefaultPreferredLocationsRetriever(\n                        id -> Optional.empty(), inputsLocationsRetriever);\n\n        final CompletableFuture<Collection<TaskManagerLocation>> preferredLocations =\n                locationsRetriever.getPreferredLocations(\n                        consumerId, Collections.singleton(producerId1));\n\n        assertThat(preferredLocations.getNow(null)).hasSize(1);\n\n        final TaskManagerLocation producerLocation2 =\n                inputsLocationsRetriever.getTaskManagerLocation(producerId2).get().getNow(null);\n        assertThat(preferredLocations.getNow(null)).containsExactly(producerLocation2);\n    }",
          "conflictNames": [
              "locationRetrieverBuilder",
              "consumerId",
              "producerJobVertexId",
              "producerId2",
              "inputsLocationsRetriever",
              "locationsRetriever",
              "preferredLocations",
              "producerLocation2"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/76ebeb93257369c136a9eeabd5bacb71a9699968^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/ExecutionGraphToInputsLocationsRetrieverAdapterTest.java",
      "locators": [
          {
              "line": 76,
              "column": 51
          },
          {
              "line": 83,
              "column": 20
          }
      ],
      "old_name": "producersOfProducer1",
      "new_name": "consumedPartitionGroupsOfProducer1",
      "ctx": {
          "symbolName": "producersOfProducer1",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Collection<Collection<ExecutionVertexID>>",
          "scopeHint": "in testGetConsumedResultPartitionsProducers(...)",
          "filePath": "ExecutionGraphToInputsLocationsRetrieverAdapterTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Tests that can get the producers of consumed result partitions. */\n    @Test\n    void testGetConsumedResultPartitionsProducers() throws Exception {\n        final JobVertex producer1 = ExecutionGraphTestUtils.createNoOpVertex(1);\n        final JobVertex producer2 = ExecutionGraphTestUtils.createNoOpVertex(1);\n        final JobVertex consumer = ExecutionGraphTestUtils.createNoOpVertex(1);\n        consumer.connectNewDataSetAsInput(\n                producer1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED);\n        consumer.connectNewDataSetAsInput(\n                producer2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED);\n\n        final ExecutionGraph eg =\n                ExecutionGraphTestUtils.createExecutionGraph(\n                        EXECUTOR_EXTENSION.getExecutor(), producer1, producer2, consumer);\n        final ExecutionGraphToInputsLocationsRetrieverAdapter inputsLocationsRetriever =\n                new ExecutionGraphToInputsLocationsRetrieverAdapter(eg);\n\n        ExecutionVertexID evIdOfProducer1 = new ExecutionVertexID(producer1.getID(), 0);\n        ExecutionVertexID evIdOfProducer2 = new ExecutionVertexID(producer2.getID(), 0);\n        ExecutionVertexID evIdOfConsumer = new ExecutionVertexID(consumer.getID(), 0);\n\n        Collection<Collection<ExecutionVertexID>> producersOfProducer1 =\n                inputsLocationsRetriever.getConsumedResultPartitionsProducers(evIdOfProducer1);\n        Collection<Collection<ExecutionVertexID>> producersOfProducer2 =\n                inputsLocationsRetriever.getConsumedResultPartitionsProducers(evIdOfProducer2);\n        Collection<Collection<ExecutionVertexID>> producersOfConsumer =\n                inputsLocationsRetriever.getConsumedResultPartitionsProducers(evIdOfConsumer);\n\n        assertThat(producersOfProducer1).isEmpty();\n        assertThat(producersOfProducer2).isEmpty();\n        assertThat(producersOfConsumer).hasSize(2);\n        assertThat(producersOfConsumer)\n                .containsExactlyInAnyOrder(\n                        Collections.singletonList(evIdOfProducer1),\n                        Collections.singletonList(evIdOfProducer2));\n    }",
          "conflictNames": [
              "producer1",
              "producer2",
              "consumer",
              "eg",
              "inputsLocationsRetriever",
              "evIdOfProducer1",
              "evIdOfProducer2",
              "evIdOfConsumer",
              "producersOfProducer2",
              "producersOfConsumer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/76ebeb93257369c136a9eeabd5bacb71a9699968^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/ExecutionGraphToInputsLocationsRetrieverAdapterTest.java",
      "locators": [
          {
              "line": 78,
              "column": 51
          },
          {
              "line": 84,
              "column": 20
          }
      ],
      "old_name": "producersOfProducer2",
      "new_name": "consumedPartitionGroupsOfProducer2",
      "ctx": {
          "symbolName": "producersOfProducer2",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Collection<Collection<ExecutionVertexID>>",
          "scopeHint": "in testGetConsumedResultPartitionsProducers(...)",
          "filePath": "ExecutionGraphToInputsLocationsRetrieverAdapterTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Tests that can get the producers of consumed result partitions. */\n    @Test\n    void testGetConsumedResultPartitionsProducers() throws Exception {\n        final JobVertex producer1 = ExecutionGraphTestUtils.createNoOpVertex(1);\n        final JobVertex producer2 = ExecutionGraphTestUtils.createNoOpVertex(1);\n        final JobVertex consumer = ExecutionGraphTestUtils.createNoOpVertex(1);\n        consumer.connectNewDataSetAsInput(\n                producer1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED);\n        consumer.connectNewDataSetAsInput(\n                producer2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED);\n\n        final ExecutionGraph eg =\n                ExecutionGraphTestUtils.createExecutionGraph(\n                        EXECUTOR_EXTENSION.getExecutor(), producer1, producer2, consumer);\n        final ExecutionGraphToInputsLocationsRetrieverAdapter inputsLocationsRetriever =\n                new ExecutionGraphToInputsLocationsRetrieverAdapter(eg);\n\n        ExecutionVertexID evIdOfProducer1 = new ExecutionVertexID(producer1.getID(), 0);\n        ExecutionVertexID evIdOfProducer2 = new ExecutionVertexID(producer2.getID(), 0);\n        ExecutionVertexID evIdOfConsumer = new ExecutionVertexID(consumer.getID(), 0);\n\n        Collection<Collection<ExecutionVertexID>> producersOfProducer1 =\n                inputsLocationsRetriever.getConsumedResultPartitionsProducers(evIdOfProducer1);\n        Collection<Collection<ExecutionVertexID>> producersOfProducer2 =\n                inputsLocationsRetriever.getConsumedResultPartitionsProducers(evIdOfProducer2);\n        Collection<Collection<ExecutionVertexID>> producersOfConsumer =\n                inputsLocationsRetriever.getConsumedResultPartitionsProducers(evIdOfConsumer);\n\n        assertThat(producersOfProducer1).isEmpty();\n        assertThat(producersOfProducer2).isEmpty();\n        assertThat(producersOfConsumer).hasSize(2);\n        assertThat(producersOfConsumer)\n                .containsExactlyInAnyOrder(\n                        Collections.singletonList(evIdOfProducer1),\n                        Collections.singletonList(evIdOfProducer2));\n    }",
          "conflictNames": [
              "producer1",
              "producer2",
              "consumer",
              "eg",
              "inputsLocationsRetriever",
              "evIdOfProducer1",
              "evIdOfProducer2",
              "evIdOfConsumer",
              "producersOfProducer1",
              "producersOfConsumer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/76ebeb93257369c136a9eeabd5bacb71a9699968^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/ExecutionGraphToInputsLocationsRetrieverAdapterTest.java",
      "locators": [
          {
              "line": 80,
              "column": 51
          },
          {
              "line": 85,
              "column": 20
          },
          {
              "line": 86,
              "column": 20
          }
      ],
      "old_name": "producersOfConsumer",
      "new_name": "consumedPartitionGroupsOfConsumer",
      "ctx": {
          "symbolName": "producersOfConsumer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Collection<Collection<ExecutionVertexID>>",
          "scopeHint": "in testGetConsumedResultPartitionsProducers(...)",
          "filePath": "ExecutionGraphToInputsLocationsRetrieverAdapterTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Tests that can get the producers of consumed result partitions. */\n    @Test\n    void testGetConsumedResultPartitionsProducers() throws Exception {\n        final JobVertex producer1 = ExecutionGraphTestUtils.createNoOpVertex(1);\n        final JobVertex producer2 = ExecutionGraphTestUtils.createNoOpVertex(1);\n        final JobVertex consumer = ExecutionGraphTestUtils.createNoOpVertex(1);\n        consumer.connectNewDataSetAsInput(\n                producer1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED);\n        consumer.connectNewDataSetAsInput(\n                producer2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED);\n\n        final ExecutionGraph eg =\n                ExecutionGraphTestUtils.createExecutionGraph(\n                        EXECUTOR_EXTENSION.getExecutor(), producer1, producer2, consumer);\n        final ExecutionGraphToInputsLocationsRetrieverAdapter inputsLocationsRetriever =\n                new ExecutionGraphToInputsLocationsRetrieverAdapter(eg);\n\n        ExecutionVertexID evIdOfProducer1 = new ExecutionVertexID(producer1.getID(), 0);\n        ExecutionVertexID evIdOfProducer2 = new ExecutionVertexID(producer2.getID(), 0);\n        ExecutionVertexID evIdOfConsumer = new ExecutionVertexID(consumer.getID(), 0);\n\n        Collection<Collection<ExecutionVertexID>> producersOfProducer1 =\n                inputsLocationsRetriever.getConsumedResultPartitionsProducers(evIdOfProducer1);\n        Collection<Collection<ExecutionVertexID>> producersOfProducer2 =\n                inputsLocationsRetriever.getConsumedResultPartitionsProducers(evIdOfProducer2);\n        Collection<Collection<ExecutionVertexID>> producersOfConsumer =\n                inputsLocationsRetriever.getConsumedResultPartitionsProducers(evIdOfConsumer);\n\n        assertThat(producersOfProducer1).isEmpty();\n        assertThat(producersOfProducer2).isEmpty();\n        assertThat(producersOfConsumer).hasSize(2);\n        assertThat(producersOfConsumer)\n                .containsExactlyInAnyOrder(\n                        Collections.singletonList(evIdOfProducer1),\n                        Collections.singletonList(evIdOfProducer2));\n    }",
          "conflictNames": [
              "producer1",
              "producer2",
              "consumer",
              "eg",
              "inputsLocationsRetriever",
              "evIdOfProducer1",
              "evIdOfProducer2",
              "evIdOfConsumer",
              "producersOfProducer1",
              "producersOfProducer2"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/76ebeb93257369c136a9eeabd5bacb71a9699968^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetriever.java",
      "locators": [
          {
              "line": 87,
              "column": 57
          },
          {
              "line": 89,
              "column": 56
          }
      ],
      "old_name": "allProducers",
      "new_name": "consumedPartitionGroups",
      "ctx": {
          "symbolName": "allProducers",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Collection<Collection<ExecutionVertexID>>",
          "scopeHint": "in getPreferredLocationsBasedOnInputs(...)",
          "filePath": "DefaultPreferredLocationsRetriever.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private CompletableFuture<Collection<TaskManagerLocation>> getPreferredLocationsBasedOnInputs(\n            final ExecutionVertexID executionVertexId,\n            final Set<ExecutionVertexID> producersToIgnore) {\n\n        CompletableFuture<Collection<TaskManagerLocation>> preferredLocations =\n                CompletableFuture.completedFuture(Collections.emptyList());\n\n        final Collection<Collection<ExecutionVertexID>> allProducers =\n                inputsLocationsRetriever.getConsumedResultPartitionsProducers(executionVertexId);\n        for (Collection<ExecutionVertexID> producers : allProducers) {\n            final Collection<CompletableFuture<TaskManagerLocation>> locationsFutures =\n                    getInputLocationFutures(producersToIgnore, producers);\n\n            preferredLocations = combineLocations(preferredLocations, locationsFutures);\n        }\n        return preferredLocations;\n    }",
          "conflictNames": [
              "executionVertexId",
              "producersToIgnore",
              "preferredLocations",
              "locationsFutures"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/76ebeb93257369c136a9eeabd5bacb71a9699968^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultPreferredLocationsRetriever.java",
      "locators": [
          {
              "line": 57,
              "column": 42
          },
          {
              "line": 60,
              "column": 22
          },
          {
              "line": 68,
              "column": 70
          },
          {
              "line": 82,
              "column": 42
          },
          {
              "line": 89,
              "column": 44
          },
          {
              "line": 91,
              "column": 45
          },
          {
              "line": 91,
              "column": 64
          },
          {
              "line": 99,
              "column": 42
          },
          {
              "line": 100,
              "column": 49
          },
          {
              "line": 105,
              "column": 43
          },
          {
              "line": 107,
              "column": 18
          }
      ],
      "old_name": "producers",
      "new_name": "consumedPartitionGroup",
      "ctx": {
          "symbolName": "producers",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Collection<ExecutionVertexID>",
          "scopeHint": "in getPreferredLocationsBasedOnInputs(...)",
          "filePath": "DefaultPreferredLocationsRetriever.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "pletableFuture.completedFuture(Collections.emptyList());\n\n        final Collection<Collection<ExecutionVertexID>> allProducers =\n                inputsLocationsRetriever.getConsumedResultPartitionsProducers(executionVertexId);\n        for (Collection<ExecutionVertexID> producers : allProducers) {\n            final Collection<CompletableFuture<TaskManagerLocation>> locationsFutures =\n                    getInputLocationFutures(producersToIgnore, producers);\n\n            preferredLocations = combineLocations(preferr",
          "conflictNames": [
              "executionVertexId",
              "producersToIgnore",
              "preferredLocations",
              "allProducers",
              "locationsFutures"
          ]
      },
      "suggestions": [
          {
              "name": "consumedPartitionGroup",
              "confidence": 0.8
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/77231de60683753382ec8299a2a5d311e08b24e7^1/flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestServerEndpoint.java",
      "locators": [
          {
              "line": 516,
              "column": 22
          },
          {
              "line": 521,
              "column": 68
          },
          {
              "line": 538,
              "column": 25
          },
          {
              "line": 541,
              "column": 25
          },
          {
              "line": 550,
              "column": 20
          },
          {
              "line": 555,
              "column": 31
          },
          {
              "line": 558,
              "column": 32
          },
          {
              "line": 561,
              "column": 34
          },
          {
              "line": 564,
              "column": 33
          },
          {
              "line": 567,
              "column": 31
          }
      ],
      "old_name": "handlerURL",
      "new_name": "handlerUrl",
      "ctx": {
          "symbolName": "handlerURL",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in registerHandler(...)",
          "filePath": "RestServerEndpoint.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void registerHandler(\n            Router router,\n            Tuple2<RestHandlerSpecification, ChannelInboundHandler> specificationHandler,\n            Logger log) {\n        final String handlerURL = specificationHandler.f0.getTargetRestEndpointURL();\n        // setup versioned urls\n        for (final RestAPIVersion supportedVersion :\n                specificationHandler.f0.getSupportedAPIVersions()) {\n            final String versionedHandlerURL =\n                    '/' + supportedVersion.getURLVersionPrefix() + handlerURL;\n            log.debug(\n                    \"Register handler {} under {}@{}.\",\n                    specificationHandler.f1,\n                    specificationHandler.f0.getHttpMethod(),\n                    versionedHandlerURL);\n            registerHandler(\n                    router,\n                    versionedHandlerURL,\n                    specificationHandler.f0.getHttpMethod(),\n                    specificationHandler.f1);\n            if (supportedVersion.isDefaultVersion()) {\n                // setup unversioned url for convenience and backwards compatibility\n                log.debug(\n                        \"Register handler {} under {}@{}.\",\n                        specificationHandler.f1,\n                        specificationHandler.f0.getHttpMethod(),\n                        handlerURL);\n                registerHandler(\n                        router,\n                        handlerURL,\n                        specificationHandler.f0.getHttpMethod(),\n                        specificationHandler.f1);\n            }\n        }\n    }",
          "conflictNames": [
              "router",
              "specificationHandler",
              "log",
              "versionedHandlerURL"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/77231de60683753382ec8299a2a5d311e08b24e7^1/flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestServerEndpoint.java",
      "locators": [
          {
              "line": 520,
              "column": 26
          },
          {
              "line": 526,
              "column": 21
          },
          {
              "line": 529,
              "column": 21
          }
      ],
      "old_name": "versionedHandlerURL",
      "new_name": "versionedUrl",
      "ctx": {
          "symbolName": "versionedHandlerURL",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in registerHandler(...)",
          "filePath": "RestServerEndpoint.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void registerHandler(\n            Router router,\n            Tuple2<RestHandlerSpecification, ChannelInboundHandler> specificationHandler,\n            Logger log) {\n        final String handlerURL = specificationHandler.f0.getTargetRestEndpointURL();\n        // setup versioned urls\n        for (final RestAPIVersion supportedVersion :\n                specificationHandler.f0.getSupportedAPIVersions()) {\n            final String versionedHandlerURL =\n                    '/' + supportedVersion.getURLVersionPrefix() + handlerURL;\n            log.debug(\n                    \"Register handler {} under {}@{}.\",\n                    specificationHandler.f1,\n                    specificationHandler.f0.getHttpMethod(),\n                    versionedHandlerURL);\n            registerHandler(\n                    router,\n                    versionedHandlerURL,\n                    specificationHandler.f0.getHttpMethod(),\n                    specificationHandler.f1);\n            if (supportedVersion.isDefaultVersion()) {\n                // setup unversioned url for convenience and backwards compatibility\n                log.debug(\n                        \"Register handler {} under {}@{}.\",\n                        specificationHandler.f1,\n                        specificationHandler.f0.getHttpMethod(),\n                        handlerURL);\n                registerHandler(\n                        router,\n                        handlerURL,\n                        specificationHandler.f0.getHttpMethod(),\n                        specificationHandler.f1);\n            }\n        }\n    }",
          "conflictNames": [
              "router",
              "specificationHandler",
              "log",
              "handlerURL"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/773feebbb2426ab1a8f7684f59b9a73db8f6a613^1/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesLeaderElectionAndRetrievalITCase.java",
      "locators": [
          {
              "line": 70,
              "column": 22
          },
          {
              "line": 113,
              "column": 29
          },
          {
              "line": 126,
              "column": 59
          }
      ],
      "old_name": "contenderID",
      "new_name": "componentId",
      "ctx": {
          "symbolName": "contenderID",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in testLeaderElectionAndRetrieval(...)",
          "filePath": "KubernetesLeaderElectionAndRetrievalITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testLeaderElectionAndRetrieval() throws Exception {\n        final String contenderID = \"contender-id\";\n        final String leaderAddress = \"random-address\";\n        final String configMapName = LEADER_CONFIGMAP_NAME + UUID.randomUUID();\n        final FlinkKubeClient flinkKubeClient = KUBERNETES_EXTENSION.getFlinkKubeClient();\n        final Configuration configuration = KUBERNETES_EXTENSION.getConfiguration();\n\n        final String clusterId = configuration.getString(KubernetesConfigOptions.CLUSTER_ID);\n\n        // This will make the leader election retrieval time out if we won't process already\n        // existing leader information when starting it up.\n        configuration.set(\n                KubernetesHighAvailabilityOptions.KUBERNETES_LEASE_DURATION, Duration.ofHours(1));\n        configuration.set(\n                KubernetesHighAvailabilityOptions.KUBERNETES_RETRY_PERIOD, Duration.ofHours(1));\n        configuration.set(\n                KubernetesHighAvailabilityOptions.KUBERNETES_RENEW_DEADLINE, Duration.ofHours(1));\n\n        final List<AutoCloseable> closeables = new ArrayList<>();\n\n        final KubernetesConfigMapSharedWatcher configMapSharedWatcher =\n                flinkKubeClient.createConfigMapSharedWatcher(\n                        KubernetesUtils.getConfigMapLabels(\n                                clusterId, LABEL_CONFIGMAP_TYPE_HIGH_AVAILABILITY));\n        closeables.add(configMapSharedWatcher);\n\n        final TestingLeaderElectionListener electionEventHandler =\n                new TestingLeaderElectionListener();\n        try {\n            final KubernetesLeaderElectionDriver leaderElectionDriver =\n                    new KubernetesLeaderElectionDriver(\n                            new KubernetesLeaderElectionConfiguration(\n                                    configMapName, UUID.randomUUID().toString(), configuration),\n                            flinkKubeClient,\n                            electionEventHandler,\n                            configMapSharedWatcher,\n                            EXECUTOR_EXTENSION.getExecutor());\n            closeables.add(leaderElectionDriver);\n\n            final KubernetesLeaderRetrievalDriverFactory driverFactory =\n                    new KubernetesLeaderRetrievalDriverFactory(\n                            configMapSharedWatcher,\n                            EXECUTOR_EXTENSION.getExecutor(),\n                            configMapName,\n                            contenderID);\n\n            final TestingFatalErrorHandler fatalErrorHandler = new TestingFatalErrorHandler();\n            final TestingLeaderRetrievalEventHandler firstLeaderRetrievalEventHandler =\n                    new TestingLeaderRetrievalEventHandler();\n            closeables.add(\n                    driverFactory.createLeaderRetrievalDriver(\n                            firstLeaderRetrievalEventHandler, fatalErrorHandler));\n\n            // Wait for the driver to obtain leadership.\n            electionEventHandler.await(LeaderElectionEvent.IsLeaderEvent.class);\n            final LeaderInformation leaderInformation =\n                    LeaderInformation.known(UUID.randomUUID(), leaderAddress);\n            leaderElectionDriver.publishLeaderInformation(contenderID, leaderInformation);\n\n            // Check if the leader retrieval driver is notified about the leader address\n            awaitLeadership(firstLeaderRetrievalEventHandler, leaderInformation);\n\n            // Start a second leader retrieval that should be notified immediately because we\n            // already know who the leader is.\n            final TestingLeaderRetrievalEventHandler secondRetrievalEventHandler =\n                    new TestingLeaderRetrievalEventHandler();\n            closeables.add(\n                    driverFactory.createLeaderRetrievalDriver(\n                            secondRetrievalEventHandler, fatalErrorHandler));\n            awaitLeadership(secondRetrievalEventHandler, leaderInformation);\n        } finally {\n            for (AutoCloseable closeable : closeables) {\n                closeable.close();\n            }\n\n            flinkKubeClient.deleteConfigMap(configMapName).get();\n\n            electionEventHandler.failIfErrorEventHappened();\n        }\n    }",
          "conflictNames": [
              "leaderAddress",
              "configMapName",
              "flinkKubeClient",
              "configuration",
              "clusterId",
              "closeables",
              "configMapSharedWatcher",
              "electionEventHandler",
              "leaderElectionDriver",
              "driverFactory",
              "fatalErrorHandler",
              "firstLeaderRetrievalEventHandler",
              "leaderInformation",
              "secondRetrievalEventHandler"
          ]
      },
      "suggestions": [
          {
              "name": "componentId",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/773feebbb2426ab1a8f7684f59b9a73db8f6a613^1/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/DefaultLeaderElectionServiceTest.java",
      "locators": [
          {
              "line": 72,
              "column": 69
          },
          {
              "line": 82,
              "column": 85
          },
          {
              "line": 96,
              "column": 69
          },
          {
              "line": 107,
              "column": 85
          },
          {
              "line": 126,
              "column": 83
          },
          {
              "line": 289,
              "column": 26
          },
          {
              "line": 296,
              "column": 59
          },
          {
              "line": 527,
              "column": 69
          },
          {
              "line": 532,
              "column": 69
          },
          {
              "line": 538,
              "column": 85
          },
          {
              "line": 551,
              "column": 69
          },
          {
              "line": 584,
              "column": 55
          },
          {
              "line": 588,
              "column": 87
          },
          {
              "line": 596,
              "column": 63
          },
          {
              "line": 599,
              "column": 55
          },
          {
              "line": 603,
              "column": 87
          },
          {
              "line": 626,
              "column": 63
          },
          {
              "line": 627,
              "column": 63
          },
          {
              "line": 630,
              "column": 84
          },
          {
              "line": 631,
              "column": 87
          },
          {
              "line": 677,
              "column": 63
          },
          {
              "line": 678,
              "column": 63
          },
          {
              "line": 680,
              "column": 86
          },
          {
              "line": 716,
              "column": 69
          },
          {
              "line": 720,
              "column": 69
          },
          {
              "line": 749,
              "column": 69
          },
          {
              "line": 753,
              "column": 69
          },
          {
              "line": 777,
              "column": 69
          },
          {
              "line": 787,
              "column": 69
          },
          {
              "line": 809,
              "column": 69
          },
          {
              "line": 813,
              "column": 69
          },
          {
              "line": 836,
              "column": 69
          },
          {
              "line": 856,
              "column": 63
          },
          {
              "line": 859,
              "column": 55
          },
          {
              "line": 864,
              "column": 87
          },
          {
              "line": 885,
              "column": 69
          },
          {
              "line": 902,
              "column": 28
          },
          {
              "line": 903,
              "column": 25
          },
          {
              "line": 930,
              "column": 63
          },
          {
              "line": 931,
              "column": 63
          },
          {
              "line": 952,
              "column": 63
          },
          {
              "line": 953,
              "column": 63
          },
          {
              "line": 962,
              "column": 63
          },
          {
              "line": 971,
              "column": 77
          },
          {
              "line": 995,
              "column": 63
          },
          {
              "line": 1036,
              "column": 85
          },
          {
              "line": 1044,
              "column": 69
          },
          {
              "line": 1076,
              "column": 69
          },
          {
              "line": 1142,
              "column": 28
          },
          {
              "line": 1144,
              "column": 29
          },
          {
              "line": 1145,
              "column": 75
          },
          {
              "line": 1152,
              "column": 28
          },
          {
              "line": 1173,
              "column": 63
          },
          {
              "line": 1177,
              "column": 55
          },
          {
              "line": 1356,
              "column": 30
          },
          {
              "line": 1365,
              "column": 26
          },
          {
              "line": 1369,
              "column": 64
          },
          {
              "line": 1373,
              "column": 41
          },
          {
              "line": 1377,
              "column": 24
          },
          {
              "line": 1381,
              "column": 18
          },
          {
              "line": 1381,
              "column": 32
          }
      ],
      "old_name": "contenderID",
      "new_name": "componentId",
      "ctx": {
          "symbolName": "contenderID",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in testMultipleDriverCreations(...)",
          "filePath": "DefaultLeaderElectionServiceTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * The leadership can be granted as soon as the driver is instantiated. We need to make sure\n     * that the event is still handled properly while registering the contender.\n     */\n    @Test\n    void testMultipleDriverCreations() throws Exception {\n        final AtomicInteger closeCount = new AtomicInteger(0);\n        final TestingLeaderElectionDriver.Factory driverFactory =\n                new TestingLeaderElectionDriver.Factory(\n                        TestingLeaderElectionDriver.newNoOpBuilder()\n                                .setCloseConsumer(ignoredLock -> closeCount.incrementAndGet()));\n\n        try (final DefaultLeaderElectionService testInstance =\n                new DefaultLeaderElectionService(driverFactory)) {\n\n            final String contenderID = \"contender_id\";\n            final int numberOfStartCloseSessions = 2;\n            for (int i = 1; i <= numberOfStartCloseSessions; i++) {\n                assertThat(driverFactory.getCreatedDriverCount()).isEqualTo(i - 1);\n                assertThat(closeCount).hasValue(i - 1);\n\n                try (final LeaderElection leaderElection =\n                        testInstance.createLeaderElection(contenderID)) {\n                    leaderElection.startLeaderElection(\n                            TestingGenericLeaderContender.newBuilder().build());\n                }\n\n                assertThat(driverFactory.getCreatedDriverCount()).isEqualTo(i);\n                assertThat(closeCount).hasValue(i);\n            }\n        }\n    }",
          "conflictNames": [
              "closeCount",
              "driverFactory",
              "testInstance",
              "numberOfStartCloseSessions",
              "i",
              "leaderElection"
          ]
      },
      "suggestions": [
          {
              "name": "componentId",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/773feebbb2426ab1a8f7684f59b9a73db8f6a613^1/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/DefaultLeaderElectionServiceTest.java",
      "locators": [
          {
              "line": 630,
              "column": 42
          },
          {
              "line": 636,
              "column": 53
          },
          {
              "line": 644,
              "column": 69
          },
          {
              "line": 648,
              "column": 53
          }
      ],
      "old_name": "contenderIdWithChange",
      "new_name": "componentIdWithChange",
      "ctx": {
          "symbolName": "contenderIdWithChange",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in testAllLeaderInformationChangeEventWithPartialCorrection(...)",
          "filePath": "DefaultLeaderElectionServiceTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testAllLeaderInformationChangeEventWithPartialCorrection() throws Exception {\n        final AtomicReference<LeaderInformationRegister> storedLeaderInformation =\n                new AtomicReference<>();\n        new Context(storedLeaderInformation) {\n            {\n                runTestWithSynchronousEventHandling(\n                        () -> {\n                            final UUID leaderSessionID = UUID.randomUUID();\n                            grantLeadership(leaderSessionID);\n\n                            final LeaderInformationRegister correctLeaderInformationRegister =\n                                    storedLeaderInformation.get();\n                            assertThat(correctLeaderInformationRegister.getRegisteredContenderIDs())\n                                    .containsExactlyInAnyOrder(\n                                            contenderContext0.contenderID,\n                                            contenderContext1.contenderID);\n\n                            // change LeaderInformation partially on external storage\n                            final String contenderIdWithChange = contenderContext0.contenderID;\n                            final String contenderIdWithoutChange = contenderContext1.contenderID;\n                            final LeaderInformationRegister\n                                    partiallyChangedLeaderInformationRegister =\n                                            LeaderInformationRegister.clear(\n                                                    correctLeaderInformationRegister,\n                                                    contenderIdWithChange);\n                            storedLeaderInformation.set(partiallyChangedLeaderInformationRegister);\n                            leaderElectionService.onLeaderInformationChange(\n                                    partiallyChangedLeaderInformationRegister);\n\n                            assertThat(\n                                            storedLeaderInformation\n                                                    .get()\n                                                    .forContenderID(contenderIdWithChange))\n                                    .as(\"Removed leader information should have been reset.\")\n                                    .hasValue(\n                                            correctLeaderInformationRegister.forContenderIdOrEmpty(\n                                                    contenderIdWithChange));\n\n                            assertThat(\n                                            storedLeaderInformation\n                                                    .get()\n                                                    .forContenderID(contenderIdWithoutChange))\n                                    .hasValue(\n                                            correctLeaderInformationRegister.forContenderIdOrEmpty(\n                                                    contenderIdWithoutChange));\n                        });\n            }\n        };\n    }",
          "conflictNames": [
              "storedLeaderInformation",
              "leaderSessionID",
              "correctLeaderInformationRegister",
              "contenderIdWithoutChange",
              "partiallyChangedLeaderInformationRegister"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/773feebbb2426ab1a8f7684f59b9a73db8f6a613^1/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/DefaultLeaderElectionServiceTest.java",
      "locators": [
          {
              "line": 631,
              "column": 42
          },
          {
              "line": 653,
              "column": 69
          },
          {
              "line": 656,
              "column": 53
          }
      ],
      "old_name": "contenderIdWithoutChange",
      "new_name": "componentIdWithoutChange",
      "ctx": {
          "symbolName": "contenderIdWithoutChange",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in testAllLeaderInformationChangeEventWithPartialCorrection(...)",
          "filePath": "DefaultLeaderElectionServiceTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testAllLeaderInformationChangeEventWithPartialCorrection() throws Exception {\n        final AtomicReference<LeaderInformationRegister> storedLeaderInformation =\n                new AtomicReference<>();\n        new Context(storedLeaderInformation) {\n            {\n                runTestWithSynchronousEventHandling(\n                        () -> {\n                            final UUID leaderSessionID = UUID.randomUUID();\n                            grantLeadership(leaderSessionID);\n\n                            final LeaderInformationRegister correctLeaderInformationRegister =\n                                    storedLeaderInformation.get();\n                            assertThat(correctLeaderInformationRegister.getRegisteredContenderIDs())\n                                    .containsExactlyInAnyOrder(\n                                            contenderContext0.contenderID,\n                                            contenderContext1.contenderID);\n\n                            // change LeaderInformation partially on external storage\n                            final String contenderIdWithChange = contenderContext0.contenderID;\n                            final String contenderIdWithoutChange = contenderContext1.contenderID;\n                            final LeaderInformationRegister\n                                    partiallyChangedLeaderInformationRegister =\n                                            LeaderInformationRegister.clear(\n                                                    correctLeaderInformationRegister,\n                                                    contenderIdWithChange);\n                            storedLeaderInformation.set(partiallyChangedLeaderInformationRegister);\n                            leaderElectionService.onLeaderInformationChange(\n                                    partiallyChangedLeaderInformationRegister);\n\n                            assertThat(\n                                            storedLeaderInformation\n                                                    .get()\n                                                    .forContenderID(contenderIdWithChange))\n                                    .as(\"Removed leader information should have been reset.\")\n                                    .hasValue(\n                                            correctLeaderInformationRegister.forContenderIdOrEmpty(\n                                                    contenderIdWithChange));\n\n                            assertThat(\n                                            storedLeaderInformation\n                                                    .get()\n                                                    .forContenderID(contenderIdWithoutChange))\n                                    .hasValue(\n                                            correctLeaderInformationRegister.forContenderIdOrEmpty(\n                                                    contenderIdWithoutChange));\n                        });\n            }\n        };\n    }",
          "conflictNames": [
              "storedLeaderInformation",
              "leaderSessionID",
              "correctLeaderInformationRegister",
              "contenderIdWithChange",
              "partiallyChangedLeaderInformationRegister"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/773feebbb2426ab1a8f7684f59b9a73db8f6a613^1/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/DefaultLeaderElectionServiceTest.java",
      "locators": [
          {
              "line": 941,
              "column": 42
          },
          {
              "line": 944,
              "column": 81
          },
          {
              "line": 947,
              "column": 45
          },
          {
              "line": 962,
              "column": 76
          }
      ],
      "old_name": "otherContenderID",
      "new_name": "otherComponentId",
      "ctx": {
          "symbolName": "otherContenderID",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in testLeadershipChangeEventHandlingBeingIgnoredAfterLeaderElectionClose(...)",
          "filePath": "DefaultLeaderElectionServiceTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void testLeadershipChangeEventHandlingBeingIgnoredAfterLeaderElectionClose(\n            TriConsumer<LeaderElectionDriver.Listener, Iterable<String>, LeaderInformationRegister>\n                    callback)\n            throws Exception {\n        final AtomicReference<LeaderInformationRegister> storedLeaderInformation =\n                new AtomicReference<>();\n        new Context(storedLeaderInformation) {\n            {\n                runTestWithSynchronousEventHandling(\n                        () -> {\n                            grantLeadership();\n\n                            assertThat(storedLeaderInformation.get().getRegisteredContenderIDs())\n                                    .containsExactlyInAnyOrder(\n                                            contenderContext0.contenderID,\n                                            contenderContext1.contenderID);\n\n                            contenderContext0.leaderElection.close();\n\n                            // another contender adds its information to the external storage\n                            // having additional data stored in the register helps to check whether\n                            // the register was touched later on (the empty\n                            // LeaderInformationRegister is implemented as a singleton which would\n                            // prevent us from checking the identity of the external storage at the\n                            // end of the test)\n                            final String otherContenderID = createRandomContenderID();\n                            final LeaderInformation otherLeaderInformation =\n                                    LeaderInformation.known(\n                                            UUID.randomUUID(), \"address-for-\" + otherContenderID);\n                            final LeaderInformationRegister registerWithUnknownContender =\n                                    LeaderInformationRegister.of(\n                                            otherContenderID, otherLeaderInformation);\n                            storedLeaderInformation.set(registerWithUnknownContender);\n                            callback.accept(\n                                    leaderElectionService,\n                                    Arrays.asList(\n                                            contenderContext0.contenderID,\n                                            contenderContext1.contenderID),\n                                    storedLeaderInformation.get());\n\n                            final LeaderInformationRegister correctedExternalStorage =\n                                    storedLeaderInformation.get();\n                            assertThat(correctedExternalStorage.getRegisteredContenderIDs())\n                                    .as(\n                                            \"Only the still registered contender and the unknown one should have corrected its LeaderInformation.\")\n                                    .containsExactlyInAnyOrder(\n                                            contenderContext1.contenderID, otherContenderID);\n\n                            contenderContext1.leaderElection.close();\n\n                            final LeaderInformationRegister leftOverData =\n                                    storedLeaderInformation.get();\n\n                            callback.accept(\n                                    leaderElectionService,\n                                    Collections.singleton(contenderContext1.contenderID),\n                                    leftOverData);\n\n                            assertThat(storedLeaderInformation.get().getRegisteredContenderIDs())\n                                    .as(\n                                            \"The following identity check does only make sense if we're not using an empty register.\")\n                                    .hasSize(1);\n                            assertThat(storedLeaderInformation.get())\n                                    .as(\"The external storage shouldn't have been touched.\")\n                                    .isSameAs(leftOverData);\n                        });\n            }\n        };\n    }",
          "conflictNames": [
              "callback",
              "storedLeaderInformation",
              "otherLeaderInformation",
              "registerWithUnknownContender",
              "correctedExternalStorage",
              "leftOverData"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/773feebbb2426ab1a8f7684f59b9a73db8f6a613^1/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/DefaultLeaderElectionServiceTest.java",
      "locators": [
          {
              "line": 681,
              "column": 42
          },
          {
              "line": 686,
              "column": 53
          },
          {
              "line": 689,
              "column": 78
          }
      ],
      "old_name": "unknownContenderID",
      "new_name": "unknownComponentId",
      "ctx": {
          "symbolName": "unknownContenderID",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in testAllLeaderInformationChangeEventWithUnknownContenderID(...)",
          "filePath": "DefaultLeaderElectionServiceTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testAllLeaderInformationChangeEventWithUnknownContenderID() throws Exception {\n        final AtomicReference<LeaderInformationRegister> storedLeaderInformation =\n                new AtomicReference<>();\n        new Context(storedLeaderInformation) {\n            {\n                runTestWithSynchronousEventHandling(\n                        () -> {\n                            final UUID leaderSessionID = UUID.randomUUID();\n                            grantLeadership(leaderSessionID);\n\n                            final LeaderInformationRegister correctLeaderInformationRegister =\n                                    storedLeaderInformation.get();\n                            assertThat(correctLeaderInformationRegister.getRegisteredContenderIDs())\n                                    .containsExactlyInAnyOrder(\n                                            contenderContext0.contenderID,\n                                            contenderContext1.contenderID);\n\n                            // change LeaderInformation only affects an unregistered contenderID\n                            final String unknownContenderID = createRandomContenderID();\n                            final LeaderInformationRegister\n                                    partiallyChangedLeaderInformationRegister =\n                                            LeaderInformationRegister.merge(\n                                                    correctLeaderInformationRegister,\n                                                    unknownContenderID,\n                                                    LeaderInformation.known(\n                                                            UUID.randomUUID(),\n                                                            \"address-for-\" + unknownContenderID));\n                            storedLeaderInformation.set(partiallyChangedLeaderInformationRegister);\n                            leaderElectionService.onLeaderInformationChange(\n                                    partiallyChangedLeaderInformationRegister);\n\n                            assertThat(storedLeaderInformation.get())\n                                    .as(\n                                            \"The HA backend shouldn't have been touched by the service.\")\n                                    .isSameAs(partiallyChangedLeaderInformationRegister);\n                        });\n            }\n        };\n    }",
          "conflictNames": [
              "storedLeaderInformation",
              "leaderSessionID",
              "correctLeaderInformationRegister",
              "partiallyChangedLeaderInformationRegister"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/773feebbb2426ab1a8f7684f59b9a73db8f6a613^1/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/DefaultLeaderElectionService.java",
      "locators": [
          {
              "line": 79,
              "column": 37
          },
          {
              "line": 149,
              "column": 55
          },
          {
              "line": 155,
              "column": 58
          },
          {
              "line": 157,
              "column": 21
          },
          {
              "line": 158,
              "column": 52
          },
          {
              "line": 179,
              "column": 36
          },
          {
              "line": 180,
              "column": 22
          },
          {
              "line": 193,
              "column": 49
          },
          {
              "line": 195,
              "column": 21
          },
          {
              "line": 199,
              "column": 21
          },
          {
              "line": 208,
              "column": 41
          },
          {
              "line": 214,
              "column": 40
          },
          {
              "line": 217,
              "column": 54
          },
          {
              "line": 219,
              "column": 65
          },
          {
              "line": 220,
              "column": 25
          },
          {
              "line": 229,
              "column": 21
          },
          {
              "line": 231,
              "column": 84
          },
          {
              "line": 234,
              "column": 83
          },
          {
              "line": 235,
              "column": 21
          },
          {
              "line": 237,
              "column": 55
          },
          {
              "line": 239,
              "column": 57
          },
          {
              "line": 240,
              "column": 25
          },
          {
              "line": 243,
              "column": 66
          },
          {
              "line": 246,
              "column": 29
          },
          {
              "line": 254,
              "column": 53
          },
          {
              "line": 255,
              "column": 25
          },
          {
              "line": 317,
              "column": 20
          },
          {
              "line": 318,
              "column": 73
          },
          {
              "line": 321,
              "column": 17
          },
          {
              "line": 328,
              "column": 31
          },
          {
              "line": 333,
              "column": 74
          },
          {
              "line": 341,
              "column": 33
          },
          {
              "line": 344,
              "column": 25
          },
          {
              "line": 350,
              "column": 29
          },
          {
              "line": 356,
              "column": 29
          },
          {
              "line": 364,
              "column": 44
          },
          {
              "line": 367,
              "column": 57
          },
          {
              "line": 373,
              "column": 29
          },
          {
              "line": 384,
              "column": 67
          },
          {
              "line": 389,
              "column": 43
          },
          {
              "line": 391,
              "column": 56
          },
          {
              "line": 393,
              "column": 52
          },
          {
              "line": 412,
              "column": 25
          },
          {
              "line": 414,
              "column": 41
          },
          {
              "line": 418,
              "column": 59
          },
          {
              "line": 419,
              "column": 50
          },
          {
              "line": 434,
              "column": 66
          },
          {
              "line": 439,
              "column": 17
          },
          {
              "line": 442,
              "column": 37
          },
          {
              "line": 465,
              "column": 20
          },
          {
              "line": 470,
              "column": 62
          },
          {
              "line": 473,
              "column": 21
          },
          {
              "line": 477,
              "column": 21
          },
          {
              "line": 479,
              "column": 78
          },
          {
              "line": 483,
              "column": 77
          },
          {
              "line": 489,
              "column": 20
          },
          {
              "line": 508,
              "column": 21
          },
          {
              "line": 514,
              "column": 21
          },
          {
              "line": 519,
              "column": 21
          },
          {
              "line": 524,
              "column": 55
          },
          {
              "line": 596,
              "column": 50
          },
          {
              "line": 599,
              "column": 21
          },
          {
              "line": 601,
              "column": 70
          },
          {
              "line": 609,
              "column": 22
          },
          {
              "line": 612,
              "column": 57
          },
          {
              "line": 615,
              "column": 82
          },
          {
              "line": 618,
              "column": 33
          }
      ],
      "old_name": "contenderID",
      "new_name": "componentId",
      "ctx": {
          "symbolName": "contenderID",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in createLeaderElection(...)",
          "filePath": "DefaultLeaderElectionService.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "ion = LeaderInformationRegister.empty();\n\n        this.leadershipOperationExecutor = Preconditions.checkNotNull(leadershipOperationExecutor);\n\n        this.running = true;\n    }\n\n    @Override\n    public LeaderElection createLeaderElection(String contenderID) {\n        synchronized (lock) {\n            Preconditions.checkState(\n                    !leadershipOperationExecutor.isShutdown(),\n                    \"The service was already closed and cannot be reused.\");\n            Preconditions.ch"
      },
      "suggestions": [
          {
              "name": "componentId",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/773feebbb2426ab1a8f7684f59b9a73db8f6a613^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterServiceLeadershipRunnerTest.java",
      "locators": [
          {
              "line": 722,
              "column": 22
          },
          {
              "line": 724,
              "column": 67
          }
      ],
      "old_name": "contenderID",
      "new_name": "componentId",
      "ctx": {
          "symbolName": "contenderID",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in testJobMasterServiceLeadershipRunnerCloseWhenElectionServiceGrantLeaderShip(...)",
          "filePath": "JobMasterServiceLeadershipRunnerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Disabled\n    @Test\n    void testJobMasterServiceLeadershipRunnerCloseWhenElectionServiceGrantLeaderShip()\n            throws Exception {\n        final AtomicReference<LeaderInformationRegister> storedLeaderInformation =\n                new AtomicReference<>(LeaderInformationRegister.empty());\n\n        final TestingLeaderElectionDriver.Factory driverFactory =\n                new TestingLeaderElectionDriver.Factory(\n                        TestingLeaderElectionDriver.newBuilder(\n                                new AtomicBoolean(), storedLeaderInformation, new AtomicBoolean()));\n\n        // we need to use DefaultLeaderElectionService here because JobMasterServiceLeadershipRunner\n        // in connection with the DefaultLeaderElectionService generates the nested locking\n        final DefaultLeaderElectionService defaultLeaderElectionService =\n                new DefaultLeaderElectionService(driverFactory, fatalErrorHandler);\n\n        final TestingLeaderElectionDriver currentLeaderDriver =\n                driverFactory.assertAndGetOnlyCreatedDriver();\n\n        // latch to detect when we reached the first synchronized section having a lock on the\n        // JobMasterServiceProcess#stop side\n        final OneShotLatch closeAsyncCalledTrigger = new OneShotLatch();\n        // latch to halt the JobMasterServiceProcess#stop before calling stop on the\n        // DefaultLeaderElectionService instance (and entering the LeaderElectionService's\n        // synchronized block)\n        final OneShotLatch triggerClassLoaderLeaseRelease = new OneShotLatch();\n\n        final JobMasterServiceProcess jobMasterServiceProcess =\n                TestingJobMasterServiceProcess.newBuilder()\n                        .setGetJobMasterGatewayFutureSupplier(CompletableFuture::new)\n                        .setGetResultFutureSupplier(CompletableFuture::new)\n                        .setGetLeaderAddressFutureSupplier(\n                                () -> CompletableFuture.completedFuture(\"unused address\"))\n                        .setCloseAsyncSupplier(\n                                () -> {\n                                    closeAsyncCalledTrigger.trigger();\n                                    // we have to return a completed future because we need the\n                                    // follow-up task to run in the calling thread to make the\n                                    // follow-up code block being executed in the synchronized block\n                                    return CompletableFuture.completedFuture(null);\n                                })\n                        .build();\n        final String contenderID = \"random-contender-id\";\n        final LeaderElection leaderElection =\n                defaultLeaderElectionService.createLeaderElection(contenderID);\n        try (final JobMasterServiceLeadershipRunner jobManagerRunner =\n                newJobMasterServiceLeadershipRunnerBuilder()\n                        .setClassLoaderLease(\n                                TestingClassLoaderLease.newBuilder()\n                                        .setCloseRunnable(\n                                                () -> {\n                                                    try {\n                                                        // we want to wait with releasing to halt\n                                                        // before calling stop on the\n                                                        // DefaultLeaderElectionService\n                                                        triggerClassLoaderLeaseRelease.await();\n                                                        // In order to reproduce the deadlock, we\n                                                        // need to ensure that\n                                                        // leaderContender#grantLeadership can be\n                                                        // called after\n                                                        // JobMasterServiceLeadershipRunner obtains\n                                                        // its own lock. Unfortunately, This will\n                                                        // change the running status of\n                                                        // DefaultLeaderElectionService\n                                                        // to false, which will cause the\n                                                        // notification of leadership to be\n                                                        // ignored. The issue is that we\n                                                        // don't have any means of verify that we're\n                                                        // in the synchronized block of\n                                                        // DefaultLeaderElectionService#lock in\n                                                        // DefaultLeaderElectionService#onGrantLeadership,\n                                                        // but we trigger this implicitly through\n                                                        // TestingLeaderElectionDriver#grantLeadership(UUID).\n                                                        // Adding a short sleep can ensure that\n                                                        // another thread successfully receives the\n                                                        // leadership notification, so that the\n                                                        // deadlock problem can recur.\n                                                        Thread.sleep(5);\n                                                    } catch (InterruptedException e) {\n                                                        ExceptionUtils.checkInterrupted(e);\n                                                    }\n                                                })\n                                        .build())\n                        .setJobMasterServiceProcessFactory(\n                                TestingJobMasterServiceProcessFactory.newBuilder()\n                                        .setJobMasterServiceProcessFunction(\n                                                ignoredSessionId -> jobMasterServiceProcess)\n                                        .build())\n                        .setLeaderElection(leaderElection)\n                        .build()) {\n            jobManagerRunner.start();\n\n            // grant leadership to create jobMasterServiceProcess\n            final UUID leaderSessionID = UUID.randomUUID();\n            defaultLeaderElectionService.onGrantLeadership(leaderSessionID);\n\n            while (!currentLeaderDriver.hasLeadership()\n                    || !leaderElection.hasLeadership(leaderSessionID)) {\n                Thread.sleep(100);\n            }\n\n            final CheckedThread contenderCloseThread = createCheckedThread(jobManagerRunner::close);\n            contenderCloseThread.start();\n\n            // waiting for the contender reaching the synchronized section of the stop call\n            closeAsyncCalledTrigger.await();\n\n            final CheckedThread grantLeadershipThread =\n                    createCheckedThread(\n                            () -> {\n                                // DefaultLeaderElectionService enforces a proper event handling\n                                // order (i.e. no two grant or revoke events should appear after\n                                // each other). This requires the leadership to be revoked before\n                                // regaining leadership in this test.\n                                defaultLeaderElectionService.onRevokeLeadership();\n                                defaultLeaderElectionService.onGrantLeadership(UUID.randomUUID());\n                            });\n            grantLeadershipThread.start();\n\n            // finalize ClassloaderLease release to trigger DefaultLeaderElectionService#stop\n            triggerClassLoaderLeaseRelease.trigger();\n\n            contenderCloseThread.sync();\n            grantLeadershipThread.sync();\n        }\n    }",
          "conflictNames": [
              "storedLeaderInformation",
              "driverFactory",
              "defaultLeaderElectionService",
              "currentLeaderDriver",
              "closeAsyncCalledTrigger",
              "triggerClassLoaderLeaseRelease",
              "jobMasterServiceProcess",
              "leaderElection",
              "jobManagerRunner",
              "leaderSessionID",
              "contenderCloseThread",
              "grantLeadershipThread"
          ]
      },
      "suggestions": [
          {
              "name": "componentId",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/773feebbb2426ab1a8f7684f59b9a73db8f6a613^1/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/ZooKeeperLeaderElectionDriverTest.java",
      "locators": [
          {
              "line": 99,
              "column": 42
          },
          {
              "line": 104,
              "column": 53
          },
          {
              "line": 115,
              "column": 37
          },
          {
              "line": 134,
              "column": 42
          },
          {
              "line": 139,
              "column": 53
          },
          {
              "line": 148,
              "column": 37
          },
          {
              "line": 154,
              "column": 37
          },
          {
              "line": 185,
              "column": 42
          },
          {
              "line": 214,
              "column": 42
          },
          {
              "line": 214,
              "column": 57
          },
          {
              "line": 216,
              "column": 86
          },
          {
              "line": 231,
              "column": 48
          },
          {
              "line": 309,
              "column": 42
          },
          {
              "line": 309,
              "column": 57
          },
          {
              "line": 311,
              "column": 86
          },
          {
              "line": 332,
              "column": 48
          },
          {
              "line": 378,
              "column": 46
          },
          {
              "line": 380,
              "column": 59
          },
          {
              "line": 408,
              "column": 24
          }
      ],
      "old_name": "contenderID",
      "new_name": "componentId",
      "ctx": {
          "symbolName": "contenderID",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in testPublishLeaderInformation(...)",
          "filePath": "ZooKeeperLeaderElectionDriverTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testPublishLeaderInformation() throws Exception {\n        new Context() {\n            {\n                runTest(\n                        () -> {\n                            leaderElectionListener.await(LeaderElectionEvent.IsLeaderEvent.class);\n\n                            final String contenderID = \"retrieved-component\";\n                            final DefaultLeaderRetrievalService defaultLeaderRetrievalService =\n                                    new DefaultLeaderRetrievalService(\n                                            new ZooKeeperLeaderRetrievalDriverFactory(\n                                                    curatorFramework.asCuratorFramework(),\n                                                    contenderID,\n                                                    ZooKeeperLeaderRetrievalDriver\n                                                            .LeaderInformationClearancePolicy\n                                                            .ON_LOST_CONNECTION));\n\n                            final TestingListener leaderRetrievalListener = new TestingListener();\n                            defaultLeaderRetrievalService.start(leaderRetrievalListener);\n\n                            final LeaderInformation leaderInformation =\n                                    LeaderInformation.known(UUID.randomUUID(), \"foobar\");\n                            leaderElectionDriver.publishLeaderInformation(\n                                    contenderID, leaderInformation);\n\n                            leaderRetrievalListener.waitForNewLeader();\n\n                            assertThat(leaderRetrievalListener.getLeader())\n                                    .isEqualTo(leaderInformation);\n                        });\n            }\n        };\n    }",
          "conflictNames": [
              "defaultLeaderRetrievalService",
              "leaderRetrievalListener",
              "leaderInformation"
          ]
      },
      "suggestions": [
          {
              "name": "componentId",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/773feebbb2426ab1a8f7684f59b9a73db8f6a613^1/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/LeaderInformationRegisterTest.java",
      "locators": [
          {
              "line": 33,
              "column": 22
          },
          {
              "line": 38,
              "column": 46
          },
          {
              "line": 39,
              "column": 78
          },
          {
              "line": 40,
              "column": 48
          },
          {
              "line": 45,
              "column": 22
          },
          {
              "line": 47,
              "column": 46
          },
          {
              "line": 50,
              "column": 48
          },
          {
              "line": 55,
              "column": 22
          },
          {
              "line": 64,
              "column": 46
          },
          {
              "line": 72,
              "column": 44
          },
          {
              "line": 73,
              "column": 47
          },
          {
              "line": 79,
              "column": 22
          },
          {
              "line": 86,
              "column": 46
          },
          {
              "line": 93,
              "column": 77
          },
          {
              "line": 99,
              "column": 22
          },
          {
              "line": 104,
              "column": 46
          },
          {
              "line": 108,
              "column": 42
          },
          {
              "line": 112,
              "column": 47
          },
          {
              "line": 117,
              "column": 22
          },
          {
              "line": 122,
              "column": 46
          },
          {
              "line": 127,
              "column": 66
          },
          {
              "line": 130,
              "column": 77
          },
          {
              "line": 131,
              "column": 47
          },
          {
              "line": 136,
              "column": 22
          },
          {
              "line": 141,
              "column": 46
          },
          {
              "line": 144,
              "column": 66
          },
          {
              "line": 148,
              "column": 47
          },
          {
              "line": 153,
              "column": 22
          },
          {
              "line": 156,
              "column": 25
          },
          {
              "line": 162,
              "column": 77
          },
          {
              "line": 167,
              "column": 22
          },
          {
              "line": 171,
              "column": 22
          },
          {
              "line": 174,
              "column": 21
          },
          {
              "line": 175,
              "column": 21
          },
          {
              "line": 178,
              "column": 78
          },
          {
              "line": 179,
              "column": 48
          },
          {
              "line": 190,
              "column": 22
          },
          {
              "line": 194,
              "column": 54
          },
          {
              "line": 195,
              "column": 49
          },
          {
              "line": 201,
              "column": 22
          },
          {
              "line": 205,
              "column": 54
          },
          {
              "line": 206,
              "column": 56
          },
          {
              "line": 212,
              "column": 22
          },
          {
              "line": 214,
              "column": 54
          },
          {
              "line": 215,
              "column": 49
          },
          {
              "line": 221,
              "column": 22
          },
          {
              "line": 223,
              "column": 54
          },
          {
              "line": 224,
              "column": 56
          },
          {
              "line": 230,
              "column": 22
          },
          {
              "line": 234,
              "column": 54
          },
          {
              "line": 235,
              "column": 55
          },
          {
              "line": 241,
              "column": 22
          },
          {
              "line": 243,
              "column": 54
          },
          {
              "line": 244,
              "column": 55
          }
      ],
      "old_name": "contenderID",
      "new_name": "componentId",
      "ctx": {
          "symbolName": "contenderID",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in testOfWithKnownLeaderInformation(...)",
          "filePath": "LeaderInformationRegisterTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testOfWithKnownLeaderInformation() {\n        final String contenderID = \"contender-id\";\n        final LeaderInformation leaderInformation =\n                LeaderInformation.known(UUID.randomUUID(), \"address\");\n\n        final LeaderInformationRegister testInstance =\n                LeaderInformationRegister.of(contenderID, leaderInformation);\n        assertThat(testInstance.getRegisteredContenderIDs()).containsExactly(contenderID);\n        assertThat(testInstance.forContenderID(contenderID)).hasValue(leaderInformation);\n    }",
          "conflictNames": [
              "leaderInformation",
              "testInstance"
          ]
      },
      "suggestions": [
          {
              "name": "componentId",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/773feebbb2426ab1a8f7684f59b9a73db8f6a613^1/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/LeaderInformationRegisterTest.java",
      "locators": [
          {
              "line": 59,
              "column": 22
          },
          {
              "line": 68,
              "column": 42
          },
          {
              "line": 72,
              "column": 57
          },
          {
              "line": 74,
              "column": 47
          },
          {
              "line": 83,
              "column": 22
          },
          {
              "line": 90,
              "column": 42
          },
          {
              "line": 94,
              "column": 47
          }
      ],
      "old_name": "newContenderID",
      "new_name": "newComponentId",
      "ctx": {
          "symbolName": "newContenderID",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in testMerge(...)",
          "filePath": "LeaderInformationRegisterTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testMerge() {\n        final String contenderID = \"contender-id\";\n        final LeaderInformation leaderInformation =\n                LeaderInformation.known(UUID.randomUUID(), \"address\");\n\n        final String newContenderID = \"new-contender-id\";\n        final LeaderInformation newLeaderInformation =\n                LeaderInformation.known(UUID.randomUUID(), \"new-address\");\n\n        final LeaderInformationRegister initialRegister =\n                LeaderInformationRegister.of(contenderID, leaderInformation);\n\n        final LeaderInformationRegister newRegister =\n                LeaderInformationRegister.merge(\n                        initialRegister, newContenderID, newLeaderInformation);\n\n        assertThat(newRegister).isNotSameAs(initialRegister);\n        assertThat(newRegister.getRegisteredContenderIDs())\n                .containsExactlyInAnyOrder(contenderID, newContenderID);\n        assertThat(newRegister.forContenderID(contenderID)).hasValue(leaderInformation);\n        assertThat(newRegister.forContenderID(newContenderID)).hasValue(newLeaderInformation);\n    }",
          "conflictNames": [
              "contenderID",
              "leaderInformation",
              "newLeaderInformation",
              "initialRegister",
              "newRegister"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/773feebbb2426ab1a8f7684f59b9a73db8f6a613^1/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/LeaderInformationRegisterTest.java",
      "locators": [
          {
              "line": 171,
              "column": 22
          },
          {
              "line": 175,
              "column": 21
          },
          {
              "line": 179,
              "column": 48
          }
      ],
      "old_name": "contenderIDWithEmptyLeaderInformation",
      "new_name": "componentIdWithEmptyLeaderInformation",
      "ctx": {
          "symbolName": "contenderIDWithEmptyLeaderInformation",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in testEmptyLeaderInformationFiltering(...)",
          "filePath": "LeaderInformationRegisterTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testEmptyLeaderInformationFiltering() {\n        final String contenderID = \"contender-id\";\n        final LeaderInformation leaderInformation =\n                LeaderInformation.known(UUID.randomUUID(), \"address\");\n\n        final String contenderIDWithEmptyLeaderInformation = \"new-contender-id\";\n\n        final Map<String, LeaderInformation> records = new HashMap<>();\n        records.put(contenderID, leaderInformation);\n        records.put(contenderIDWithEmptyLeaderInformation, LeaderInformation.empty());\n\n        final LeaderInformationRegister testInstance = new LeaderInformationRegister(records);\n        assertThat(testInstance.getRegisteredContenderIDs()).containsExactly(contenderID);\n        assertThat(testInstance.forContenderID(contenderIDWithEmptyLeaderInformation))\n                .isNotPresent();\n    }",
          "conflictNames": [
              "contenderID",
              "leaderInformation",
              "records",
              "testInstance"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/773feebbb2426ab1a8f7684f59b9a73db8f6a613^1/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/DefaultLeaderElectionTest.java",
      "locators": [
          {
              "line": 42,
              "column": 39
          },
          {
              "line": 48,
              "column": 37
          },
          {
              "line": 58,
              "column": 24
          },
          {
              "line": 97,
              "column": 39
          },
          {
              "line": 104,
              "column": 37
          },
          {
              "line": 116,
              "column": 24
          },
          {
              "line": 168,
              "column": 39
          },
          {
              "line": 174,
              "column": 37
          },
          {
              "line": 185,
              "column": 24
          }
      ],
      "old_name": "contenderIDRef",
      "new_name": "componentIdRef",
      "ctx": {
          "symbolName": "contenderIDRef",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "AtomicReference<String>",
          "scopeHint": "in testContenderRegistration(...)",
          "filePath": "DefaultLeaderElectionTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testContenderRegistration() throws Exception {\n        final AtomicReference<String> contenderIDRef = new AtomicReference<>();\n        final AtomicReference<LeaderContender> contenderRef = new AtomicReference<>();\n        final DefaultLeaderElection.ParentService parentService =\n                TestingAbstractLeaderElectionService.newBuilder()\n                        .setRegisterConsumer(\n                                (actualContenderID, actualContender) -> {\n                                    contenderIDRef.set(actualContenderID);\n                                    contenderRef.set(actualContender);\n                                })\n                        .build();\n        try (final DefaultLeaderElection testInstance =\n                new DefaultLeaderElection(parentService, DEFAULT_TEST_CONTENDER_ID)) {\n\n            final LeaderContender contender = TestingGenericLeaderContender.newBuilder().build();\n            testInstance.startLeaderElection(contender);\n\n            assertThat(contenderIDRef).hasValue(DEFAULT_TEST_CONTENDER_ID);\n            assertThat(contenderRef.get()).isSameAs(contender);\n        }\n    }",
          "conflictNames": [
              "contenderRef",
              "parentService",
              "testInstance",
              "contender"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/773feebbb2426ab1a8f7684f59b9a73db8f6a613^1/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/TestingLeaderElectionDriver.java",
      "locators": [
          {
              "line": 65,
              "column": 49
          },
          {
              "line": 66,
              "column": 55
          },
          {
              "line": 70,
              "column": 48
          },
          {
              "line": 71,
              "column": 54
          },
          {
              "line": 125,
              "column": 32
          },
          {
              "line": 133,
              "column": 61
          },
          {
              "line": 141,
              "column": 32
          },
          {
              "line": 148,
              "column": 70
          }
      ],
      "old_name": "contenderID",
      "new_name": "componentId",
      "ctx": {
          "symbolName": "contenderID",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in publishLeaderInformation(...)",
          "filePath": "TestingLeaderElectionDriver.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "eaderInformationConsumer;\n        this.closeConsumer = closeConsumer;\n    }\n\n    @Override\n    public boolean hasLeadership() {\n        return hasLeadershipFunction.apply(lock);\n    }\n\n    @Override\n    public void publishLeaderInformation(String contenderID, LeaderInformation leaderInformation) {\n        publishLeaderInformationConsumer.accept(lock, contenderID, leaderInformation);\n    }\n\n    @Override\n    public void deleteLeaderInformation(String contenderID) {\n        deleteLeaderInformati",
          "conflictNames": [
              "leaderInformation"
          ]
      },
      "suggestions": [
          {
              "name": "componentId",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/773feebbb2426ab1a8f7684f59b9a73db8f6a613^1/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/ZooKeeperLeaderElectionDriver.java",
      "locators": [
          {
              "line": 204,
              "column": 26
          },
          {
              "line": 207,
              "column": 60
          },
          {
              "line": 209,
              "column": 62
          },
          {
              "line": 227,
              "column": 26
          },
          {
              "line": 229,
              "column": 62
          }
      ],
      "old_name": "leaderName",
      "new_name": "componentId",
      "ctx": {
          "symbolName": "leaderName",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in handleChangedLeaderInformation(...)",
          "filePath": "ZooKeeperLeaderElectionDriver.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void handleChangedLeaderInformation(ChildData childData) {\n        if (shouldHandleLeaderInformationEvent(childData.getPath())) {\n            final String leaderName = extractLeaderName(childData.getPath());\n\n            final LeaderInformation leaderInformation =\n                    tryReadingLeaderInformation(childData, leaderName);\n\n            leaderElectionListener.onLeaderInformationChange(leaderName, leaderInformation);\n        }\n    }",
          "conflictNames": [
              "childData",
              "leaderInformation"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/79254c1a3402392d6c883e51d83f7d4f7e43a97f^1/flink-libraries/flink-state-processing-api/src/main/java/org/apache/flink/state/table/SavepointDynamicTableSourceFactory.java",
      "locators": [
          {
              "line": 89,
              "column": 30
          },
          {
              "line": 93,
              "column": 29
          },
          {
              "line": 94,
              "column": 22
          },
          {
              "line": 95,
              "column": 37
          },
          {
              "line": 193,
              "column": 17
          }
      ],
      "old_name": "keyFormat",
      "new_name": "keyTypeInfo",
      "ctx": {
          "symbolName": "keyFormat",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in createDynamicTableSource(...)",
          "filePath": "SavepointDynamicTableSourceFactory.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "\n    @Override\n    public DynamicTableSource createDynamicTableSource(Context context) {\n        Configuration options = new Configuration();\n        context.getCatalogTable().getOptions().forEach(options::setString);\n\n        final String stateBackendType = options.getOptional(STATE_BACKEND_TYPE).orElse(null);\n        final String statePath = options.get(STATE_PATH);\n        final OperatorIdentifier operatorIdentifier = getOperatorIdentifier(options);\n\n        final Tuple2<Integer, int[]> keyValueProjections =\n                createKeyValueProjections(context.getCatalogTable());\n\n        LogicalType logicalType = context.getPhysicalRowDataType().getLogicalType();\n        Preconditions.checkArgument(logicalType.is(LogicalTypeRoot.ROW), \"Row data type expected.\");\n        RowType rowType = (RowType) logicalType;\n\n        Set<ConfigOption<?>> requiredOptions = new HashSet<>(requiredOptions());\n        Set<ConfigOption<?>> optionalOptions = new HashSet<>(optionalOptions());\n\n        RowType.RowField keyRowField = rowType.getFields().get(keyValueProjections.f0);\n        ConfigOption<String> keyFormatOption =\n                key(String.format(\"%s.%s.%s\", FIELDS, keyRowField.getName(), VALUE_FORMAT))\n                        .stringType()\n                        .noDefaultValue();\n        optionalOptions.add(keyFormatOption);\n        final String keyFormat =\n                options.getOptional(keyFormatOption)\n                        .orElseGet(\n                                () ->\n                                        inferStateValueFormat(\n                                                keyRowField.getName(), keyRowField.getType()));\n\n        final Tuple2<Integer, List<StateValueColumnConfiguration>> keyValueConfigProjections =\n                Tuple2.of(\n                        keyValueProjections.f0,\n                        Arrays.stream(keyValueProjections.f1)\n                                .mapToObj(\n                                        columnIndex -> {\n                                            RowType.RowField valueRowField =\n                                                    rowType.getFields().get(columnIndex);\n\n                                            ConfigOption<String> stateNameOption =\n                                                    key(String.format(\n                                                                    \"%s.%s.%s\",\n                                                                    FIELDS,\n                                                                    valueRowField.getName(),\n                                                                    STATE_NAME))\n                                                            .stringType()\n                                                            .noDefaultValue();\n                                            optionalOptions.add(stateNameOption);\n\n                                            ConfigOption<SavepointConnectorOptions.StateType>\n                                                    stateTypeOption =\n                                                            key(String.format(\n                                                                            \"%s.%s.%s\",\n                                                                            FIELDS,\n                                                                            valueRowField.getName(),\n                                                                            STATE_TYPE))\n                                                                    .enumType(\n                                                                            SavepointConnectorOptions\n                                                                                    .StateType\n                                                                                    .class)\n                                                                    .noDefaultValue();\n                                            optionalOptions.add(stateTypeOption);\n\n                                            ConfigOption<String> mapKeyFormatOption =\n                                                    key(String.format(\n                                                                    \"%s.%s.%s\",\n                                                                    FIELDS,\n                                                                    valueRowField.getName(),\n                                                                    MAP_KEY_FORMAT))\n                                                            .stringType()\n                                                            .noDefaultValue();\n                                            optionalOptions.add(mapKeyFormatOption);\n\n                                            ConfigOption<String> valueFormatOption =\n                                                    key(String.format(\n                                                                    \"%s.%s.%s\",\n                                                                    FIELDS,\n                                                                    valueRowField.getName(),\n                                                                    VALUE_FORMAT))\n                                                            .stringType()\n                                                            .noDefaultValue();\n                                            optionalOptions.add(valueFormatOption);\n\n                                            LogicalType valueLogicalType = valueRowField.getType();\n                                            return new StateValueColumnConfiguration(\n                                                    columnIndex,\n                                                    options.getOptional(stateNameOption)\n                                                            .orElse(valueRowField.getName()),\n                                                    options.getOptional(stateTypeOption)\n                                                            .orElseGet(\n                                                                    () ->\n                                                                            inferStateType(\n                                                                                    valueLogicalType)),\n                                                    options.getOptional(mapKeyFormatOption)\n                                                            .orElseGet(\n                                                                    () ->\n                                                                            inferStateMapKeyFormat(\n                                                                                    valueRowField\n                                                                                            .getName(),\n                                                                                    valueLogicalType)),\n                                                    options.getOptional(valueFormatOption)\n                                                            .orElseGet(\n                                                                    () ->\n                                                                            inferStateValueFormat(\n                                                                                    valueRowField\n                                                                                            .getName(),\n                                                                                    valueLogicalType)));\n                                        })\n                                .collect(Collectors.toList()));\n        FactoryUtil.validateFactoryOptions(requiredOptions, optionalOptions, options);\n\n        Set<String> consumedOptionKeys = new HashSet<>();\n        consumedOptionKeys.add(CONNECTOR.key());\n        requiredOptions.stream().map(ConfigOption::key).forEach(consumedOptionKeys::add);\n        optionalOptions.stream().map(ConfigOption::key).forEach(consumedOptionKeys::add);\n        FactoryUtil.validateUnconsumedKeys(\n                factoryIdentifier(), options.keySet(), consumedOptionKeys);\n\n        return new SavepointDynamicTableSource(\n                stateBackendType,\n                statePath,\n                operatorIdentifier,\n                keyFormat,\n                keyValueConfigProjections,\n                rowType);\n    }",
          "conflictNames": [
              "context",
              "options",
              "stateBackendType",
              "statePath",
              "operatorIdentifier",
              "keyValueProjections",
              "logicalType",
              "rowType",
              "requiredOptions",
              "optionalOptions",
              "keyRowField",
              "keyFormatOption",
              "keyValueConfigProjections",
              "valueRowField",
              "stateNameOption",
              "stateTypeOption",
              "mapKeyFormatOption",
              "valueFormatOption",
              "valueLogicalType",
              "consumedOptionKeys"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/795ec7f6a4555047e3b5ce85cbfc1fff0407b745^1/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/kubeclient/decorators/FlinkConfMountDecorator.java",
      "locators": [
          {
              "line": 183,
              "column": 20
          },
          {
              "line": 189,
              "column": 13
          },
          {
              "line": 190,
              "column": 35
          }
      ],
      "old_name": "log4jFile",
      "new_name": "file",
      "ctx": {
          "symbolName": "log4jFile",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "File",
          "scopeHint": "in getLocalLogConfFiles(...)",
          "filePath": "FlinkConfMountDecorator.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private List<File> getLocalLogConfFiles() {\n        final String confDir = kubernetesComponentConf.getConfigDirectory();\n        final File logbackFile = new File(confDir, CONFIG_FILE_LOGBACK_NAME);\n        final File log4jFile = new File(confDir, CONFIG_FILE_LOG4J_NAME);\n\n        List<File> localLogConfFiles = new ArrayList<>();\n        if (logbackFile.exists()) {\n            localLogConfFiles.add(logbackFile);\n        }\n        if (log4jFile.exists()) {\n            localLogConfFiles.add(log4jFile);\n        }\n\n        return localLogConfFiles;\n    }",
          "conflictNames": [
              "confDir",
              "logbackFile",
              "localLogConfFiles"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/7a709bf323c1cce3440887fe937311bae119aab0^1/flink-runtime/src/test/java/org/apache/flink/runtime/deployment/CachedShuffleDescriptorsTest.java",
      "locators": [
          {
              "line": 157,
              "column": 49
          },
          {
              "line": 160,
              "column": 17
          }
      ],
      "old_name": "nonOffloadedRaw",
      "new_name": "nonOffloaded",
      "ctx": {
          "symbolName": "nonOffloadedRaw",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "NonOffloadedRaw<ShuffleDescriptorGroup>",
          "scopeHint": "in assertNonOffloadedRawShuffleDescriptorAndIndexEquals(...)",
          "filePath": "CachedShuffleDescriptorsTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void assertNonOffloadedRawShuffleDescriptorAndIndexEquals(\n            MaybeOffloaded<ShuffleDescriptorGroup> maybeOffloaded,\n            List<ShuffleDescriptor> expectedDescriptors,\n            List<Integer> expectedIndices) {\n        assertThat(expectedDescriptors).hasSameSizeAs(expectedIndices);\n        assertThat(maybeOffloaded).isInstanceOf(NonOffloadedRaw.class);\n        NonOffloadedRaw<ShuffleDescriptorGroup> nonOffloadedRaw =\n                (NonOffloadedRaw<ShuffleDescriptorGroup>) maybeOffloaded;\n        ShuffleDescriptorAndIndex[] shuffleDescriptorAndIndices =\n                nonOffloadedRaw.value.getShuffleDescriptors();\n        assertThat(shuffleDescriptorAndIndices).hasSameSizeAs(expectedDescriptors);\n        for (int i = 0; i < shuffleDescriptorAndIndices.length; i++) {\n            assertThat(shuffleDescriptorAndIndices[i].getIndex()).isEqualTo(expectedIndices.get(i));\n            assertThat(shuffleDescriptorAndIndices[i].getShuffleDescriptor().getResultPartitionID())\n                    .isEqualTo(expectedDescriptors.get(i).getResultPartitionID());\n        }\n    }",
          "conflictNames": [
              "maybeOffloaded",
              "expectedDescriptors",
              "expectedIndices",
              "shuffleDescriptorAndIndices",
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/7a709bf323c1cce3440887fe937311bae119aab0^1/flink-runtime/src/main/java/org/apache/flink/runtime/deployment/InputGateDeploymentDescriptor.java",
      "locators": [
          {
              "line": 148,
              "column": 57
          },
          {
              "line": 151,
              "column": 25
          },
          {
              "line": 154,
              "column": 67
          }
      ],
      "old_name": "rawShuffleDescriptors",
      "new_name": "serializedShuffleDescriptors",
      "ctx": {
          "symbolName": "rawShuffleDescriptors",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "MaybeOffloaded<ShuffleDescriptorGroup>",
          "scopeHint": "in getShuffleDescriptors(...)",
          "filePath": "InputGateDeploymentDescriptor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "cenarios, in a production environment we always call\n            // tryLoadAndDeserializeShuffleDescriptors to deserialize ShuffleDescriptors first.\n            inputChannels = new ShuffleDescriptor[numberOfInputChannels];\n            for (MaybeOffloaded<ShuffleDescriptorGroup> rawShuffleDescriptors :\n                    serializedInputChannels) {\n                checkState(\n                        rawShuffleDescriptors instanceof NonOffloadedRaw,\n                        \"Trying to work with offloaded serialized shuffle descriptors.\")",
          "conflictNames": [
              "nonOffloadedRawValue"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/7a709bf323c1cce3440887fe937311bae119aab0^1/flink-runtime/src/main/java/org/apache/flink/runtime/deployment/InputGateDeploymentDescriptor.java",
      "locators": [
          {
              "line": 153,
              "column": 57
          },
          {
              "line": 155,
              "column": 48
          }
      ],
      "old_name": "nonOffloadedRawValue",
      "new_name": "nonOffloadedSerializedValue",
      "ctx": {
          "symbolName": "nonOffloadedRawValue",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "NonOffloadedRaw<ShuffleDescriptorGroup>",
          "scopeHint": "in getShuffleDescriptors(...)",
          "filePath": "InputGateDeploymentDescriptor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public ShuffleDescriptor[] getShuffleDescriptors() {\n        if (inputChannels == null) {\n            // This is only for testing scenarios, in a production environment we always call\n            // tryLoadAndDeserializeShuffleDescriptors to deserialize ShuffleDescriptors first.\n            inputChannels = new ShuffleDescriptor[numberOfInputChannels];\n            for (MaybeOffloaded<ShuffleDescriptorGroup> rawShuffleDescriptors :\n                    serializedInputChannels) {\n                checkState(\n                        rawShuffleDescriptors instanceof NonOffloadedRaw,\n                        \"Trying to work with offloaded serialized shuffle descriptors.\");\n                NonOffloadedRaw<ShuffleDescriptorGroup> nonOffloadedRawValue =\n                        (NonOffloadedRaw<ShuffleDescriptorGroup>) rawShuffleDescriptors;\n                putOrReplaceShuffleDescriptors(nonOffloadedRawValue.value);\n            }\n        }\n        return inputChannels;\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/7a709bf323c1cce3440887fe937311bae119aab0^1/flink-runtime/src/main/java/org/apache/flink/runtime/deployment/TaskDeploymentDescriptorFactory.java",
      "locators": [
          {
              "line": 508,
              "column": 68
          },
          {
              "line": 519,
              "column": 17
          },
          {
              "line": 520,
              "column": 71
          },
          {
              "line": 522,
              "column": 65
          }
      ],
      "old_name": "rawValueOrBlobKey",
      "new_name": "serializedValueOrBlobKey",
      "ctx": {
          "symbolName": "rawValueOrBlobKey",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Either<ShuffleDescriptorGroup, PermanentBlobKey>",
          "scopeHint": "in trySerializeAndOffloadShuffleDescriptor(...)",
          "filePath": "TaskDeploymentDescriptorFactory.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public MaybeOffloaded<ShuffleDescriptorGroup> trySerializeAndOffloadShuffleDescriptor(\n                ShuffleDescriptorGroup shuffleDescriptorGroup, int numConsumer) throws IOException {\n\n            final Either<ShuffleDescriptorGroup, PermanentBlobKey> rawValueOrBlobKey =\n                    shouldOffload(shuffleDescriptorGroup.getShuffleDescriptors(), numConsumer)\n                            ? BlobWriter.offloadWithException(\n                                            CompressedSerializedValue.fromObject(\n                                                    shuffleDescriptorGroup),\n                                            jobID,\n                                            blobWriter)\n                                    .map(Either::<ShuffleDescriptorGroup, PermanentBlobKey>Right)\n                                    .orElse(Either.Left(shuffleDescriptorGroup))\n                            : Either.Left(shuffleDescriptorGroup);\n\n            if (rawValueOrBlobKey.isLeft()) {\n                return new TaskDeploymentDescriptor.NonOffloadedRaw<>(rawValueOrBlobKey.left());\n            } else {\n                return new TaskDeploymentDescriptor.Offloaded<>(rawValueOrBlobKey.right());\n            }\n        }",
          "conflictNames": [
              "shuffleDescriptorGroup",
              "numConsumer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/7adeecd3445947f42d3e3d1e2961b9464e910236^1/flink-clients/src/main/java/org/apache/flink/client/cli/CliFrontendParser.java",
      "locators": [
          {
              "line": 151,
              "column": 22
          },
          {
              "line": 700,
              "column": 31
          },
          {
              "line": 702,
              "column": 17
          },
          {
              "line": 707,
              "column": 17
          },
          {
              "line": 715,
              "column": 17
          },
          {
              "line": 718,
              "column": 59
          }
      ],
      "old_name": "restoreMode",
      "new_name": "recoveryClaimMode",
      "ctx": {
          "symbolName": "restoreMode",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RestoreMode",
          "scopeHint": "in createSavepointRestoreSettings(...)",
          "filePath": "CliFrontendParser.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static SavepointRestoreSettings createSavepointRestoreSettings(CommandLine commandLine) {\n        if (commandLine.hasOption(SAVEPOINT_PATH_OPTION.getOpt())) {\n            String savepointPath = commandLine.getOptionValue(SAVEPOINT_PATH_OPTION.getOpt());\n            boolean allowNonRestoredState =\n                    commandLine.hasOption(SAVEPOINT_ALLOW_NON_RESTORED_OPTION.getOpt());\n            final RestoreMode restoreMode;\n            if (commandLine.hasOption(SAVEPOINT_CLAIM_MODE)) {\n                restoreMode =\n                        ConfigurationUtils.convertValue(\n                                commandLine.getOptionValue(SAVEPOINT_CLAIM_MODE),\n                                RestoreMode.class);\n            } else if (commandLine.hasOption(SAVEPOINT_RESTORE_MODE)) {\n                restoreMode =\n                        ConfigurationUtils.convertValue(\n                                commandLine.getOptionValue(SAVEPOINT_RESTORE_MODE),\n                                RestoreMode.class);\n                System.out.printf(\n                        \"The option '%s' is deprecated. Please use '%s' instead.%n\",\n                        SAVEPOINT_RESTORE_MODE.getLongOpt(), SAVEPOINT_CLAIM_MODE.getLongOpt());\n            } else {\n                restoreMode = StateRecoveryOptions.RESTORE_MODE.defaultValue();\n            }\n            return SavepointRestoreSettings.forPath(\n                    savepointPath, allowNonRestoredState, restoreMode);\n        } else {\n            return SavepointRestoreSettings.none();\n        }\n    }",
          "conflictNames": [
              "commandLine",
              "savepointPath",
              "allowNonRestoredState"
          ]
      },
      "suggestions": [
          {
              "name": "recoveryClaimMode",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/7adeecd3445947f42d3e3d1e2961b9464e910236^1/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTest.java",
      "locators": [
          {
              "line": 2914,
              "column": 26
          },
          {
              "line": 2932,
              "column": 29
          },
          {
              "line": 3038,
              "column": 29
          },
          {
              "line": 3082,
              "column": 29
          }
      ],
      "old_name": "restoreMode",
      "new_name": "recoveryClaimMode",
      "ctx": {
          "symbolName": "restoreMode",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "RestoreMode",
          "scopeHint": "in testSharedStateRegistrationOnRestore(...)",
          "filePath": "CheckpointCoordinatorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "      .isTrue();\n\n        assertThat(tracker.createSnapshot().getLatestRestoredCheckpoint().getCheckpointId())\n                .isEqualTo(42);\n    }\n\n    @Test\n    void testSharedStateRegistrationOnRestore() throws Exception {\n        for (RestoreMode restoreMode : RestoreMode.values()) {\n            JobVertexID jobVertexID1 = new JobVertexID();\n\n            int parallelism1 = 2;\n            int maxParallelism1 = 4;\n\n            ExecutionGraph graph =\n                    new CheckpointCoordinatorTe",
          "conflictNames": [
              "jobVertexID1",
              "parallelism1",
              "maxParallelism1",
              "graph",
              "jobVertex1",
              "checkpoints",
              "firstInstance",
              "store",
              "coordinatorBuilder",
              "coordinator",
              "numCheckpoints",
              "keyGroupPartitions1",
              "i",
              "completedCheckpoints",
              "sharedHandleCount",
              "sharedHandlesByCheckpoint",
              "cp",
              "incrementalKeyedStateHandle",
              "streamStateHandle",
              "tasks",
              "secondInstance",
              "secondStore",
              "secondCoordinator",
              "verificationMode"
          ]
      },
      "suggestions": [
          {
              "name": "recoveryClaimMode",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/7adeecd3445947f42d3e3d1e2961b9464e910236^1/flink-runtime-web/src/main/java/org/apache/flink/runtime/webmonitor/handlers/JarRunHandler.java",
      "locators": [
          {
              "line": 152,
              "column": 27
          },
          {
              "line": 159,
              "column": 35
          },
          {
              "line": 161,
              "column": 13
          },
          {
              "line": 172,
              "column": 67
          }
      ],
      "old_name": "restoreMode",
      "new_name": "recoveryClaimMode",
      "ctx": {
          "symbolName": "restoreMode",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RestoreMode",
          "scopeHint": "in getSavepointRestoreSettings(...)",
          "filePath": "JarRunHandler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private SavepointRestoreSettings getSavepointRestoreSettings(\n            final @Nonnull HandlerRequest<JarRunRequestBody> request,\n            final Configuration effectiveConfiguration)\n            throws RestHandlerException {\n\n        final JarRunRequestBody requestBody = request.getRequestBody();\n\n        final boolean allowNonRestoredState =\n                fromRequestBodyOrQueryParameter(\n                        requestBody.getAllowNonRestoredState(),\n                        () -> getQueryParameter(request, AllowNonRestoredStateQueryParameter.class),\n                        effectiveConfiguration.get(\n                                StateRecoveryOptions.SAVEPOINT_IGNORE_UNCLAIMED_STATE),\n                        log);\n        final String savepointPath =\n                fromRequestBodyOrQueryParameter(\n                        emptyToNull(requestBody.getSavepointPath()),\n                        () ->\n                                emptyToNull(\n                                        getQueryParameter(\n                                                request, SavepointPathQueryParameter.class)),\n                        effectiveConfiguration.get(StateRecoveryOptions.SAVEPOINT_PATH),\n                        log);\n        final RestoreMode restoreMode =\n                Optional.ofNullable(requestBody.getRestoreMode())\n                        .orElseGet(\n                                () ->\n                                        effectiveConfiguration.get(\n                                                StateRecoveryOptions.RESTORE_MODE));\n        if (requestBody.isDeprecatedRestoreModeHasValue()) {\n            log.warn(\"The option 'restoreMode' is deprecated, please use 'claimMode' instead.\");\n        }\n        if (restoreMode.equals(RestoreMode.LEGACY)) {\n            log.warn(\n                    \"The {} restore mode is deprecated, please use {} or {} mode instead.\",\n                    RestoreMode.LEGACY,\n                    RestoreMode.CLAIM,\n                    RestoreMode.NO_CLAIM);\n        }\n        final SavepointRestoreSettings savepointRestoreSettings;\n        if (savepointPath != null) {\n            savepointRestoreSettings =\n                    SavepointRestoreSettings.forPath(\n                            savepointPath, allowNonRestoredState, restoreMode);\n        } else {\n            savepointRestoreSettings = SavepointRestoreSettings.none();\n        }\n        return savepointRestoreSettings;\n    }",
          "conflictNames": [
              "request",
              "effectiveConfiguration",
              "requestBody",
              "allowNonRestoredState",
              "savepointPath",
              "savepointRestoreSettings"
          ]
      },
      "suggestions": [
          {
              "name": "recoveryClaimMode",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/7adeecd3445947f42d3e3d1e2961b9464e910236^1/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/SavepointRestoreSettings.java",
      "locators": [
          {
              "line": 51,
              "column": 40
          },
          {
              "line": 58,
              "column": 15
          },
          {
              "line": 61,
              "column": 85
          },
          {
              "line": 64,
              "column": 14
          },
          {
              "line": 64,
              "column": 28
          },
          {
              "line": 98,
              "column": 16
          },
          {
              "line": 113,
              "column": 35
          },
          {
              "line": 113,
              "column": 53
          },
          {
              "line": 119,
              "column": 32
          },
          {
              "line": 133,
              "column": 26
          },
          {
              "line": 134,
              "column": 23
          },
          {
              "line": 163,
              "column": 87
          },
          {
              "line": 165,
              "column": 83
          },
          {
              "line": 189,
              "column": 27
          },
          {
              "line": 192,
              "column": 85
          }
      ],
      "old_name": "restoreMode",
      "new_name": "recoveryClaimMode",
      "ctx": {
          "symbolName": "restoreMode",
          "symbolKind": "field",
          "language": "JAVA",
          "type": "RestoreMode",
          "scopeHint": "in SavepointRestoreSettings",
          "filePath": "SavepointRestoreSettings.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "nal String restorePath;\n\n    /**\n     * Flag indicating whether non restored state is allowed if the savepoint contains state for an\n     * operator that is not part of the job.\n     */\n    private final boolean allowNonRestoredState;\n\n    private final @Nonnull RestoreMode restoreMode;\n\n    /**\n     * Creates the restore settings.\n     *\n     * @param restorePath Savepoint restore path.\n     * @param allowNonRestoredState Ignore unmapped state.\n     * @param restoreMode how to restore from the savepoint\n     */\n    priva",
          "conflictNames": [
              "serialVersionUID",
              "NONE",
              "restorePath",
              "allowNonRestoredState"
          ]
      },
      "suggestions": [
          {
              "name": "recoveryClaimMode",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/7b35edeb3e343d9d35e432bb2c08f43055b96590^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/operators/process/ProcessTableOperator.java",
      "locators": [
          {
              "line": 109,
              "column": 49
          },
          {
              "line": 115,
              "column": 17
          },
          {
              "line": 117,
              "column": 35
          },
          {
              "line": 118,
              "column": 56
          }
      ],
      "old_name": "descriptor",
      "new_name": "stateDescriptor",
      "ctx": {
          "symbolName": "descriptor",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ValueStateDescriptor<RowData>",
          "scopeHint": "in open(...)",
          "filePath": "ProcessTableOperator.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    public void open() throws Exception {\n        super.open();\n\n        // Pass through columns\n        if (tableSemantics == null || tableSemantics.passColumnsThrough()) {\n            collector = new PassAllCollector(output);\n        } else {\n            collector = new PassPartitionKeysCollector(output, tableSemantics.partitionByColumns());\n        }\n        processTableRunner.runnerCollector = this.collector;\n\n        // State\n        final KeyedStateStore keyedStateStore = getKeyedStateStore();\n        stateDescriptors = new ValueStateDescriptor[stateInfos.size()];\n        stateHandles = new ValueState[stateInfos.size()];\n        stateToFunction = new RowData[stateInfos.size()];\n        stateCleared = new boolean[stateInfos.size()];\n        stateFromFunction = new RowData[stateInfos.size()];\n        for (int i = 0; i < stateInfos.size(); i++) {\n            final RuntimeStateInfo stateInfo = stateInfos.get(i);\n            final LogicalType type = stateInfo.getType();\n            final ValueStateDescriptor<RowData> descriptor =\n                    new ValueStateDescriptor(\n                            stateInfo.getStateName(), InternalSerializers.create(type));\n            final StateTtlConfig ttlConfig =\n                    StateConfigUtil.createTtlConfig(stateInfo.getTimeToLive());\n            if (ttlConfig.isEnabled()) {\n                descriptor.enableTimeToLive(ttlConfig);\n            }\n            stateDescriptors[i] = descriptor;\n            stateHandles[i] = keyedStateStore.getState(descriptor);\n        }\n\n        // Context\n        processTableRunner.runnerContext = new ProcessFunctionContext();\n\n        // Prepare runner\n        FunctionUtils.setFunctionRuntimeContext(processTableRunner, getRuntimeContext());\n        FunctionUtils.openFunction(processTableRunner, DefaultOpenContext.INSTANCE);\n    }",
          "conflictNames": [
              "keyedStateStore",
              "i",
              "stateInfo",
              "type",
              "ttlConfig"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/7b9b4e53a59ab8f4f2a99a6e162a794d264f7daf^1/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/RestHandlerConfiguration.java",
      "locators": [
          {
              "line": 34,
              "column": 23
          },
          {
              "line": 48,
              "column": 17
          },
          {
              "line": 58,
              "column": 14
          },
          {
              "line": 58,
              "column": 51
          },
          {
              "line": 72,
              "column": 16
          },
          {
              "line": 98,
              "column": 19
          },
          {
              "line": 116,
              "column": 17
          }
      ],
      "old_name": "maxCheckpointStatisticCacheEntries",
      "new_name": "checkpointHistorySize",
      "ctx": {
          "symbolName": "maxCheckpointStatisticCacheEntries",
          "symbolKind": "field",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in RestHandlerConfiguration",
          "filePath": "RestHandlerConfiguration.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "ons;\nimport org.apache.flink.util.Preconditions;\n\nimport java.io.File;\n\n/** Configuration object containing values for the rest handler configuration. */\npublic class RestHandlerConfiguration {\n\n    private final long refreshInterval;\n\n    private final int maxCheckpointStatisticCacheEntries;\n\n    private final Time timeout;\n\n    private final File webUiDir;\n\n    private final boolean webSubmitEnabled;\n\n    private final boolean webCancelEnabled;\n\n    private final boolean webRescaleEnabled;\n\n    public RestHandlerConfiguration",
          "conflictNames": [
              "refreshInterval",
              "timeout",
              "webUiDir",
              "webSubmitEnabled",
              "webCancelEnabled",
              "webRescaleEnabled"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/7bd5ea2cd13a28ab07e963fb4230916a664dafe2^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/SubpartitionRemoteCacheManagerTest.java",
      "locators": [
          {
              "line": 50,
              "column": 13
          },
          {
              "line": 61,
              "column": 58
          },
          {
              "line": 73,
              "column": 35
          },
          {
              "line": 75,
              "column": 36
          },
          {
              "line": 84,
              "column": 13
          },
          {
              "line": 93,
              "column": 60
          },
          {
              "line": 102,
              "column": 13
          },
          {
              "line": 110,
              "column": 35
          },
          {
              "line": 163,
              "column": 13
          },
          {
              "line": 174,
              "column": 58
          }
      ],
      "old_name": "segmentId",
      "new_name": "firstSegmentId",
      "ctx": {
          "symbolName": "segmentId",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in testStartAndFinishSegment(...)",
          "filePath": "SubpartitionRemoteCacheManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testStartAndFinishSegment() {\n        TieredStoragePartitionId partitionId =\n                TieredStorageIdMappingUtils.convertId(new ResultPartitionID());\n        int subpartitionId = 0;\n        int segmentId = 0;\n\n        AtomicInteger numReceivedBuffers = new AtomicInteger(0);\n        TestingPartitionFileWriter partitionFileWriter =\n                new TestingPartitionFileWriter.Builder()\n                        .setWriteFunction(\n                                (ignoredPartitionId, bufferContexts) -> {\n                                    numReceivedBuffers.addAndGet(\n                                            bufferContexts\n                                                    .get(subpartitionId)\n                                                    .getSegmentBufferContexts()\n                                                    .get(segmentId)\n                                                    .getBufferAndIndexes()\n                                                    .size());\n                                    return FutureUtils.completedVoidFuture();\n                                })\n                        .build();\n        SubpartitionRemoteCacheManager cacheManager =\n                new SubpartitionRemoteCacheManager(\n                        partitionId,\n                        subpartitionId,\n                        new TestingTieredStorageMemoryManager.Builder().build(),\n                        partitionFileWriter);\n        cacheManager.startSegment(segmentId);\n        cacheManager.addBuffer(BufferBuilderTestUtils.buildSomeBuffer());\n        cacheManager.finishSegment(segmentId);\n        assertThat(numReceivedBuffers).hasValue(1);\n    }",
          "conflictNames": [
              "partitionId",
              "subpartitionId",
              "numReceivedBuffers",
              "partitionFileWriter",
              "cacheManager"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/7cd6547a9027dfdc7ea97e496bb0e15213150529^1/flink-table/flink-table-api-java-bridge/src/main/java/org/apache/flink/connector/datagen/table/DataGenTableSourceFactory.java",
      "locators": [
          {
              "line": 144,
              "column": 31
          },
          {
              "line": 152,
              "column": 29
          }
      ],
      "old_name": "lenOption",
      "new_name": "varLenOption",
      "ctx": {
          "symbolName": "lenOption",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ConfigOption<Boolean>",
          "scopeHint": "in validateFieldOptions(...)",
          "filePath": "DataGenTableSourceFactory.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void validateFieldOptions(String name, DataType type, ReadableConfig options) {\n        ConfigOption<Boolean> lenOption =\n                key(DataGenConnectorOptionsUtil.FIELDS\n                                + \".\"\n                                + name\n                                + \".\"\n                                + DataGenConnectorOptionsUtil.VAR_LEN)\n                        .booleanType()\n                        .defaultValue(false);\n        options.getOptional(lenOption)\n                .filter(option -> option)\n                .ifPresent(\n                        option -> {\n                            LogicalType logicalType = type.getLogicalType();\n                            if (!(logicalType instanceof VarCharType\n                                    || logicalType instanceof VarBinaryType)) {\n                                throw new ValidationException(\n                                        String.format(\n                                                \"Only supports specifying '%s' option for variable-length types (varchar, string, varbinary, bytes). The type of field %s is not within this range.\",\n                                                \"fields.#.\" + DataGenConnectorOptionsUtil.VAR_LEN,\n                                                name));\n                            }\n                        });\n    }",
          "conflictNames": [
              "name",
              "type",
              "options",
              "logicalType"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/7d0111dfab640f2f590dd710d76de927c86cf83e^1/flink-connectors/flink-connector-files/src/test/java/org/apache/flink/connector/file/table/FileSystemOutputFormatTest.java",
      "locators": [
          {
              "line": 60,
              "column": 27
          },
          {
              "line": 63,
              "column": 20
          },
          {
              "line": 68,
              "column": 13
          },
          {
              "line": 70,
              "column": 16
          },
          {
              "line": 102,
              "column": 27
          },
          {
              "line": 103,
              "column": 20
          },
          {
              "line": 130,
              "column": 27
          },
          {
              "line": 131,
              "column": 20
          },
          {
              "line": 132,
              "column": 20
          },
          {
              "line": 155,
              "column": 27
          },
          {
              "line": 156,
              "column": 20
          },
          {
              "line": 157,
              "column": 20
          },
          {
              "line": 158,
              "column": 20
          },
          {
              "line": 172,
              "column": 27
          },
          {
              "line": 174,
              "column": 9
          },
          {
              "line": 198,
              "column": 27
          },
          {
              "line": 200,
              "column": 9
          }
      ],
      "old_name": "content",
      "new_name": "fileToContent",
      "ctx": {
          "symbolName": "content",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Map<File, String>",
          "scopeHint": "in testNonPartition(...)",
          "filePath": "FileSystemOutputFormatTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testNonPartition() throws Exception {\n        AtomicReference<FileSystemOutputFormat<Row>> ref = new AtomicReference<>();\n        try (OneInputStreamOperatorTestHarness<Row, Object> testHarness =\n                createSink(false, false, false, new LinkedHashMap<>(), ref)) {\n            writeUnorderedRecords(testHarness);\n            assertThat(getFileContentByPath(tmpPath)).hasSize(1);\n        }\n\n        ref.get().finalizeGlobal(finalizationContext);\n        Map<File, String> content = getFileContentByPath(outputPath);\n        assertThat(content.values())\n                .containsExactly(\"a1,1,p1\\n\" + \"a2,2,p1\\n\" + \"a2,2,p2\\n\" + \"a3,3,p1\\n\");\n    }",
          "conflictNames": [
              "ref",
              "testHarness"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/7d0111dfab640f2f590dd710d76de927c86cf83e^1/flink-connectors/flink-connector-files/src/test/java/org/apache/flink/connector/file/table/FileSystemOutputFormatTest.java",
      "locators": [
          {
              "line": 94,
              "column": 54
          },
          {
              "line": 96,
              "column": 72
          },
          {
              "line": 101,
              "column": 9
          },
          {
              "line": 122,
              "column": 54
          },
          {
              "line": 124,
              "column": 71
          },
          {
              "line": 129,
              "column": 9
          },
          {
              "line": 139,
              "column": 54
          },
          {
              "line": 143,
              "column": 61
          },
          {
              "line": 154,
              "column": 9
          },
          {
              "line": 164,
              "column": 54
          },
          {
              "line": 166,
              "column": 71
          },
          {
              "line": 171,
              "column": 9
          },
          {
              "line": 184,
              "column": 54
          },
          {
              "line": 186,
              "column": 70
          },
          {
              "line": 197,
              "column": 9
          }
      ],
      "old_name": "ref",
      "new_name": "outputFormat",
      "ctx": {
          "symbolName": "ref",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "AtomicReference<FileSystemOutputFormat<Row>>",
          "scopeHint": "in testNonPartition(...)",
          "filePath": "FileSystemOutputFormatTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testNonPartition() throws Exception {\n        AtomicReference<FileSystemOutputFormat<Row>> ref = new AtomicReference<>();\n        try (OneInputStreamOperatorTestHarness<Row, Object> testHarness =\n                createSink(false, false, false, new LinkedHashMap<>(), ref)) {\n            writeUnorderedRecords(testHarness);\n            assertThat(getFileContentByPath(tmpPath)).hasSize(1);\n        }\n\n        ref.get().finalizeGlobal(finalizationContext);\n        Map<File, String> content = getFileContentByPath(outputPath);\n        assertThat(content.values())\n                .containsExactly(\"a1,1,p1\\n\" + \"a2,2,p1\\n\" + \"a2,2,p2\\n\" + \"a3,3,p1\\n\");\n    }",
          "conflictNames": [
              "testHarness",
              "content"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/7ea4476c0544e17798cbb1e39609827954f6c266^1/flink-formats/flink-protobuf/src/test/java/org/apache/flink/formats/protobuf/SimpleRowToProtoTest.java",
      "locators": [
          {
              "line": 50,
              "column": 20
          },
          {
              "line": 51,
              "column": 20
          },
          {
              "line": 52,
              "column": 25
          },
          {
              "line": 53,
              "column": 26
          },
          {
              "line": 54,
              "column": 21
          },
          {
              "line": 55,
              "column": 57
          },
          {
              "line": 56,
              "column": 60
          },
          {
              "line": 57,
              "column": 31
          },
          {
              "line": 58,
              "column": 25
          },
          {
              "line": 59,
              "column": 48
          },
          {
              "line": 60,
              "column": 25
          },
          {
              "line": 79,
              "column": 20
          },
          {
              "line": 80,
              "column": 21
          },
          {
              "line": 81,
              "column": 21
          },
          {
              "line": 82,
              "column": 21
          },
          {
              "line": 93,
              "column": 20
          },
          {
              "line": 94,
              "column": 48
          }
      ],
      "old_name": "simpleTest",
      "new_name": "simpleTestMulti",
      "ctx": {
          "symbolName": "simpleTest",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SimpleTest",
          "scopeHint": "in testSimple(...)",
          "filePath": "SimpleRowToProtoTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "\n    @Test\n    public void testSimple() throws Exception {\n        RowData row =\n                GenericRowData.of(\n                        1,\n                        2L,\n                        false,\n                        0.1f,\n                        0.01,\n                        StringData.fromString(\"hello\"),\n                        new byte[] {1},\n                        StringData.fromString(\"IMAGES\"),\n                        1,\n                        2);\n\n        byte[] bytes = ProtobufTestHelper.rowToPbBytes(row, SimpleTest.class);\n        SimpleTest simpleTest = SimpleTest.parseFrom(bytes);\n        assertTrue(simpleTest.hasA());\n        assertEquals(1, simpleTest.getA());\n        assertEquals(2L, simpleTest.getB());\n        assertFalse(simpleTest.getC());\n        assertEquals(Float.valueOf(0.1f), Float.valueOf(simpleTest.getD()));\n        assertEquals(Double.valueOf(0.01d), Double.valueOf(simpleTest.getE()));\n        assertEquals(\"hello\", simpleTest.getF());\n        assertEquals(1, simpleTest.getG().byteAt(0));\n        assertEquals(SimpleTest.Corpus.IMAGES, simpleTest.getH());\n        assertEquals(1, simpleTest.getFAbc7D());\n    }",
          "conflictNames": [
              "row",
              "bytes"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/7f1399561b3ff303ea48ec0b93eef79eaaf3e4c8^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerTest.java",
      "locators": [
          {
              "line": 18,
              "column": 34
          },
          {
              "line": 89,
              "column": 33
          },
          {
              "line": 90,
              "column": 33
          },
          {
              "line": 91,
              "column": 33
          },
          {
              "line": 92,
              "column": 33
          },
          {
              "line": 93,
              "column": 33
          },
          {
              "line": 94,
              "column": 33
          },
          {
              "line": 95,
              "column": 33
          },
          {
              "line": 96,
              "column": 33
          },
          {
              "line": 97,
              "column": 33
          },
          {
              "line": 151,
              "column": 40
          },
          {
              "line": 183,
              "column": 33
          },
          {
              "line": 190,
              "column": 20
          },
          {
              "line": 231,
              "column": 32
          },
          {
              "line": 240,
              "column": 33
          },
          {
              "line": 247,
              "column": 29
          },
          {
              "line": 249,
              "column": 20
          },
          {
              "line": 250,
              "column": 20
          },
          {
              "line": 255,
              "column": 33
          },
          {
              "line": 263,
              "column": 9
          },
          {
              "line": 263,
              "column": 30
          },
          {
              "line": 269,
              "column": 33
          },
          {
              "line": 277,
              "column": 9
          },
          {
              "line": 339,
              "column": 33
          },
          {
              "line": 355,
              "column": 21
          },
          {
              "line": 369,
              "column": 39
          },
          {
              "line": 457,
              "column": 33
          },
          {
              "line": 467,
              "column": 9
          },
          {
              "line": 468,
              "column": 17
          },
          {
              "line": 485,
              "column": 33
          },
          {
              "line": 493,
              "column": 9
          },
          {
              "line": 535,
              "column": 33
          },
          {
              "line": 553,
              "column": 67
          },
          {
              "line": 557,
              "column": 21
          },
          {
              "line": 625,
              "column": 33
          },
          {
              "line": 645,
              "column": 67
          },
          {
              "line": 649,
              "column": 21
          },
          {
              "line": 690,
              "column": 33
          },
          {
              "line": 697,
              "column": 9
          },
          {
              "line": 699,
              "column": 20
          },
          {
              "line": 709,
              "column": 33
          },
          {
              "line": 715,
              "column": 9
          },
          {
              "line": 731,
              "column": 33
          },
          {
              "line": 738,
              "column": 9
          },
          {
              "line": 758,
              "column": 33
          },
          {
              "line": 773,
              "column": 21
          },
          {
              "line": 774,
              "column": 50
          },
          {
              "line": 790,
              "column": 39
          },
          {
              "line": 800,
              "column": 33
          },
          {
              "line": 810,
              "column": 9
          },
          {
              "line": 812,
              "column": 20
          },
          {
              "line": 818,
              "column": 33
          },
          {
              "line": 829,
              "column": 20
          },
          {
              "line": 834,
              "column": 9
          },
          {
              "line": 853,
              "column": 33
          },
          {
              "line": 883,
              "column": 21
          },
          {
              "line": 898,
              "column": 25
          },
          {
              "line": 930,
              "column": 33
          },
          {
              "line": 942,
              "column": 21
          },
          {
              "line": 944,
              "column": 21
          },
          {
              "line": 945,
              "column": 21
          },
          {
              "line": 954,
              "column": 33
          },
          {
              "line": 963,
              "column": 9
          },
          {
              "line": 967,
              "column": 9
          },
          {
              "line": 983,
              "column": 33
          },
          {
              "line": 994,
              "column": 67
          },
          {
              "line": 999,
              "column": 21
          },
          {
              "line": 1011,
              "column": 56
          },
          {
              "line": 1034,
              "column": 56
          },
          {
              "line": 1051,
              "column": 33
          },
          {
              "line": 1057,
              "column": 82
          },
          {
              "line": 1060,
              "column": 17
          },
          {
              "line": 1061,
              "column": 57
          },
          {
              "line": 1068,
              "column": 21
          },
          {
              "line": 1077,
              "column": 57
          },
          {
              "line": 1087,
              "column": 33
          },
          {
              "line": 1091,
              "column": 74
          },
          {
              "line": 1094,
              "column": 17
          },
          {
              "line": 1095,
              "column": 57
          },
          {
              "line": 1101,
              "column": 23
          },
          {
              "line": 1103,
              "column": 57
          },
          {
              "line": 1114,
              "column": 33
          },
          {
              "line": 1118,
              "column": 74
          },
          {
              "line": 1121,
              "column": 17
          },
          {
              "line": 1122,
              "column": 57
          },
          {
              "line": 1130,
              "column": 43
          },
          {
              "line": 1131,
              "column": 29
          },
          {
              "line": 1133,
              "column": 32
          },
          {
              "line": 1134,
              "column": 40
          },
          {
              "line": 1151,
              "column": 33
          },
          {
              "line": 1156,
              "column": 82
          },
          {
              "line": 1159,
              "column": 17
          },
          {
              "line": 1160,
              "column": 57
          },
          {
              "line": 1168,
              "column": 65
          },
          {
              "line": 1169,
              "column": 37
          },
          {
              "line": 1171,
              "column": 48
          },
          {
              "line": 1180,
              "column": 65
          },
          {
              "line": 1187,
              "column": 48
          },
          {
              "line": 1206,
              "column": 57
          },
          {
              "line": 1221,
              "column": 33
          },
          {
              "line": 1234,
              "column": 74
          },
          {
              "line": 1237,
              "column": 17
          },
          {
              "line": 1240,
              "column": 42
          },
          {
              "line": 1259,
              "column": 33
          },
          {
              "line": 1265,
              "column": 74
          },
          {
              "line": 1268,
              "column": 17
          },
          {
              "line": 1274,
              "column": 23
          },
          {
              "line": 1276,
              "column": 57
          },
          {
              "line": 1300,
              "column": 42
          },
          {
              "line": 1307,
              "column": 41
          },
          {
              "line": 1315,
              "column": 25
          },
          {
              "line": 1321,
              "column": 21
          },
          {
              "line": 1333,
              "column": 25
          },
          {
              "line": 1341,
              "column": 39
          },
          {
              "line": 1380,
              "column": 33
          },
          {
              "line": 1391,
              "column": 25
          },
          {
              "line": 1412,
              "column": 33
          },
          {
              "line": 1423,
              "column": 17
          },
          {
              "line": 1442,
              "column": 33
          },
          {
              "line": 1452,
              "column": 25
          },
          {
              "line": 1468,
              "column": 18
          },
          {
              "line": 1468,
              "column": 44
          },
          {
              "line": 1493,
              "column": 18
          },
          {
              "line": 1493,
              "column": 44
          },
          {
              "line": 1515,
              "column": 18
          },
          {
              "line": 1517,
              "column": 21
          },
          {
              "line": 1542,
              "column": 18
          },
          {
              "line": 1544,
              "column": 21
          },
          {
              "line": 1573,
              "column": 18
          },
          {
              "line": 1575,
              "column": 21
          },
          {
              "line": 1620,
              "column": 18
          },
          {
              "line": 1623,
              "column": 21
          },
          {
              "line": 1625,
              "column": 21
          },
          {
              "line": 1632,
              "column": 25
          },
          {
              "line": 1634,
              "column": 41
          },
          {
              "line": 1662,
              "column": 18
          },
          {
              "line": 1663,
              "column": 21
          },
          {
              "line": 1664,
              "column": 21
          },
          {
              "line": 1691,
              "column": 18
          },
          {
              "line": 1695,
              "column": 21
          },
          {
              "line": 1699,
              "column": 21
          },
          {
              "line": 1729,
              "column": 33
          },
          {
              "line": 1736,
              "column": 29
          },
          {
              "line": 1741,
              "column": 34
          },
          {
              "line": 1741,
              "column": 82
          },
          {
              "line": 1751,
              "column": 33
          },
          {
              "line": 1759,
              "column": 25
          },
          {
              "line": 1767,
              "column": 33
          },
          {
              "line": 1775,
              "column": 25
          },
          {
              "line": 1783,
              "column": 33
          },
          {
              "line": 1792,
              "column": 33
          },
          {
              "line": 1801,
              "column": 33
          },
          {
              "line": 1809,
              "column": 25
          },
          {
              "line": 1818,
              "column": 33
          },
          {
              "line": 1824,
              "column": 25
          },
          {
              "line": 1834,
              "column": 33
          },
          {
              "line": 1843,
              "column": 33
          },
          {
              "line": 1850,
              "column": 33
          },
          {
              "line": 1859,
              "column": 33
          },
          {
              "line": 1967,
              "column": 33
          },
          {
              "line": 1983,
              "column": 71
          },
          {
              "line": 1987,
              "column": 25
          },
          {
              "line": 2002,
              "column": 29
          },
          {
              "line": 2016,
              "column": 52
          },
          {
              "line": 2024,
              "column": 47
          },
          {
              "line": 2033,
              "column": 33
          },
          {
              "line": 2042,
              "column": 33
          },
          {
              "line": 2051,
              "column": 33
          },
          {
              "line": 2056,
              "column": 20
          },
          {
              "line": 2069,
              "column": 33
          },
          {
              "line": 2074,
              "column": 20
          },
          {
              "line": 2088,
              "column": 33
          },
          {
              "line": 2097,
              "column": 20
          },
          {
              "line": 2099,
              "column": 9
          },
          {
              "line": 2100,
              "column": 20
          },
          {
              "line": 2107,
              "column": 20
          },
          {
              "line": 2109,
              "column": 9
          },
          {
              "line": 2110,
              "column": 20
          },
          {
              "line": 2126,
              "column": 33
          },
          {
              "line": 2133,
              "column": 17
          },
          {
              "line": 2142,
              "column": 29
          },
          {
              "line": 2161,
              "column": 43
          },
          {
              "line": 2170,
              "column": 25
          },
          {
              "line": 2175,
              "column": 33
          },
          {
              "line": 2182,
              "column": 75
          },
          {
              "line": 2186,
              "column": 33
          },
          {
              "line": 2376,
              "column": 18
          },
          {
              "line": 2377,
              "column": 52
          },
          {
              "line": 2392,
              "column": 52
          },
          {
              "line": 2393,
              "column": 18
          },
          {
              "line": 2393,
              "column": 38
          },
          {
              "line": 2433,
              "column": 13
          },
          {
              "line": 2434,
              "column": 37
          },
          {
              "line": 2442,
              "column": 45
          },
          {
              "line": 2451,
              "column": 25
          },
          {
              "line": 2468,
              "column": 37
          },
          {
              "line": 2480,
              "column": 52
          },
          {
              "line": 2483,
              "column": 40
          },
          {
              "line": 2484,
              "column": 13
          },
          {
              "line": 2486,
              "column": 20
          }
      ],
      "old_name": "scheduler",
      "new_name": "settings",
      "ctx": {
          "symbolName": "scheduler",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "AdaptiveScheduler",
          "scopeHint": "in testInitialState(...)",
          "filePath": "AdaptiveSchedulerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testInitialState() throws Exception {\n        final AdaptiveScheduler scheduler =\n                new AdaptiveSchedulerBuilder(\n                                createJobGraph(),\n                                mainThreadExecutor,\n                                EXECUTOR_RESOURCE.getExecutor())\n                        .build();\n\n        assertThat(scheduler.getState()).isInstanceOf(Created.class);\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/7f1c201d92bb3f3ddc4cff24342c75946b1ad2b2^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptivebatch/DefaultVertexParallelismAndInputInfosDecider.java",
      "locators": [
          {
              "line": 333,
              "column": 26
          },
          {
              "line": 337,
              "column": 33
          },
          {
              "line": 341,
              "column": 29
          },
          {
              "line": 363,
              "column": 13
          },
          {
              "line": 366,
              "column": 39
          },
          {
              "line": 367,
              "column": 64
          },
          {
              "line": 401,
              "column": 15
          },
          {
              "line": 414,
              "column": 46
          },
          {
              "line": 452,
              "column": 32
          },
          {
              "line": 459,
              "column": 71
          },
          {
              "line": 468,
              "column": 41
          },
          {
              "line": 481,
              "column": 49
          },
          {
              "line": 492,
              "column": 45
          },
          {
              "line": 497,
              "column": 26
          },
          {
              "line": 506,
              "column": 17
          },
          {
              "line": 511,
              "column": 9
          },
          {
              "line": 512,
              "column": 16
          }
      ],
      "old_name": "subpartitionRanges",
      "new_name": "pointwiseInputs",
      "ctx": {
          "symbolName": "subpartitionRanges",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<IndexRange>",
          "scopeHint": "in decideParallelismAndEvenlyDistributeData(...)",
          "filePath": "DefaultVertexParallelismAndInputInfosDecider.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Decide parallelism and input infos, which will make the data be evenly distributed to\n     * downstream subtasks, such that different downstream subtasks consume roughly the same amount\n     * of data.\n     *\n     * @param jobVertexId The job vertex id\n     * @param consumedResults The information of consumed blocking results\n     * @param initialParallelism The initial parallelism of the job vertex\n     * @param minParallelism the min parallelism\n     * @param maxParallelism the max parallelism\n     * @return the parallelism and vertex input infos\n     */\n    private ParallelismAndInputInfos decideParallelismAndEvenlyDistributeData(\n            JobVertexID jobVertexId,\n            List<BlockingInputInfo> consumedResults,\n            int initialParallelism,\n            int minParallelism,\n            int maxParallelism) {\n        checkArgument(initialParallelism == ExecutionConfig.PARALLELISM_DEFAULT);\n        checkArgument(!consumedResults.isEmpty());\n        consumedResults.forEach(resultInfo -> checkState(!resultInfo.isPointwise()));\n\n        // Considering that the sizes of broadcast results are usually very small, we compute the\n        // parallelism and input infos only based on sizes of non-broadcast results\n        final List<BlockingInputInfo> nonBroadcastResults =\n                getNonBroadcastResultInfos(consumedResults);\n        int subpartitionNum = checkAndGetSubpartitionNum(nonBroadcastResults);\n\n        long[] bytesBySubpartition = new long[subpartitionNum];\n        Arrays.fill(bytesBySubpartition, 0L);\n        for (BlockingInputInfo resultInfo : nonBroadcastResults) {\n            List<Long> subpartitionBytes = resultInfo.getAggregatedSubpartitionBytes();\n            for (int i = 0; i < subpartitionNum; ++i) {\n                bytesBySubpartition[i] += subpartitionBytes.get(i);\n            }\n        }\n\n        int maxNumPartitions = getMaxNumPartitions(nonBroadcastResults);\n        int maxRangeSize = MAX_NUM_SUBPARTITIONS_PER_TASK_CONSUME / maxNumPartitions;\n        // compute subpartition ranges\n        List<IndexRange> subpartitionRanges =\n                computeSubpartitionRanges(bytesBySubpartition, dataVolumePerTask, maxRangeSize);\n\n        // if the parallelism is not legal, adjust to a legal parallelism\n        if (!isLegalParallelism(subpartitionRanges.size(), minParallelism, maxParallelism)) {\n            Optional<List<IndexRange>> adjustedSubpartitionRanges =\n                    adjustToClosestLegalParallelism(\n                            dataVolumePerTask,\n                            subpartitionRanges.size(),\n                            minParallelism,\n                            maxParallelism,\n                            Arrays.stream(bytesBySubpartition).min().getAsLong(),\n                            Arrays.stream(bytesBySubpartition).sum(),\n                            limit -> computeParallelism(bytesBySubpartition, limit, maxRangeSize),\n                            limit ->\n                                    computeSubpartitionRanges(\n                                            bytesBySubpartition, limit, maxRangeSize));\n            if (!adjustedSubpartitionRanges.isPresent()) {\n                // can't find any legal parallelism, fall back to evenly distribute subpartitions\n                LOG.info(\n                        \"Cannot find a legal parallelism to evenly distribute data for job vertex {}. \"\n                                + \"Fall back to compute a parallelism that can evenly distribute subpartitions.\",\n                        jobVertexId);\n                return decideParallelismAndEvenlyDistributeSubpartitions(\n                        jobVertexId,\n                        consumedResults,\n                        initialParallelism,\n                        minParallelism,\n                        maxParallelism);\n            }\n            subpartitionRanges = adjustedSubpartitionRanges.get();\n        }\n\n        checkState(isLegalParallelism(subpartitionRanges.size(), minParallelism, maxParallelism));\n        return createParallelismAndInputInfos(consumedResults, subpartitionRanges);\n    }",
          "conflictNames": [
              "jobVertexId",
              "consumedResults",
              "initialParallelism",
              "minParallelism",
              "maxParallelism",
              "nonBroadcastResults",
              "subpartitionNum",
              "bytesBySubpartition",
              "subpartitionBytes",
              "i",
              "maxNumPartitions",
              "maxRangeSize",
              "adjustedSubpartitionRanges"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/7f1c201d92bb3f3ddc4cff24342c75946b1ad2b2^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptivebatch/DefaultVertexParallelismAndInputInfosDecider.java",
      "locators": [
          {
              "line": 467,
              "column": 52
          },
          {
              "line": 485,
              "column": 25
          },
          {
              "line": 490,
              "column": 52
          }
      ],
      "old_name": "executionVertexInputInfos",
      "new_name": "allToAllInputs",
      "ctx": {
          "symbolName": "executionVertexInputInfos",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<ExecutionVertexInputInfo>",
          "scopeHint": "in createParallelismAndInputInfos(...)",
          "filePath": "DefaultVertexParallelismAndInputInfosDecider.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static ParallelismAndInputInfos createParallelismAndInputInfos(\n            List<BlockingInputInfo> consumedResults, List<IndexRange> subpartitionRanges) {\n\n        final Map<IntermediateDataSetID, JobVertexInputInfo> vertexInputInfos = new HashMap<>();\n        consumedResults.forEach(\n                resultInfo -> {\n                    int sourceParallelism = resultInfo.getNumPartitions();\n                    IndexRange partitionRange = new IndexRange(0, sourceParallelism - 1);\n\n                    List<ExecutionVertexInputInfo> executionVertexInputInfos = new ArrayList<>();\n                    for (int i = 0; i < subpartitionRanges.size(); ++i) {\n                        IndexRange subpartitionRange;\n                        if (resultInfo.isBroadcast()) {\n                            if (resultInfo.isSingleSubpartitionContainsAllData()) {\n                                subpartitionRange = new IndexRange(0, 0);\n                            } else {\n                                // The partitions of the all-to-all result have the same number of\n                                // subpartitions. So we can use the first partition's subpartition\n                                // number.\n                                subpartitionRange =\n                                        new IndexRange(0, resultInfo.getNumSubpartitions(0) - 1);\n                            }\n                        } else {\n                            subpartitionRange = subpartitionRanges.get(i);\n                        }\n                        ExecutionVertexInputInfo executionVertexInputInfo =\n                                new ExecutionVertexInputInfo(i, partitionRange, subpartitionRange);\n                        executionVertexInputInfos.add(executionVertexInputInfo);\n                    }\n\n                    vertexInputInfos.put(\n                            resultInfo.getResultId(),\n                            new JobVertexInputInfo(executionVertexInputInfos));\n                });\n        return new ParallelismAndInputInfos(subpartitionRanges.size(), vertexInputInfos);\n    }",
          "conflictNames": [
              "consumedResults",
              "subpartitionRanges",
              "vertexInputInfos",
              "sourceParallelism",
              "partitionRange",
              "i",
              "subpartitionRange",
              "executionVertexInputInfo"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/7f2818bea1c50d9a092c5360a3d4de3a86c411b2^1/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/TestJvmProcess.java",
      "locators": [
          {
              "line": 154,
              "column": 18
          },
          {
              "line": 156,
              "column": 13
          },
          {
              "line": 156,
              "column": 32
          },
          {
              "line": 157,
              "column": 42
          }
      ],
      "old_name": "jvmArgs",
      "new_name": "mainMethodArgs",
      "ctx": {
          "symbolName": "jvmArgs",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String[]",
          "scopeHint": "in startProcess(...)",
          "filePath": "TestJvmProcess.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Creates and starts the {@link Process}.\n     *\n     * <p><strong>Important:</strong> Don't forget to call {@link #destroy()} to prevent resource\n     * leaks. The created process will be child process and is not guaranteed to terminate when the\n     * parent process terminates.\n     */\n    public void startProcess() throws IOException {\n        String[] cmd =\n                new String[] {\n                    javaCommandPath,\n                    \"-Dlog.level=DEBUG\",\n                    \"-Dlog4j.configurationFile=file:\" + log4jConfigFilePath,\n                    \"-Xms\" + jvmMemoryInMb + \"m\",\n                    \"-Xmx\" + jvmMemoryInMb + \"m\",\n                    \"-classpath\",\n                    getCurrentClasspath(),\n                    \"-XX:+IgnoreUnrecognizedVMOptions\"\n                };\n\n        final String moduleConfig = System.getProperty(\"surefire.module.config\");\n        if (moduleConfig != null) {\n            cmd = ArrayUtils.addAll(cmd, moduleConfig.trim().split(\"\\\\s+\"));\n        }\n\n        cmd = ArrayUtils.add(cmd, getEntryPointClassName());\n\n        String[] jvmArgs = getJvmArgs();\n\n        if (jvmArgs != null && jvmArgs.length > 0) {\n            cmd = ArrayUtils.addAll(cmd, jvmArgs);\n        }\n\n        synchronized (createDestroyLock) {\n            checkState(process == null, \"process already started\");\n\n            LOG.debug(\"Running command '{}'.\", Arrays.toString(cmd));\n            this.process = new ProcessBuilder(cmd).start();\n\n            // Forward output\n            this.processOutput = new StringWriter();\n            new CommonTestUtils.PipeForwarder(process.getErrorStream(), processOutput);\n\n            try {\n                // Add JVM shutdown hook to call shutdown of service\n                Runtime.getRuntime().addShutdownHook(shutdownHook);\n            } catch (IllegalStateException ignored) {\n                // JVM is already shutting down. No need to do this.\n            } catch (Throwable t) {\n                LOG.error(\"Cannot register process cleanup shutdown hook.\", t);\n            }\n        }\n    }",
          "conflictNames": [
              "cmd",
              "moduleConfig"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/7f338e87a777abd102719dcb772b184770b62b88^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/HsFullSpillingStrategy.java",
      "locators": [
          {
              "line": 131,
              "column": 56
          },
          {
              "line": 141,
              "column": 13
          },
          {
              "line": 166,
              "column": 30
          }
      ],
      "old_name": "consumedBuffersToRelease",
      "new_name": "bufferToRelease",
      "ctx": {
          "symbolName": "consumedBuffersToRelease",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TreeMap<Integer, Deque<BufferIndexAndChannel>>",
          "scopeHint": "in checkRelease(...)",
          "filePath": "HsFullSpillingStrategy.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void checkRelease(\n            HsSpillingInfoProvider spillingInfoProvider, int poolSize, Decision.Builder builder) {\n        if (spillingInfoProvider.getNumTotalRequestedBuffers() < poolSize * releaseThreshold) {\n            // In case situation changed since onMemoryUsageChanged() returns Optional#empty()\n            return;\n        }\n\n        int releaseNum = (int) (spillingInfoProvider.getPoolSize() * releaseBufferRatio);\n\n        // first, release all consumed buffers\n        TreeMap<Integer, Deque<BufferIndexAndChannel>> consumedBuffersToRelease = new TreeMap<>();\n        int numConsumedBuffers = 0;\n        for (int subpartitionId = 0;\n                subpartitionId < spillingInfoProvider.getNumSubpartitions();\n                subpartitionId++) {\n\n            Deque<BufferIndexAndChannel> consumedSpillSubpartitionBuffers =\n                    spillingInfoProvider.getBuffersInOrder(\n                            subpartitionId, SpillStatus.SPILL, ConsumeStatus.CONSUMED);\n            numConsumedBuffers += consumedSpillSubpartitionBuffers.size();\n            consumedBuffersToRelease.put(subpartitionId, consumedSpillSubpartitionBuffers);\n        }\n\n        // make up the releaseNum with unconsumed buffers, if needed, w.r.t. the consuming priority\n        TreeMap<Integer, List<BufferIndexAndChannel>> unconsumedBufferToRelease = new TreeMap<>();\n        if (releaseNum > numConsumedBuffers) {\n            TreeMap<Integer, Deque<BufferIndexAndChannel>> unconsumedBuffers = new TreeMap<>();\n            for (int subpartitionId = 0;\n                    subpartitionId < spillingInfoProvider.getNumSubpartitions();\n                    subpartitionId++) {\n                unconsumedBuffers.put(\n                        subpartitionId,\n                        spillingInfoProvider.getBuffersInOrder(\n                                subpartitionId, SpillStatus.SPILL, ConsumeStatus.NOT_CONSUMED));\n            }\n            unconsumedBufferToRelease.putAll(\n                    getBuffersByConsumptionPriorityInOrder(\n                            spillingInfoProvider.getNextBufferIndexToConsume(),\n                            unconsumedBuffers,\n                            releaseNum - numConsumedBuffers));\n        }\n\n        // collect results in order\n        for (int i = 0; i < spillingInfoProvider.getNumSubpartitions(); i++) {\n            List<BufferIndexAndChannel> toRelease = new ArrayList<>();\n            toRelease.addAll(consumedBuffersToRelease.getOrDefault(i, new ArrayDeque<>()));\n            toRelease.addAll(unconsumedBufferToRelease.getOrDefault(i, new ArrayList<>()));\n            builder.addBufferToRelease(i, toRelease);\n        }\n    }",
          "conflictNames": [
              "spillingInfoProvider",
              "poolSize",
              "builder",
              "releaseNum",
              "numConsumedBuffers",
              "subpartitionId",
              "consumedSpillSubpartitionBuffers",
              "unconsumedBufferToRelease",
              "unconsumedBuffers",
              "i",
              "toRelease"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/7f338e87a777abd102719dcb772b184770b62b88^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/HsFullSpillingStrategy.java",
      "locators": [
          {
              "line": 137,
              "column": 42
          },
          {
              "line": 140,
              "column": 35
          },
          {
              "line": 141,
              "column": 58
          }
      ],
      "old_name": "consumedSpillSubpartitionBuffers",
      "new_name": "buffersInOrder",
      "ctx": {
          "symbolName": "consumedSpillSubpartitionBuffers",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Deque<BufferIndexAndChannel>",
          "scopeHint": "in checkRelease(...)",
          "filePath": "HsFullSpillingStrategy.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void checkRelease(\n            HsSpillingInfoProvider spillingInfoProvider, int poolSize, Decision.Builder builder) {\n        if (spillingInfoProvider.getNumTotalRequestedBuffers() < poolSize * releaseThreshold) {\n            // In case situation changed since onMemoryUsageChanged() returns Optional#empty()\n            return;\n        }\n\n        int releaseNum = (int) (spillingInfoProvider.getPoolSize() * releaseBufferRatio);\n\n        // first, release all consumed buffers\n        TreeMap<Integer, Deque<BufferIndexAndChannel>> consumedBuffersToRelease = new TreeMap<>();\n        int numConsumedBuffers = 0;\n        for (int subpartitionId = 0;\n                subpartitionId < spillingInfoProvider.getNumSubpartitions();\n                subpartitionId++) {\n\n            Deque<BufferIndexAndChannel> consumedSpillSubpartitionBuffers =\n                    spillingInfoProvider.getBuffersInOrder(\n                            subpartitionId, SpillStatus.SPILL, ConsumeStatus.CONSUMED);\n            numConsumedBuffers += consumedSpillSubpartitionBuffers.size();\n            consumedBuffersToRelease.put(subpartitionId, consumedSpillSubpartitionBuffers);\n        }\n\n        // make up the releaseNum with unconsumed buffers, if needed, w.r.t. the consuming priority\n        TreeMap<Integer, List<BufferIndexAndChannel>> unconsumedBufferToRelease = new TreeMap<>();\n        if (releaseNum > numConsumedBuffers) {\n            TreeMap<Integer, Deque<BufferIndexAndChannel>> unconsumedBuffers = new TreeMap<>();\n            for (int subpartitionId = 0;\n                    subpartitionId < spillingInfoProvider.getNumSubpartitions();\n                    subpartitionId++) {\n                unconsumedBuffers.put(\n                        subpartitionId,\n                        spillingInfoProvider.getBuffersInOrder(\n                                subpartitionId, SpillStatus.SPILL, ConsumeStatus.NOT_CONSUMED));\n            }\n            unconsumedBufferToRelease.putAll(\n                    getBuffersByConsumptionPriorityInOrder(\n                            spillingInfoProvider.getNextBufferIndexToConsume(),\n                            unconsumedBuffers,\n                            releaseNum - numConsumedBuffers));\n        }\n\n        // collect results in order\n        for (int i = 0; i < spillingInfoProvider.getNumSubpartitions(); i++) {\n            List<BufferIndexAndChannel> toRelease = new ArrayList<>();\n            toRelease.addAll(consumedBuffersToRelease.getOrDefault(i, new ArrayDeque<>()));\n            toRelease.addAll(unconsumedBufferToRelease.getOrDefault(i, new ArrayList<>()));\n            builder.addBufferToRelease(i, toRelease);\n        }\n    }",
          "conflictNames": [
              "spillingInfoProvider",
              "poolSize",
              "builder",
              "releaseNum",
              "consumedBuffersToRelease",
              "numConsumedBuffers",
              "subpartitionId",
              "unconsumedBufferToRelease",
              "unconsumedBuffers",
              "i",
              "toRelease"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/80c748f7b7f3058a197e984208d0f02eb25bc2a9^1/flink-runtime/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java",
      "locators": [
          {
              "line": 1016,
              "column": 21
          },
          {
              "line": 1017,
              "column": 42
          },
          {
              "line": 1167,
              "column": 21
          },
          {
              "line": 1172,
              "column": 63
          },
          {
              "line": 1174,
              "column": 55
          },
          {
              "line": 1176,
              "column": 28
          },
          {
              "line": 1202,
              "column": 51
          },
          {
              "line": 1270,
              "column": 59
          },
          {
              "line": 1271,
              "column": 68
          },
          {
              "line": 1299,
              "column": 21
          },
          {
              "line": 1321,
              "column": 25
          },
          {
              "line": 1359,
              "column": 30
          },
          {
              "line": 1362,
              "column": 49
          },
          {
              "line": 1364,
              "column": 41
          },
          {
              "line": 1393,
              "column": 17
          },
          {
              "line": 1402,
              "column": 24
          }
      ],
      "old_name": "vertexId",
      "new_name": "streamNodeId",
      "ctx": {
          "symbolName": "vertexId",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Integer",
          "scopeHint": "in getChainedSourcesByVertexId(...)",
          "filePath": "StreamingJobGraphGenerator.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "   return operatorName + \" -> \" + chainedNames.get(chainedOutputs.get(0).getTargetId());\n        } else {\n            return operatorName;\n        }\n    }\n\n    private static List<ChainedSourceInfo> getChainedSourcesByVertexId(\n            Integer vertexId, OperatorChainInfo chainInfo, StreamGraph streamGraph) {\n        return streamGraph.getStreamNode(vertexId).getInEdges().stream()\n                .map(inEdge -> chainInfo.getChainedSources().get(inEdge.getSourceId()))\n                .filt",
          "conflictNames": [
              "chainInfo",
              "streamGraph"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/819ba92994a5dcc4ced054a3530d423123a8de23^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/netty/TieredStorageNettyServiceImpl.java",
      "locators": [
          {
              "line": 125,
              "column": 35
          },
          {
              "line": 133,
              "column": 13
          },
          {
              "line": 137,
              "column": 17
          }
      ],
      "old_name": "queues",
      "new_name": "nettyPayloadManagers",
      "ctx": {
          "symbolName": "queues",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<Queue<NettyPayload>>",
          "scopeHint": "in createResultSubpartitionView(...)",
          "filePath": "TieredStorageNettyServiceImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Create a {@link ResultSubpartitionView} for the netty server.\n     *\n     * @param partitionId partition id indicates the unique id of {@link TieredResultPartition}.\n     * @param subpartitionId subpartition id indicates the unique id of subpartition.\n     * @param availabilityListener listener is used to listen the available status of data.\n     * @return the {@link TieredStorageResultSubpartitionView}.\n     */\n    public ResultSubpartitionView createResultSubpartitionView(\n            TieredStoragePartitionId partitionId,\n            TieredStorageSubpartitionId subpartitionId,\n            BufferAvailabilityListener availabilityListener) {\n        List<NettyServiceProducer> serviceProducers = registeredServiceProducers.get(partitionId);\n        if (serviceProducers == null) {\n            return new TieredStorageResultSubpartitionView(\n                    availabilityListener, new ArrayList<>(), new ArrayList<>(), new ArrayList<>());\n        }\n        List<Queue<NettyPayload>> queues = new ArrayList<>();\n        List<NettyConnectionId> nettyConnectionIds = new ArrayList<>();\n        for (NettyServiceProducer serviceProducer : serviceProducers) {\n            LinkedBlockingQueue<NettyPayload> queue = new LinkedBlockingQueue<>();\n            NettyConnectionWriterImpl writer =\n                    new NettyConnectionWriterImpl(queue, availabilityListener);\n            serviceProducer.connectionEstablished(subpartitionId, writer);\n            nettyConnectionIds.add(writer.getNettyConnectionId());\n            queues.add(queue);\n        }\n        return new TieredStorageResultSubpartitionView(\n                availabilityListener,\n                queues,\n                nettyConnectionIds,\n                registeredServiceProducers.get(partitionId));\n    }",
          "conflictNames": [
              "partitionId",
              "subpartitionId",
              "availabilityListener",
              "serviceProducers",
              "nettyConnectionIds",
              "queue",
              "writer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/819ba92994a5dcc4ced054a3530d423123a8de23^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/netty/TieredStorageNettyServiceImpl.java",
      "locators": [
          {
              "line": 125,
              "column": 35
          },
          {
              "line": 128,
              "column": 47
          },
          {
              "line": 130,
              "column": 51
          },
          {
              "line": 133,
              "column": 13
          },
          {
              "line": 133,
              "column": 24
          },
          {
              "line": 137,
              "column": 17
          }
      ],
      "old_name": "queue",
      "new_name": "nettyPayloadManager",
      "ctx": {
          "symbolName": "queue",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "LinkedBlockingQueue<NettyPayload>",
          "scopeHint": "in createResultSubpartitionView(...)",
          "filePath": "TieredStorageNettyServiceImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Create a {@link ResultSubpartitionView} for the netty server.\n     *\n     * @param partitionId partition id indicates the unique id of {@link TieredResultPartition}.\n     * @param subpartitionId subpartition id indicates the unique id of subpartition.\n     * @param availabilityListener listener is used to listen the available status of data.\n     * @return the {@link TieredStorageResultSubpartitionView}.\n     */\n    public ResultSubpartitionView createResultSubpartitionView(\n            TieredStoragePartitionId partitionId,\n            TieredStorageSubpartitionId subpartitionId,\n            BufferAvailabilityListener availabilityListener) {\n        List<NettyServiceProducer> serviceProducers = registeredServiceProducers.get(partitionId);\n        if (serviceProducers == null) {\n            return new TieredStorageResultSubpartitionView(\n                    availabilityListener, new ArrayList<>(), new ArrayList<>(), new ArrayList<>());\n        }\n        List<Queue<NettyPayload>> queues = new ArrayList<>();\n        List<NettyConnectionId> nettyConnectionIds = new ArrayList<>();\n        for (NettyServiceProducer serviceProducer : serviceProducers) {\n            LinkedBlockingQueue<NettyPayload> queue = new LinkedBlockingQueue<>();\n            NettyConnectionWriterImpl writer =\n                    new NettyConnectionWriterImpl(queue, availabilityListener);\n            serviceProducer.connectionEstablished(subpartitionId, writer);\n            nettyConnectionIds.add(writer.getNettyConnectionId());\n            queues.add(queue);\n        }\n        return new TieredStorageResultSubpartitionView(\n                availabilityListener,\n                queues,\n                nettyConnectionIds,\n                registeredServiceProducers.get(partitionId));\n    }",
          "conflictNames": [
              "partitionId",
              "subpartitionId",
              "availabilityListener",
              "serviceProducers",
              "queues",
              "nettyConnectionIds",
              "writer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/819ba92994a5dcc4ced054a3530d423123a8de23^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/netty/TieredStorageResultSubpartitionViewTest.java",
      "locators": [
          {
              "line": 51,
              "column": 39
          },
          {
              "line": 60,
              "column": 9
          },
          {
              "line": 66,
              "column": 25
          },
          {
              "line": 85,
              "column": 9
          },
          {
              "line": 89,
              "column": 25
          },
          {
              "line": 118,
              "column": 20
          },
          {
              "line": 119,
              "column": 20
          },
          {
              "line": 144,
              "column": 35
          },
          {
              "line": 157,
              "column": 13
          },
          {
              "line": 159,
              "column": 16
          },
          {
              "line": 163,
              "column": 35
          },
          {
              "line": 168,
              "column": 13
          },
          {
              "line": 170,
              "column": 16
          }
      ],
      "old_name": "nettyPayloadQueues",
      "new_name": "nettyPayloadManagers",
      "ctx": {
          "symbolName": "nettyPayloadQueues",
          "symbolKind": "field",
          "language": "JAVA",
          "type": "List<Queue<NettyPayload>>",
          "scopeHint": "in TieredStorageResultSubpartitionViewTest",
          "filePath": "TieredStorageResultSubpartitionViewTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "tThrownBy;\n\n/** Tests for {@link TieredStorageResultSubpartitionView}. */\npublic class TieredStorageResultSubpartitionViewTest {\n\n    private static final int TIER_NUMBER = 2;\n\n    private CompletableFuture<Void> availabilityListener;\n\n    private List<Queue<NettyPayload>> nettyPayloadQueues;\n\n    private List<CompletableFuture<NettyConnectionId>> connectionBrokenConsumers;\n\n    private TieredStorageResultSubpartitionView tieredStorageResultSubpartitionView;\n\n    @BeforeEach\n    void before() {\n        availabilityListener = ne",
          "conflictNames": [
              "TIER_NUMBER",
              "availabilityListener",
              "connectionBrokenConsumers",
              "tieredStorageResultSubpartitionView"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/819ba92994a5dcc4ced054a3530d423123a8de23^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/netty/NettyConnectionWriterTest.java",
      "locators": [
          {
              "line": 39,
              "column": 34
          },
          {
              "line": 41,
              "column": 47
          },
          {
              "line": 43,
              "column": 20
          },
          {
              "line": 49,
              "column": 34
          },
          {
              "line": 51,
              "column": 47
          },
          {
              "line": 58,
              "column": 34
          },
          {
              "line": 61,
              "column": 25
          },
          {
              "line": 72,
              "column": 34
          },
          {
              "line": 74,
              "column": 47
          }
      ],
      "old_name": "nettyPayloadQueue",
      "new_name": "nettyPayloadManager",
      "ctx": {
          "symbolName": "nettyPayloadQueue",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ArrayDeque<NettyPayload>",
          "scopeHint": "in testWriteBuffer(...)",
          "filePath": "NettyConnectionWriterTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testWriteBuffer() {\n        int bufferNumber = 10;\n        ArrayDeque<NettyPayload> nettyPayloadQueue = new ArrayDeque<>();\n        NettyConnectionWriter nettyConnectionWriter =\n                new NettyConnectionWriterImpl(nettyPayloadQueue, () -> {});\n        writeBufferToWriter(bufferNumber, nettyConnectionWriter);\n        assertThat(nettyPayloadQueue).hasSize(bufferNumber);\n        assertThat(nettyConnectionWriter.numQueuedBuffers()).isEqualTo(bufferNumber);\n    }",
          "conflictNames": [
              "bufferNumber",
              "nettyConnectionWriter"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/819ba92994a5dcc4ced054a3530d423123a8de23^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/netty/TieredStorageResultSubpartitionView.java",
      "locators": [
          {
              "line": 77,
              "column": 29
          },
          {
              "line": 78,
              "column": 56
          },
          {
              "line": 87,
              "column": 49
          },
          {
              "line": 88,
              "column": 21
          },
          {
              "line": 97,
              "column": 33
          },
          {
              "line": 101,
              "column": 52
          },
          {
              "line": 104,
              "column": 62
          }
      ],
      "old_name": "currentQueue",
      "new_name": "nettyPayloadManager",
      "ctx": {
          "symbolName": "currentQueue",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Queue<NettyPayload>",
          "scopeHint": "in getNextBuffer(...)",
          "filePath": "TieredStorageResultSubpartitionView.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Nullable\n    @Override\n    public BufferAndBacklog getNextBuffer() throws IOException {\n        if (stopSendingData || !findCurrentNettyPayloadQueue()) {\n            return null;\n        }\n        Queue<NettyPayload> currentQueue = nettyPayloadQueues.get(queueIndexContainsCurrentSegment);\n        Optional<Buffer> nextBuffer = readNettyPayload(currentQueue);\n        if (nextBuffer.isPresent()) {\n            stopSendingData = nextBuffer.get().getDataType() == END_OF_SEGMENT;\n            if (stopSendingData) {\n                queueIndexContainsCurrentSegment = -1;\n            }\n            currentSequenceNumber++;\n            return BufferAndBacklog.fromBufferAndLookahead(\n                    nextBuffer.get(),\n                    getNettyPayloadNextDataType(currentQueue),\n                    currentQueue.size(),\n                    currentSequenceNumber);\n        }\n        return null;\n    }",
          "conflictNames": [
              "nextBuffer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/819ba92994a5dcc4ced054a3530d423123a8de23^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/netty/TieredStorageResultSubpartitionView.java",
      "locators": [
          {
              "line": 56,
              "column": 17
          },
          {
              "line": 77,
              "column": 67
          },
          {
              "line": 82,
              "column": 17
          },
          {
              "line": 98,
              "column": 44
          },
          {
              "line": 146,
              "column": 39
          },
          {
              "line": 152,
              "column": 39
          },
          {
              "line": 221,
              "column": 13
          },
          {
              "line": 224,
              "column": 18
          },
          {
              "line": 224,
              "column": 34
          },
          {
              "line": 224,
              "column": 74
          },
          {
              "line": 225,
              "column": 69
          },
          {
              "line": 230,
              "column": 13
          },
          {
              "line": 230,
              "column": 48
          }
      ],
      "old_name": "queueIndex",
      "new_name": "managerIndex",
      "ctx": {
          "symbolName": "queueIndex",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in findCurrentNettyPayloadQueue(...)",
          "filePath": "TieredStorageResultSubpartitionView.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private boolean findCurrentNettyPayloadQueue() {\n        if (queueIndexContainsCurrentSegment != -1 && !stopSendingData) {\n            return true;\n        }\n        for (int queueIndex = 0; queueIndex < nettyPayloadQueues.size(); queueIndex++) {\n            NettyPayload firstNettyPayload = nettyPayloadQueues.get(queueIndex).peek();\n            if (firstNettyPayload == null\n                    || firstNettyPayload.getSegmentId() != requiredSegmentId) {\n                continue;\n            }\n            queueIndexContainsCurrentSegment = queueIndex;\n            return true;\n        }\n        return false;\n    }",
          "conflictNames": [
              "firstNettyPayload"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/81aaff4581d98ab2fb762712ffa27c73539e5b9c^1/flink-state-backends/flink-statebackend-forst/src/test/java/org/apache/flink/state/forst/ForStStateExecutorTest.java",
      "locators": [
          {
              "line": 56,
              "column": 31
          },
          {
              "line": 58,
              "column": 20
          },
          {
              "line": 64,
              "column": 13
          },
          {
              "line": 68,
              "column": 49
          },
          {
              "line": 71,
              "column": 9
          },
          {
              "line": 78,
              "column": 13
          },
          {
              "line": 83,
              "column": 13
          },
          {
              "line": 86,
              "column": 49
          },
          {
              "line": 99,
              "column": 9
          },
          {
              "line": 102,
              "column": 13
          },
          {
              "line": 107,
              "column": 13
          },
          {
              "line": 110,
              "column": 49
          },
          {
              "line": 113,
              "column": 9
          },
          {
              "line": 119,
              "column": 13
          },
          {
              "line": 122,
              "column": 49
          },
          {
              "line": 137,
              "column": 31
          },
          {
              "line": 139,
              "column": 20
          },
          {
              "line": 143,
              "column": 13
          },
          {
              "line": 156,
              "column": 13
          },
          {
              "line": 159,
              "column": 49
          },
          {
              "line": 161,
              "column": 9
          },
          {
              "line": 168,
              "column": 13
          },
          {
              "line": 172,
              "column": 49
          },
          {
              "line": 200,
              "column": 9
          },
          {
              "line": 204,
              "column": 13
          },
          {
              "line": 208,
              "column": 49
          },
          {
              "line": 209,
              "column": 9
          },
          {
              "line": 215,
              "column": 13
          },
          {
              "line": 218,
              "column": 49
          },
          {
              "line": 241,
              "column": 31
          },
          {
              "line": 243,
              "column": 20
          },
          {
              "line": 248,
              "column": 13
          },
          {
              "line": 253,
              "column": 49
          },
          {
              "line": 257,
              "column": 9
          },
          {
              "line": 268,
              "column": 13
          },
          {
              "line": 271,
              "column": 49
          },
          {
              "line": 282,
              "column": 9
          },
          {
              "line": 291,
              "column": 17
          },
          {
              "line": 302,
              "column": 13
          },
          {
              "line": 305,
              "column": 49
          },
          {
              "line": 309,
              "column": 9
          },
          {
              "line": 320,
              "column": 13
          },
          {
              "line": 323,
              "column": 49
          }
      ],
      "old_name": "stateRequestContainer",
      "new_name": "asyncRequestContainer",
      "ctx": {
          "symbolName": "stateRequestContainer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "StateRequestContainer",
          "scopeHint": "in testExecuteValueStateRequest(...)",
          "filePath": "ForStStateExecutorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    @SuppressWarnings(\"unchecked\")\n    void testExecuteValueStateRequest() throws Exception {\n        ForStStateExecutor forStStateExecutor =\n                new ForStStateExecutor(false, false, 3, 1, db, new WriteOptions());\n        ForStValueState<Integer, VoidNamespace, String> state1 =\n                buildForStValueState(\"value-state-1\");\n        ForStValueState<Integer, VoidNamespace, String> state2 =\n                buildForStValueState(\"value-state-2\");\n\n        StateRequestContainer stateRequestContainer =\n                forStStateExecutor.createStateRequestContainer();\n        assertTrue(stateRequestContainer.isEmpty());\n\n        // 1. Update value state: keyRange [0, keyNum)\n        int keyNum = 1000;\n        for (int i = 0; i < keyNum; i++) {\n            ForStValueState<Integer, VoidNamespace, String> state = (i % 2 == 0 ? state1 : state2);\n            stateRequestContainer.offer(\n                    buildStateRequest(state, StateRequestType.VALUE_UPDATE, i, \"test-\" + i, i * 2));\n        }\n\n        forStStateExecutor.executeBatchRequests(stateRequestContainer).get();\n\n        List<StateRequest<?, ?, ?, ?>> checkList = new ArrayList<>();\n        stateRequestContainer = forStStateExecutor.createStateRequestContainer();\n        // 2. Get value state: keyRange [0, keyNum)\n        //    Update value state: keyRange [keyNum, keyNum + 100]\n        for (int i = 0; i < keyNum; i++) {\n            ForStValueState<Integer, VoidNamespace, String> state = (i % 2 == 0 ? state1 : state2);\n            StateRequest<?, ?, ?, ?> getRequest =\n                    buildStateRequest(state, StateRequestType.VALUE_GET, i, null, i * 2);\n            stateRequestContainer.offer(getRequest);\n            checkList.add(getRequest);\n        }\n        for (int i = keyNum; i < keyNum + 100; i++) {\n            ForStValueState<Integer, VoidNamespace, String> state = (i % 2 == 0 ? state1 : state2);\n            stateRequestContainer.offer(\n                    buildStateRequest(state, StateRequestType.VALUE_UPDATE, i, \"test-\" + i, i * 2));\n        }\n        forStStateExecutor.executeBatchRequests(stateRequestContainer).get();\n\n        // 3. Check value state Get result : [0, keyNum)\n        for (StateRequest<?, ?, ?, ?> getRequest : checkList) {\n            assertThat(getRequest.getRequestType()).isEqualTo(StateRequestType.VALUE_GET);\n            int key = (Integer) getRequest.getRecordContext().getKey();\n            assertThat(getRequest.getRecordContext().getRecord()).isEqualTo(key * 2);\n            assertThat(((TestStateFuture<String>) getRequest.getFuture()).getCompletedResult())\n                    .isEqualTo(\"test-\" + key);\n        }\n\n        // 4. Clear value state:  keyRange [keyNum - 100, keyNum)\n        //    Update state with null-value : keyRange [keyNum, keyNum + 100]\n        stateRequestContainer = forStStateExecutor.createStateRequestContainer();\n        for (int i = keyNum - 100; i < keyNum; i++) {\n            ForStValueState<Integer, VoidNamespace, String> state = (i % 2 == 0 ? state1 : state2);\n            stateRequestContainer.offer(\n                    buildStateRequest(state, StateRequestType.CLEAR, i, null, i * 2));\n        }\n        for (int i = keyNum; i < keyNum + 100; i++) {\n            ForStValueState<Integer, VoidNamespace, String> state = (i % 2 == 0 ? state1 : state2);\n            stateRequestContainer.offer(\n                    buildStateRequest(state, StateRequestType.VALUE_UPDATE, i, null, i * 2));\n        }\n        forStStateExecutor.executeBatchRequests(stateRequestContainer).get();\n\n        // 5. Check that the deleted value is null :  keyRange [keyNum - 100, keyNum + 100)\n        stateRequestContainer = forStStateExecutor.createStateRequestContainer();\n        checkList.clear();\n        for (int i = keyNum - 100; i < keyNum + 100; i++) {\n            ForStValueState<Integer, VoidNamespace, String> state = (i % 2 == 0 ? state1 : state2);\n            StateRequest<?, ?, ?, ?> getRequest =\n                    buildStateRequest(state, StateRequestType.VALUE_GET, i, null, i * 2);\n            stateRequestContainer.offer(getRequest);\n            checkList.add(getRequest);\n        }\n        forStStateExecutor.executeBatchRequests(stateRequestContainer).get();\n        for (StateRequest<?, ?, ?, ?> getRequest : checkList) {\n            assertThat(getRequest.getRequestType()).isEqualTo(StateRequestType.VALUE_GET);\n            assertThat(((TestStateFuture<String>) getRequest.getFuture()).getCompletedResult())\n                    .isEqualTo(null);\n        }\n        forStStateExecutor.shutdown();\n    }",
          "conflictNames": [
              "forStStateExecutor",
              "state1",
              "state2",
              "keyNum",
              "i",
              "state",
              "checkList",
              "getRequest",
              "key"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/81aaff4581d98ab2fb762712ffa27c73539e5b9c^1/flink-runtime/src/main/java/org/apache/flink/runtime/asyncprocessing/StateRequestBuffer.java",
      "locators": [
          {
              "line": 204,
              "column": 34
          },
          {
              "line": 209,
              "column": 16
          },
          {
              "line": 244,
              "column": 63
          },
          {
              "line": 253,
              "column": 31
          },
          {
              "line": 255,
              "column": 13
          },
          {
              "line": 257,
              "column": 28
          }
      ],
      "old_name": "stateRequest",
      "new_name": "asyncRequest",
      "ctx": {
          "symbolName": "stateRequest",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "StateRequest<K, ?, ?, ?>",
          "scopeHint": "in unblockOneByKey(...)",
          "filePath": "StateRequestBuffer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Try to pull one state request with specific key from blocking queue to active queue.\n     *\n     * @param key The key to release, the other records with this key is no longer blocking.\n     * @return The first record context with the same key in blocking queue, null if no such record.\n     */\n    @Nullable\n    StateRequest<K, ?, ?, ?> unblockOneByKey(K key) {\n        if (!blockingQueue.containsKey(key)) {\n            return null;\n        }\n\n        StateRequest<K, ?, ?, ?> stateRequest = blockingQueue.get(key).removeFirst();\n        if (blockingQueue.get(key).isEmpty()) {\n            blockingQueue.remove(key);\n        }\n        blockingQueueSize--;\n        return stateRequest;\n    }",
          "conflictNames": [
              "key"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/81aaff4581d98ab2fb762712ffa27c73539e5b9c^1/flink-runtime/src/main/java/org/apache/flink/runtime/asyncprocessing/StateRequestBuffer.java",
      "locators": [
          {
              "line": 253,
              "column": 31
          },
          {
              "line": 255,
              "column": 13
          },
          {
              "line": 257,
              "column": 28
          }
      ],
      "old_name": "stateRequestContainer",
      "new_name": "asyncRequestContainer",
      "ctx": {
          "symbolName": "stateRequestContainer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "StateRequestContainer",
          "scopeHint": "in popActive(...)",
          "filePath": "StateRequestBuffer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Try to pop state requests from active queue, if the size of active queue is less than N,\n     * return all the requests in active queue.\n     *\n     * @param n The number of state requests to pop.\n     * @param requestContainerInitializer Initializer for the stateRequest container\n     * @return A StateRequestContainer which holds the popped state requests.\n     */\n    Optional<StateRequestContainer> popActive(\n            int n, Supplier<StateRequestContainer> requestContainerInitializer) {\n        final int count = Math.min(n, activeQueue.size());\n        if (count <= 0) {\n            return Optional.empty();\n        }\n        StateRequestContainer stateRequestContainer = requestContainerInitializer.get();\n        for (int i = 0; i < count; i++) {\n            stateRequestContainer.offer(activeQueue.pop());\n        }\n        return Optional.of(stateRequestContainer);\n    }",
          "conflictNames": [
              "n",
              "requestContainerInitializer",
              "count",
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/81ed6c649e1a219c457628c54a7165d75b803474^1/flink-connectors/flink-connector-datagen/src/test/java/org/apache/flink/connector/datagen/source/DataGeneratorSourceITCase.java",
      "locators": [
          {
              "line": 181,
              "column": 13
          },
          {
              "line": 183,
              "column": 31
          },
          {
              "line": 208,
              "column": 52
          }
      ],
      "old_name": "capacityPerSubtaskPerCycle",
      "new_name": "capacityPerSubtaskPerCheckpoint",
      "ctx": {
          "symbolName": "capacityPerSubtaskPerCycle",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in testGatedRateLimiter(...)",
          "filePath": "DataGeneratorSourceITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    @DisplayName(\"Test GatedRateLimiter\")\n    void testGatedRateLimiter() throws Exception {\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.enableCheckpointing(100);\n\n        env.setParallelism(PARALLELISM);\n\n        int capacityPerSubtaskPerCycle = 2;\n        int capacityPerCycle = // avoid rounding errors when spreading records among subtasks\n                PARALLELISM * capacityPerSubtaskPerCycle;\n\n        final GeneratorFunction<Long, Long> generatorFunction = index -> 1L;\n\n        // Allow each subtask to produce at least 3 cycles, gated by checkpoints\n        int count = capacityPerCycle * 3;\n        final DataGeneratorSource<Long> generatorSource =\n                new DataGeneratorSource<>(\n                        generatorFunction,\n                        count,\n                        RateLimiterStrategy.perCheckpoint(capacityPerCycle),\n                        Types.LONG);\n\n        final DataStreamSource<Long> streamSource =\n                env.fromSource(generatorSource, WatermarkStrategy.noWatermarks(), \"Data Generator\");\n        final DataStream<Tuple2<Integer, Long>> map =\n                streamSource.map(new SubtaskAndCheckpointMapper());\n        final List<Tuple2<Integer, Long>> results = map.executeAndCollect(1000);\n\n        final Map<Tuple2<Integer, Long>, Integer> collect =\n                results.stream()\n                        .collect(\n                                Collectors.groupingBy(\n                                        x -> (new Tuple2<>(x.f0, x.f1)), summingInt(x -> 1)));\n        for (Map.Entry<Tuple2<Integer, Long>, Integer> entry : collect.entrySet()) {\n            assertThat(entry.getValue()).isEqualTo(capacityPerSubtaskPerCycle);\n        }\n    }",
          "conflictNames": [
              "env",
              "capacityPerCycle",
              "generatorFunction",
              "count",
              "generatorSource",
              "streamSource",
              "map",
              "results",
              "collect"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/81ed6c649e1a219c457628c54a7165d75b803474^1/flink-connectors/flink-connector-datagen/src/test/java/org/apache/flink/connector/datagen/source/DataGeneratorSourceITCase.java",
      "locators": [
          {
              "line": 182,
              "column": 13
          },
          {
              "line": 188,
              "column": 21
          },
          {
              "line": 193,
              "column": 59
          }
      ],
      "old_name": "capacityPerCycle",
      "new_name": "capacityPerCheckpoint",
      "ctx": {
          "symbolName": "capacityPerCycle",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in testGatedRateLimiter(...)",
          "filePath": "DataGeneratorSourceITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    @DisplayName(\"Test GatedRateLimiter\")\n    void testGatedRateLimiter() throws Exception {\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.enableCheckpointing(100);\n\n        env.setParallelism(PARALLELISM);\n\n        int capacityPerSubtaskPerCycle = 2;\n        int capacityPerCycle = // avoid rounding errors when spreading records among subtasks\n                PARALLELISM * capacityPerSubtaskPerCycle;\n\n        final GeneratorFunction<Long, Long> generatorFunction = index -> 1L;\n\n        // Allow each subtask to produce at least 3 cycles, gated by checkpoints\n        int count = capacityPerCycle * 3;\n        final DataGeneratorSource<Long> generatorSource =\n                new DataGeneratorSource<>(\n                        generatorFunction,\n                        count,\n                        RateLimiterStrategy.perCheckpoint(capacityPerCycle),\n                        Types.LONG);\n\n        final DataStreamSource<Long> streamSource =\n                env.fromSource(generatorSource, WatermarkStrategy.noWatermarks(), \"Data Generator\");\n        final DataStream<Tuple2<Integer, Long>> map =\n                streamSource.map(new SubtaskAndCheckpointMapper());\n        final List<Tuple2<Integer, Long>> results = map.executeAndCollect(1000);\n\n        final Map<Tuple2<Integer, Long>, Integer> collect =\n                results.stream()\n                        .collect(\n                                Collectors.groupingBy(\n                                        x -> (new Tuple2<>(x.f0, x.f1)), summingInt(x -> 1)));\n        for (Map.Entry<Tuple2<Integer, Long>, Integer> entry : collect.entrySet()) {\n            assertThat(entry.getValue()).isEqualTo(capacityPerSubtaskPerCycle);\n        }\n    }",
          "conflictNames": [
              "env",
              "capacityPerSubtaskPerCycle",
              "generatorFunction",
              "count",
              "generatorSource",
              "streamSource",
              "map",
              "results",
              "collect"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/82fb74e23b1dfa46fa98c89a58d7f3126aeaec6c^1/flink-core/src/test/java/org/apache/flink/api/java/typeutils/runtime/RowSerializerUpgradeTest.java",
      "locators": [
          {
              "line": 46,
              "column": 44
          },
          {
              "line": 54,
              "column": 13
          },
          {
              "line": 61,
              "column": 16
          }
      ],
      "old_name": "testSpecifications",
      "new_name": "testVersions",
      "ctx": {
          "symbolName": "testSpecifications",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ArrayList<TestSpecification<?, ?>>",
          "scopeHint": "in createTestSpecifications(...)",
          "filePath": "RowSerializerUpgradeTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public Collection<TestSpecification<?, ?>> createTestSpecifications() throws Exception {\n        ArrayList<TestSpecification<?, ?>> testSpecifications = new ArrayList<>();\n        // for RowSerializer we also test against 1.10 and newer because we have snapshots\n        // for this which go beyond what we have for the usual subclasses of\n        // TypeSerializerUpgradeTestBase\n        List<FlinkVersion> testVersions = new ArrayList<>();\n        testVersions.add(FlinkVersion.v1_10);\n        testVersions.addAll(MIGRATION_VERSIONS);\n        for (FlinkVersion flinkVersion : testVersions) {\n            testSpecifications.add(\n                    new TestSpecification<>(\n                            \"row-serializer\",\n                            flinkVersion,\n                            RowSerializerSetup.class,\n                            RowSerializerVerifier.class));\n        }\n        return testSpecifications;\n    }",
          "conflictNames": [
              "testVersions"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/841f23c73e4399df91112dd11ddca74f45ea5b37^1/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManagerTest.java",
      "locators": [
          {
              "line": 144,
              "column": 26
          },
          {
              "line": 147,
              "column": 24
          },
          {
              "line": 149,
              "column": 24
          },
          {
              "line": 164,
              "column": 44
          },
          {
              "line": 451,
              "column": 26
          },
          {
              "line": 454,
              "column": 24
          }
      ],
      "old_name": "file6",
      "new_name": "file5",
      "ctx": {
          "symbolName": "file6",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "PhysicalFile",
          "scopeHint": "in testCreateAndReuseFiles(...)",
          "filePath": "FileMergingSnapshotManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testCreateAndReuseFiles() throws IOException {\n        try (FileMergingSnapshotManagerBase fmsm =\n                (FileMergingSnapshotManagerBase)\n                        createFileMergingSnapshotManager(checkpointBaseDir)) {\n            fmsm.registerSubtaskForSharedStates(subtaskKey1);\n            fmsm.registerSubtaskForSharedStates(subtaskKey2);\n            // firstly, we try shared state.\n            PhysicalFile file1 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file1.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            // allocate another\n            PhysicalFile file2 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file2.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file2).isNotEqualTo(file1);\n\n            // return for reuse\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file1);\n\n            // allocate for another subtask\n            PhysicalFile file3 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey2, 0, CheckpointedStateScope.SHARED);\n            assertThat(file3.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.SHARED));\n            assertThat(file3).isNotEqualTo(file1);\n\n            // allocate for another checkpoint\n            PhysicalFile file4 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 1, CheckpointedStateScope.SHARED);\n            assertThat(file4.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file4).isNotEqualTo(file1);\n\n            // allocate for this checkpoint\n            PhysicalFile file5 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file5.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file5).isEqualTo(file1);\n\n            // a physical file whose size is bigger than maxPhysicalFileSize cannot be reused\n            file5.incSize(fmsm.maxPhysicalFileSize);\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file5);\n            PhysicalFile file6 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file6.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file6).isNotEqualTo(file5);\n\n            // Secondly, we try private state\n            PhysicalFile file7 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file7.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n\n            // allocate another\n            PhysicalFile file8 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file8.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file8).isNotEqualTo(file6);\n\n            // return for reuse\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file7);\n\n            // allocate for another checkpoint\n            PhysicalFile file9 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 1, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file9.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file9).isNotEqualTo(file7);\n\n            // allocate for this checkpoint but another subtask\n            PhysicalFile file10 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey2, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file10.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file10).isEqualTo(file7);\n\n            // a physical file whose size is bigger than maxPhysicalFileSize cannot be reused\n            file10.incSize(fmsm.maxPhysicalFileSize);\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file10);\n            PhysicalFile file11 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file11.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file11).isNotEqualTo(file10);\n\n            assertThat(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.EXCLUSIVE))\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n        }\n    }",
          "conflictNames": [
              "fmsm",
              "file1",
              "file2",
              "file3",
              "file4",
              "file5",
              "file7",
              "file8",
              "file9",
              "file10",
              "file11"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/841f23c73e4399df91112dd11ddca74f45ea5b37^1/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManagerTest.java",
      "locators": [
          {
              "line": 152,
              "column": 26
          },
          {
              "line": 155,
              "column": 24
          },
          {
              "line": 167,
              "column": 65
          },
          {
              "line": 175,
              "column": 44
          },
          {
              "line": 183,
              "column": 42
          }
      ],
      "old_name": "file7",
      "new_name": "file6",
      "ctx": {
          "symbolName": "file7",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "PhysicalFile",
          "scopeHint": "in testCreateAndReuseFiles(...)",
          "filePath": "FileMergingSnapshotManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testCreateAndReuseFiles() throws IOException {\n        try (FileMergingSnapshotManagerBase fmsm =\n                (FileMergingSnapshotManagerBase)\n                        createFileMergingSnapshotManager(checkpointBaseDir)) {\n            fmsm.registerSubtaskForSharedStates(subtaskKey1);\n            fmsm.registerSubtaskForSharedStates(subtaskKey2);\n            // firstly, we try shared state.\n            PhysicalFile file1 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file1.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            // allocate another\n            PhysicalFile file2 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file2.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file2).isNotEqualTo(file1);\n\n            // return for reuse\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file1);\n\n            // allocate for another subtask\n            PhysicalFile file3 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey2, 0, CheckpointedStateScope.SHARED);\n            assertThat(file3.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.SHARED));\n            assertThat(file3).isNotEqualTo(file1);\n\n            // allocate for another checkpoint\n            PhysicalFile file4 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 1, CheckpointedStateScope.SHARED);\n            assertThat(file4.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file4).isNotEqualTo(file1);\n\n            // allocate for this checkpoint\n            PhysicalFile file5 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file5.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file5).isEqualTo(file1);\n\n            // a physical file whose size is bigger than maxPhysicalFileSize cannot be reused\n            file5.incSize(fmsm.maxPhysicalFileSize);\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file5);\n            PhysicalFile file6 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file6.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file6).isNotEqualTo(file5);\n\n            // Secondly, we try private state\n            PhysicalFile file7 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file7.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n\n            // allocate another\n            PhysicalFile file8 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file8.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file8).isNotEqualTo(file6);\n\n            // return for reuse\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file7);\n\n            // allocate for another checkpoint\n            PhysicalFile file9 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 1, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file9.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file9).isNotEqualTo(file7);\n\n            // allocate for this checkpoint but another subtask\n            PhysicalFile file10 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey2, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file10.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file10).isEqualTo(file7);\n\n            // a physical file whose size is bigger than maxPhysicalFileSize cannot be reused\n            file10.incSize(fmsm.maxPhysicalFileSize);\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file10);\n            PhysicalFile file11 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file11.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file11).isNotEqualTo(file10);\n\n            assertThat(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.EXCLUSIVE))\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n        }\n    }",
          "conflictNames": [
              "fmsm",
              "file1",
              "file2",
              "file3",
              "file4",
              "file5",
              "file6",
              "file8",
              "file9",
              "file10",
              "file11"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/841f23c73e4399df91112dd11ddca74f45ea5b37^1/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManagerTest.java",
      "locators": [
          {
              "line": 159,
              "column": 26
          },
          {
              "line": 162,
              "column": 24
          },
          {
              "line": 164,
              "column": 24
          }
      ],
      "old_name": "file8",
      "new_name": "file7",
      "ctx": {
          "symbolName": "file8",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "PhysicalFile",
          "scopeHint": "in testCreateAndReuseFiles(...)",
          "filePath": "FileMergingSnapshotManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testCreateAndReuseFiles() throws IOException {\n        try (FileMergingSnapshotManagerBase fmsm =\n                (FileMergingSnapshotManagerBase)\n                        createFileMergingSnapshotManager(checkpointBaseDir)) {\n            fmsm.registerSubtaskForSharedStates(subtaskKey1);\n            fmsm.registerSubtaskForSharedStates(subtaskKey2);\n            // firstly, we try shared state.\n            PhysicalFile file1 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file1.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            // allocate another\n            PhysicalFile file2 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file2.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file2).isNotEqualTo(file1);\n\n            // return for reuse\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file1);\n\n            // allocate for another subtask\n            PhysicalFile file3 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey2, 0, CheckpointedStateScope.SHARED);\n            assertThat(file3.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.SHARED));\n            assertThat(file3).isNotEqualTo(file1);\n\n            // allocate for another checkpoint\n            PhysicalFile file4 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 1, CheckpointedStateScope.SHARED);\n            assertThat(file4.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file4).isNotEqualTo(file1);\n\n            // allocate for this checkpoint\n            PhysicalFile file5 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file5.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file5).isEqualTo(file1);\n\n            // a physical file whose size is bigger than maxPhysicalFileSize cannot be reused\n            file5.incSize(fmsm.maxPhysicalFileSize);\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file5);\n            PhysicalFile file6 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file6.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file6).isNotEqualTo(file5);\n\n            // Secondly, we try private state\n            PhysicalFile file7 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file7.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n\n            // allocate another\n            PhysicalFile file8 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file8.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file8).isNotEqualTo(file6);\n\n            // return for reuse\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file7);\n\n            // allocate for another checkpoint\n            PhysicalFile file9 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 1, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file9.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file9).isNotEqualTo(file7);\n\n            // allocate for this checkpoint but another subtask\n            PhysicalFile file10 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey2, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file10.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file10).isEqualTo(file7);\n\n            // a physical file whose size is bigger than maxPhysicalFileSize cannot be reused\n            file10.incSize(fmsm.maxPhysicalFileSize);\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file10);\n            PhysicalFile file11 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file11.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file11).isNotEqualTo(file10);\n\n            assertThat(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.EXCLUSIVE))\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n        }\n    }",
          "conflictNames": [
              "fmsm",
              "file1",
              "file2",
              "file3",
              "file4",
              "file5",
              "file6",
              "file7",
              "file9",
              "file10",
              "file11"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/841f23c73e4399df91112dd11ddca74f45ea5b37^1/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManagerTest.java",
      "locators": [
          {
              "line": 170,
              "column": 26
          },
          {
              "line": 173,
              "column": 24
          },
          {
              "line": 175,
              "column": 24
          }
      ],
      "old_name": "file9",
      "new_name": "file8",
      "ctx": {
          "symbolName": "file9",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "PhysicalFile",
          "scopeHint": "in testCreateAndReuseFiles(...)",
          "filePath": "FileMergingSnapshotManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testCreateAndReuseFiles() throws IOException {\n        try (FileMergingSnapshotManagerBase fmsm =\n                (FileMergingSnapshotManagerBase)\n                        createFileMergingSnapshotManager(checkpointBaseDir)) {\n            fmsm.registerSubtaskForSharedStates(subtaskKey1);\n            fmsm.registerSubtaskForSharedStates(subtaskKey2);\n            // firstly, we try shared state.\n            PhysicalFile file1 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file1.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            // allocate another\n            PhysicalFile file2 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file2.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file2).isNotEqualTo(file1);\n\n            // return for reuse\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file1);\n\n            // allocate for another subtask\n            PhysicalFile file3 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey2, 0, CheckpointedStateScope.SHARED);\n            assertThat(file3.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.SHARED));\n            assertThat(file3).isNotEqualTo(file1);\n\n            // allocate for another checkpoint\n            PhysicalFile file4 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 1, CheckpointedStateScope.SHARED);\n            assertThat(file4.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file4).isNotEqualTo(file1);\n\n            // allocate for this checkpoint\n            PhysicalFile file5 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file5.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file5).isEqualTo(file1);\n\n            // a physical file whose size is bigger than maxPhysicalFileSize cannot be reused\n            file5.incSize(fmsm.maxPhysicalFileSize);\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file5);\n            PhysicalFile file6 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file6.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file6).isNotEqualTo(file5);\n\n            // Secondly, we try private state\n            PhysicalFile file7 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file7.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n\n            // allocate another\n            PhysicalFile file8 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file8.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file8).isNotEqualTo(file6);\n\n            // return for reuse\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file7);\n\n            // allocate for another checkpoint\n            PhysicalFile file9 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 1, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file9.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file9).isNotEqualTo(file7);\n\n            // allocate for this checkpoint but another subtask\n            PhysicalFile file10 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey2, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file10.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file10).isEqualTo(file7);\n\n            // a physical file whose size is bigger than maxPhysicalFileSize cannot be reused\n            file10.incSize(fmsm.maxPhysicalFileSize);\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file10);\n            PhysicalFile file11 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file11.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file11).isNotEqualTo(file10);\n\n            assertThat(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.EXCLUSIVE))\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n        }\n    }",
          "conflictNames": [
              "fmsm",
              "file1",
              "file2",
              "file3",
              "file4",
              "file5",
              "file6",
              "file7",
              "file8",
              "file10",
              "file11"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/841f23c73e4399df91112dd11ddca74f45ea5b37^1/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManagerTest.java",
      "locators": [
          {
              "line": 178,
              "column": 26
          },
          {
              "line": 181,
              "column": 24
          },
          {
              "line": 183,
              "column": 24
          },
          {
              "line": 186,
              "column": 13
          },
          {
              "line": 187,
              "column": 65
          },
          {
              "line": 193,
              "column": 45
          }
      ],
      "old_name": "file10",
      "new_name": "file9",
      "ctx": {
          "symbolName": "file10",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "PhysicalFile",
          "scopeHint": "in testCreateAndReuseFiles(...)",
          "filePath": "FileMergingSnapshotManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testCreateAndReuseFiles() throws IOException {\n        try (FileMergingSnapshotManagerBase fmsm =\n                (FileMergingSnapshotManagerBase)\n                        createFileMergingSnapshotManager(checkpointBaseDir)) {\n            fmsm.registerSubtaskForSharedStates(subtaskKey1);\n            fmsm.registerSubtaskForSharedStates(subtaskKey2);\n            // firstly, we try shared state.\n            PhysicalFile file1 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file1.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            // allocate another\n            PhysicalFile file2 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file2.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file2).isNotEqualTo(file1);\n\n            // return for reuse\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file1);\n\n            // allocate for another subtask\n            PhysicalFile file3 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey2, 0, CheckpointedStateScope.SHARED);\n            assertThat(file3.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.SHARED));\n            assertThat(file3).isNotEqualTo(file1);\n\n            // allocate for another checkpoint\n            PhysicalFile file4 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 1, CheckpointedStateScope.SHARED);\n            assertThat(file4.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file4).isNotEqualTo(file1);\n\n            // allocate for this checkpoint\n            PhysicalFile file5 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file5.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file5).isEqualTo(file1);\n\n            // a physical file whose size is bigger than maxPhysicalFileSize cannot be reused\n            file5.incSize(fmsm.maxPhysicalFileSize);\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file5);\n            PhysicalFile file6 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file6.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file6).isNotEqualTo(file5);\n\n            // Secondly, we try private state\n            PhysicalFile file7 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file7.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n\n            // allocate another\n            PhysicalFile file8 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file8.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file8).isNotEqualTo(file6);\n\n            // return for reuse\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file7);\n\n            // allocate for another checkpoint\n            PhysicalFile file9 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 1, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file9.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file9).isNotEqualTo(file7);\n\n            // allocate for this checkpoint but another subtask\n            PhysicalFile file10 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey2, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file10.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file10).isEqualTo(file7);\n\n            // a physical file whose size is bigger than maxPhysicalFileSize cannot be reused\n            file10.incSize(fmsm.maxPhysicalFileSize);\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file10);\n            PhysicalFile file11 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file11.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file11).isNotEqualTo(file10);\n\n            assertThat(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.EXCLUSIVE))\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n        }\n    }",
          "conflictNames": [
              "fmsm",
              "file1",
              "file2",
              "file3",
              "file4",
              "file5",
              "file6",
              "file7",
              "file8",
              "file9",
              "file11"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/841f23c73e4399df91112dd11ddca74f45ea5b37^1/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManagerTest.java",
      "locators": [
          {
              "line": 188,
              "column": 26
          },
          {
              "line": 191,
              "column": 24
          },
          {
              "line": 193,
              "column": 24
          }
      ],
      "old_name": "file11",
      "new_name": "file10",
      "ctx": {
          "symbolName": "file11",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "PhysicalFile",
          "scopeHint": "in testCreateAndReuseFiles(...)",
          "filePath": "FileMergingSnapshotManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testCreateAndReuseFiles() throws IOException {\n        try (FileMergingSnapshotManagerBase fmsm =\n                (FileMergingSnapshotManagerBase)\n                        createFileMergingSnapshotManager(checkpointBaseDir)) {\n            fmsm.registerSubtaskForSharedStates(subtaskKey1);\n            fmsm.registerSubtaskForSharedStates(subtaskKey2);\n            // firstly, we try shared state.\n            PhysicalFile file1 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file1.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            // allocate another\n            PhysicalFile file2 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file2.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file2).isNotEqualTo(file1);\n\n            // return for reuse\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file1);\n\n            // allocate for another subtask\n            PhysicalFile file3 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey2, 0, CheckpointedStateScope.SHARED);\n            assertThat(file3.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.SHARED));\n            assertThat(file3).isNotEqualTo(file1);\n\n            // allocate for another checkpoint\n            PhysicalFile file4 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 1, CheckpointedStateScope.SHARED);\n            assertThat(file4.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file4).isNotEqualTo(file1);\n\n            // allocate for this checkpoint\n            PhysicalFile file5 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file5.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file5).isEqualTo(file1);\n\n            // a physical file whose size is bigger than maxPhysicalFileSize cannot be reused\n            file5.incSize(fmsm.maxPhysicalFileSize);\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file5);\n            PhysicalFile file6 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file6.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file6).isNotEqualTo(file5);\n\n            // Secondly, we try private state\n            PhysicalFile file7 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file7.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n\n            // allocate another\n            PhysicalFile file8 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file8.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file8).isNotEqualTo(file6);\n\n            // return for reuse\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file7);\n\n            // allocate for another checkpoint\n            PhysicalFile file9 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 1, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file9.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file9).isNotEqualTo(file7);\n\n            // allocate for this checkpoint but another subtask\n            PhysicalFile file10 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey2, 0, CheckpointedStateScope.EXCLUSIVE);\n            assertThat(file10.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.EXCLUSIVE));\n            assertThat(file10).isEqualTo(file7);\n\n            // a physical file whose size is bigger than maxPhysicalFileSize cannot be reused\n            file10.incSize(fmsm.maxPhysicalFileSize);\n            fmsm.returnPhysicalFileForNextReuse(subtaskKey1, 0, file10);\n            PhysicalFile file11 =\n                    fmsm.getOrCreatePhysicalFileForCheckpoint(\n                            subtaskKey1, 0, CheckpointedStateScope.SHARED);\n            assertThat(file11.getFilePath().getParent())\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED));\n            assertThat(file11).isNotEqualTo(file10);\n\n            assertThat(fmsm.getManagedDir(subtaskKey2, CheckpointedStateScope.EXCLUSIVE))\n                    .isEqualTo(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE));\n        }\n    }",
          "conflictNames": [
              "fmsm",
              "file1",
              "file2",
              "file3",
              "file4",
              "file5",
              "file6",
              "file7",
              "file8",
              "file9",
              "file10"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/8430068db0d9fdf6e37cffd61143e709d5ecfff5^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/typeutils/BinaryRowDataSerializer.java",
      "locators": [
          {
              "line": 381,
              "column": 37
          },
          {
              "line": 383,
              "column": 38
          }
      ],
      "old_name": "newBinaryRowSerializer",
      "new_name": "oldBinaryRowSerializerSnapshot",
      "ctx": {
          "symbolName": "newBinaryRowSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "BinaryRowDataSerializer",
          "scopeHint": "in resolveSchemaCompatibility(...)",
          "filePath": "BinaryRowDataSerializer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public TypeSerializerSchemaCompatibility<BinaryRowData> resolveSchemaCompatibility(\n                TypeSerializer<BinaryRowData> newSerializer) {\n            if (!(newSerializer instanceof BinaryRowDataSerializer)) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            }\n\n            BinaryRowDataSerializer newBinaryRowSerializer =\n                    (BinaryRowDataSerializer) newSerializer;\n            if (previousNumFields != newBinaryRowSerializer.numFields) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            } else {\n                return TypeSerializerSchemaCompatibility.compatibleAsIs();\n            }\n        }",
          "conflictNames": [
              "newSerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/84444d5071984a8543a81574dc69c0c9849a8a4a^1/flink-connectors/flink-connector-files/src/test/java/org/apache/flink/connector/file/table/stream/PartitionCommitInfoTest.java",
      "locators": [
          {
              "line": 32,
              "column": 25
          },
          {
              "line": 33,
              "column": 9
          },
          {
              "line": 35,
              "column": 80
          }
      ],
      "old_name": "executionConfig",
      "new_name": "serializerConfig",
      "ctx": {
          "symbolName": "executionConfig",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ExecutionConfig",
          "scopeHint": "in testPartitionCommitSerializer(...)",
          "filePath": "PartitionCommitInfoTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "\n    @Test\n    public void testPartitionCommitSerializer() {\n        ExecutionConfig executionConfig = new ExecutionConfig();\n        executionConfig.disableGenericTypes();\n        assertNotNull(\n                TypeInformation.of(PartitionCommitInfo.class).createSerializer(executionConfig));\n    }"
      },
      "suggestions": [
          {
              "name": "serializerConfigImpl",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/84444d5071984a8543a81574dc69c0c9849a8a4a^1/flink-core/src/test/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializerTest.java",
      "locators": [
          {
              "line": 372,
              "column": 25
          },
          {
              "line": 373,
              "column": 9
          },
          {
              "line": 374,
              "column": 9
          },
          {
              "line": 377,
              "column": 71
          },
          {
              "line": 394,
              "column": 9
          },
          {
              "line": 395,
              "column": 9
          },
          {
              "line": 397,
              "column": 9
          },
          {
              "line": 399,
              "column": 80
          }
      ],
      "old_name": "executionConfig",
      "new_name": "serializerConfig",
      "ctx": {
          "symbolName": "executionConfig",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ExecutionConfig",
          "scopeHint": "in testReconfigureDifferentSubclassRegistrationOrder(...)",
          "filePath": "PojoSerializerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Tests that reconfiguration correctly reorders subclass registrations to their previous order.\n     */\n    @Test\n    void testReconfigureDifferentSubclassRegistrationOrder() throws Exception {\n        ExecutionConfig executionConfig = new ExecutionConfig();\n        executionConfig.registerPojoType(SubTestUserClassA.class);\n        executionConfig.registerPojoType(SubTestUserClassB.class);\n\n        PojoSerializer<TestUserClass> pojoSerializer =\n                (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig);\n\n        // get original registration ids\n        int subClassATag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class);\n        int subClassBTag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class);\n\n        // snapshot configuration and serialize to bytes\n        TypeSerializerSnapshot pojoSerializerConfigSnapshot =\n                pojoSerializer.snapshotConfiguration();\n        byte[] serializedConfig;\n        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n            TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(\n                    new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot);\n            serializedConfig = out.toByteArray();\n        }\n\n        // use new config and instantiate new PojoSerializer\n        executionConfig = new ExecutionConfig();\n        executionConfig.registerPojoType(\n                SubTestUserClassB.class); // test with B registered before A\n        executionConfig.registerPojoType(SubTestUserClassA.class);\n\n        pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig);\n\n        // read configuration from bytes\n        try (ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {\n            pojoSerializerConfigSnapshot =\n                    TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(\n                            new DataInputViewStreamWrapper(in),\n                            Thread.currentThread().getContextClassLoader());\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        TypeSerializerSchemaCompatibility<TestUserClass> compatResult =\n                pojoSerializer\n                        .snapshotConfiguration()\n                        .resolveSchemaCompatibility(pojoSerializerConfigSnapshot);\n        assertThat(compatResult.isCompatibleWithReconfiguredSerializer()).isTrue();\n        assertThat(compatResult.getReconfiguredSerializer()).isInstanceOf(PojoSerializer.class);\n\n        // reconfigure - check reconfiguration result and that registration ids remains the same\n        // assertEquals(ReconfigureResult.COMPATIBLE,\n        // pojoSerializer.reconfigure(pojoSerializerConfigSnapshot));\n        PojoSerializer<TestUserClass> reconfiguredPojoSerializer =\n                (PojoSerializer<TestUserClass>) compatResult.getReconfiguredSerializer();\n        assertThat(subClassATag)\n                .isEqualTo(\n                        reconfiguredPojoSerializer\n                                .getRegisteredClasses()\n                                .get(SubTestUserClassA.class)\n                                .intValue());\n        assertThat(subClassBTag)\n                .isEqualTo(\n                        reconfiguredPojoSerializer\n                                .getRegisteredClasses()\n                                .get(SubTestUserClassB.class)\n                                .intValue());\n    }",
          "conflictNames": [
              "pojoSerializer",
              "subClassATag",
              "subClassBTag",
              "pojoSerializerConfigSnapshot",
              "serializedConfig",
              "out",
              "in",
              "compatResult",
              "reconfiguredPojoSerializer"
          ]
      },
      "suggestions": [
          {
              "name": "serializerConfigImpl",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/84444d5071984a8543a81574dc69c0c9849a8a4a^1/flink-core/src/test/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializerTest.java",
      "locators": [
          {
              "line": 533,
              "column": 25
          },
          {
              "line": 534,
              "column": 9
          },
          {
              "line": 535,
              "column": 9
          },
          {
              "line": 536,
              "column": 80
          }
      ],
      "old_name": "newExecutionConfig",
      "new_name": "serializerConfig",
      "ctx": {
          "symbolName": "newExecutionConfig",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ExecutionConfig",
          "scopeHint": "in testReconfigureWithPreviouslyNonregisteredSubclasses(...)",
          "filePath": "PojoSerializerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Tests that: - Previous Pojo serializer did not have registrations, and created cached\n     * serializers for subclasses - On restore, it had those subclasses registered\n     *\n     * <p>In this case, after reconfiguration, the cache should be repopulated, and registrations\n     * should also exist for the subclasses.\n     *\n     * <p>Note: the cache still needs to be repopulated because previous data of those subclasses\n     * were written with the cached serializers. In this case, the repopulated cache has\n     * reconfigured serializers for the subclasses so that previous written data can be read, but\n     * the registered serializers for the subclasses do not necessarily need to be reconfigured\n     * since they will only be used to write new data.\n     */\n    @Test\n    void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception {\n        // don't register any subclasses at first\n        PojoSerializer<TestUserClass> pojoSerializer =\n                (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig());\n\n        // create cached serializers for SubTestUserClassA and SubTestUserClassB\n        pojoSerializer.getSubclassSerializer(SubTestUserClassA.class);\n        pojoSerializer.getSubclassSerializer(SubTestUserClassB.class);\n\n        // make sure serializers are in cache\n        assertThat(pojoSerializer.getSubclassSerializerCache())\n                .containsOnlyKeys(SubTestUserClassA.class, SubTestUserClassB.class);\n\n        // make sure that registrations are empty\n        assertThat(pojoSerializer.getRegisteredClasses()).isEmpty();\n        assertThat(pojoSerializer.getRegisteredSerializers()).isEmpty();\n\n        // snapshot configuration and serialize to bytes\n        TypeSerializerSnapshot pojoSerializerConfigSnapshot =\n                pojoSerializer.snapshotConfiguration();\n        byte[] serializedConfig;\n        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n            TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(\n                    new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot);\n            serializedConfig = out.toByteArray();\n        }\n\n        // instantiate new PojoSerializer, with new execution config that has the subclass\n        // registrations\n        ExecutionConfig newExecutionConfig = new ExecutionConfig();\n        newExecutionConfig.registerPojoType(SubTestUserClassA.class);\n        newExecutionConfig.registerPojoType(SubTestUserClassB.class);\n        pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(newExecutionConfig);\n\n        // read configuration from bytes\n        try (ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {\n            pojoSerializerConfigSnapshot =\n                    TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(\n                            new DataInputViewStreamWrapper(in),\n                            Thread.currentThread().getContextClassLoader());\n        }\n\n        // reconfigure - check reconfiguration result and that\n        // 1) subclass serializer cache is repopulated\n        // 2) registrations also contain the now registered subclasses\n        @SuppressWarnings(\"unchecked\")\n        TypeSerializerSchemaCompatibility<TestUserClass> compatResult =\n                pojoSerializer\n                        .snapshotConfiguration()\n                        .resolveSchemaCompatibility(pojoSerializerConfigSnapshot);\n        assertThat(compatResult.isCompatibleWithReconfiguredSerializer()).isTrue();\n        assertThat(compatResult.getReconfiguredSerializer()).isInstanceOf(PojoSerializer.class);\n\n        PojoSerializer<TestUserClass> reconfiguredPojoSerializer =\n                (PojoSerializer<TestUserClass>) compatResult.getReconfiguredSerializer();\n\n        assertThat(reconfiguredPojoSerializer.getSubclassSerializerCache())\n                .containsOnlyKeys(SubTestUserClassA.class, SubTestUserClassB.class);\n\n        assertThat(reconfiguredPojoSerializer.getRegisteredClasses())\n                .containsOnlyKeys(SubTestUserClassA.class, SubTestUserClassB.class);\n    }",
          "conflictNames": [
              "pojoSerializer",
              "pojoSerializerConfigSnapshot",
              "serializedConfig",
              "out",
              "in",
              "compatResult",
              "reconfiguredPojoSerializer"
          ]
      },
      "suggestions": [
          {
              "name": "newSerializerConfig",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/84444d5071984a8543a81574dc69c0c9849a8a4a^1/flink-core/src/test/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializerUpgradeTestSpecifications.java",
      "locators": [
          {
              "line": 476,
              "column": 29
          },
          {
              "line": 477,
              "column": 13
          },
          {
              "line": 480,
              "column": 83
          },
          {
              "line": 555,
              "column": 29
          },
          {
              "line": 556,
              "column": 13
          },
          {
              "line": 559,
              "column": 83
          },
          {
              "line": 600,
              "column": 29
          },
          {
              "line": 601,
              "column": 13
          },
          {
              "line": 605,
              "column": 47
          },
          {
              "line": 637,
              "column": 29
          },
          {
              "line": 638,
              "column": 13
          },
          {
              "line": 642,
              "column": 47
          },
          {
              "line": 719,
              "column": 29
          },
          {
              "line": 720,
              "column": 13
          },
          {
              "line": 721,
              "column": 13
          },
          {
              "line": 725,
              "column": 47
          },
          {
              "line": 741,
              "column": 29
          },
          {
              "line": 743,
              "column": 13
          },
          {
              "line": 744,
              "column": 13
          },
          {
              "line": 748,
              "column": 47
          },
          {
              "line": 777,
              "column": 29
          },
          {
              "line": 778,
              "column": 13
          },
          {
              "line": 779,
              "column": 13
          },
          {
              "line": 783,
              "column": 47
          },
          {
              "line": 799,
              "column": 29
          },
          {
              "line": 801,
              "column": 13
          },
          {
              "line": 805,
              "column": 47
          },
          {
              "line": 833,
              "column": 29
          },
          {
              "line": 837,
              "column": 47
          },
          {
              "line": 854,
              "column": 29
          },
          {
              "line": 856,
              "column": 13
          },
          {
              "line": 860,
              "column": 47
          },
          {
              "line": 888,
              "column": 29
          },
          {
              "line": 889,
              "column": 13
          },
          {
              "line": 890,
              "column": 13
          },
          {
              "line": 894,
              "column": 47
          },
          {
              "line": 910,
              "column": 29
          },
          {
              "line": 911,
              "column": 13
          },
          {
              "line": 912,
              "column": 13
          },
          {
              "line": 916,
              "column": 47
          }
      ],
      "old_name": "executionConfig",
      "new_name": "serializerConfigImpl",
      "ctx": {
          "symbolName": "executionConfig",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ExecutionConfig",
          "scopeHint": "in createPriorSerializer(...)",
          "filePath": "PojoSerializerUpgradeTestSpecifications.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public TypeSerializer<BasePojo> createPriorSerializer() {\n            ExecutionConfig executionConfig = new ExecutionConfig();\n            executionConfig.registerPojoType(SubclassPojoBeforeSchemaUpgrade.class);\n\n            TypeSerializer<BasePojo> serializer =\n                    TypeExtractor.createTypeInfo(BasePojo.class).createSerializer(executionConfig);\n            assertSame(PojoSerializer.class, serializer.getClass());\n            return serializer;\n        }",
          "conflictNames": [
              "serializer"
          ]
      },
      "suggestions": [
          {
              "name": "serializerConfigImpl",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/84444d5071984a8543a81574dc69c0c9849a8a4a^1/flink-core/src/test/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializerUpgradeTestSpecifications.java",
      "locators": [
          {
              "line": 476,
              "column": 29
          },
          {
              "line": 477,
              "column": 13
          },
          {
              "line": 480,
              "column": 83
          },
          {
              "line": 555,
              "column": 29
          },
          {
              "line": 556,
              "column": 13
          },
          {
              "line": 559,
              "column": 83
          },
          {
              "line": 600,
              "column": 29
          },
          {
              "line": 601,
              "column": 13
          },
          {
              "line": 605,
              "column": 47
          },
          {
              "line": 637,
              "column": 29
          },
          {
              "line": 638,
              "column": 13
          },
          {
              "line": 642,
              "column": 47
          },
          {
              "line": 719,
              "column": 29
          },
          {
              "line": 720,
              "column": 13
          },
          {
              "line": 721,
              "column": 13
          },
          {
              "line": 725,
              "column": 47
          },
          {
              "line": 741,
              "column": 29
          },
          {
              "line": 743,
              "column": 13
          },
          {
              "line": 744,
              "column": 13
          },
          {
              "line": 748,
              "column": 47
          },
          {
              "line": 777,
              "column": 29
          },
          {
              "line": 778,
              "column": 13
          },
          {
              "line": 779,
              "column": 13
          },
          {
              "line": 783,
              "column": 47
          },
          {
              "line": 799,
              "column": 29
          },
          {
              "line": 801,
              "column": 13
          },
          {
              "line": 805,
              "column": 47
          },
          {
              "line": 833,
              "column": 29
          },
          {
              "line": 837,
              "column": 47
          },
          {
              "line": 854,
              "column": 29
          },
          {
              "line": 856,
              "column": 13
          },
          {
              "line": 860,
              "column": 47
          },
          {
              "line": 888,
              "column": 29
          },
          {
              "line": 889,
              "column": 13
          },
          {
              "line": 890,
              "column": 13
          },
          {
              "line": 894,
              "column": 47
          },
          {
              "line": 910,
              "column": 29
          },
          {
              "line": 911,
              "column": 13
          },
          {
              "line": 912,
              "column": 13
          },
          {
              "line": 916,
              "column": 47
          }
      ],
      "old_name": "executionConfig",
      "new_name": "serializerConfig",
      "ctx": {
          "symbolName": "executionConfig",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ExecutionConfig",
          "scopeHint": "in createPriorSerializer(...)",
          "filePath": "PojoSerializerUpgradeTestSpecifications.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public TypeSerializer<BasePojo> createPriorSerializer() {\n            ExecutionConfig executionConfig = new ExecutionConfig();\n            executionConfig.registerPojoType(SubclassPojoBeforeSchemaUpgrade.class);\n\n            TypeSerializer<BasePojo> serializer =\n                    TypeExtractor.createTypeInfo(BasePojo.class).createSerializer(executionConfig);\n            assertSame(PojoSerializer.class, serializer.getClass());\n            return serializer;\n        }",
          "conflictNames": [
              "serializer"
          ]
      },
      "suggestions": [
          {
              "name": "serializerConfigImpl",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/84444d5071984a8543a81574dc69c0c9849a8a4a^1/flink-core/src/test/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoClearedBufferTest.java",
      "locators": [
          {
              "line": 50,
              "column": 25
          },
          {
              "line": 51,
              "column": 9
          },
          {
              "line": 53,
              "column": 9
          },
          {
              "line": 56,
              "column": 66
          }
      ],
      "old_name": "executionConfig",
      "new_name": "serializerConfigImpl",
      "ctx": {
          "symbolName": "executionConfig",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ExecutionConfig",
          "scopeHint": "in testOutputBufferedBeingClearedInCaseOfException(...)",
          "filePath": "KryoClearedBufferTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Tests that the kryo output buffer is cleared in case of an exception. Flink uses the\n     * EOFException to signal that a buffer is full. In such a case, the record which was tried to\n     * be written will be rewritten. Therefore, eventually buffered data of this record has to be\n     * cleared.\n     */\n    @Test\n    public void testOutputBufferedBeingClearedInCaseOfException() throws Exception {\n        ExecutionConfig executionConfig = new ExecutionConfig();\n        executionConfig.registerTypeWithKryoSerializer(\n                TestRecord.class, new TestRecordSerializer());\n        executionConfig.registerKryoType(TestRecord.class);\n\n        KryoSerializer<TestRecord> kryoSerializer =\n                new KryoSerializer<TestRecord>(TestRecord.class, executionConfig);\n\n        int size = 94;\n        int bufferSize = 150;\n\n        TestRecord testRecord = new TestRecord(size);\n\n        TestDataOutputView target = new TestDataOutputView(bufferSize);\n\n        kryoSerializer.serialize(testRecord, target);\n\n        try {\n            kryoSerializer.serialize(testRecord, target);\n            Assert.fail(\"Expected an EOFException.\");\n        } catch (EOFException eofException) {\n            // expected exception\n            // now the Kryo Output should have been cleared\n        }\n\n        TestRecord actualRecord =\n                kryoSerializer.deserialize(\n                        new DataInputViewStreamWrapper(\n                                new ByteArrayInputStream(target.getBuffer())));\n\n        Assert.assertEquals(testRecord, actualRecord);\n\n        target.clear();\n\n        // if the kryo output has been cleared then we can serialize our test record into the target\n        // because the target buffer 150 bytes can host one TestRecord (total serialization size\n        // 100)\n        kryoSerializer.serialize(testRecord, target);\n\n        byte[] buffer = target.getBuffer();\n        int counter = 0;\n\n        for (int i = 0; i < buffer.length; i++) {\n            if (buffer[i] == 42) {\n                counter++;\n            }\n        }\n\n        Assert.assertEquals(size, counter);\n    }",
          "conflictNames": [
              "kryoSerializer",
              "size",
              "bufferSize",
              "testRecord",
              "target",
              "actualRecord",
              "buffer",
              "counter",
              "i"
          ]
      },
      "suggestions": [
          {
              "name": "serializerConfigImpl",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/84444d5071984a8543a81574dc69c0c9849a8a4a^1/flink-core/src/test/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializerCompatibilityTest.java",
      "locators": [
          {
              "line": 108,
              "column": 26
          },
          {
              "line": 110,
              "column": 53
          },
          {
              "line": 133,
              "column": 29
          },
          {
              "line": 135,
              "column": 63
          },
          {
              "line": 162,
              "column": 26
          },
          {
              "line": 164,
              "column": 49
          },
          {
              "line": 186,
              "column": 29
          },
          {
              "line": 188,
              "column": 59
          },
          {
              "line": 211,
              "column": 25
          },
          {
              "line": 212,
              "column": 9
          },
          {
              "line": 213,
              "column": 9
          },
          {
              "line": 216,
              "column": 55
          },
          {
              "line": 234,
              "column": 9
          },
          {
              "line": 235,
              "column": 9
          },
          {
              "line": 236,
              "column": 9
          },
          {
              "line": 238,
              "column": 64
          }
      ],
      "old_name": "executionConfig",
      "new_name": "serializerConfigImpl",
      "ctx": {
          "symbolName": "executionConfig",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ExecutionConfig",
          "scopeHint": "in testMigrationOfTypeWithAvroType(...)",
          "filePath": "KryoSerializerCompatibilityTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testMigrationOfTypeWithAvroType() throws Exception {\n\n        /*\n        When Avro sees the schema \"{\"type\" : \"array\", \"items\" : \"boolean\"}\" it will create a field\n        of type List<Integer> but the actual type will be GenericData.Array<Integer>. The\n        KryoSerializer registers a special Serializer for this type that simply deserializes\n        as ArrayList because Kryo cannot handle GenericData.Array well. Before Flink 1.4 Avro\n        was always in the classpath but after 1.4 it's only present if the flink-avro jar is\n        included. This test verifies that we can still deserialize data written pre-1.4.\n        */\n        class FakeAvroClass {\n            public List<Integer> array;\n\n            FakeAvroClass(List<Integer> array) {\n                this.array = array;\n            }\n        }\n\n        /*\n        // This has to be executed on a pre-1.4 branch to generate the binary blob\n        {\n        \tExecutionConfig executionConfig = new ExecutionConfig();\n        \tKryoSerializer<FakeAvroClass> kryoSerializer =\n        \t\tnew KryoSerializer<>(FakeAvroClass.class, executionConfig);\n\n        \ttry (\n        \t\tFileOutputStream f = new FileOutputStream(\n        \t\t\t\"src/test/resources/type-with-avro-serialized-using-kryo\");\n        \t\tDataOutputViewStreamWrapper outputView = new DataOutputViewStreamWrapper(f)) {\n\n\n        \t\tGenericData.Array<Integer> array =\n        \t\t\tnew GenericData.Array<>(10, Schema.createArray(Schema.create(Schema.Type.INT)));\n\n        \t\tarray.add(10);\n        \t\tarray.add(20);\n        \t\tarray.add(30);\n\n        \t\tFakeAvroClass myTestClass = new FakeAvroClass(array);\n\n        \t\tkryoSerializer.serialize(myTestClass, outputView);\n        \t}\n        }\n        */\n\n        {\n            ExecutionConfig executionConfig = new ExecutionConfig();\n            KryoSerializer<FakeAvroClass> kryoSerializer =\n                    new KryoSerializer<>(FakeAvroClass.class, executionConfig);\n\n            try (FileInputStream f =\n                            new FileInputStream(\n                                    \"src/test/resources/type-with-avro-serialized-using-kryo\");\n                    DataInputViewStreamWrapper inputView = new DataInputViewStreamWrapper(f)) {\n\n                thrown.expectMessage(\"Could not find required Avro dependency\");\n                kryoSerializer.deserialize(inputView);\n            }\n        }\n    }",
          "conflictNames": [
              "kryoSerializer",
              "f",
              "inputView"
          ]
      },
      "suggestions": [
          {
              "name": "serializerConfigImpl",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/84444d5071984a8543a81574dc69c0c9849a8a4a^1/flink-core/src/test/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializerConcurrencyTest.java",
      "locators": [
          {
              "line": 50,
              "column": 25
          },
          {
              "line": 51,
              "column": 9
          },
          {
              "line": 52,
              "column": 36
          },
          {
              "line": 57,
              "column": 25
          },
          {
              "line": 58,
              "column": 9
          },
          {
              "line": 59,
              "column": 36
          },
          {
              "line": 64,
              "column": 25
          },
          {
              "line": 65,
              "column": 9
          },
          {
              "line": 66,
              "column": 36
          },
          {
              "line": 71,
              "column": 25
          },
          {
              "line": 72,
              "column": 9
          },
          {
              "line": 73,
              "column": 36
          },
          {
              "line": 76,
              "column": 61
          },
          {
              "line": 78,
              "column": 59
          }
      ],
      "old_name": "executionConfig",
      "new_name": "serializerConfigImpl",
      "ctx": {
          "symbolName": "executionConfig",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ExecutionConfig",
          "scopeHint": "in testDuplicateSerializerWithDefaultSerializerClass(...)",
          "filePath": "KryoSerializerConcurrencyTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testDuplicateSerializerWithDefaultSerializerClass() {\n        ExecutionConfig executionConfig = new ExecutionConfig();\n        executionConfig.addDefaultKryoSerializer(WrappedString.class, TestSerializer.class);\n        runDuplicateSerializerTest(executionConfig);\n    }"
      },
      "suggestions": [
          {
              "name": "serializerConfigImpl",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/84444d5071984a8543a81574dc69c0c9849a8a4a^1/flink-core/src/test/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializerUpgradeTest.java",
      "locators": [
          {
              "line": 124,
              "column": 29
          },
          {
              "line": 125,
              "column": 13
          },
          {
              "line": 126,
              "column": 13
          },
          {
              "line": 129,
              "column": 55
          },
          {
              "line": 155,
              "column": 29
          },
          {
              "line": 156,
              "column": 13
          },
          {
              "line": 157,
              "column": 13
          },
          {
              "line": 158,
              "column": 13
          },
          {
              "line": 160,
              "column": 55
          },
          {
              "line": 174,
              "column": 29
          },
          {
              "line": 175,
              "column": 13
          },
          {
              "line": 176,
              "column": 13
          },
          {
              "line": 177,
              "column": 13
          },
          {
              "line": 178,
              "column": 13
          },
          {
              "line": 179,
              "column": 13
          },
          {
              "line": 181,
              "column": 55
          },
          {
              "line": 207,
              "column": 29
          },
          {
              "line": 208,
              "column": 13
          },
          {
              "line": 210,
              "column": 13
          },
          {
              "line": 211,
              "column": 13
          },
          {
              "line": 214,
              "column": 55
          },
          {
              "line": 228,
              "column": 29
          },
          {
              "line": 229,
              "column": 13
          },
          {
              "line": 230,
              "column": 13
          },
          {
              "line": 232,
              "column": 13
          },
          {
              "line": 233,
              "column": 13
          },
          {
              "line": 234,
              "column": 13
          },
          {
              "line": 237,
              "column": 55
          }
      ],
      "old_name": "executionConfig",
      "new_name": "serializerConfigImpl",
      "ctx": {
          "symbolName": "executionConfig",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ExecutionConfig",
          "scopeHint": "in createUpgradedSerializer(...)",
          "filePath": "KryoSerializerUpgradeTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public TypeSerializer<Animal> createUpgradedSerializer() {\n            ExecutionConfig executionConfig = new ExecutionConfig();\n            executionConfig.registerKryoType(DummyClassOne.class);\n            executionConfig.registerTypeWithKryoSerializer(\n                    DummyClassTwo.class, DefaultSerializers.StringSerializer.class);\n\n            return new KryoSerializer<>(Animal.class, executionConfig);\n        }"
      },
      "suggestions": [
          {
              "name": "serializerConfigImpl",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/84444d5071984a8543a81574dc69c0c9849a8a4a^1/flink-test-utils-parent/flink-test-utils/src/main/java/org/apache/flink/types/PojoTestUtils.java",
      "locators": [
          {
              "line": 71,
              "column": 31
          },
          {
              "line": 72,
              "column": 9
          },
          {
              "line": 77,
              "column": 65
          }
      ],
      "old_name": "executionConfig",
      "new_name": "serializerConfig",
      "ctx": {
          "symbolName": "executionConfig",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ExecutionConfig",
          "scopeHint": "in assertSerializedAsPojoWithoutKryo(...)",
          "filePath": "PojoTestUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Verifies that instances of the given class fulfill all conditions to be serialized with the\n     * {@link PojoSerializer}, as documented <a\n     * href=\"https://nightlies.apache.org/flink/flink-docs-stable/docs/dev/datastream/fault-tolerance/serialization/types_serialization/#pojos\">here</a>,\n     * without any field being serialized with Kryo.\n     *\n     * @param clazz class to analyze\n     * @param <T> class type\n     * @throws AssertionError if instances of the class cannot be serialized as a POJO or required\n     *     Kryo for one or more fields\n     */\n    public static <T> void assertSerializedAsPojoWithoutKryo(Class<T> clazz) throws AssertionError {\n        final ExecutionConfig executionConfig = new ExecutionConfig();\n        executionConfig.disableGenericTypes();\n\n        final TypeInformation<T> typeInformation = TypeInformation.of(clazz);\n        final TypeSerializer<T> actualSerializer;\n        try {\n            actualSerializer = typeInformation.createSerializer(executionConfig);\n        } catch (UnsupportedOperationException e) {\n            throw new AssertionError(e);\n        }\n\n        assertThat(actualSerializer)\n                .withFailMessage(\n                        \"Instances of the class '%s' cannot be serialized as a POJO, but would use a '%s' instead. %n\"\n                                + \"Re-run this test with INFO logging enabled and check messages from the '%s' for possible reasons.\",\n                        clazz.getSimpleName(),\n                        actualSerializer.getClass().getSimpleName(),\n                        TypeExtractor.class.getCanonicalName())\n                .isInstanceOf(PojoSerializer.class);\n    }",
          "conflictNames": [
              "clazz",
              "typeInformation",
              "actualSerializer"
          ]
      },
      "suggestions": [
          {
              "name": "serializerConfigImpl",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/84444d5071984a8543a81574dc69c0c9849a8a4a^1/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/catalog/DataTypeFactoryImpl.java",
      "locators": [
          {
              "line": 133,
              "column": 35
          },
          {
              "line": 137,
              "column": 21
          },
          {
              "line": 141,
              "column": 21
          },
          {
              "line": 148,
              "column": 41
          },
          {
              "line": 153,
              "column": 34
          },
          {
              "line": 157,
              "column": 34
          },
          {
              "line": 161,
              "column": 34
          },
          {
              "line": 167,
              "column": 41
          },
          {
              "line": 171,
              "column": 13
          },
          {
              "line": 173,
              "column": 20
          }
      ],
      "old_name": "newExecutionConfig",
      "new_name": "newSerializerConfig",
      "ctx": {
          "symbolName": "newExecutionConfig",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ExecutionConfig",
          "scopeHint": "in createSerializerExecutionConfig(...)",
          "filePath": "DataTypeFactoryImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Creates a lazy {@link ExecutionConfig} that contains options for {@link TypeSerializer}s with\n     * information from existing {@link ExecutionConfig} (if available) enriched with table {@link\n     * ReadableConfig}.\n     */\n    private static Supplier<ExecutionConfig> createSerializerExecutionConfig(\n            ClassLoader classLoader, ReadableConfig config, ExecutionConfig executionConfig) {\n        return () -> {\n            final ExecutionConfig newExecutionConfig = new ExecutionConfig();\n\n            if (executionConfig != null) {\n                if (executionConfig.isForceKryoEnabled()) {\n                    newExecutionConfig.enableForceKryo();\n                }\n\n                if (executionConfig.isForceAvroEnabled()) {\n                    newExecutionConfig.enableForceAvro();\n                }\n\n                executionConfig\n                        .getDefaultKryoSerializers()\n                        .forEach(\n                                (c, s) ->\n                                        newExecutionConfig.addDefaultKryoSerializer(\n                                                c, s.getSerializer()));\n\n                executionConfig\n                        .getDefaultKryoSerializerClasses()\n                        .forEach(newExecutionConfig::addDefaultKryoSerializer);\n\n                executionConfig\n                        .getRegisteredKryoTypes()\n                        .forEach(newExecutionConfig::registerKryoType);\n\n                executionConfig\n                        .getRegisteredTypesWithKryoSerializerClasses()\n                        .forEach(newExecutionConfig::registerTypeWithKryoSerializer);\n\n                executionConfig\n                        .getRegisteredTypesWithKryoSerializers()\n                        .forEach(\n                                (c, s) ->\n                                        newExecutionConfig.registerTypeWithKryoSerializer(\n                                                c, s.getSerializer()));\n            }\n\n            newExecutionConfig.configure(config, classLoader);\n\n            return newExecutionConfig;\n        };\n    }",
          "conflictNames": [
              "classLoader",
              "config",
              "executionConfig"
          ]
      },
      "suggestions": [
          {
              "name": "serializerConfig",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/85937b8c11dcca25fd978d095d07af121d7ae8e3^1/flink-formats/flink-avro/src/main/java/org/apache/flink/formats/avro/typeutils/AvroSerializerSnapshot.java",
      "locators": [
          {
              "line": 137,
              "column": 27
          },
          {
              "line": 138,
              "column": 51
          }
      ],
      "old_name": "newAvroSerializer",
      "new_name": "oldAvroSerializerSnapshot",
      "ctx": {
          "symbolName": "newAvroSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "AvroSerializer<?>",
          "scopeHint": "in resolveSchemaCompatibility(...)",
          "filePath": "AvroSerializerSnapshot.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(\n            TypeSerializer<T> newSerializer) {\n        if (!(newSerializer instanceof AvroSerializer)) {\n            return TypeSerializerSchemaCompatibility.incompatible();\n        }\n        AvroSerializer<?> newAvroSerializer = (AvroSerializer<?>) newSerializer;\n        return resolveSchemaCompatibility(schema, newAvroSerializer.getAvroSchema());\n    }",
          "conflictNames": [
              "newSerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/86ee4b58e3878335d15aeb425025dd8b05973823^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/QueryOperationConverter.java",
      "locators": [
          {
              "line": 305,
              "column": 33
          },
          {
              "line": 332,
              "column": 61
          },
          {
              "line": 335,
              "column": 45
          },
          {
              "line": 352,
              "column": 29
          },
          {
              "line": 464,
              "column": 17
          },
          {
              "line": 466,
              "column": 17
          },
          {
              "line": 471,
              "column": 17
          },
          {
              "line": 475,
              "column": 17
          },
          {
              "line": 476,
              "column": 40
          }
      ],
      "old_name": "inputs",
      "new_name": "inputStack",
      "ctx": {
          "symbolName": "inputs",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<RelNode>",
          "scopeHint": "in visit(...)",
          "filePath": "QueryOperationConverter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public RelNode visit(FunctionQueryOperation functionTable) {\n            final FlinkTypeFactory typeFactory = ShortcutUtils.unwrapTypeFactory(relBuilder);\n            final ContextResolvedFunction contextFunction = functionTable.getResolvedFunction();\n            final List<ResolvedExpression> resolvedArgs = functionTable.getArguments();\n            final LogicalType outputType = functionTable.getOutputDataType().getLogicalType();\n            final RelDataType outputRelDataType =\n                    typeFactory.buildRelNodeRowType((RowType) outputType);\n\n            final List<RelNode> inputs = new ArrayList<>();\n            final List<RexNode> rexNodeArgs =\n                    resolvedArgs.stream()\n                            .map(\n                                    resolvedArg -> {\n                                        if (resolvedArg instanceof TableReferenceExpression) {\n                                            final TableReferenceExpression tableRef =\n                                                    (TableReferenceExpression) resolvedArg;\n                                            final LogicalType tableArgType =\n                                                    tableRef.getOutputDataType().getLogicalType();\n                                            final RelDataType rowType =\n                                                    typeFactory.buildRelNodeRowType(\n                                                            (RowType) tableArgType);\n                                            final int[] partitionKeys;\n                                            if (tableRef.getQueryOperation()\n                                                    instanceof PartitionQueryOperation) {\n                                                final PartitionQueryOperation partitionOperation =\n                                                        (PartitionQueryOperation)\n                                                                tableRef.getQueryOperation();\n                                                partitionKeys =\n                                                        partitionOperation.getPartitionKeys();\n                                            } else {\n                                                partitionKeys = new int[0];\n                                            }\n                                            final RexTableArgCall tableArgCall =\n                                                    new RexTableArgCall(\n                                                            rowType,\n                                                            inputs.size(),\n                                                            partitionKeys,\n                                                            new int[0]);\n                                            inputs.add(relBuilder.build());\n                                            return tableArgCall;\n                                        }\n                                        return convertExprToRexNode(resolvedArg);\n                                    })\n                            .collect(Collectors.toList());\n\n            final BridgingSqlFunction sqlFunction =\n                    BridgingSqlFunction.of(relBuilder.getCluster(), contextFunction);\n\n            final RexNode call =\n                    relBuilder\n                            .getRexBuilder()\n                            .makeCall(outputRelDataType, sqlFunction, rexNodeArgs);\n            final RelNode functionScan =\n                    LogicalTableFunctionScan.create(\n                            relBuilder.getCluster(),\n                            inputs,\n                            call,\n                            null,\n                            outputRelDataType,\n                            Collections.emptySet());\n            relBuilder.push(functionScan);\n            return relBuilder.build();\n        }",
          "conflictNames": [
              "functionTable",
              "typeFactory",
              "contextFunction",
              "resolvedArgs",
              "outputType",
              "outputRelDataType",
              "rexNodeArgs",
              "tableRef",
              "tableArgType",
              "rowType",
              "partitionKeys",
              "partitionOperation",
              "tableArgCall",
              "sqlFunction",
              "call",
              "functionScan"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/8986bf0f599d6547f6988cf3259c1b403cd4e317^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveScheduler.java",
      "locators": [
          {
              "line": 1058,
              "column": 47
          },
          {
              "line": 1062,
              "column": 17
          },
          {
              "line": 1065,
              "column": 25
          }
      ],
      "old_name": "potentialNewParallelism",
      "new_name": "maybeNewParallelism",
      "ctx": {
          "symbolName": "potentialNewParallelism",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Optional<VertexParallelism>",
          "scopeHint": "in canScaleUp(...)",
          "filePath": "AdaptiveScheduler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public boolean canScaleUp(ExecutionGraph executionGraph) {\n        int availableSlots = declarativeSlotPool.getFreeSlotsInformation().size();\n\n        if (availableSlots > 0) {\n            final Optional<VertexParallelism> potentialNewParallelism =\n                    slotAllocator.determineParallelism(\n                            jobInformation, declarativeSlotPool.getAllSlotsInformation());\n\n            if (potentialNewParallelism.isPresent()) {\n                int currentCumulativeParallelism = getCurrentCumulativeParallelism(executionGraph);\n                int newCumulativeParallelism =\n                        potentialNewParallelism.get().getCumulativeParallelism();\n                if (newCumulativeParallelism > currentCumulativeParallelism) {\n                    LOG.debug(\n                            \"Offering scale up to scale up controller with currentCumulativeParallelism={}, newCumulativeParallelism={}\",\n                            currentCumulativeParallelism,\n                            newCumulativeParallelism);\n                    return scaleUpController.canScaleUp(\n                            currentCumulativeParallelism, newCumulativeParallelism);\n                }\n            }\n        }\n        return false;\n    }",
          "conflictNames": [
              "executionGraph",
              "availableSlots",
              "currentCumulativeParallelism",
              "newCumulativeParallelism"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/8b5a1cff8551e66974e1009fd225d3f39b55f52d^1/flink-table/flink-table-planner/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java",
      "locators": [
          {
              "line": 4548,
              "column": 15
          },
          {
              "line": 4551,
              "column": 66
          },
          {
              "line": 4552,
              "column": 40
          },
          {
              "line": 4553,
              "column": 40
          },
          {
              "line": 4936,
              "column": 22
          },
          {
              "line": 4937,
              "column": 21
          },
          {
              "line": 4937,
              "column": 48
          },
          {
              "line": 4939,
              "column": 38
          },
          {
              "line": 4942,
              "column": 21
          }
      ],
      "old_name": "rowConstructor",
      "new_name": "newRowConst",
      "ctx": {
          "symbolName": "rowConstructor",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "SqlCall",
          "scopeHint": "in convertRowConstructor(...)",
          "filePath": "SqlToRelConverter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "tional expression.\n     *\n     * @param bb Blackboard\n     * @param rowConstructor Row constructor expression\n     * @return Relational expression which returns a single row.\n     */\n    private RelNode convertRowConstructor(Blackboard bb, SqlCall rowConstructor) {\n        checkArgument(isRowConstructor(rowConstructor));\n        final List<SqlNode> operands = rowConstructor.getOperandList();\n        return convertMultisets(operands, bb);\n    }\n\n    private RelNode convertCursor(Blackboard bb, SubQ",
          "conflictNames": [
              "bb",
              "operands"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/8b5a1cff8551e66974e1009fd225d3f39b55f52d^1/flink-table/flink-table-planner/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java",
      "locators": [
          {
              "line": 4936,
              "column": 22
          },
          {
              "line": 4937,
              "column": 48
          }
      ],
      "old_name": "rowConstructor1",
      "new_name": "rowConstructor",
      "ctx": {
          "symbolName": "rowConstructor1",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "SqlNode",
          "scopeHint": "in convertValuesImpl(...)",
          "filePath": "SqlToRelConverter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": ".\n        RelNode valuesRel =\n                convertRowValues(bb, values, values.getOperandList(), true, targetRowType);\n        if (valuesRel != null) {\n            bb.setRoot(valuesRel, true);\n            return;\n        }\n\n        for (SqlNode rowConstructor1 : values.getOperandList()) {\n            SqlCall rowConstructor = (SqlCall) rowConstructor1;\n            Blackboard tmpBb = createBlackboard(bb.scope, null, false);\n            replaceSubQueries(tmpBb, rowConstructor, RelOptUtil.Logic.TRUE",
          "conflictNames": [
              "bb",
              "values",
              "targetRowType",
              "valuesRel",
              "rowConstructor",
              "tmpBb",
              "exps",
              "in"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/8b6a608490322d7eb1056120824809c2455950c3^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PartitionedFileReader.java",
      "locators": [
          {
              "line": 78,
              "column": 45
          },
          {
              "line": 103,
              "column": 18
          },
          {
              "line": 104,
              "column": 36
          },
          {
              "line": 104,
              "column": 52
          },
          {
              "line": 105,
              "column": 36
          },
          {
              "line": 106,
              "column": 47
          },
          {
              "line": 110,
              "column": 64
          },
          {
              "line": 118,
              "column": 17
          },
          {
              "line": 147,
              "column": 15
          },
          {
              "line": 152,
              "column": 65
          },
          {
              "line": 160,
              "column": 72
          },
          {
              "line": 166,
              "column": 21
          },
          {
              "line": 171,
              "column": 21
          },
          {
              "line": 184,
              "column": 15
          },
          {
              "line": 192,
              "column": 39
          },
          {
              "line": 205,
              "column": 13
          },
          {
              "line": 212,
              "column": 17
          }
      ],
      "old_name": "offsetAndSize",
      "new_name": "descriptor",
      "ctx": {
          "symbolName": "offsetAndSize",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Tuple2<Long, Long>",
          "scopeHint": "in moveToNextReadablePosition(...)",
          "filePath": "PartitionedFileReader.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void moveToNextReadablePosition(ByteBuffer indexEntryBuf) throws IOException {\n        while (currentRegionRemainingBytes <= 0 && hasNextPositionToRead()) {\n            if (!offsetAndSizesToRead.isEmpty()) {\n                Tuple2<Long, Long> offsetAndSize = offsetAndSizesToRead.poll();\n                nextOffsetToRead = offsetAndSize.f0;\n                currentRegionRemainingBytes = offsetAndSize.f1;\n            } else {\n                // move to next region which has buffers\n                if (nextRegionToRead < partitionedFile.getNumRegions()) {\n                    updateReadableOffsetAndSize(indexEntryBuf, offsetAndSizesToRead);\n                    ++nextRegionToRead;\n                }\n            }\n        }\n    }",
          "conflictNames": [
              "indexEntryBuf"
          ]
      },
      "suggestions": [
          {
              "name": "descriptor",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/8b6a608490322d7eb1056120824809c2455950c3^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PartitionedFileWriteReadTest.java",
      "locators": [
          {
              "line": 221,
              "column": 35
          },
          {
              "line": 223,
              "column": 52
          },
          {
              "line": 226,
              "column": 24
          },
          {
              "line": 227,
              "column": 46
          },
          {
              "line": 235,
              "column": 24
          },
          {
              "line": 237,
              "column": 32
          },
          {
              "line": 237,
              "column": 48
          },
          {
              "line": 238,
              "column": 24
          },
          {
              "line": 244,
              "column": 24
          },
          {
              "line": 246,
              "column": 24
          },
          {
              "line": 248,
              "column": 32
          },
          {
              "line": 248,
              "column": 49
          },
          {
              "line": 249,
              "column": 32
          },
          {
              "line": 249,
              "column": 49
          },
          {
              "line": 250,
              "column": 24
          },
          {
              "line": 252,
              "column": 24
          },
          {
              "line": 258,
              "column": 24
          },
          {
              "line": 264,
              "column": 24
          }
      ],
      "old_name": "offsetAndSize",
      "new_name": "descriptor",
      "ctx": {
          "symbolName": "offsetAndSize",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Tuple2<Long, Long>",
          "scopeHint": "in verifyReadablePosition(...)",
          "filePath": "PartitionedFileWriteReadTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void verifyReadablePosition(\n            int start,\n            int end,\n            int subpartitionOrderRotationIndex,\n            FileChannel dataFileChannel,\n            FileChannel indexFileChannel,\n            PartitionedFile partitionedFile,\n            List<Tuple2<Long, Long>>[] regionStat,\n            boolean isBroadcastRegion)\n            throws IOException {\n        PartitionedFileReader fileReader =\n                new PartitionedFileReader(\n                        partitionedFile,\n                        new ResultSubpartitionIndexSet(start, end),\n                        dataFileChannel,\n                        indexFileChannel,\n                        BufferReaderWriterUtil.allocatedHeaderBuffer(),\n                        createAndConfigIndexEntryBuffer(),\n                        subpartitionOrderRotationIndex);\n\n        Queue<Tuple2<Long, Long>> offsetAndSizesToRead = new ArrayDeque<>();\n        fileReader.updateReadableOffsetAndSize(\n                createAndConfigIndexEntryBuffer(), offsetAndSizesToRead);\n\n        if (isBroadcastRegion) {\n            assertThat(offsetAndSizesToRead).hasSize(end - start + 1);\n            for (Tuple2<Long, Long> tuple2 : offsetAndSizesToRead) {\n                assertThat(tuple2.f0).isEqualTo(regionStat[start].get(0).f0);\n                assertThat(tuple2.f1).isEqualTo(regionStat[start].get(0).f1);\n            }\n            return;\n        }\n\n        if (start >= subpartitionOrderRotationIndex || end <= subpartitionOrderRotationIndex - 1) {\n            assertThat(offsetAndSizesToRead).hasSize(1);\n\n            Tuple2<Long, Long> offsetAndSize = offsetAndSizesToRead.poll();\n            assertThat(offsetAndSize.f0).isEqualTo(regionStat[start].get(0).f0);\n\n            long expectedSize = 0L;\n            for (int i = start; i <= end; i++) {\n                expectedSize += regionStat[i].get(0).f1;\n            }\n            assertThat(offsetAndSize.f1).isEqualTo(expectedSize);\n        } else {\n            assertThat(offsetAndSizesToRead).hasSize(2);\n\n            Tuple2<Long, Long> offsetAndSize1 = offsetAndSizesToRead.poll();\n            Tuple2<Long, Long> offsetAndSize2 = offsetAndSizesToRead.poll();\n            assertThat(offsetAndSize1.f0)\n                    .isEqualTo(regionStat[subpartitionOrderRotationIndex].get(0).f0);\n            assertThat(offsetAndSize2.f0).isEqualTo(regionStat[start].get(0).f0);\n\n            long expectedSize = 0L;\n            for (int i = subpartitionOrderRotationIndex; i <= end; i++) {\n                expectedSize += regionStat[i].get(0).f1;\n            }\n            assertThat(offsetAndSize1.f1).isEqualTo(expectedSize);\n\n            expectedSize = 0L;\n            for (int i = start; i < subpartitionOrderRotationIndex; i++) {\n                expectedSize += regionStat[i].get(0).f1;\n            }\n            assertThat(offsetAndSize2.f1).isEqualTo(expectedSize);\n        }\n    }",
          "conflictNames": [
              "start",
              "end",
              "subpartitionOrderRotationIndex",
              "dataFileChannel",
              "indexFileChannel",
              "partitionedFile",
              "regionStat",
              "isBroadcastRegion",
              "fileReader",
              "offsetAndSizesToRead",
              "expectedSize",
              "i",
              "offsetAndSize1",
              "offsetAndSize2"
          ]
      },
      "suggestions": [
          {
              "name": "descriptor",
              "confidence": 0.7625
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/8b6a608490322d7eb1056120824809c2455950c3^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PartitionedFileWriteReadTest.java",
      "locators": [
          {
              "line": 248,
              "column": 32
          },
          {
              "line": 250,
              "column": 24
          },
          {
              "line": 258,
              "column": 24
          }
      ],
      "old_name": "offsetAndSize1",
      "new_name": "descriptor1",
      "ctx": {
          "symbolName": "offsetAndSize1",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Tuple2<Long, Long>",
          "scopeHint": "in verifyReadablePosition(...)",
          "filePath": "PartitionedFileWriteReadTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void verifyReadablePosition(\n            int start,\n            int end,\n            int subpartitionOrderRotationIndex,\n            FileChannel dataFileChannel,\n            FileChannel indexFileChannel,\n            PartitionedFile partitionedFile,\n            List<Tuple2<Long, Long>>[] regionStat,\n            boolean isBroadcastRegion)\n            throws IOException {\n        PartitionedFileReader fileReader =\n                new PartitionedFileReader(\n                        partitionedFile,\n                        new ResultSubpartitionIndexSet(start, end),\n                        dataFileChannel,\n                        indexFileChannel,\n                        BufferReaderWriterUtil.allocatedHeaderBuffer(),\n                        createAndConfigIndexEntryBuffer(),\n                        subpartitionOrderRotationIndex);\n\n        Queue<Tuple2<Long, Long>> offsetAndSizesToRead = new ArrayDeque<>();\n        fileReader.updateReadableOffsetAndSize(\n                createAndConfigIndexEntryBuffer(), offsetAndSizesToRead);\n\n        if (isBroadcastRegion) {\n            assertThat(offsetAndSizesToRead).hasSize(end - start + 1);\n            for (Tuple2<Long, Long> tuple2 : offsetAndSizesToRead) {\n                assertThat(tuple2.f0).isEqualTo(regionStat[start].get(0).f0);\n                assertThat(tuple2.f1).isEqualTo(regionStat[start].get(0).f1);\n            }\n            return;\n        }\n\n        if (start >= subpartitionOrderRotationIndex || end <= subpartitionOrderRotationIndex - 1) {\n            assertThat(offsetAndSizesToRead).hasSize(1);\n\n            Tuple2<Long, Long> offsetAndSize = offsetAndSizesToRead.poll();\n            assertThat(offsetAndSize.f0).isEqualTo(regionStat[start].get(0).f0);\n\n            long expectedSize = 0L;\n            for (int i = start; i <= end; i++) {\n                expectedSize += regionStat[i].get(0).f1;\n            }\n            assertThat(offsetAndSize.f1).isEqualTo(expectedSize);\n        } else {\n            assertThat(offsetAndSizesToRead).hasSize(2);\n\n            Tuple2<Long, Long> offsetAndSize1 = offsetAndSizesToRead.poll();\n            Tuple2<Long, Long> offsetAndSize2 = offsetAndSizesToRead.poll();\n            assertThat(offsetAndSize1.f0)\n                    .isEqualTo(regionStat[subpartitionOrderRotationIndex].get(0).f0);\n            assertThat(offsetAndSize2.f0).isEqualTo(regionStat[start].get(0).f0);\n\n            long expectedSize = 0L;\n            for (int i = subpartitionOrderRotationIndex; i <= end; i++) {\n                expectedSize += regionStat[i].get(0).f1;\n            }\n            assertThat(offsetAndSize1.f1).isEqualTo(expectedSize);\n\n            expectedSize = 0L;\n            for (int i = start; i < subpartitionOrderRotationIndex; i++) {\n                expectedSize += regionStat[i].get(0).f1;\n            }\n            assertThat(offsetAndSize2.f1).isEqualTo(expectedSize);\n        }\n    }",
          "conflictNames": [
              "start",
              "end",
              "subpartitionOrderRotationIndex",
              "dataFileChannel",
              "indexFileChannel",
              "partitionedFile",
              "regionStat",
              "isBroadcastRegion",
              "fileReader",
              "offsetAndSizesToRead",
              "offsetAndSize",
              "expectedSize",
              "i",
              "offsetAndSize2"
          ]
      },
      "suggestions": [
          {
              "name": "descriptor1",
              "confidence": 0.7625
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/8b6a608490322d7eb1056120824809c2455950c3^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PartitionedFileWriteReadTest.java",
      "locators": [
          {
              "line": 249,
              "column": 32
          },
          {
              "line": 252,
              "column": 24
          },
          {
              "line": 264,
              "column": 24
          }
      ],
      "old_name": "offsetAndSize2",
      "new_name": "descriptor2",
      "ctx": {
          "symbolName": "offsetAndSize2",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Tuple2<Long, Long>",
          "scopeHint": "in verifyReadablePosition(...)",
          "filePath": "PartitionedFileWriteReadTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void verifyReadablePosition(\n            int start,\n            int end,\n            int subpartitionOrderRotationIndex,\n            FileChannel dataFileChannel,\n            FileChannel indexFileChannel,\n            PartitionedFile partitionedFile,\n            List<Tuple2<Long, Long>>[] regionStat,\n            boolean isBroadcastRegion)\n            throws IOException {\n        PartitionedFileReader fileReader =\n                new PartitionedFileReader(\n                        partitionedFile,\n                        new ResultSubpartitionIndexSet(start, end),\n                        dataFileChannel,\n                        indexFileChannel,\n                        BufferReaderWriterUtil.allocatedHeaderBuffer(),\n                        createAndConfigIndexEntryBuffer(),\n                        subpartitionOrderRotationIndex);\n\n        Queue<Tuple2<Long, Long>> offsetAndSizesToRead = new ArrayDeque<>();\n        fileReader.updateReadableOffsetAndSize(\n                createAndConfigIndexEntryBuffer(), offsetAndSizesToRead);\n\n        if (isBroadcastRegion) {\n            assertThat(offsetAndSizesToRead).hasSize(end - start + 1);\n            for (Tuple2<Long, Long> tuple2 : offsetAndSizesToRead) {\n                assertThat(tuple2.f0).isEqualTo(regionStat[start].get(0).f0);\n                assertThat(tuple2.f1).isEqualTo(regionStat[start].get(0).f1);\n            }\n            return;\n        }\n\n        if (start >= subpartitionOrderRotationIndex || end <= subpartitionOrderRotationIndex - 1) {\n            assertThat(offsetAndSizesToRead).hasSize(1);\n\n            Tuple2<Long, Long> offsetAndSize = offsetAndSizesToRead.poll();\n            assertThat(offsetAndSize.f0).isEqualTo(regionStat[start].get(0).f0);\n\n            long expectedSize = 0L;\n            for (int i = start; i <= end; i++) {\n                expectedSize += regionStat[i].get(0).f1;\n            }\n            assertThat(offsetAndSize.f1).isEqualTo(expectedSize);\n        } else {\n            assertThat(offsetAndSizesToRead).hasSize(2);\n\n            Tuple2<Long, Long> offsetAndSize1 = offsetAndSizesToRead.poll();\n            Tuple2<Long, Long> offsetAndSize2 = offsetAndSizesToRead.poll();\n            assertThat(offsetAndSize1.f0)\n                    .isEqualTo(regionStat[subpartitionOrderRotationIndex].get(0).f0);\n            assertThat(offsetAndSize2.f0).isEqualTo(regionStat[start].get(0).f0);\n\n            long expectedSize = 0L;\n            for (int i = subpartitionOrderRotationIndex; i <= end; i++) {\n                expectedSize += regionStat[i].get(0).f1;\n            }\n            assertThat(offsetAndSize1.f1).isEqualTo(expectedSize);\n\n            expectedSize = 0L;\n            for (int i = start; i < subpartitionOrderRotationIndex; i++) {\n                expectedSize += regionStat[i].get(0).f1;\n            }\n            assertThat(offsetAndSize2.f1).isEqualTo(expectedSize);\n        }\n    }",
          "conflictNames": [
              "start",
              "end",
              "subpartitionOrderRotationIndex",
              "dataFileChannel",
              "indexFileChannel",
              "partitionedFile",
              "regionStat",
              "isBroadcastRegion",
              "fileReader",
              "offsetAndSizesToRead",
              "offsetAndSize",
              "expectedSize",
              "i",
              "offsetAndSize1"
          ]
      },
      "suggestions": [
          {
              "name": "descriptor2",
              "confidence": 0.7625
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/8b6a608490322d7eb1056120824809c2455950c3^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PartitionedFileWriteReadTest.java",
      "locators": [
          {
              "line": 227,
              "column": 37
          },
          {
              "line": 228,
              "column": 28
          },
          {
              "line": 229,
              "column": 28
          }
      ],
      "old_name": "tuple2",
      "new_name": "descriptor",
      "ctx": {
          "symbolName": "tuple2",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Tuple2<Long, Long>",
          "scopeHint": "in verifyReadablePosition(...)",
          "filePath": "PartitionedFileWriteReadTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "    fileReader.updateReadableOffsetAndSize(\n                createAndConfigIndexEntryBuffer(), offsetAndSizesToRead);\n\n        if (isBroadcastRegion) {\n            assertThat(offsetAndSizesToRead).hasSize(end - start + 1);\n            for (Tuple2<Long, Long> tuple2 : offsetAndSizesToRead) {\n                assertThat(tuple2.f0).isEqualTo(regionStat[start].get(0).f0);\n                assertThat(tuple2.f1).isEqualTo(regionStat[start].get(0).f1);\n            }\n            return;\n        }\n\n        if (",
          "conflictNames": [
              "start",
              "end",
              "subpartitionOrderRotationIndex",
              "dataFileChannel",
              "indexFileChannel",
              "partitionedFile",
              "regionStat",
              "isBroadcastRegion",
              "fileReader",
              "offsetAndSizesToRead",
              "offsetAndSize",
              "expectedSize",
              "i",
              "offsetAndSize1",
              "offsetAndSize2"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/8be94e6663d8ac6e3d74bf4cd5f540cc96c8289e^1/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateCheckpointWriter.java",
      "locators": [
          {
              "line": 217,
              "column": 27
          },
          {
              "line": 219,
              "column": 17
          },
          {
              "line": 224,
              "column": 17
          },
          {
              "line": 245,
              "column": 31
          },
          {
              "line": 252,
              "column": 53
          },
          {
              "line": 263,
              "column": 31
          },
          {
              "line": 268,
              "column": 17
          },
          {
              "line": 286,
              "column": 21
          },
          {
              "line": 322,
              "column": 35
          }
      ],
      "old_name": "underlying",
      "new_name": "stateHandle",
      "ctx": {
          "symbolName": "underlying",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "StreamStateHandle",
          "scopeHint": "in finishWriteAndResult(...)",
          "filePath": "ChannelStateCheckpointWriter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void finishWriteAndResult() throws IOException {\n        if (inputChannelOffsets.isEmpty() && resultSubpartitionOffsets.isEmpty()) {\n            dataStream.close();\n            result.inputChannelStateHandles.complete(emptyList());\n            result.resultSubpartitionStateHandles.complete(emptyList());\n            return;\n        }\n        dataStream.flush();\n        StreamStateHandle underlying = checkpointStream.closeAndGetHandle();\n        complete(\n                underlying,\n                result.inputChannelStateHandles,\n                inputChannelOffsets,\n                HandleFactory.INPUT_CHANNEL);\n        complete(\n                underlying,\n                result.resultSubpartitionStateHandles,\n                resultSubpartitionOffsets,\n                HandleFactory.RESULT_SUBPARTITION);\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/8c899b02ab25a34e4d35c73a8fc0299894110aca^1/flink-formats/flink-parquet/src/main/java/org/apache/flink/formats/parquet/vector/reader/ArrayColumnReader.java",
      "locators": [
          {
              "line": 315,
              "column": 35
          },
          {
              "line": 316,
              "column": 17
          },
          {
              "line": 317,
              "column": 30
          }
      ],
      "old_name": "booleanVector",
      "new_name": "heapBooleanVector",
      "ctx": {
          "symbolName": "booleanVector",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "HeapBooleanVector",
          "scopeHint": "in fillColumnVector(...)",
          "filePath": "ArrayColumnReader.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void fillColumnVector(\n            LogicalType type, HeapArrayVector lcv, List valueList, int elementNum) {\n        int total = valueList.size();\n        setChildrenInfo(lcv, total, elementNum);\n        switch (type.getTypeRoot()) {\n            case CHAR:\n            case VARCHAR:\n            case BINARY:\n            case VARBINARY:\n                HeapBytesVector bytesVector = new HeapBytesVector(total);\n                bytesVector.reset();\n                lcv.setChild(bytesVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    byte[] src = (byte[]) valueList.get(i);\n                    if (src == null) {\n                        ((HeapBytesVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapBytesVector) lcv.getChild()).appendBytes(i, src, 0, src.length);\n                    }\n                }\n                break;\n            case BOOLEAN:\n                HeapBooleanVector booleanVector = new HeapBooleanVector(total);\n                booleanVector.reset();\n                lcv.setChild(booleanVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapBooleanVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapBooleanVector) lcv.getChild()).vector[i] = (boolean) valueList.get(i);\n                    }\n                }\n                break;\n            case TINYINT:\n                HeapByteVector byteVector = new HeapByteVector(total);\n                byteVector.reset();\n                lcv.setChild(byteVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapByteVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapByteVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i).byteValue();\n                    }\n                }\n                break;\n            case SMALLINT:\n                HeapShortVector shortVector = new HeapShortVector(total);\n                shortVector.reset();\n                lcv.setChild(shortVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapShortVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapShortVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i).shortValue();\n                    }\n                }\n                break;\n            case INTEGER:\n            case DATE:\n            case TIME_WITHOUT_TIME_ZONE:\n                HeapIntVector intVector = new HeapIntVector(total);\n                intVector.reset();\n                lcv.setChild(intVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapIntVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapIntVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i);\n                    }\n                }\n                break;\n            case FLOAT:\n                HeapFloatVector floatVector = new HeapFloatVector(total);\n                floatVector.reset();\n                lcv.setChild(floatVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapFloatVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapFloatVector) lcv.getChild()).vector[i] =\n                                ((List<Float>) valueList).get(i);\n                    }\n                }\n                break;\n            case BIGINT:\n                HeapLongVector longVector = new HeapLongVector(total);\n                longVector.reset();\n                lcv.setChild(longVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapLongVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapLongVector) lcv.getChild()).vector[i] =\n                                ((List<Long>) valueList).get(i);\n                    }\n                }\n                break;\n            case DOUBLE:\n                HeapDoubleVector doubleVector = new HeapDoubleVector(total);\n                doubleVector.reset();\n                lcv.setChild(doubleVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapDoubleVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapDoubleVector) lcv.getChild()).vector[i] =\n                                ((List<Double>) valueList).get(i);\n                    }\n                }\n                break;\n            case TIMESTAMP_WITHOUT_TIME_ZONE:\n            case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n                HeapTimestampVector timestampVector = new HeapTimestampVector(total);\n                timestampVector.reset();\n                lcv.setChild(timestampVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapTimestampVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapTimestampVector) lcv.getChild())\n                                .setTimestamp(i, ((List<TimestampData>) valueList).get(i));\n                    }\n                }\n                break;\n            case DECIMAL:\n                PrimitiveType.PrimitiveTypeName primitiveTypeName =\n                        descriptor.getPrimitiveType().getPrimitiveTypeName();\n                switch (primitiveTypeName) {\n                    case INT32:\n                        HeapIntVector heapIntVector = new HeapIntVector(total);\n                        heapIntVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapIntVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            if (valueList.get(i) == null) {\n                                ((HeapIntVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapIntVector)\n                                                        ((ParquetDecimalVector) lcv.getChild())\n                                                                .getVector())\n                                                .vector[i] =\n                                        ((List<Integer>) valueList).get(i);\n                            }\n                        }\n                        break;\n                    case INT64:\n                        HeapLongVector heapLongVector = new HeapLongVector(total);\n                        heapLongVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapLongVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            if (valueList.get(i) == null) {\n                                ((HeapLongVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapLongVector)\n                                                        ((ParquetDecimalVector) lcv.getChild())\n                                                                .getVector())\n                                                .vector[i] =\n                                        ((List<Long>) valueList).get(i);\n                            }\n                        }\n                        break;\n                    default:\n                        HeapBytesVector heapBytesVector = new HeapBytesVector(total);\n                        heapBytesVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapBytesVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            byte[] src = (byte[]) valueList.get(i);\n                            if (valueList.get(i) == null) {\n                                ((HeapBytesVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapBytesVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .appendBytes(i, src, 0, src.length);\n                            }\n                        }\n                        break;\n                }\n                break;\n            default:\n                throw new RuntimeException(\"Unsupported type in the list: \" + type);\n        }\n    }",
          "conflictNames": [
              "type",
              "lcv",
              "valueList",
              "elementNum",
              "total",
              "bytesVector",
              "i",
              "src",
              "byteVector",
              "shortVector",
              "intVector",
              "floatVector",
              "longVector",
              "doubleVector",
              "timestampVector",
              "primitiveTypeName",
              "heapIntVector",
              "heapLongVector",
              "heapBytesVector"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/8c899b02ab25a34e4d35c73a8fc0299894110aca^1/flink-formats/flink-parquet/src/main/java/org/apache/flink/formats/parquet/vector/reader/ArrayColumnReader.java",
      "locators": [
          {
              "line": 327,
              "column": 32
          },
          {
              "line": 328,
              "column": 17
          },
          {
              "line": 329,
              "column": 30
          }
      ],
      "old_name": "byteVector",
      "new_name": "heapByteVector",
      "ctx": {
          "symbolName": "byteVector",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "HeapByteVector",
          "scopeHint": "in fillColumnVector(...)",
          "filePath": "ArrayColumnReader.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void fillColumnVector(\n            LogicalType type, HeapArrayVector lcv, List valueList, int elementNum) {\n        int total = valueList.size();\n        setChildrenInfo(lcv, total, elementNum);\n        switch (type.getTypeRoot()) {\n            case CHAR:\n            case VARCHAR:\n            case BINARY:\n            case VARBINARY:\n                HeapBytesVector bytesVector = new HeapBytesVector(total);\n                bytesVector.reset();\n                lcv.setChild(bytesVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    byte[] src = (byte[]) valueList.get(i);\n                    if (src == null) {\n                        ((HeapBytesVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapBytesVector) lcv.getChild()).appendBytes(i, src, 0, src.length);\n                    }\n                }\n                break;\n            case BOOLEAN:\n                HeapBooleanVector booleanVector = new HeapBooleanVector(total);\n                booleanVector.reset();\n                lcv.setChild(booleanVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapBooleanVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapBooleanVector) lcv.getChild()).vector[i] = (boolean) valueList.get(i);\n                    }\n                }\n                break;\n            case TINYINT:\n                HeapByteVector byteVector = new HeapByteVector(total);\n                byteVector.reset();\n                lcv.setChild(byteVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapByteVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapByteVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i).byteValue();\n                    }\n                }\n                break;\n            case SMALLINT:\n                HeapShortVector shortVector = new HeapShortVector(total);\n                shortVector.reset();\n                lcv.setChild(shortVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapShortVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapShortVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i).shortValue();\n                    }\n                }\n                break;\n            case INTEGER:\n            case DATE:\n            case TIME_WITHOUT_TIME_ZONE:\n                HeapIntVector intVector = new HeapIntVector(total);\n                intVector.reset();\n                lcv.setChild(intVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapIntVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapIntVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i);\n                    }\n                }\n                break;\n            case FLOAT:\n                HeapFloatVector floatVector = new HeapFloatVector(total);\n                floatVector.reset();\n                lcv.setChild(floatVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapFloatVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapFloatVector) lcv.getChild()).vector[i] =\n                                ((List<Float>) valueList).get(i);\n                    }\n                }\n                break;\n            case BIGINT:\n                HeapLongVector longVector = new HeapLongVector(total);\n                longVector.reset();\n                lcv.setChild(longVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapLongVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapLongVector) lcv.getChild()).vector[i] =\n                                ((List<Long>) valueList).get(i);\n                    }\n                }\n                break;\n            case DOUBLE:\n                HeapDoubleVector doubleVector = new HeapDoubleVector(total);\n                doubleVector.reset();\n                lcv.setChild(doubleVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapDoubleVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapDoubleVector) lcv.getChild()).vector[i] =\n                                ((List<Double>) valueList).get(i);\n                    }\n                }\n                break;\n            case TIMESTAMP_WITHOUT_TIME_ZONE:\n            case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n                HeapTimestampVector timestampVector = new HeapTimestampVector(total);\n                timestampVector.reset();\n                lcv.setChild(timestampVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapTimestampVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapTimestampVector) lcv.getChild())\n                                .setTimestamp(i, ((List<TimestampData>) valueList).get(i));\n                    }\n                }\n                break;\n            case DECIMAL:\n                PrimitiveType.PrimitiveTypeName primitiveTypeName =\n                        descriptor.getPrimitiveType().getPrimitiveTypeName();\n                switch (primitiveTypeName) {\n                    case INT32:\n                        HeapIntVector heapIntVector = new HeapIntVector(total);\n                        heapIntVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapIntVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            if (valueList.get(i) == null) {\n                                ((HeapIntVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapIntVector)\n                                                        ((ParquetDecimalVector) lcv.getChild())\n                                                                .getVector())\n                                                .vector[i] =\n                                        ((List<Integer>) valueList).get(i);\n                            }\n                        }\n                        break;\n                    case INT64:\n                        HeapLongVector heapLongVector = new HeapLongVector(total);\n                        heapLongVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapLongVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            if (valueList.get(i) == null) {\n                                ((HeapLongVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapLongVector)\n                                                        ((ParquetDecimalVector) lcv.getChild())\n                                                                .getVector())\n                                                .vector[i] =\n                                        ((List<Long>) valueList).get(i);\n                            }\n                        }\n                        break;\n                    default:\n                        HeapBytesVector heapBytesVector = new HeapBytesVector(total);\n                        heapBytesVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapBytesVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            byte[] src = (byte[]) valueList.get(i);\n                            if (valueList.get(i) == null) {\n                                ((HeapBytesVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapBytesVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .appendBytes(i, src, 0, src.length);\n                            }\n                        }\n                        break;\n                }\n                break;\n            default:\n                throw new RuntimeException(\"Unsupported type in the list: \" + type);\n        }\n    }",
          "conflictNames": [
              "type",
              "lcv",
              "valueList",
              "elementNum",
              "total",
              "bytesVector",
              "i",
              "src",
              "booleanVector",
              "shortVector",
              "intVector",
              "floatVector",
              "longVector",
              "doubleVector",
              "timestampVector",
              "primitiveTypeName",
              "heapIntVector",
              "heapLongVector",
              "heapBytesVector"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/8c899b02ab25a34e4d35c73a8fc0299894110aca^1/flink-formats/flink-parquet/src/main/java/org/apache/flink/formats/parquet/vector/reader/ArrayColumnReader.java",
      "locators": [
          {
              "line": 340,
              "column": 33
          },
          {
              "line": 341,
              "column": 17
          },
          {
              "line": 342,
              "column": 30
          }
      ],
      "old_name": "shortVector",
      "new_name": "heapShortVector",
      "ctx": {
          "symbolName": "shortVector",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "HeapShortVector",
          "scopeHint": "in fillColumnVector(...)",
          "filePath": "ArrayColumnReader.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void fillColumnVector(\n            LogicalType type, HeapArrayVector lcv, List valueList, int elementNum) {\n        int total = valueList.size();\n        setChildrenInfo(lcv, total, elementNum);\n        switch (type.getTypeRoot()) {\n            case CHAR:\n            case VARCHAR:\n            case BINARY:\n            case VARBINARY:\n                HeapBytesVector bytesVector = new HeapBytesVector(total);\n                bytesVector.reset();\n                lcv.setChild(bytesVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    byte[] src = (byte[]) valueList.get(i);\n                    if (src == null) {\n                        ((HeapBytesVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapBytesVector) lcv.getChild()).appendBytes(i, src, 0, src.length);\n                    }\n                }\n                break;\n            case BOOLEAN:\n                HeapBooleanVector booleanVector = new HeapBooleanVector(total);\n                booleanVector.reset();\n                lcv.setChild(booleanVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapBooleanVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapBooleanVector) lcv.getChild()).vector[i] = (boolean) valueList.get(i);\n                    }\n                }\n                break;\n            case TINYINT:\n                HeapByteVector byteVector = new HeapByteVector(total);\n                byteVector.reset();\n                lcv.setChild(byteVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapByteVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapByteVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i).byteValue();\n                    }\n                }\n                break;\n            case SMALLINT:\n                HeapShortVector shortVector = new HeapShortVector(total);\n                shortVector.reset();\n                lcv.setChild(shortVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapShortVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapShortVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i).shortValue();\n                    }\n                }\n                break;\n            case INTEGER:\n            case DATE:\n            case TIME_WITHOUT_TIME_ZONE:\n                HeapIntVector intVector = new HeapIntVector(total);\n                intVector.reset();\n                lcv.setChild(intVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapIntVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapIntVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i);\n                    }\n                }\n                break;\n            case FLOAT:\n                HeapFloatVector floatVector = new HeapFloatVector(total);\n                floatVector.reset();\n                lcv.setChild(floatVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapFloatVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapFloatVector) lcv.getChild()).vector[i] =\n                                ((List<Float>) valueList).get(i);\n                    }\n                }\n                break;\n            case BIGINT:\n                HeapLongVector longVector = new HeapLongVector(total);\n                longVector.reset();\n                lcv.setChild(longVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapLongVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapLongVector) lcv.getChild()).vector[i] =\n                                ((List<Long>) valueList).get(i);\n                    }\n                }\n                break;\n            case DOUBLE:\n                HeapDoubleVector doubleVector = new HeapDoubleVector(total);\n                doubleVector.reset();\n                lcv.setChild(doubleVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapDoubleVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapDoubleVector) lcv.getChild()).vector[i] =\n                                ((List<Double>) valueList).get(i);\n                    }\n                }\n                break;\n            case TIMESTAMP_WITHOUT_TIME_ZONE:\n            case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n                HeapTimestampVector timestampVector = new HeapTimestampVector(total);\n                timestampVector.reset();\n                lcv.setChild(timestampVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapTimestampVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapTimestampVector) lcv.getChild())\n                                .setTimestamp(i, ((List<TimestampData>) valueList).get(i));\n                    }\n                }\n                break;\n            case DECIMAL:\n                PrimitiveType.PrimitiveTypeName primitiveTypeName =\n                        descriptor.getPrimitiveType().getPrimitiveTypeName();\n                switch (primitiveTypeName) {\n                    case INT32:\n                        HeapIntVector heapIntVector = new HeapIntVector(total);\n                        heapIntVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapIntVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            if (valueList.get(i) == null) {\n                                ((HeapIntVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapIntVector)\n                                                        ((ParquetDecimalVector) lcv.getChild())\n                                                                .getVector())\n                                                .vector[i] =\n                                        ((List<Integer>) valueList).get(i);\n                            }\n                        }\n                        break;\n                    case INT64:\n                        HeapLongVector heapLongVector = new HeapLongVector(total);\n                        heapLongVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapLongVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            if (valueList.get(i) == null) {\n                                ((HeapLongVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapLongVector)\n                                                        ((ParquetDecimalVector) lcv.getChild())\n                                                                .getVector())\n                                                .vector[i] =\n                                        ((List<Long>) valueList).get(i);\n                            }\n                        }\n                        break;\n                    default:\n                        HeapBytesVector heapBytesVector = new HeapBytesVector(total);\n                        heapBytesVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapBytesVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            byte[] src = (byte[]) valueList.get(i);\n                            if (valueList.get(i) == null) {\n                                ((HeapBytesVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapBytesVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .appendBytes(i, src, 0, src.length);\n                            }\n                        }\n                        break;\n                }\n                break;\n            default:\n                throw new RuntimeException(\"Unsupported type in the list: \" + type);\n        }\n    }",
          "conflictNames": [
              "type",
              "lcv",
              "valueList",
              "elementNum",
              "total",
              "bytesVector",
              "i",
              "src",
              "booleanVector",
              "byteVector",
              "intVector",
              "floatVector",
              "longVector",
              "doubleVector",
              "timestampVector",
              "primitiveTypeName",
              "heapIntVector",
              "heapLongVector",
              "heapBytesVector"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/8c899b02ab25a34e4d35c73a8fc0299894110aca^1/flink-formats/flink-parquet/src/main/java/org/apache/flink/formats/parquet/vector/reader/ArrayColumnReader.java",
      "locators": [
          {
              "line": 368,
              "column": 33
          },
          {
              "line": 369,
              "column": 17
          },
          {
              "line": 370,
              "column": 30
          }
      ],
      "old_name": "floatVector",
      "new_name": "heapFloatVector",
      "ctx": {
          "symbolName": "floatVector",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "HeapFloatVector",
          "scopeHint": "in fillColumnVector(...)",
          "filePath": "ArrayColumnReader.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void fillColumnVector(\n            LogicalType type, HeapArrayVector lcv, List valueList, int elementNum) {\n        int total = valueList.size();\n        setChildrenInfo(lcv, total, elementNum);\n        switch (type.getTypeRoot()) {\n            case CHAR:\n            case VARCHAR:\n            case BINARY:\n            case VARBINARY:\n                HeapBytesVector bytesVector = new HeapBytesVector(total);\n                bytesVector.reset();\n                lcv.setChild(bytesVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    byte[] src = (byte[]) valueList.get(i);\n                    if (src == null) {\n                        ((HeapBytesVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapBytesVector) lcv.getChild()).appendBytes(i, src, 0, src.length);\n                    }\n                }\n                break;\n            case BOOLEAN:\n                HeapBooleanVector booleanVector = new HeapBooleanVector(total);\n                booleanVector.reset();\n                lcv.setChild(booleanVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapBooleanVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapBooleanVector) lcv.getChild()).vector[i] = (boolean) valueList.get(i);\n                    }\n                }\n                break;\n            case TINYINT:\n                HeapByteVector byteVector = new HeapByteVector(total);\n                byteVector.reset();\n                lcv.setChild(byteVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapByteVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapByteVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i).byteValue();\n                    }\n                }\n                break;\n            case SMALLINT:\n                HeapShortVector shortVector = new HeapShortVector(total);\n                shortVector.reset();\n                lcv.setChild(shortVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapShortVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapShortVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i).shortValue();\n                    }\n                }\n                break;\n            case INTEGER:\n            case DATE:\n            case TIME_WITHOUT_TIME_ZONE:\n                HeapIntVector intVector = new HeapIntVector(total);\n                intVector.reset();\n                lcv.setChild(intVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapIntVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapIntVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i);\n                    }\n                }\n                break;\n            case FLOAT:\n                HeapFloatVector floatVector = new HeapFloatVector(total);\n                floatVector.reset();\n                lcv.setChild(floatVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapFloatVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapFloatVector) lcv.getChild()).vector[i] =\n                                ((List<Float>) valueList).get(i);\n                    }\n                }\n                break;\n            case BIGINT:\n                HeapLongVector longVector = new HeapLongVector(total);\n                longVector.reset();\n                lcv.setChild(longVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapLongVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapLongVector) lcv.getChild()).vector[i] =\n                                ((List<Long>) valueList).get(i);\n                    }\n                }\n                break;\n            case DOUBLE:\n                HeapDoubleVector doubleVector = new HeapDoubleVector(total);\n                doubleVector.reset();\n                lcv.setChild(doubleVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapDoubleVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapDoubleVector) lcv.getChild()).vector[i] =\n                                ((List<Double>) valueList).get(i);\n                    }\n                }\n                break;\n            case TIMESTAMP_WITHOUT_TIME_ZONE:\n            case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n                HeapTimestampVector timestampVector = new HeapTimestampVector(total);\n                timestampVector.reset();\n                lcv.setChild(timestampVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapTimestampVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapTimestampVector) lcv.getChild())\n                                .setTimestamp(i, ((List<TimestampData>) valueList).get(i));\n                    }\n                }\n                break;\n            case DECIMAL:\n                PrimitiveType.PrimitiveTypeName primitiveTypeName =\n                        descriptor.getPrimitiveType().getPrimitiveTypeName();\n                switch (primitiveTypeName) {\n                    case INT32:\n                        HeapIntVector heapIntVector = new HeapIntVector(total);\n                        heapIntVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapIntVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            if (valueList.get(i) == null) {\n                                ((HeapIntVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapIntVector)\n                                                        ((ParquetDecimalVector) lcv.getChild())\n                                                                .getVector())\n                                                .vector[i] =\n                                        ((List<Integer>) valueList).get(i);\n                            }\n                        }\n                        break;\n                    case INT64:\n                        HeapLongVector heapLongVector = new HeapLongVector(total);\n                        heapLongVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapLongVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            if (valueList.get(i) == null) {\n                                ((HeapLongVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapLongVector)\n                                                        ((ParquetDecimalVector) lcv.getChild())\n                                                                .getVector())\n                                                .vector[i] =\n                                        ((List<Long>) valueList).get(i);\n                            }\n                        }\n                        break;\n                    default:\n                        HeapBytesVector heapBytesVector = new HeapBytesVector(total);\n                        heapBytesVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapBytesVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            byte[] src = (byte[]) valueList.get(i);\n                            if (valueList.get(i) == null) {\n                                ((HeapBytesVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapBytesVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .appendBytes(i, src, 0, src.length);\n                            }\n                        }\n                        break;\n                }\n                break;\n            default:\n                throw new RuntimeException(\"Unsupported type in the list: \" + type);\n        }\n    }",
          "conflictNames": [
              "type",
              "lcv",
              "valueList",
              "elementNum",
              "total",
              "bytesVector",
              "i",
              "src",
              "booleanVector",
              "byteVector",
              "shortVector",
              "intVector",
              "longVector",
              "doubleVector",
              "timestampVector",
              "primitiveTypeName",
              "heapIntVector",
              "heapLongVector",
              "heapBytesVector"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/8c899b02ab25a34e4d35c73a8fc0299894110aca^1/flink-formats/flink-parquet/src/main/java/org/apache/flink/formats/parquet/vector/reader/ArrayColumnReader.java",
      "locators": [
          {
              "line": 394,
              "column": 34
          },
          {
              "line": 395,
              "column": 17
          },
          {
              "line": 396,
              "column": 30
          }
      ],
      "old_name": "doubleVector",
      "new_name": "heapDoubleVector",
      "ctx": {
          "symbolName": "doubleVector",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "HeapDoubleVector",
          "scopeHint": "in fillColumnVector(...)",
          "filePath": "ArrayColumnReader.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void fillColumnVector(\n            LogicalType type, HeapArrayVector lcv, List valueList, int elementNum) {\n        int total = valueList.size();\n        setChildrenInfo(lcv, total, elementNum);\n        switch (type.getTypeRoot()) {\n            case CHAR:\n            case VARCHAR:\n            case BINARY:\n            case VARBINARY:\n                HeapBytesVector bytesVector = new HeapBytesVector(total);\n                bytesVector.reset();\n                lcv.setChild(bytesVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    byte[] src = (byte[]) valueList.get(i);\n                    if (src == null) {\n                        ((HeapBytesVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapBytesVector) lcv.getChild()).appendBytes(i, src, 0, src.length);\n                    }\n                }\n                break;\n            case BOOLEAN:\n                HeapBooleanVector booleanVector = new HeapBooleanVector(total);\n                booleanVector.reset();\n                lcv.setChild(booleanVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapBooleanVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapBooleanVector) lcv.getChild()).vector[i] = (boolean) valueList.get(i);\n                    }\n                }\n                break;\n            case TINYINT:\n                HeapByteVector byteVector = new HeapByteVector(total);\n                byteVector.reset();\n                lcv.setChild(byteVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapByteVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapByteVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i).byteValue();\n                    }\n                }\n                break;\n            case SMALLINT:\n                HeapShortVector shortVector = new HeapShortVector(total);\n                shortVector.reset();\n                lcv.setChild(shortVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapShortVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapShortVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i).shortValue();\n                    }\n                }\n                break;\n            case INTEGER:\n            case DATE:\n            case TIME_WITHOUT_TIME_ZONE:\n                HeapIntVector intVector = new HeapIntVector(total);\n                intVector.reset();\n                lcv.setChild(intVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapIntVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapIntVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i);\n                    }\n                }\n                break;\n            case FLOAT:\n                HeapFloatVector floatVector = new HeapFloatVector(total);\n                floatVector.reset();\n                lcv.setChild(floatVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapFloatVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapFloatVector) lcv.getChild()).vector[i] =\n                                ((List<Float>) valueList).get(i);\n                    }\n                }\n                break;\n            case BIGINT:\n                HeapLongVector longVector = new HeapLongVector(total);\n                longVector.reset();\n                lcv.setChild(longVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapLongVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapLongVector) lcv.getChild()).vector[i] =\n                                ((List<Long>) valueList).get(i);\n                    }\n                }\n                break;\n            case DOUBLE:\n                HeapDoubleVector doubleVector = new HeapDoubleVector(total);\n                doubleVector.reset();\n                lcv.setChild(doubleVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapDoubleVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapDoubleVector) lcv.getChild()).vector[i] =\n                                ((List<Double>) valueList).get(i);\n                    }\n                }\n                break;\n            case TIMESTAMP_WITHOUT_TIME_ZONE:\n            case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n                HeapTimestampVector timestampVector = new HeapTimestampVector(total);\n                timestampVector.reset();\n                lcv.setChild(timestampVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapTimestampVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapTimestampVector) lcv.getChild())\n                                .setTimestamp(i, ((List<TimestampData>) valueList).get(i));\n                    }\n                }\n                break;\n            case DECIMAL:\n                PrimitiveType.PrimitiveTypeName primitiveTypeName =\n                        descriptor.getPrimitiveType().getPrimitiveTypeName();\n                switch (primitiveTypeName) {\n                    case INT32:\n                        HeapIntVector heapIntVector = new HeapIntVector(total);\n                        heapIntVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapIntVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            if (valueList.get(i) == null) {\n                                ((HeapIntVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapIntVector)\n                                                        ((ParquetDecimalVector) lcv.getChild())\n                                                                .getVector())\n                                                .vector[i] =\n                                        ((List<Integer>) valueList).get(i);\n                            }\n                        }\n                        break;\n                    case INT64:\n                        HeapLongVector heapLongVector = new HeapLongVector(total);\n                        heapLongVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapLongVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            if (valueList.get(i) == null) {\n                                ((HeapLongVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapLongVector)\n                                                        ((ParquetDecimalVector) lcv.getChild())\n                                                                .getVector())\n                                                .vector[i] =\n                                        ((List<Long>) valueList).get(i);\n                            }\n                        }\n                        break;\n                    default:\n                        HeapBytesVector heapBytesVector = new HeapBytesVector(total);\n                        heapBytesVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapBytesVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            byte[] src = (byte[]) valueList.get(i);\n                            if (valueList.get(i) == null) {\n                                ((HeapBytesVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapBytesVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .appendBytes(i, src, 0, src.length);\n                            }\n                        }\n                        break;\n                }\n                break;\n            default:\n                throw new RuntimeException(\"Unsupported type in the list: \" + type);\n        }\n    }",
          "conflictNames": [
              "type",
              "lcv",
              "valueList",
              "elementNum",
              "total",
              "bytesVector",
              "i",
              "src",
              "booleanVector",
              "byteVector",
              "shortVector",
              "intVector",
              "floatVector",
              "longVector",
              "timestampVector",
              "primitiveTypeName",
              "heapIntVector",
              "heapLongVector",
              "heapBytesVector"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/8c899b02ab25a34e4d35c73a8fc0299894110aca^1/flink-formats/flink-parquet/src/main/java/org/apache/flink/formats/parquet/vector/reader/ArrayColumnReader.java",
      "locators": [
          {
              "line": 408,
              "column": 37
          },
          {
              "line": 409,
              "column": 17
          },
          {
              "line": 410,
              "column": 30
          }
      ],
      "old_name": "timestampVector",
      "new_name": "heapTimestampVector",
      "ctx": {
          "symbolName": "timestampVector",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "HeapTimestampVector",
          "scopeHint": "in fillColumnVector(...)",
          "filePath": "ArrayColumnReader.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void fillColumnVector(\n            LogicalType type, HeapArrayVector lcv, List valueList, int elementNum) {\n        int total = valueList.size();\n        setChildrenInfo(lcv, total, elementNum);\n        switch (type.getTypeRoot()) {\n            case CHAR:\n            case VARCHAR:\n            case BINARY:\n            case VARBINARY:\n                HeapBytesVector bytesVector = new HeapBytesVector(total);\n                bytesVector.reset();\n                lcv.setChild(bytesVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    byte[] src = (byte[]) valueList.get(i);\n                    if (src == null) {\n                        ((HeapBytesVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapBytesVector) lcv.getChild()).appendBytes(i, src, 0, src.length);\n                    }\n                }\n                break;\n            case BOOLEAN:\n                HeapBooleanVector booleanVector = new HeapBooleanVector(total);\n                booleanVector.reset();\n                lcv.setChild(booleanVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapBooleanVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapBooleanVector) lcv.getChild()).vector[i] = (boolean) valueList.get(i);\n                    }\n                }\n                break;\n            case TINYINT:\n                HeapByteVector byteVector = new HeapByteVector(total);\n                byteVector.reset();\n                lcv.setChild(byteVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapByteVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapByteVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i).byteValue();\n                    }\n                }\n                break;\n            case SMALLINT:\n                HeapShortVector shortVector = new HeapShortVector(total);\n                shortVector.reset();\n                lcv.setChild(shortVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapShortVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapShortVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i).shortValue();\n                    }\n                }\n                break;\n            case INTEGER:\n            case DATE:\n            case TIME_WITHOUT_TIME_ZONE:\n                HeapIntVector intVector = new HeapIntVector(total);\n                intVector.reset();\n                lcv.setChild(intVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapIntVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapIntVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i);\n                    }\n                }\n                break;\n            case FLOAT:\n                HeapFloatVector floatVector = new HeapFloatVector(total);\n                floatVector.reset();\n                lcv.setChild(floatVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapFloatVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapFloatVector) lcv.getChild()).vector[i] =\n                                ((List<Float>) valueList).get(i);\n                    }\n                }\n                break;\n            case BIGINT:\n                HeapLongVector longVector = new HeapLongVector(total);\n                longVector.reset();\n                lcv.setChild(longVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapLongVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapLongVector) lcv.getChild()).vector[i] =\n                                ((List<Long>) valueList).get(i);\n                    }\n                }\n                break;\n            case DOUBLE:\n                HeapDoubleVector doubleVector = new HeapDoubleVector(total);\n                doubleVector.reset();\n                lcv.setChild(doubleVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapDoubleVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapDoubleVector) lcv.getChild()).vector[i] =\n                                ((List<Double>) valueList).get(i);\n                    }\n                }\n                break;\n            case TIMESTAMP_WITHOUT_TIME_ZONE:\n            case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n                HeapTimestampVector timestampVector = new HeapTimestampVector(total);\n                timestampVector.reset();\n                lcv.setChild(timestampVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapTimestampVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapTimestampVector) lcv.getChild())\n                                .setTimestamp(i, ((List<TimestampData>) valueList).get(i));\n                    }\n                }\n                break;\n            case DECIMAL:\n                PrimitiveType.PrimitiveTypeName primitiveTypeName =\n                        descriptor.getPrimitiveType().getPrimitiveTypeName();\n                switch (primitiveTypeName) {\n                    case INT32:\n                        HeapIntVector heapIntVector = new HeapIntVector(total);\n                        heapIntVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapIntVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            if (valueList.get(i) == null) {\n                                ((HeapIntVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapIntVector)\n                                                        ((ParquetDecimalVector) lcv.getChild())\n                                                                .getVector())\n                                                .vector[i] =\n                                        ((List<Integer>) valueList).get(i);\n                            }\n                        }\n                        break;\n                    case INT64:\n                        HeapLongVector heapLongVector = new HeapLongVector(total);\n                        heapLongVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapLongVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            if (valueList.get(i) == null) {\n                                ((HeapLongVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapLongVector)\n                                                        ((ParquetDecimalVector) lcv.getChild())\n                                                                .getVector())\n                                                .vector[i] =\n                                        ((List<Long>) valueList).get(i);\n                            }\n                        }\n                        break;\n                    default:\n                        HeapBytesVector heapBytesVector = new HeapBytesVector(total);\n                        heapBytesVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapBytesVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            byte[] src = (byte[]) valueList.get(i);\n                            if (valueList.get(i) == null) {\n                                ((HeapBytesVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapBytesVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .appendBytes(i, src, 0, src.length);\n                            }\n                        }\n                        break;\n                }\n                break;\n            default:\n                throw new RuntimeException(\"Unsupported type in the list: \" + type);\n        }\n    }",
          "conflictNames": [
              "type",
              "lcv",
              "valueList",
              "elementNum",
              "total",
              "bytesVector",
              "i",
              "src",
              "booleanVector",
              "byteVector",
              "shortVector",
              "intVector",
              "floatVector",
              "longVector",
              "doubleVector",
              "primitiveTypeName",
              "heapIntVector",
              "heapLongVector",
              "heapBytesVector"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/8c899b02ab25a34e4d35c73a8fc0299894110aca^1/flink-formats/flink-parquet/src/main/java/org/apache/flink/formats/parquet/vector/reader/ArrayColumnReader.java",
      "locators": [
          {
              "line": 355,
              "column": 31
          },
          {
              "line": 356,
              "column": 17
          },
          {
              "line": 357,
              "column": 30
          }
      ],
      "old_name": "intVector",
      "new_name": "phiv",
      "ctx": {
          "symbolName": "intVector",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "HeapIntVector",
          "scopeHint": "in fillColumnVector(...)",
          "filePath": "ArrayColumnReader.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void fillColumnVector(\n            LogicalType type, HeapArrayVector lcv, List valueList, int elementNum) {\n        int total = valueList.size();\n        setChildrenInfo(lcv, total, elementNum);\n        switch (type.getTypeRoot()) {\n            case CHAR:\n            case VARCHAR:\n            case BINARY:\n            case VARBINARY:\n                HeapBytesVector bytesVector = new HeapBytesVector(total);\n                bytesVector.reset();\n                lcv.setChild(bytesVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    byte[] src = (byte[]) valueList.get(i);\n                    if (src == null) {\n                        ((HeapBytesVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapBytesVector) lcv.getChild()).appendBytes(i, src, 0, src.length);\n                    }\n                }\n                break;\n            case BOOLEAN:\n                HeapBooleanVector booleanVector = new HeapBooleanVector(total);\n                booleanVector.reset();\n                lcv.setChild(booleanVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapBooleanVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapBooleanVector) lcv.getChild()).vector[i] = (boolean) valueList.get(i);\n                    }\n                }\n                break;\n            case TINYINT:\n                HeapByteVector byteVector = new HeapByteVector(total);\n                byteVector.reset();\n                lcv.setChild(byteVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapByteVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapByteVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i).byteValue();\n                    }\n                }\n                break;\n            case SMALLINT:\n                HeapShortVector shortVector = new HeapShortVector(total);\n                shortVector.reset();\n                lcv.setChild(shortVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapShortVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapShortVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i).shortValue();\n                    }\n                }\n                break;\n            case INTEGER:\n            case DATE:\n            case TIME_WITHOUT_TIME_ZONE:\n                HeapIntVector intVector = new HeapIntVector(total);\n                intVector.reset();\n                lcv.setChild(intVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapIntVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapIntVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i);\n                    }\n                }\n                break;\n            case FLOAT:\n                HeapFloatVector floatVector = new HeapFloatVector(total);\n                floatVector.reset();\n                lcv.setChild(floatVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapFloatVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapFloatVector) lcv.getChild()).vector[i] =\n                                ((List<Float>) valueList).get(i);\n                    }\n                }\n                break;\n            case BIGINT:\n                HeapLongVector longVector = new HeapLongVector(total);\n                longVector.reset();\n                lcv.setChild(longVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapLongVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapLongVector) lcv.getChild()).vector[i] =\n                                ((List<Long>) valueList).get(i);\n                    }\n                }\n                break;\n            case DOUBLE:\n                HeapDoubleVector doubleVector = new HeapDoubleVector(total);\n                doubleVector.reset();\n                lcv.setChild(doubleVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapDoubleVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapDoubleVector) lcv.getChild()).vector[i] =\n                                ((List<Double>) valueList).get(i);\n                    }\n                }\n                break;\n            case TIMESTAMP_WITHOUT_TIME_ZONE:\n            case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n                HeapTimestampVector timestampVector = new HeapTimestampVector(total);\n                timestampVector.reset();\n                lcv.setChild(timestampVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapTimestampVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapTimestampVector) lcv.getChild())\n                                .setTimestamp(i, ((List<TimestampData>) valueList).get(i));\n                    }\n                }\n                break;\n            case DECIMAL:\n                PrimitiveType.PrimitiveTypeName primitiveTypeName =\n                        descriptor.getPrimitiveType().getPrimitiveTypeName();\n                switch (primitiveTypeName) {\n                    case INT32:\n                        HeapIntVector heapIntVector = new HeapIntVector(total);\n                        heapIntVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapIntVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            if (valueList.get(i) == null) {\n                                ((HeapIntVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapIntVector)\n                                                        ((ParquetDecimalVector) lcv.getChild())\n                                                                .getVector())\n                                                .vector[i] =\n                                        ((List<Integer>) valueList).get(i);\n                            }\n                        }\n                        break;\n                    case INT64:\n                        HeapLongVector heapLongVector = new HeapLongVector(total);\n                        heapLongVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapLongVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            if (valueList.get(i) == null) {\n                                ((HeapLongVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapLongVector)\n                                                        ((ParquetDecimalVector) lcv.getChild())\n                                                                .getVector())\n                                                .vector[i] =\n                                        ((List<Long>) valueList).get(i);\n                            }\n                        }\n                        break;\n                    default:\n                        HeapBytesVector heapBytesVector = new HeapBytesVector(total);\n                        heapBytesVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapBytesVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            byte[] src = (byte[]) valueList.get(i);\n                            if (valueList.get(i) == null) {\n                                ((HeapBytesVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapBytesVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .appendBytes(i, src, 0, src.length);\n                            }\n                        }\n                        break;\n                }\n                break;\n            default:\n                throw new RuntimeException(\"Unsupported type in the list: \" + type);\n        }\n    }",
          "conflictNames": [
              "type",
              "lcv",
              "valueList",
              "elementNum",
              "total",
              "bytesVector",
              "i",
              "src",
              "booleanVector",
              "byteVector",
              "shortVector",
              "floatVector",
              "longVector",
              "doubleVector",
              "timestampVector",
              "primitiveTypeName",
              "heapIntVector",
              "heapLongVector",
              "heapBytesVector"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/8c899b02ab25a34e4d35c73a8fc0299894110aca^1/flink-formats/flink-parquet/src/main/java/org/apache/flink/formats/parquet/vector/reader/ArrayColumnReader.java",
      "locators": [
          {
              "line": 381,
              "column": 32
          },
          {
              "line": 382,
              "column": 17
          },
          {
              "line": 383,
              "column": 30
          }
      ],
      "old_name": "longVector",
      "new_name": "phlv",
      "ctx": {
          "symbolName": "longVector",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "HeapLongVector",
          "scopeHint": "in fillColumnVector(...)",
          "filePath": "ArrayColumnReader.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void fillColumnVector(\n            LogicalType type, HeapArrayVector lcv, List valueList, int elementNum) {\n        int total = valueList.size();\n        setChildrenInfo(lcv, total, elementNum);\n        switch (type.getTypeRoot()) {\n            case CHAR:\n            case VARCHAR:\n            case BINARY:\n            case VARBINARY:\n                HeapBytesVector bytesVector = new HeapBytesVector(total);\n                bytesVector.reset();\n                lcv.setChild(bytesVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    byte[] src = (byte[]) valueList.get(i);\n                    if (src == null) {\n                        ((HeapBytesVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapBytesVector) lcv.getChild()).appendBytes(i, src, 0, src.length);\n                    }\n                }\n                break;\n            case BOOLEAN:\n                HeapBooleanVector booleanVector = new HeapBooleanVector(total);\n                booleanVector.reset();\n                lcv.setChild(booleanVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapBooleanVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapBooleanVector) lcv.getChild()).vector[i] = (boolean) valueList.get(i);\n                    }\n                }\n                break;\n            case TINYINT:\n                HeapByteVector byteVector = new HeapByteVector(total);\n                byteVector.reset();\n                lcv.setChild(byteVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapByteVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapByteVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i).byteValue();\n                    }\n                }\n                break;\n            case SMALLINT:\n                HeapShortVector shortVector = new HeapShortVector(total);\n                shortVector.reset();\n                lcv.setChild(shortVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapShortVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapShortVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i).shortValue();\n                    }\n                }\n                break;\n            case INTEGER:\n            case DATE:\n            case TIME_WITHOUT_TIME_ZONE:\n                HeapIntVector intVector = new HeapIntVector(total);\n                intVector.reset();\n                lcv.setChild(intVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapIntVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapIntVector) lcv.getChild()).vector[i] =\n                                ((List<Integer>) valueList).get(i);\n                    }\n                }\n                break;\n            case FLOAT:\n                HeapFloatVector floatVector = new HeapFloatVector(total);\n                floatVector.reset();\n                lcv.setChild(floatVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapFloatVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapFloatVector) lcv.getChild()).vector[i] =\n                                ((List<Float>) valueList).get(i);\n                    }\n                }\n                break;\n            case BIGINT:\n                HeapLongVector longVector = new HeapLongVector(total);\n                longVector.reset();\n                lcv.setChild(longVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapLongVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapLongVector) lcv.getChild()).vector[i] =\n                                ((List<Long>) valueList).get(i);\n                    }\n                }\n                break;\n            case DOUBLE:\n                HeapDoubleVector doubleVector = new HeapDoubleVector(total);\n                doubleVector.reset();\n                lcv.setChild(doubleVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapDoubleVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapDoubleVector) lcv.getChild()).vector[i] =\n                                ((List<Double>) valueList).get(i);\n                    }\n                }\n                break;\n            case TIMESTAMP_WITHOUT_TIME_ZONE:\n            case TIMESTAMP_WITH_LOCAL_TIME_ZONE:\n                HeapTimestampVector timestampVector = new HeapTimestampVector(total);\n                timestampVector.reset();\n                lcv.setChild(timestampVector);\n                for (int i = 0; i < valueList.size(); i++) {\n                    if (valueList.get(i) == null) {\n                        ((HeapTimestampVector) lcv.getChild()).setNullAt(i);\n                    } else {\n                        ((HeapTimestampVector) lcv.getChild())\n                                .setTimestamp(i, ((List<TimestampData>) valueList).get(i));\n                    }\n                }\n                break;\n            case DECIMAL:\n                PrimitiveType.PrimitiveTypeName primitiveTypeName =\n                        descriptor.getPrimitiveType().getPrimitiveTypeName();\n                switch (primitiveTypeName) {\n                    case INT32:\n                        HeapIntVector heapIntVector = new HeapIntVector(total);\n                        heapIntVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapIntVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            if (valueList.get(i) == null) {\n                                ((HeapIntVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapIntVector)\n                                                        ((ParquetDecimalVector) lcv.getChild())\n                                                                .getVector())\n                                                .vector[i] =\n                                        ((List<Integer>) valueList).get(i);\n                            }\n                        }\n                        break;\n                    case INT64:\n                        HeapLongVector heapLongVector = new HeapLongVector(total);\n                        heapLongVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapLongVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            if (valueList.get(i) == null) {\n                                ((HeapLongVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapLongVector)\n                                                        ((ParquetDecimalVector) lcv.getChild())\n                                                                .getVector())\n                                                .vector[i] =\n                                        ((List<Long>) valueList).get(i);\n                            }\n                        }\n                        break;\n                    default:\n                        HeapBytesVector heapBytesVector = new HeapBytesVector(total);\n                        heapBytesVector.reset();\n                        lcv.setChild(new ParquetDecimalVector(heapBytesVector));\n                        for (int i = 0; i < valueList.size(); i++) {\n                            byte[] src = (byte[]) valueList.get(i);\n                            if (valueList.get(i) == null) {\n                                ((HeapBytesVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .setNullAt(i);\n                            } else {\n                                ((HeapBytesVector)\n                                                ((ParquetDecimalVector) lcv.getChild()).getVector())\n                                        .appendBytes(i, src, 0, src.length);\n                            }\n                        }\n                        break;\n                }\n                break;\n            default:\n                throw new RuntimeException(\"Unsupported type in the list: \" + type);\n        }\n    }",
          "conflictNames": [
              "type",
              "lcv",
              "valueList",
              "elementNum",
              "total",
              "bytesVector",
              "i",
              "src",
              "booleanVector",
              "byteVector",
              "shortVector",
              "intVector",
              "floatVector",
              "doubleVector",
              "timestampVector",
              "primitiveTypeName",
              "heapIntVector",
              "heapLongVector",
              "heapBytesVector"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/8d1e043b0c4277582b8862c2bc3314631eec4a7b^1/flink-table/flink-sql-gateway/src/main/java/org/apache/flink/table/gateway/workflow/EmbeddedWorkflowScheduler.java",
      "locators": [
          {
              "line": 99,
              "column": 56
          },
          {
              "line": 116,
              "column": 41
          },
          {
              "line": 148,
              "column": 46
          },
          {
              "line": 160,
              "column": 33
          },
          {
              "line": 181,
              "column": 33
          },
          {
              "line": 210,
              "column": 46
          },
          {
              "line": 221,
              "column": 29
          }
      ],
      "old_name": "requestBody",
      "new_name": "suspendRequestBody",
      "ctx": {
          "symbolName": "requestBody",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CreateEmbeddedSchedulerWorkflowRequestBody",
          "scopeHint": "in createRefreshWorkflow(...)",
          "filePath": "EmbeddedWorkflowScheduler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public EmbeddedRefreshHandler createRefreshWorkflow(CreateRefreshWorkflow createRefreshWorkflow)\n            throws WorkflowException {\n        if (createRefreshWorkflow instanceof CreatePeriodicRefreshWorkflow) {\n            CreatePeriodicRefreshWorkflow periodicRefreshWorkflow =\n                    (CreatePeriodicRefreshWorkflow) createRefreshWorkflow;\n            ObjectIdentifier materializedTableIdentifier =\n                    periodicRefreshWorkflow.getMaterializedTableIdentifier();\n            CreateEmbeddedSchedulerWorkflowRequestBody requestBody =\n                    new CreateEmbeddedSchedulerWorkflowRequestBody(\n                            materializedTableIdentifier.asSerializableString(),\n                            periodicRefreshWorkflow.getCronExpression(),\n                            periodicRefreshWorkflow.getInitConfig(),\n                            periodicRefreshWorkflow.getExecutionConfig(),\n                            null,\n                            periodicRefreshWorkflow.getRestEndpointUrl());\n            CreateEmbeddedSchedulerWorkflowResponseBody responseBody;\n            try {\n                responseBody =\n                        restClient\n                                .sendRequest(\n                                        restAddress,\n                                        port,\n                                        CreateEmbeddedSchedulerWorkflowHeaders.getInstance(),\n                                        EmptyMessageParameters.getInstance(),\n                                        requestBody)\n                                .get(30, TimeUnit.SECONDS);\n            } catch (Exception e) {\n                LOG.error(\n                        \"Failed to create periodic refresh workflow for materialized table {}.\",\n                        materializedTableIdentifier,\n                        e);\n                throw new WorkflowException(\n                        String.format(\n                                \"Failed to create periodic refresh workflow for materialized table %s.\",\n                                materializedTableIdentifier),\n                        e);\n            }\n\n            return new EmbeddedRefreshHandler(\n                    responseBody.getWorkflowName(), responseBody.getWorkflowGroup());\n        } else {\n            LOG.error(\n                    \"Unsupported create refresh workflow type {}.\",\n                    createRefreshWorkflow.getClass().getSimpleName());\n            throw new WorkflowException(\n                    String.format(\n                            \"Unsupported create refresh workflow type %s.\",\n                            createRefreshWorkflow.getClass().getSimpleName()));\n        }\n    }",
          "conflictNames": [
              "createRefreshWorkflow",
              "periodicRefreshWorkflow",
              "materializedTableIdentifier",
              "responseBody"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/8dc212c32036c3a4afd3af2e50e95cb87c8cee23^1/flink-runtime/src/main/java/org/apache/flink/streaming/api/connector/sink2/GlobalCommitterOperator.java",
      "locators": [
          {
              "line": 36,
              "column": 58
          },
          {
              "line": 37,
              "column": 58
          },
          {
              "line": 38,
              "column": 58
          },
          {
              "line": 39,
              "column": 58
          },
          {
              "line": 64,
              "column": 13
          },
          {
              "line": 68,
              "column": 41
          },
          {
              "line": 70,
              "column": 46
          },
          {
              "line": 78,
              "column": 68
          },
          {
              "line": 80,
              "column": 14
          },
          {
              "line": 80,
              "column": 58
          },
          {
              "line": 91,
              "column": 9
          },
          {
              "line": 92,
              "column": 9
          },
          {
              "line": 92,
              "column": 33
          },
          {
              "line": 102,
              "column": 33
          },
          {
              "line": 108,
              "column": 53
          },
          {
              "line": 110,
              "column": 25
          },
          {
              "line": 116,
              "column": 25
          },
          {
              "line": 132,
              "column": 33
          },
          {
              "line": 149,
              "column": 73
          },
          {
              "line": 150,
              "column": 17
          },
          {
              "line": 151,
              "column": 13
          },
          {
              "line": 154,
              "column": 16
          },
          {
              "line": 158,
              "column": 50
          },
          {
              "line": 159,
              "column": 13
          },
          {
              "line": 166,
              "column": 17
          },
          {
              "line": 170,
              "column": 23
          },
          {
              "line": 176,
              "column": 9
          }
      ],
      "old_name": "committable",
      "new_name": "checkpoint",
      "ctx": {
          "symbolName": "committable",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "CheckpointCommittableManager<CommT>",
          "scopeHint": "in commit(...)",
          "filePath": "GlobalCommitterOperator.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "checkpointId);\n        if (committables == null) {\n            return Collections.emptyList();\n        }\n        return committables;\n    }\n\n    private void commit(long checkpointId) throws IOException, InterruptedException {\n        for (CheckpointCommittableManager<CommT> committable : getCommittables(checkpointId)) {\n            committable.commit(committer);\n        }\n    }\n\n    @Override\n    public void endInput() throws Exception {\n        final CommittableManager<CommT> endOfInputCommittable =\n                comm",
          "conflictNames": [
              "checkpointId"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/8dcb0ae9063b66af1d674b7b0b3be76b6d752692^1/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/transformations/TwoInputTransformation.java",
      "locators": [
          {
              "line": 38,
              "column": 33
          },
          {
              "line": 42,
              "column": 47
          },
          {
              "line": 221,
              "column": 33
          },
          {
              "line": 222,
              "column": 9
          },
          {
              "line": 223,
              "column": 9
          },
          {
              "line": 224,
              "column": 9
          },
          {
              "line": 225,
              "column": 16
          }
      ],
      "old_name": "result",
      "new_name": "predecessors",
      "ctx": {
          "symbolName": "result",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<Transformation<?>>",
          "scopeHint": "in getTransitivePredecessors(...)",
          "filePath": "TwoInputTransformation.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public List<Transformation<?>> getTransitivePredecessors() {\n        List<Transformation<?>> result = Lists.newArrayList();\n        result.add(this);\n        result.addAll(input1.getTransitivePredecessors());\n        result.addAll(input2.getTransitivePredecessors());\n        return result;\n    }"
      },
      "suggestions": [
          {
              "name": "predecessors",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/8dcb0ae9063b66af1d674b7b0b3be76b6d752692^1/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/transformations/UnionTransformation.java",
      "locators": [
          {
              "line": 35,
              "column": 45
          },
          {
              "line": 67,
              "column": 33
          },
          {
              "line": 68,
              "column": 9
          },
          {
              "line": 70,
              "column": 13
          },
          {
              "line": 72,
              "column": 16
          }
      ],
      "old_name": "result",
      "new_name": "predecessors",
      "ctx": {
          "symbolName": "result",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<Transformation<?>>",
          "scopeHint": "in getTransitivePredecessors(...)",
          "filePath": "UnionTransformation.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public List<Transformation<?>> getTransitivePredecessors() {\n        List<Transformation<?>> result = Lists.newArrayList();\n        result.add(this);\n        for (Transformation<T> input : inputs) {\n            result.addAll(input.getTransitivePredecessors());\n        }\n        return result;\n    }"
      },
      "suggestions": [
          {
              "name": "predecessors",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/8e5bdd9405b15b21e209518e3c5881984bd16ce9^1/flink-runtime/src/test/java/org/apache/flink/runtime/util/SerializedThrowableTest.java",
      "locators": [
          {
              "line": 42,
              "column": 33
          },
          {
              "line": 46,
              "column": 55
          },
          {
              "line": 48,
              "column": 57
          },
          {
              "line": 67,
              "column": 24
          },
          {
              "line": 68,
              "column": 53
          },
          {
              "line": 75,
              "column": 33
          },
          {
              "line": 78,
              "column": 55
          },
          {
              "line": 79,
              "column": 62
          },
          {
              "line": 84,
              "column": 33
          },
          {
              "line": 89,
              "column": 26
          },
          {
              "line": 91,
              "column": 25
          },
          {
              "line": 92,
              "column": 79
          },
          {
              "line": 99,
              "column": 25
          },
          {
              "line": 100,
              "column": 35
          },
          {
              "line": 103,
              "column": 32
          },
          {
              "line": 106,
              "column": 64
          },
          {
              "line": 152,
              "column": 29
          },
          {
              "line": 153,
              "column": 23
          },
          {
              "line": 155,
              "column": 60
          },
          {
              "line": 169,
              "column": 29
          },
          {
              "line": 171,
              "column": 25
          },
          {
              "line": 172,
              "column": 38
          },
          {
              "line": 183,
              "column": 29
          },
          {
              "line": 184,
              "column": 60
          }
      ],
      "old_name": "serialized",
      "new_name": "serializedBytes",
      "ctx": {
          "symbolName": "serialized",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SerializedThrowable",
          "scopeHint": "in testIdenticalMessageAndStack(...)",
          "filePath": "SerializedThrowableTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testIdenticalMessageAndStack() {\n        try {\n            IllegalArgumentException original = new IllegalArgumentException(\"test message\");\n            SerializedThrowable serialized = new SerializedThrowable(original);\n\n            assertEquals(\n                    ExceptionUtils.stringifyException(original),\n                    ExceptionUtils.stringifyException(serialized));\n\n            assertArrayEquals(original.getStackTrace(), serialized.getStackTrace());\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n    }",
          "conflictNames": [
              "original"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/8ffe6d698fb4f37c68a3914e3903dc874dfcb999^1/flink-table/flink-table-runtime/src/test/java/org/apache/flink/table/formats/raw/RawFormatSerDeSchemaTest.java",
      "locators": [
          {
              "line": 59,
              "column": 49
          },
          {
              "line": 71,
              "column": 73
          },
          {
              "line": 75,
              "column": 33
          },
          {
              "line": 76,
              "column": 70
          },
          {
              "line": 80,
              "column": 33
          },
          {
              "line": 83,
              "column": 33
          },
          {
              "line": 87,
              "column": 33
          },
          {
              "line": 88,
              "column": 70
          },
          {
              "line": 92,
              "column": 33
          },
          {
              "line": 95,
              "column": 33
          },
          {
              "line": 99,
              "column": 33
          },
          {
              "line": 222,
              "column": 20
          },
          {
              "line": 227,
              "column": 23
          }
      ],
      "old_name": "hex",
      "new_name": "hexes",
      "ctx": {
          "symbolName": "hex",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in toString(...)",
          "filePath": "RawFormatSerDeSchemaTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public String toString() {\n            String hex = binary == null ? \"null\" : \"0x\" + StringUtils.byteToHexString(binary);\n            return \"TestSpec{\"\n                    + \"value=\"\n                    + value\n                    + \", binary=\"\n                    + hex\n                    + \", type=\"\n                    + type\n                    + \", charsetName='\"\n                    + charsetName\n                    + '\\''\n                    + \", isBigEndian=\"\n                    + isBigEndian\n                    + '}';\n        }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/9036cc52c28540f68cdf1d1bd3b7216aa43ccd3e^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/netty/TieredStorageResultSubpartitionViewTest.java",
      "locators": [
          {
              "line": 144,
              "column": 33
          },
          {
              "line": 145,
              "column": 13
          },
          {
              "line": 146,
              "column": 13
          },
          {
              "line": 147,
              "column": 13
          },
          {
              "line": 155,
              "column": 38
          },
          {
              "line": 163,
              "column": 33
          },
          {
              "line": 164,
              "column": 13
          },
          {
              "line": 165,
              "column": 13
          },
          {
              "line": 166,
              "column": 38
          }
      ],
      "old_name": "queue",
      "new_name": "nettyPayloadManager",
      "ctx": {
          "symbolName": "queue",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "NettyPayloadManager",
          "scopeHint": "in createNettyPayloadQueues(...)",
          "filePath": "TieredStorageResultSubpartitionViewTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static List<NettyPayloadManager> createNettyPayloadQueues() {\n        List<NettyPayloadManager> nettyPayloadManagers = new ArrayList<>();\n        for (int index = 0; index < TIER_NUMBER; ++index) {\n            NettyPayloadManager queue = new NettyPayloadManager();\n            queue.add(NettyPayload.newSegment(index));\n            queue.add(NettyPayload.newBuffer(BufferBuilderTestUtils.buildSomeBuffer(0), 0, index));\n            queue.add(\n                    NettyPayload.newBuffer(\n                            new NetworkBuffer(\n                                    MemorySegmentFactory.allocateUnpooledSegment(0),\n                                    FreeingBufferRecycler.INSTANCE,\n                                    END_OF_SEGMENT),\n                            1,\n                            index));\n            nettyPayloadManagers.add(queue);\n        }\n        return nettyPayloadManagers;\n    }",
          "conflictNames": [
              "nettyPayloadManagers",
              "index"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/90deccaf09eb31fc01d488c8fd6298ee9d362e3b^1/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManagerTest.java",
      "locators": [
          {
              "line": 196,
              "column": 47
          },
          {
              "line": 199,
              "column": 54
          },
          {
              "line": 206,
              "column": 13
          },
          {
              "line": 219,
              "column": 47
          },
          {
              "line": 222,
              "column": 54
          },
          {
              "line": 250,
              "column": 13
          }
      ],
      "old_name": "allocateResourceFuture",
      "new_name": "declareResourceFuture",
      "ctx": {
          "symbolName": "allocateResourceFuture",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CompletableFuture<WorkerResourceSpec>",
          "scopeHint": "in testRequirementDeclarationWithoutFreeSlotsTriggersWorkerAllocation(...)",
          "filePath": "DeclarativeSlotManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Tests that a slot request with no free slots will trigger the resource allocation. */\n    @Test\n    void testRequirementDeclarationWithoutFreeSlotsTriggersWorkerAllocation() throws Exception {\n        final ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n\n        final ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n\n        CompletableFuture<WorkerResourceSpec> allocateResourceFuture = new CompletableFuture<>();\n        ResourceAllocator resourceAllocator =\n                new TestingResourceAllocatorBuilder()\n                        .setAllocateResourceConsumer(allocateResourceFuture::complete)\n                        .build();\n\n        try (SlotManager slotManager = createSlotManager(resourceManagerId, resourceAllocator)) {\n\n            slotManager.processResourceRequirements(resourceRequirements);\n\n            allocateResourceFuture.get();\n        }\n    }",
          "conflictNames": [
              "resourceManagerId",
              "resourceRequirements",
              "resourceAllocator",
              "slotManager"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/90deccaf09eb31fc01d488c8fd6298ee9d362e3b^1/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/FineGrainedSlotManagerDefaultResourceAllocationStrategyITCase.java",
      "locators": [
          {
              "line": 51,
              "column": 29
          },
          {
              "line": 56,
              "column": 36
          },
          {
              "line": 67,
              "column": 40
          }
      ],
      "old_name": "resourceRequests",
      "new_name": "declareResourceCount",
      "ctx": {
          "symbolName": "resourceRequests",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "AtomicInteger",
          "scopeHint": "in testWorkerOnlyAllocatedIfRequestedSlotCouldBeFulfilled(...)",
          "filePath": "FineGrainedSlotManagerDefaultResourceAllocationStrategyITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Test that the slot manager only allocates new workers if their worker spec can fulfill the\n     * requested resource profile.\n     */\n    @Test\n    void testWorkerOnlyAllocatedIfRequestedSlotCouldBeFulfilled() throws Exception {\n        final AtomicInteger resourceRequests = new AtomicInteger(0);\n\n        new Context() {\n            {\n                resourceAllocatorBuilder.setAllocateResourceConsumer(\n                        ignored -> resourceRequests.incrementAndGet());\n                runTest(\n                        () -> {\n                            runInMainThread(\n                                    () ->\n                                            getSlotManager()\n                                                    .processResourceRequirements(\n                                                            createResourceRequirements(\n                                                                    new JobID(),\n                                                                    1,\n                                                                    OTHER_SLOT_RESOURCE_PROFILE)));\n                            assertThat(resourceRequests.get()).isEqualTo(0);\n                        });\n            }\n        };\n    }"
      },
      "suggestions": [
          {
              "name": "declareResourceCount",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/90deccaf09eb31fc01d488c8fd6298ee9d362e3b^1/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/TaskExecutorManagerTest.java",
      "locators": [
          {
              "line": 250,
              "column": 29
          },
          {
              "line": 253,
              "column": 65
          },
          {
              "line": 266,
              "column": 24
          },
          {
              "line": 279,
              "column": 29
          },
          {
              "line": 282,
              "column": 65
          },
          {
              "line": 292,
              "column": 24
          },
          {
              "line": 295,
              "column": 24
          },
          {
              "line": 298,
              "column": 24
          }
      ],
      "old_name": "resourceRequests",
      "new_name": "declareResourceCount",
      "ctx": {
          "symbolName": "resourceRequests",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "AtomicInteger",
          "scopeHint": "in testWorkerOnlyAllocatedIfRequestedSlotCouldBeFulfilled(...)",
          "filePath": "TaskExecutorManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Test that the task executor manager only allocates new workers if their worker spec can\n     * fulfill the requested resource profile.\n     */\n    @Test\n    public void testWorkerOnlyAllocatedIfRequestedSlotCouldBeFulfilled() {\n        final int numCoresPerWorker = 1;\n\n        final WorkerResourceSpec workerResourceSpec =\n                new WorkerResourceSpec.Builder().setCpuCores(numCoresPerWorker).build();\n\n        final ResourceProfile requestedProfile =\n                ResourceProfile.newBuilder().setCpuCores(numCoresPerWorker + 1).build();\n\n        final AtomicInteger resourceRequests = new AtomicInteger(0);\n        ResourceAllocator resourceAllocator =\n                createResourceAllocatorBuilder()\n                        .setAllocateResourceConsumer(ignored -> resourceRequests.incrementAndGet())\n                        .build();\n\n        try (final TaskExecutorManager taskExecutorManager =\n                createTaskExecutorManagerBuilder()\n                        .setDefaultWorkerResourceSpec(workerResourceSpec)\n                        .setNumSlotsPerWorker(1)\n                        .setMaxNumSlots(1)\n                        .setResourceAllocator(resourceAllocator)\n                        .createTaskExecutorManager()) {\n\n            assertThat(\n                    taskExecutorManager.allocateWorker(requestedProfile).orElse(null), nullValue());\n            assertThat(resourceRequests.get(), is(0));\n        }\n    }",
          "conflictNames": [
              "numCoresPerWorker",
              "workerResourceSpec",
              "requestedProfile",
              "resourceAllocator",
              "taskExecutorManager"
          ]
      },
      "suggestions": [
          {
              "name": "declareResourceCount",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/9190ea9624388b7e6963670deed7526bcdabc471^1/flink-connectors/flink-connector-kafka/src/test/java/org/apache/flink/connector/kafka/sink/KafkaWriterITCase.java",
      "locators": [
          {
              "line": 137,
              "column": 45
          },
          {
              "line": 142,
              "column": 80
          },
          {
              "line": 143,
              "column": 41
          },
          {
              "line": 144,
              "column": 43
          },
          {
              "line": 145,
              "column": 49
          },
          {
              "line": 146,
              "column": 50
          },
          {
              "line": 172,
              "column": 45
          },
          {
              "line": 178,
              "column": 25
          },
          {
              "line": 203,
              "column": 45
          },
          {
              "line": 208,
              "column": 69
          },
          {
              "line": 209,
              "column": 49
          },
          {
              "line": 465,
              "column": 45
          },
          {
              "line": 470,
              "column": 39
          },
          {
              "line": 473,
              "column": 18
          },
          {
              "line": 473,
              "column": 32
          },
          {
              "line": 509,
              "column": 38
          },
          {
              "line": 510,
              "column": 20
          }
      ],
      "old_name": "metricGroup",
      "new_name": "sinkInitContext",
      "ctx": {
          "symbolName": "metricGroup",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "InternalSinkWriterMetricGroup",
          "scopeHint": "in testIncreasingRecordBasedCounters(...)",
          "filePath": "KafkaWriterITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testIncreasingRecordBasedCounters() throws Exception {\n        final OperatorIOMetricGroup operatorIOMetricGroup =\n                UnregisteredMetricGroups.createUnregisteredOperatorMetricGroup().getIOMetricGroup();\n        final InternalSinkWriterMetricGroup metricGroup =\n                InternalSinkWriterMetricGroup.mock(\n                        metricListener.getMetricGroup(), operatorIOMetricGroup);\n        try (final KafkaWriter<Integer> writer =\n                createWriterWithConfiguration(\n                        getKafkaClientConfiguration(), DeliveryGuarantee.NONE, metricGroup)) {\n            final Counter numBytesOut = metricGroup.getIOMetricGroup().getNumBytesOutCounter();\n            final Counter numRecordsOut = metricGroup.getIOMetricGroup().getNumRecordsOutCounter();\n            final Counter numRecordsOutErrors = metricGroup.getNumRecordsOutErrorsCounter();\n            final Counter numRecordsSendErrors = metricGroup.getNumRecordsSendErrorsCounter();\n            assertThat(numBytesOut.getCount()).isEqualTo(0L);\n            assertThat(numRecordsOut.getCount()).isEqualTo(0);\n            assertThat(numRecordsOutErrors.getCount()).isEqualTo(0);\n            assertThat(numRecordsSendErrors.getCount()).isEqualTo(0);\n\n            // elements for which the serializer returns null should be silently skipped\n            writer.write(null, SINK_WRITER_CONTEXT);\n            timeService.trigger();\n            assertThat(numBytesOut.getCount()).isEqualTo(0L);\n            assertThat(numRecordsOut.getCount()).isEqualTo(0);\n            assertThat(numRecordsOutErrors.getCount()).isEqualTo(0);\n            assertThat(numRecordsSendErrors.getCount()).isEqualTo(0);\n\n            // but elements for which a non-null producer record is returned should count\n            writer.write(1, SINK_WRITER_CONTEXT);\n            timeService.trigger();\n            assertThat(numRecordsOut.getCount()).isEqualTo(1);\n            assertThat(numRecordsOutErrors.getCount()).isEqualTo(0);\n            assertThat(numRecordsSendErrors.getCount()).isEqualTo(0);\n            assertThat(numBytesOut.getCount()).isGreaterThan(0L);\n        }\n    }",
          "conflictNames": [
              "operatorIOMetricGroup",
              "writer",
              "numBytesOut",
              "numRecordsOut",
              "numRecordsOutErrors",
              "numRecordsSendErrors"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/92951a05127f1e0e2ab0ea04ae022659fc5276ab^1/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/sink/CommitterOperatorTest.java",
      "locators": [
          {
              "line": 19,
              "column": 54
          },
          {
              "line": 21,
              "column": 39
          },
          {
              "line": 22,
              "column": 39
          },
          {
              "line": 23,
              "column": 39
          },
          {
              "line": 25,
              "column": 49
          },
          {
              "line": 26,
              "column": 49
          },
          {
              "line": 27,
              "column": 49
          },
          {
              "line": 28,
              "column": 49
          },
          {
              "line": 40,
              "column": 60
          },
          {
              "line": 41,
              "column": 60
          },
          {
              "line": 42,
              "column": 60
          },
          {
              "line": 52,
              "column": 23
          },
          {
              "line": 55,
              "column": 13
          },
          {
              "line": 63,
              "column": 13
          },
          {
              "line": 75,
              "column": 77
          },
          {
              "line": 303,
              "column": 29
          },
          {
              "line": 316,
              "column": 77
          }
      ],
      "old_name": "sink",
      "new_name": "sinkAndCounters",
      "ctx": {
          "symbolName": "sink",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Sink<Integer>",
          "scopeHint": "in testEmitCommittables(...)",
          "filePath": "CommitterOperatorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@ParameterizedTest\n    @ValueSource(booleans = {true, false})\n    void testEmitCommittables(boolean withPostCommitTopology) throws Exception {\n        final ForwardingCommitter committer = new ForwardingCommitter();\n\n        Sink<Integer> sink;\n        if (withPostCommitTopology) {\n            // Insert global committer to simulate post commit topology\n            sink =\n                    TestSink.newBuilder()\n                            .setCommitter(committer)\n                            .setDefaultGlobalCommitter()\n                            .setCommittableSerializer(TestSink.StringCommittableSerializer.INSTANCE)\n                            .build()\n                            .asV2();\n        } else {\n            sink =\n                    TestSink.newBuilder()\n                            .setCommitter(committer)\n                            .setCommittableSerializer(TestSink.StringCommittableSerializer.INSTANCE)\n                            .build()\n                            .asV2();\n        }\n        final OneInputStreamOperatorTestHarness<\n                        CommittableMessage<String>, CommittableMessage<String>>\n                testHarness =\n                        new OneInputStreamOperatorTestHarness<>(\n                                new CommitterOperatorFactory<>(\n                                        (TwoPhaseCommittingSink<?, String>) sink, false, true));\n        testHarness.open();\n\n        final CommittableSummary<String> committableSummary =\n                new CommittableSummary<>(1, 1, 1L, 1, 1, 0);\n        testHarness.processElement(new StreamRecord<>(committableSummary));\n        final CommittableWithLineage<String> committableWithLineage =\n                new CommittableWithLineage<>(\"1\", 1L, 1);\n        testHarness.processElement(new StreamRecord<>(committableWithLineage));\n\n        // Trigger commit\n        testHarness.notifyOfCompletedCheckpoint(1);\n\n        assertThat(committer.getSuccessfulCommits()).isEqualTo(1);\n        if (withPostCommitTopology) {\n            final List<StreamElement> output = fromOutput(testHarness.getOutput());\n            SinkV2Assertions.assertThat(toCommittableSummary(output.get(0)))\n                    .hasFailedCommittables(committableSummary.getNumberOfFailedCommittables())\n                    .hasOverallCommittables(committableSummary.getNumberOfCommittables())\n                    .hasPendingCommittables(0);\n            SinkV2Assertions.assertThat(toCommittableWithLinage(output.get(1)))\n                    .isEqualTo(copyCommittableWithDifferentOrigin(committableWithLineage, 0));\n        } else {\n            assertThat(testHarness.getOutput()).isEmpty();\n        }\n        testHarness.close();\n    }",
          "conflictNames": [
              "withPostCommitTopology",
              "committer",
              "testHarness",
              "committableSummary",
              "committableWithLineage",
              "output"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/92951a05127f1e0e2ab0ea04ae022659fc5276ab^1/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/SinkTransformationTranslatorITCase.java",
      "locators": [
          {
              "line": 163,
              "column": 26
          },
          {
              "line": 167,
              "column": 17
          },
          {
              "line": 203,
              "column": 26
          },
          {
              "line": 216,
              "column": 17
          },
          {
              "line": 264,
              "column": 26
          },
          {
              "line": 268,
              "column": 17
          },
          {
              "line": 278,
              "column": 22
          },
          {
              "line": 283,
              "column": 52
          },
          {
              "line": 297,
              "column": 70
          }
      ],
      "old_name": "globalCommitter",
      "new_name": "committer",
      "ctx": {
          "symbolName": "globalCommitter",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "StreamNode",
          "scopeHint": "in disableOperatorChain(...)",
          "filePath": "SinkTransformationTranslatorITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void disableOperatorChain() {\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n        final DataStreamSource<Integer> src = env.fromElements(1, 2);\n        final DataStreamSink<Integer> dataStreamSink =\n                src.sinkTo(\n                                TestSink.newBuilder()\n                                        .setDefaultCommitter()\n                                        .setDefaultGlobalCommitter()\n                                        .build())\n                        .name(NAME);\n        dataStreamSink.disableChaining();\n\n        final StreamGraph streamGraph = env.getStreamGraph();\n        final StreamNode writer = findWriter(streamGraph);\n        final StreamNode globalCommitter = findCommitter(streamGraph);\n\n        assertThat(writer.getOperatorFactory().getChainingStrategy(), is(ChainingStrategy.NEVER));\n        assertThat(\n                globalCommitter.getOperatorFactory().getChainingStrategy(),\n                is(ChainingStrategy.NEVER));\n    }",
          "conflictNames": [
              "env",
              "src",
              "dataStreamSink",
              "streamGraph",
              "writer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/92951a05127f1e0e2ab0ea04ae022659fc5276ab^1/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/sink/SinkWriterOperatorTest.java",
      "locators": [
          {
              "line": 190,
              "column": 47
          },
          {
              "line": 193,
              "column": 58
          },
          {
              "line": 207,
              "column": 20
          },
          {
              "line": 476,
              "column": 53
          },
          {
              "line": 479,
              "column": 71
          },
          {
              "line": 490,
              "column": 47
          },
          {
              "line": 496,
              "column": 36
          }
      ],
      "old_name": "snapshottingWriter",
      "new_name": "sinkWriter",
      "ctx": {
          "symbolName": "snapshottingWriter",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SnapshottingBufferingSinkWriter",
          "scopeHint": "in testStateRestore(...)",
          "filePath": "SinkWriterOperatorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@ParameterizedTest\n    @ValueSource(booleans = {true, false})\n    void testStateRestore(boolean stateful) throws Exception {\n\n        final long initialTime = 0;\n\n        final SnapshottingBufferingSinkWriter snapshottingWriter =\n                new SnapshottingBufferingSinkWriter();\n        final OneInputStreamOperatorTestHarness<Integer, CommittableMessage<Integer>> testHarness =\n                createTestHarnessWithBufferingSinkWriter(snapshottingWriter, stateful);\n\n        testHarness.open();\n\n        testHarness.processWatermark(initialTime);\n        testHarness.processElement(1, initialTime + 1);\n        testHarness.processElement(2, initialTime + 2);\n\n        testHarness.prepareSnapshotPreBarrier(1L);\n        OperatorSubtaskState snapshot = testHarness.snapshot(1L, 1L);\n\n        // we see the watermark and the committable summary, so the committables must be stored in\n        // state\n        assertThat(testHarness.getOutput()).hasSize(2).contains(new Watermark(initialTime));\n        assertThat(snapshottingWriter.lastCheckpointId)\n                .isEqualTo(stateful ? 1L : SnapshottingBufferingSinkWriter.NOT_SNAPSHOTTED);\n\n        testHarness.close();\n\n        final OneInputStreamOperatorTestHarness<Integer, CommittableMessage<Integer>>\n                restoredTestHarness =\n                        createTestHarnessWithBufferingSinkWriter(\n                                new SnapshottingBufferingSinkWriter(), stateful);\n\n        restoredTestHarness.initializeState(snapshot);\n        restoredTestHarness.open();\n\n        // this will flush out the committables that were restored\n        restoredTestHarness.endInput();\n        final long checkpointId = 2;\n        restoredTestHarness.prepareSnapshotPreBarrier(checkpointId);\n\n        if (stateful) {\n            assertBasicOutput(restoredTestHarness.getOutput(), 2, Long.MAX_VALUE);\n        } else {\n            assertThat(fromOutput(restoredTestHarness.getOutput()).get(0).asRecord().getValue())\n                    .isInstanceOf(CommittableSummary.class)\n                    .satisfies(\n                            cs ->\n                                    SinkV2Assertions.assertThat((CommittableSummary<?>) cs)\n                                            .hasOverallCommittables(0)\n                                            .hasPendingCommittables(0)\n                                            .hasFailedCommittables(0));\n        }\n        restoredTestHarness.close();\n    }",
          "conflictNames": [
              "stateful",
              "initialTime",
              "testHarness",
              "snapshot",
              "restoredTestHarness",
              "checkpointId"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/929d96f2ee01624fdac6897664d4a02b59cef5ba^1/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/inference/strategies/CommonTypeStrategy.java",
      "locators": [
          {
              "line": 39,
              "column": 33
          },
          {
              "line": 43,
              "column": 50
          }
      ],
      "old_name": "actualTypes",
      "new_name": "selectedActualTypes",
      "ctx": {
          "symbolName": "actualTypes",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<LogicalType>",
          "scopeHint": "in inferType(...)",
          "filePath": "CommonTypeStrategy.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public Optional<DataType> inferType(CallContext callContext) {\n        final List<LogicalType> actualTypes =\n                callContext.getArgumentDataTypes().stream()\n                        .map(DataType::getLogicalType)\n                        .collect(Collectors.toList());\n        return LogicalTypeMerging.findCommonType(actualTypes)\n                .map(TypeConversions::fromLogicalToDataType);\n    }",
          "conflictNames": [
              "callContext"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/934edd37dee44fc7c8708f09d7b715cd5e8b3404^1/flink-table/flink-sql-gateway/src/test/java/org/apache/flink/table/gateway/service/SqlGatewayServiceITCase.java",
      "locators": [
          {
              "line": 298,
              "column": 23
          },
          {
              "line": 300,
              "column": 44
          },
          {
              "line": 301,
              "column": 21
          }
      ],
      "old_name": "currentResult",
      "new_name": "result",
      "ctx": {
          "symbolName": "currentResult",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ResultSet",
          "scopeHint": "in testGetOperationFinishedAndFetchResults(...)",
          "filePath": "SqlGatewayServiceITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testGetOperationFinishedAndFetchResults() throws Exception {\n        SessionHandle sessionHandle = service.openSession(defaultSessionEnvironment);\n\n        CountDownLatch startRunningLatch = new CountDownLatch(1);\n        CountDownLatch endRunningLatch = new CountDownLatch(1);\n\n        OperationHandle operationHandle =\n                submitDefaultOperation(\n                        sessionHandle,\n                        () -> {\n                            startRunningLatch.countDown();\n                            endRunningLatch.await();\n                        });\n\n        startRunningLatch.await();\n        assertThat(service.getOperationInfo(sessionHandle, operationHandle))\n                .isEqualTo(new OperationInfo(OperationStatus.RUNNING));\n\n        endRunningLatch.countDown();\n        OperationInfo expectedInfo = new OperationInfo(OperationStatus.FINISHED);\n\n        CommonTestUtils.waitUtil(\n                () -> service.getOperationInfo(sessionHandle, operationHandle).equals(expectedInfo),\n                Duration.ofSeconds(10),\n                \"Failed to wait operation finish.\");\n\n        Long token = 0L;\n        List<RowData> expectedData = getDefaultResultSet().getData();\n        List<RowData> actualData = new ArrayList<>();\n        while (token != null) {\n            ResultSet currentResult =\n                    service.fetchResults(sessionHandle, operationHandle, token, 1);\n            actualData.addAll(checkNotNull(currentResult.getData()));\n            token = currentResult.getNextToken();\n        }\n        assertThat(actualData).isEqualTo(expectedData);\n\n        service.closeOperation(sessionHandle, operationHandle);\n        assertThat(sessionManager.getOperationCount(sessionHandle)).isEqualTo(0);\n    }",
          "conflictNames": [
              "sessionHandle",
              "startRunningLatch",
              "endRunningLatch",
              "operationHandle",
              "expectedInfo",
              "token",
              "expectedData",
              "actualData"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/934edd37dee44fc7c8708f09d7b715cd5e8b3404^1/flink-table/flink-sql-gateway/src/test/java/org/apache/flink/table/gateway/service/SqlGatewayServiceITCase.java",
      "locators": [
          {
              "line": 296,
              "column": 23
          },
          {
              "line": 300,
              "column": 13
          },
          {
              "line": 303,
              "column": 20
          }
      ],
      "old_name": "actualData",
      "new_name": "results",
      "ctx": {
          "symbolName": "actualData",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<RowData>",
          "scopeHint": "in testGetOperationFinishedAndFetchResults(...)",
          "filePath": "SqlGatewayServiceITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testGetOperationFinishedAndFetchResults() throws Exception {\n        SessionHandle sessionHandle = service.openSession(defaultSessionEnvironment);\n\n        CountDownLatch startRunningLatch = new CountDownLatch(1);\n        CountDownLatch endRunningLatch = new CountDownLatch(1);\n\n        OperationHandle operationHandle =\n                submitDefaultOperation(\n                        sessionHandle,\n                        () -> {\n                            startRunningLatch.countDown();\n                            endRunningLatch.await();\n                        });\n\n        startRunningLatch.await();\n        assertThat(service.getOperationInfo(sessionHandle, operationHandle))\n                .isEqualTo(new OperationInfo(OperationStatus.RUNNING));\n\n        endRunningLatch.countDown();\n        OperationInfo expectedInfo = new OperationInfo(OperationStatus.FINISHED);\n\n        CommonTestUtils.waitUtil(\n                () -> service.getOperationInfo(sessionHandle, operationHandle).equals(expectedInfo),\n                Duration.ofSeconds(10),\n                \"Failed to wait operation finish.\");\n\n        Long token = 0L;\n        List<RowData> expectedData = getDefaultResultSet().getData();\n        List<RowData> actualData = new ArrayList<>();\n        while (token != null) {\n            ResultSet currentResult =\n                    service.fetchResults(sessionHandle, operationHandle, token, 1);\n            actualData.addAll(checkNotNull(currentResult.getData()));\n            token = currentResult.getNextToken();\n        }\n        assertThat(actualData).isEqualTo(expectedData);\n\n        service.closeOperation(sessionHandle, operationHandle);\n        assertThat(sessionManager.getOperationCount(sessionHandle)).isEqualTo(0);\n    }",
          "conflictNames": [
              "sessionHandle",
              "startRunningLatch",
              "endRunningLatch",
              "operationHandle",
              "expectedInfo",
              "token",
              "expectedData",
              "currentResult"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/934edd37dee44fc7c8708f09d7b715cd5e8b3404^1/flink-table/flink-sql-gateway/src/test/java/org/apache/flink/table/gateway/service/SqlGatewayServiceITCase.java",
      "locators": [
          {
              "line": 383,
              "column": 23
          },
          {
              "line": 387,
              "column": 13
          },
          {
              "line": 391,
              "column": 20
          }
      ],
      "old_name": "settings",
      "new_name": "results",
      "ctx": {
          "symbolName": "settings",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<RowData>",
          "scopeHint": "in testExecuteSqlWithConfig(...)",
          "filePath": "SqlGatewayServiceITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testExecuteSqlWithConfig() {\n        SessionHandle sessionHandle = service.openSession(defaultSessionEnvironment);\n        String key = \"username\";\n        String value = \"Flink\";\n        OperationHandle operationHandle =\n                service.executeStatement(\n                        sessionHandle,\n                        \"SET\",\n                        -1,\n                        Configuration.fromMap(Collections.singletonMap(key, value)));\n\n        Long token = 0L;\n        List<RowData> settings = new ArrayList<>();\n        while (token != null) {\n            ResultSet result =\n                    service.fetchResults(sessionHandle, operationHandle, token, Integer.MAX_VALUE);\n            settings.addAll(result.getData());\n            token = result.getNextToken();\n        }\n\n        assertThat(settings)\n                .contains(\n                        GenericRowData.of(\n                                StringData.fromString(key), StringData.fromString(value)));\n    }",
          "conflictNames": [
              "sessionHandle",
              "key",
              "value",
              "operationHandle",
              "token",
              "result"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/94fba321d4e29f996c8234c9dcb3b7a93ad8a593^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/utils/OperationConverterUtils.java",
      "locators": [
          {
              "line": 158,
              "column": 16
          },
          {
              "line": 159,
              "column": 61
          },
          {
              "line": 163,
              "column": 9
          },
          {
              "line": 174,
              "column": 17
          },
          {
              "line": 192,
              "column": 9
          },
          {
              "line": 229,
              "column": 67
          },
          {
              "line": 231,
              "column": 17
          }
      ],
      "old_name": "modifiedTableSchema",
      "new_name": "originSchema",
      "ctx": {
          "symbolName": "modifiedTableSchema",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Schema",
          "scopeHint": "in convertRenameColumn(...)",
          "filePath": "OperationConverterUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static Operation convertRenameColumn(\n            ObjectIdentifier tableIdentifier,\n            String originColumnName,\n            String newColumnName,\n            CatalogTable catalogTable) {\n\n        Schema modifiedTableSchema = catalogTable.getUnresolvedSchema();\n        validateColumnName(originColumnName, newColumnName, modifiedTableSchema);\n\n        Schema.Builder builder = Schema.newBuilder();\n        // build column\n        modifiedTableSchema.getColumns().stream()\n                .forEach(\n                        column -> {\n                            if (StringUtils.equals(column.getName(), originColumnName)) {\n                                buildNewColumnFromOriginColumn(builder, column, newColumnName);\n                            } else {\n                                buildNewColumnFromOriginColumn(builder, column, column.getName());\n                            }\n                        });\n        // build primary key column\n        List<String> originPrimaryKeyNames =\n                modifiedTableSchema\n                        .getPrimaryKey()\n                        .map(Schema.UnresolvedPrimaryKey::getColumnNames)\n                        .orElseGet(Lists::newArrayList);\n\n        List<String> newPrimaryKeyNames =\n                originPrimaryKeyNames.stream()\n                        .map(\n                                pkName ->\n                                        StringUtils.equals(pkName, originColumnName)\n                                                ? newColumnName\n                                                : pkName)\n                        .collect(Collectors.toList());\n\n        if (newPrimaryKeyNames.size() > 0) {\n            builder.primaryKey(newPrimaryKeyNames);\n        }\n        // build watermark\n        modifiedTableSchema.getWatermarkSpecs().stream()\n                .forEach(\n                        watermarkSpec -> {\n                            String watermarkRefColumnName = watermarkSpec.getColumnName();\n                            Expression watermarkExpression = watermarkSpec.getWatermarkExpression();\n                            if (StringUtils.equals(watermarkRefColumnName, originColumnName)) {\n                                String newWatermarkExpression =\n                                        ((SqlCallExpression) watermarkExpression)\n                                                .getSqlExpression()\n                                                .replace(watermarkRefColumnName, newColumnName);\n                                builder.watermark(newColumnName, newWatermarkExpression);\n                            } else {\n                                builder.watermark(watermarkRefColumnName, watermarkExpression);\n                            }\n                        });\n        // build partition key\n        List<String> newPartitionKeys =\n                catalogTable.getPartitionKeys().stream()\n                        .map(\n                                name ->\n                                        StringUtils.equals(name, originColumnName)\n                                                ? newColumnName\n                                                : name)\n                        .collect(Collectors.toList());\n        // generate new schema\n        Schema newSchema = builder.build();\n\n        return new AlterTableSchemaOperation(\n                tableIdentifier,\n                CatalogTable.of(\n                        newSchema,\n                        catalogTable.getComment(),\n                        newPartitionKeys,\n                        catalogTable.getOptions()));\n    }",
          "conflictNames": [
              "tableIdentifier",
              "originColumnName",
              "newColumnName",
              "catalogTable",
              "builder",
              "originPrimaryKeyNames",
              "newPrimaryKeyNames",
              "watermarkRefColumnName",
              "watermarkExpression",
              "newWatermarkExpression",
              "newPartitionKeys",
              "newSchema"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/94fba321d4e29f996c8234c9dcb3b7a93ad8a593^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/utils/OperationConverterUtils.java",
      "locators": [
          {
              "line": 208,
              "column": 22
          },
          {
              "line": 224,
              "column": 25
          }
      ],
      "old_name": "newPartitionKeys",
      "new_name": "tableColumns",
      "ctx": {
          "symbolName": "newPartitionKeys",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<String>",
          "scopeHint": "in convertRenameColumn(...)",
          "filePath": "OperationConverterUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static Operation convertRenameColumn(\n            ObjectIdentifier tableIdentifier,\n            String originColumnName,\n            String newColumnName,\n            CatalogTable catalogTable) {\n\n        Schema modifiedTableSchema = catalogTable.getUnresolvedSchema();\n        validateColumnName(originColumnName, newColumnName, modifiedTableSchema);\n\n        Schema.Builder builder = Schema.newBuilder();\n        // build column\n        modifiedTableSchema.getColumns().stream()\n                .forEach(\n                        column -> {\n                            if (StringUtils.equals(column.getName(), originColumnName)) {\n                                buildNewColumnFromOriginColumn(builder, column, newColumnName);\n                            } else {\n                                buildNewColumnFromOriginColumn(builder, column, column.getName());\n                            }\n                        });\n        // build primary key column\n        List<String> originPrimaryKeyNames =\n                modifiedTableSchema\n                        .getPrimaryKey()\n                        .map(Schema.UnresolvedPrimaryKey::getColumnNames)\n                        .orElseGet(Lists::newArrayList);\n\n        List<String> newPrimaryKeyNames =\n                originPrimaryKeyNames.stream()\n                        .map(\n                                pkName ->\n                                        StringUtils.equals(pkName, originColumnName)\n                                                ? newColumnName\n                                                : pkName)\n                        .collect(Collectors.toList());\n\n        if (newPrimaryKeyNames.size() > 0) {\n            builder.primaryKey(newPrimaryKeyNames);\n        }\n        // build watermark\n        modifiedTableSchema.getWatermarkSpecs().stream()\n                .forEach(\n                        watermarkSpec -> {\n                            String watermarkRefColumnName = watermarkSpec.getColumnName();\n                            Expression watermarkExpression = watermarkSpec.getWatermarkExpression();\n                            if (StringUtils.equals(watermarkRefColumnName, originColumnName)) {\n                                String newWatermarkExpression =\n                                        ((SqlCallExpression) watermarkExpression)\n                                                .getSqlExpression()\n                                                .replace(watermarkRefColumnName, newColumnName);\n                                builder.watermark(newColumnName, newWatermarkExpression);\n                            } else {\n                                builder.watermark(watermarkRefColumnName, watermarkExpression);\n                            }\n                        });\n        // build partition key\n        List<String> newPartitionKeys =\n                catalogTable.getPartitionKeys().stream()\n                        .map(\n                                name ->\n                                        StringUtils.equals(name, originColumnName)\n                                                ? newColumnName\n                                                : name)\n                        .collect(Collectors.toList());\n        // generate new schema\n        Schema newSchema = builder.build();\n\n        return new AlterTableSchemaOperation(\n                tableIdentifier,\n                CatalogTable.of(\n                        newSchema,\n                        catalogTable.getComment(),\n                        newPartitionKeys,\n                        catalogTable.getOptions()));\n    }",
          "conflictNames": [
              "tableIdentifier",
              "originColumnName",
              "newColumnName",
              "catalogTable",
              "modifiedTableSchema",
              "builder",
              "originPrimaryKeyNames",
              "newPrimaryKeyNames",
              "watermarkRefColumnName",
              "watermarkExpression",
              "newWatermarkExpression",
              "newSchema"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/950fceb43e628d50fb9f96973badc05cff34afa0^1/flink-tests/src/test/java/org/apache/flink/test/checkpointing/KeyedStateCheckpointingITCase.java",
      "locators": [
          {
              "line": 110,
              "column": 28
          },
          {
              "line": 111,
              "column": 32
          }
      ],
      "old_name": "asyncMemBackend",
      "new_name": "env",
      "ctx": {
          "symbolName": "asyncMemBackend",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "MemoryStateBackend",
          "scopeHint": "in testWithMemoryBackendAsync(...)",
          "filePath": "KeyedStateCheckpointingITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testWithMemoryBackendAsync() throws Exception {\n        MemoryStateBackend asyncMemBackend = new MemoryStateBackend(MAX_MEM_STATE_SIZE, true);\n        testProgramWithBackend(asyncMemBackend);\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/950fceb43e628d50fb9f96973badc05cff34afa0^1/flink-tests/src/test/java/org/apache/flink/test/checkpointing/KeyedStateCheckpointingITCase.java",
      "locators": [
          {
              "line": 123,
              "column": 24
          },
          {
              "line": 125,
              "column": 32
          }
      ],
      "old_name": "asyncFsBackend",
      "new_name": "env",
      "ctx": {
          "symbolName": "asyncFsBackend",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "FsStateBackend",
          "scopeHint": "in testWithFsBackendAsync(...)",
          "filePath": "KeyedStateCheckpointingITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testWithFsBackendAsync() throws Exception {\n        FsStateBackend asyncFsBackend =\n                new FsStateBackend(tmpFolder.newFolder().toURI().toString(), true);\n        testProgramWithBackend(asyncFsBackend);\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/950fceb43e628d50fb9f96973badc05cff34afa0^1/flink-tests/src/test/java/org/apache/flink/test/checkpointing/KeyedStateCheckpointingITCase.java",
      "locators": [
          {
              "line": 130,
              "column": 29
          },
          {
              "line": 132,
              "column": 9
          },
          {
              "line": 134,
              "column": 32
          }
      ],
      "old_name": "fullRocksDbBackend",
      "new_name": "env",
      "ctx": {
          "symbolName": "fullRocksDbBackend",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RocksDBStateBackend",
          "scopeHint": "in testWithRocksDbBackendFull(...)",
          "filePath": "KeyedStateCheckpointingITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testWithRocksDbBackendFull() throws Exception {\n        RocksDBStateBackend fullRocksDbBackend =\n                new RocksDBStateBackend(new MemoryStateBackend(MAX_MEM_STATE_SIZE), false);\n        fullRocksDbBackend.setDbStoragePath(tmpFolder.newFolder().getAbsolutePath());\n\n        testProgramWithBackend(fullRocksDbBackend);\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/950fceb43e628d50fb9f96973badc05cff34afa0^1/flink-tests/src/test/java/org/apache/flink/test/checkpointing/KeyedStateCheckpointingITCase.java",
      "locators": [
          {
              "line": 139,
              "column": 29
          },
          {
              "line": 141,
              "column": 9
          },
          {
              "line": 143,
              "column": 32
          }
      ],
      "old_name": "incRocksDbBackend",
      "new_name": "env",
      "ctx": {
          "symbolName": "incRocksDbBackend",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RocksDBStateBackend",
          "scopeHint": "in testWithRocksDbBackendIncremental(...)",
          "filePath": "KeyedStateCheckpointingITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testWithRocksDbBackendIncremental() throws Exception {\n        RocksDBStateBackend incRocksDbBackend =\n                new RocksDBStateBackend(new MemoryStateBackend(MAX_MEM_STATE_SIZE), true);\n        incRocksDbBackend.setDbStoragePath(tmpFolder.newFolder().getAbsolutePath());\n\n        testProgramWithBackend(incRocksDbBackend);\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/950fceb43e628d50fb9f96973badc05cff34afa0^1/flink-tests/src/test/java/org/apache/flink/test/checkpointing/ResumeCheckpointManuallyITCase.java",
      "locators": [
          {
              "line": 238,
              "column": 22
          },
          {
              "line": 243,
              "column": 17
          },
          {
              "line": 245,
              "column": 17
          },
          {
              "line": 254,
              "column": 22
          },
          {
              "line": 259,
              "column": 17
          },
          {
              "line": 261,
              "column": 17
          },
          {
              "line": 270,
              "column": 26
          },
          {
              "line": 275,
              "column": 21
          },
          {
              "line": 277,
              "column": 21
          },
          {
              "line": 288,
              "column": 26
          },
          {
              "line": 293,
              "column": 21
          },
          {
              "line": 295,
              "column": 21
          }
      ],
      "old_name": "previousStateBackend",
      "new_name": "previousStateBackendConfig",
      "ctx": {
          "symbolName": "previousStateBackend",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "StateBackend",
          "scopeHint": "in testExternalizedSwitchRocksDBCheckpointsStandalone(...)",
          "filePath": "ResumeCheckpointManuallyITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testExternalizedSwitchRocksDBCheckpointsStandalone() throws Exception {\n        final File checkpointDir = temporaryFolder.newFolder();\n        StateBackend previousStateBackend = createRocksDBStateBackend(checkpointDir, false);\n        StateBackend newStateBackend = createRocksDBStateBackend(checkpointDir, true);\n        testExternalizedCheckpoints(\n                checkpointDir,\n                null,\n                previousStateBackend,\n                newStateBackend,\n                previousStateBackend,\n                false,\n                recoveryClaimMode);\n    }",
          "conflictNames": [
              "checkpointDir",
              "newStateBackend"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/950fceb43e628d50fb9f96973badc05cff34afa0^1/flink-tests/src/test/java/org/apache/flink/test/checkpointing/ResumeCheckpointManuallyITCase.java",
      "locators": [
          {
              "line": 239,
              "column": 22
          },
          {
              "line": 244,
              "column": 17
          },
          {
              "line": 255,
              "column": 22
          },
          {
              "line": 260,
              "column": 17
          },
          {
              "line": 271,
              "column": 26
          },
          {
              "line": 276,
              "column": 21
          },
          {
              "line": 289,
              "column": 26
          },
          {
              "line": 294,
              "column": 21
          }
      ],
      "old_name": "newStateBackend",
      "new_name": "newStateBackendConfig",
      "ctx": {
          "symbolName": "newStateBackend",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "StateBackend",
          "scopeHint": "in testExternalizedSwitchRocksDBCheckpointsStandalone(...)",
          "filePath": "ResumeCheckpointManuallyITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testExternalizedSwitchRocksDBCheckpointsStandalone() throws Exception {\n        final File checkpointDir = temporaryFolder.newFolder();\n        StateBackend previousStateBackend = createRocksDBStateBackend(checkpointDir, false);\n        StateBackend newStateBackend = createRocksDBStateBackend(checkpointDir, true);\n        testExternalizedCheckpoints(\n                checkpointDir,\n                null,\n                previousStateBackend,\n                newStateBackend,\n                previousStateBackend,\n                false,\n                recoveryClaimMode);\n    }",
          "conflictNames": [
              "checkpointDir",
              "previousStateBackend"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/95869e0bc99f9703807a114a4240dbc443d970cb^1/flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/table/endpoint/hive/HiveServer2Endpoint.java",
      "locators": [
          {
              "line": 313,
              "column": 20
          },
          {
              "line": 325,
              "column": 71
          }
      ],
      "old_name": "hiveModule",
      "new_name": "hiveModuleCreator",
      "ctx": {
          "symbolName": "hiveModule",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Module",
          "scopeHint": "in OpenSession(...)",
          "filePath": "HiveServer2Endpoint.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public TOpenSessionResp OpenSession(TOpenSessionReq tOpenSessionReq) throws TException {\n        LOG.debug(\"Client protocol version: {}.\", tOpenSessionReq.getClient_protocol());\n        TOpenSessionResp resp = new TOpenSessionResp();\n        try {\n            // negotiate connection protocol\n            TProtocolVersion clientProtocol = tOpenSessionReq.getClient_protocol();\n            // the session version is not larger than the server version because of the\n            // min(server_version, ...)\n            HiveServer2EndpointVersion sessionVersion =\n                    HiveServer2EndpointVersion.valueOf(\n                            TProtocolVersion.findByValue(\n                                    Math.min(\n                                            clientProtocol.getValue(),\n                                            SERVER_VERSION.getVersion().getValue())));\n\n            // prepare session environment\n            Map<String, String> originSessionConf =\n                    tOpenSessionReq.getConfiguration() == null\n                            ? Collections.emptyMap()\n                            : tOpenSessionReq.getConfiguration();\n\n            HiveConf conf = new HiveConf(hiveConf);\n            Catalog hiveCatalog =\n                    new HiveCatalog(\n                            catalogName,\n                            getUsedDefaultDatabase(originSessionConf).orElse(defaultDatabase),\n                            conf,\n                            HiveShimLoader.getHiveVersion(),\n                            allowEmbedded);\n            // Trigger the creation of the HiveMetaStoreClient to use the same HiveConf. If the\n            // initial HiveConf is different, it will trigger the PersistenceManagerFactory to close\n            // all the alive PersistenceManager in the ObjectStore, which may get error like\n            // \"Persistence Manager has been closed\" in the later connection.\n            hiveCatalog.open();\n            Module hiveModule = new HiveModule();\n            // set variables to HiveConf and Session's conf\n            Map<String, String> sessionConfig = new HashMap<>();\n            sessionConfig.put(TABLE_SQL_DIALECT.key(), SqlDialect.HIVE.name());\n            sessionConfig.put(RUNTIME_MODE.key(), RuntimeExecutionMode.BATCH.name());\n            sessionConfig.put(TABLE_DML_SYNC.key(), \"true\");\n            setVariables(conf, sessionConfig, originSessionConf);\n            SessionHandle sessionHandle =\n                    service.openSession(\n                            SessionEnvironment.newBuilder()\n                                    .setSessionEndpointVersion(sessionVersion)\n                                    .registerCatalog(catalogName, hiveCatalog)\n                                    .registerModuleAtHead(moduleName, hiveModule)\n                                    .setDefaultCatalog(catalogName)\n                                    .addSessionConfig(sessionConfig)\n                                    .build());\n            // response\n            resp.setStatus(OK_STATUS);\n            resp.setServerProtocolVersion(sessionVersion.getVersion());\n            resp.setSessionHandle(toTSessionHandle(sessionHandle));\n            resp.setConfiguration(service.getSessionConfig(sessionHandle));\n        } catch (Throwable t) {\n            LOG.error(\"Failed to OpenSession.\", t);\n            resp.setStatus(toTStatus(t));\n        }\n        return resp;\n    }",
          "conflictNames": [
              "tOpenSessionReq",
              "resp",
              "clientProtocol",
              "sessionVersion",
              "originSessionConf",
              "conf",
              "hiveCatalog",
              "sessionConfig",
              "sessionHandle"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/95c617249c77b82fa150326ea7df9a65c8a34eb4^1/flink-tests/src/test/java/org/apache/flink/test/checkpointing/SnapshotFileMergingCompatibilityITCase.java",
      "locators": [
          {
              "line": 347,
              "column": 76
          },
          {
              "line": 353,
              "column": 23
          },
          {
              "line": 371,
              "column": 53
          },
          {
              "line": 375,
              "column": 45
          },
          {
              "line": 379,
              "column": 22
          },
          {
              "line": 392,
              "column": 33
          },
          {
              "line": 399,
              "column": 33
          },
          {
              "line": 402,
              "column": 29
          },
          {
              "line": 406,
              "column": 22
          },
          {
              "line": 411,
              "column": 16
          }
      ],
      "old_name": "disposed",
      "new_name": "result",
      "ctx": {
          "symbolName": "disposed",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "AtomicBoolean",
          "scopeHint": "in verifyCheckpointDisposed(...)",
          "filePath": "SnapshotFileMergingCompatibilityITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Traverse the checkpoint metadata and verify all the state handle is disposed.\n     *\n     * @param metadata the metadata to traverse.\n     * @return true if all corresponding files are deleted.\n     */\n    private static boolean verifyCheckpointDisposed(CheckpointMetadata metadata) {\n        AtomicBoolean disposed = new AtomicBoolean(true);\n        for (OperatorState operatorState : metadata.getOperatorStates()) {\n            for (OperatorSubtaskState subtaskState : operatorState.getStates()) {\n                // Check keyed state handle\n                List<KeyedStateHandle> keyedStateHandles =\n                        new ArrayList<>(subtaskState.getManagedKeyedState());\n                for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {\n                    assertThat(keyedStateHandle)\n                            .isInstanceOf(IncrementalRemoteKeyedStateHandle.class);\n                    ((IncrementalRemoteKeyedStateHandle) keyedStateHandle)\n                            .streamSubHandles()\n                            .forEach(\n                                    handle -> {\n                                        try {\n                                            if (handle instanceof FileStateHandle) {\n                                                org.apache.flink.core.fs.Path p =\n                                                        ((FileStateHandle) handle).getFilePath();\n                                                if (p.getFileSystem().exists(p)) {\n                                                    disposed.set(false);\n                                                }\n                                            }\n                                        } catch (IOException e) {\n                                            disposed.set(false);\n                                        }\n                                    });\n                }\n                if (!disposed.get()) {\n                    break;\n                }\n                List<OperatorStateHandle> operatorStateHandles =\n                        new ArrayList<>(subtaskState.getManagedOperatorState());\n                for (OperatorStateHandle handle : operatorStateHandles) {\n                    if (handle instanceof FileMergingOperatorStreamStateHandle) {\n                        try {\n                            org.apache.flink.core.fs.Path p =\n                                    ((FileMergingOperatorStreamStateHandle) handle)\n                                            .getSharedDirHandle()\n                                            .getDirectory();\n                            if (p.getFileSystem().exists(p)) {\n                                disposed.set(false);\n                            }\n                            p =\n                                    ((FileMergingOperatorStreamStateHandle) handle)\n                                            .getTaskOwnedDirHandle()\n                                            .getDirectory();\n                            if (p.getFileSystem().exists(p)) {\n                                disposed.set(false);\n                            }\n                        } catch (IOException e) {\n                            disposed.set(false);\n                        }\n                    }\n                }\n                if (!disposed.get()) {\n                    break;\n                }\n            }\n        }\n        return disposed.get();\n    }",
          "conflictNames": [
              "metadata",
              "keyedStateHandles",
              "p",
              "operatorStateHandles"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/95cb47ef53c822161ca90cdca43ad95fd1332633^1/flink-table/flink-sql-gateway/src/test/java/org/apache/flink/table/gateway/rest/SqlGatewayRestEndpointStatementITCase.java",
      "locators": [
          {
              "line": 142,
              "column": 19
          },
          {
              "line": 144,
              "column": 20
          },
          {
              "line": 153,
              "column": 17
          },
          {
              "line": 155,
              "column": 25
          },
          {
              "line": 238,
              "column": 23
          },
          {
              "line": 240,
              "column": 27
          }
      ],
      "old_name": "resultSet",
      "new_name": "resultInfo",
      "ctx": {
          "symbolName": "resultSet",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ResultSet",
          "scopeHint": "in runSingleStatement(...)",
          "filePath": "SqlGatewayRestEndpointStatementITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    protected String runSingleStatement(String statement) throws Exception {\n        ExecuteStatementRequestBody executeStatementRequestBody =\n                new ExecuteStatementRequestBody(statement, 0L, new HashMap<>());\n        CompletableFuture<ExecuteStatementResponseBody> response =\n                restClient.sendRequest(\n                        SQL_GATEWAY_REST_ENDPOINT_EXTENSION.getTargetAddress(),\n                        SQL_GATEWAY_REST_ENDPOINT_EXTENSION.getTargetPort(),\n                        executeStatementHeaders,\n                        sessionMessageParameters,\n                        executeStatementRequestBody);\n        ExecuteStatementResponseBody executeStatementResponseBody = response.get();\n        String operationHandleString = executeStatementResponseBody.getOperationHandle();\n        assertNotNull(operationHandleString);\n        OperationHandle operationHandle =\n                new OperationHandle(UUID.fromString(operationHandleString));\n        assertDoesNotThrow(\n                () ->\n                        SQL_GATEWAY_SERVICE_EXTENSION\n                                .getSessionManager()\n                                .getSession(sessionHandle)\n                                .getOperationManager()\n                                .getOperation(operationHandle));\n\n        CommonTestUtils.waitUtil(\n                () ->\n                        SQL_GATEWAY_SERVICE_EXTENSION\n                                .getService()\n                                .getOperationInfo(sessionHandle, operationHandle)\n                                .getStatus()\n                                .isTerminalStatus(),\n                Duration.ofSeconds(OPERATION_WAIT_SECONDS),\n                \"Failed to wait operation finish.\");\n\n        FetchResultsResponseBody fetchResultsResponseBody =\n                fetchResults(sessionHandle, operationHandle, 0L);\n\n        ResultSet resultSet = fetchResultsResponseBody.getResults();\n        String resultType = fetchResultsResponseBody.getResultType();\n        assertThat(resultSet).isNotNull();\n        assertThat(\n                        Arrays.asList(\n                                ResultSet.ResultType.PAYLOAD.name(),\n                                ResultSet.ResultType.EOS.name()))\n                .contains(resultType);\n\n        return toString(\n                StatementType.match(statement),\n                resultSet.getResultSchema(),\n                new RowDataToStringConverterImpl(\n                        resultSet.getResultSchema().toPhysicalRowDataType(),\n                        DateTimeUtils.UTC_ZONE.toZoneId(),\n                        SqlGatewayRestEndpointStatementITCase.class.getClassLoader(),\n                        false),\n                new RowDataIterator(sessionHandle, operationHandle));\n    }",
          "conflictNames": [
              "statement",
              "executeStatementRequestBody",
              "response",
              "executeStatementResponseBody",
              "operationHandleString",
              "operationHandle",
              "fetchResultsResponseBody",
              "resultType"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/95cb47ef53c822161ca90cdca43ad95fd1332633^1/flink-table/flink-sql-gateway/src/test/java/org/apache/flink/table/gateway/rest/serde/JsonResultSetSerDeTest.java",
      "locators": [
          {
              "line": 118,
              "column": 24
          },
          {
              "line": 120,
              "column": 13
          },
          {
              "line": 122,
              "column": 23
          },
          {
              "line": 127,
              "column": 19
          },
          {
              "line": 133,
              "column": 13
          },
          {
              "line": 135,
              "column": 23
          },
          {
              "line": 138,
              "column": 34
          },
          {
              "line": 140,
              "column": 17
          },
          {
              "line": 157,
              "column": 32
          }
      ],
      "old_name": "rowList",
      "new_name": "rows",
      "ctx": {
          "symbolName": "rowList",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ArrayList<Row>",
          "scopeHint": "in testSerDeResultSetWithMultiRowData(...)",
          "filePath": "JsonResultSetSerDeTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testSerDeResultSetWithMultiRowData() throws Exception {\n        ArrayList<Row> rowList = new ArrayList<>();\n        for (int i = 0; i < ROW_NUMBER; ++i) {\n            rowList.add(getTestRowData());\n        }\n        seDeResultSet(rowList, getFields());\n    }",
          "conflictNames": [
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/95cb47ef53c822161ca90cdca43ad95fd1332633^1/flink-table/flink-sql-gateway/src/test/java/org/apache/flink/table/gateway/rest/serde/JsonResultSetSerDeTest.java",
      "locators": [
          {
              "line": 144,
              "column": 19
          },
          {
              "line": 152,
              "column": 57
          },
          {
              "line": 160,
              "column": 28
          }
      ],
      "old_name": "testResultSet",
      "new_name": "testResultInfo",
      "ctx": {
          "symbolName": "testResultSet",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ResultSet",
          "scopeHint": "in seDeResultSet(...)",
          "filePath": "JsonResultSetSerDeTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "void seDeResultSet(List<Row> rowList, List<DataTypes.Field> fields) throws IOException {\n        List<RowData> rowDataList =\n                rowList.stream()\n                        .map(JsonResultSetSerDeTest::convertToInternal)\n                        .collect(Collectors.toList());\n        ResolvedSchema testResolvedSchema = getTestResolvedSchema(fields);\n        ResultSet testResultSet =\n                new ResultSet(ResultSet.ResultType.PAYLOAD, 0L, testResolvedSchema, rowDataList);\n        // Test serialization & deserialization\n        ObjectMapper objectMapper = new ObjectMapper();\n        SimpleModule resultSetModule = new SimpleModule();\n        resultSetModule.addSerializer(ResultSet.class, new JsonResultSetSerializer());\n        resultSetModule.addDeserializer(ResultSet.class, new JsonResultSetDeserializer());\n        objectMapper.registerModule(resultSetModule);\n        String result = objectMapper.writeValueAsString(testResultSet);\n        ResultSet resultSet = objectMapper.readValue(result, ResultSet.class);\n        List<RowData> deRowDataList = resultSet.getData();\n        for (int i = 0; i < deRowDataList.size(); ++i) {\n            assertThat(convertToExternal(deRowDataList.get(i), ROW(getFields())))\n                    .isEqualTo(rowList.get(i));\n        }\n        assertThat(resultSet.getResultSchema().toString())\n                .isEqualTo(testResultSet.getResultSchema().toString());\n    }",
          "conflictNames": [
              "rowList",
              "fields",
              "rowDataList",
              "testResolvedSchema",
              "objectMapper",
              "resultSetModule",
              "result",
              "resultSet",
              "deRowDataList",
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/95cb47ef53c822161ca90cdca43ad95fd1332633^1/flink-table/flink-sql-gateway/src/test/java/org/apache/flink/table/gateway/rest/serde/JsonResultSetSerDeTest.java",
      "locators": [
          {
              "line": 148,
              "column": 22
          },
          {
              "line": 149,
              "column": 9
          },
          {
              "line": 150,
              "column": 9
          },
          {
              "line": 151,
              "column": 37
          },
          {
              "line": 153,
              "column": 19
          },
          {
              "line": 154,
              "column": 39
          },
          {
              "line": 159,
              "column": 20
          }
      ],
      "old_name": "resultSet",
      "new_name": "resultInfo",
      "ctx": {
          "symbolName": "resultSet",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ResultSet",
          "scopeHint": "in seDeResultSet(...)",
          "filePath": "JsonResultSetSerDeTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "void seDeResultSet(List<Row> rowList, List<DataTypes.Field> fields) throws IOException {\n        List<RowData> rowDataList =\n                rowList.stream()\n                        .map(JsonResultSetSerDeTest::convertToInternal)\n                        .collect(Collectors.toList());\n        ResolvedSchema testResolvedSchema = getTestResolvedSchema(fields);\n        ResultSet testResultSet =\n                new ResultSet(ResultSet.ResultType.PAYLOAD, 0L, testResolvedSchema, rowDataList);\n        // Test serialization & deserialization\n        ObjectMapper objectMapper = new ObjectMapper();\n        SimpleModule resultSetModule = new SimpleModule();\n        resultSetModule.addSerializer(ResultSet.class, new JsonResultSetSerializer());\n        resultSetModule.addDeserializer(ResultSet.class, new JsonResultSetDeserializer());\n        objectMapper.registerModule(resultSetModule);\n        String result = objectMapper.writeValueAsString(testResultSet);\n        ResultSet resultSet = objectMapper.readValue(result, ResultSet.class);\n        List<RowData> deRowDataList = resultSet.getData();\n        for (int i = 0; i < deRowDataList.size(); ++i) {\n            assertThat(convertToExternal(deRowDataList.get(i), ROW(getFields())))\n                    .isEqualTo(rowList.get(i));\n        }\n        assertThat(resultSet.getResultSchema().toString())\n                .isEqualTo(testResultSet.getResultSchema().toString());\n    }",
          "conflictNames": [
              "rowList",
              "fields",
              "rowDataList",
              "testResolvedSchema",
              "testResultSet",
              "objectMapper",
              "resultSetModule",
              "result",
              "deRowDataList",
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/95cb47ef53c822161ca90cdca43ad95fd1332633^1/flink-table/flink-sql-gateway/src/test/java/org/apache/flink/table/gateway/rest/serde/JsonResultSetSerDeTest.java",
      "locators": [
          {
              "line": 154,
              "column": 23
          },
          {
              "line": 155,
              "column": 29
          },
          {
              "line": 156,
              "column": 42
          }
      ],
      "old_name": "deRowDataList",
      "new_name": "data",
      "ctx": {
          "symbolName": "deRowDataList",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<RowData>",
          "scopeHint": "in seDeResultSet(...)",
          "filePath": "JsonResultSetSerDeTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "void seDeResultSet(List<Row> rowList, List<DataTypes.Field> fields) throws IOException {\n        List<RowData> rowDataList =\n                rowList.stream()\n                        .map(JsonResultSetSerDeTest::convertToInternal)\n                        .collect(Collectors.toList());\n        ResolvedSchema testResolvedSchema = getTestResolvedSchema(fields);\n        ResultSet testResultSet =\n                new ResultSet(ResultSet.ResultType.PAYLOAD, 0L, testResolvedSchema, rowDataList);\n        // Test serialization & deserialization\n        ObjectMapper objectMapper = new ObjectMapper();\n        SimpleModule resultSetModule = new SimpleModule();\n        resultSetModule.addSerializer(ResultSet.class, new JsonResultSetSerializer());\n        resultSetModule.addDeserializer(ResultSet.class, new JsonResultSetDeserializer());\n        objectMapper.registerModule(resultSetModule);\n        String result = objectMapper.writeValueAsString(testResultSet);\n        ResultSet resultSet = objectMapper.readValue(result, ResultSet.class);\n        List<RowData> deRowDataList = resultSet.getData();\n        for (int i = 0; i < deRowDataList.size(); ++i) {\n            assertThat(convertToExternal(deRowDataList.get(i), ROW(getFields())))\n                    .isEqualTo(rowList.get(i));\n        }\n        assertThat(resultSet.getResultSchema().toString())\n                .isEqualTo(testResultSet.getResultSchema().toString());\n    }",
          "conflictNames": [
              "rowList",
              "fields",
              "rowDataList",
              "testResolvedSchema",
              "testResultSet",
              "objectMapper",
              "resultSetModule",
              "result",
              "resultSet",
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/95cb47ef53c822161ca90cdca43ad95fd1332633^1/flink-table/flink-sql-gateway/src/test/java/org/apache/flink/table/gateway/rest/serde/JsonResultSetSerDeTest.java",
      "locators": [
          {
              "line": 148,
              "column": 22
          },
          {
              "line": 149,
              "column": 9
          },
          {
              "line": 150,
              "column": 9
          },
          {
              "line": 151,
              "column": 37
          }
      ],
      "old_name": "resultSetModule",
      "new_name": "simpleModule",
      "ctx": {
          "symbolName": "resultSetModule",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SimpleModule",
          "scopeHint": "in seDeResultSet(...)",
          "filePath": "JsonResultSetSerDeTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "void seDeResultSet(List<Row> rowList, List<DataTypes.Field> fields) throws IOException {\n        List<RowData> rowDataList =\n                rowList.stream()\n                        .map(JsonResultSetSerDeTest::convertToInternal)\n                        .collect(Collectors.toList());\n        ResolvedSchema testResolvedSchema = getTestResolvedSchema(fields);\n        ResultSet testResultSet =\n                new ResultSet(ResultSet.ResultType.PAYLOAD, 0L, testResolvedSchema, rowDataList);\n        // Test serialization & deserialization\n        ObjectMapper objectMapper = new ObjectMapper();\n        SimpleModule resultSetModule = new SimpleModule();\n        resultSetModule.addSerializer(ResultSet.class, new JsonResultSetSerializer());\n        resultSetModule.addDeserializer(ResultSet.class, new JsonResultSetDeserializer());\n        objectMapper.registerModule(resultSetModule);\n        String result = objectMapper.writeValueAsString(testResultSet);\n        ResultSet resultSet = objectMapper.readValue(result, ResultSet.class);\n        List<RowData> deRowDataList = resultSet.getData();\n        for (int i = 0; i < deRowDataList.size(); ++i) {\n            assertThat(convertToExternal(deRowDataList.get(i), ROW(getFields())))\n                    .isEqualTo(rowList.get(i));\n        }\n        assertThat(resultSet.getResultSchema().toString())\n                .isEqualTo(testResultSet.getResultSchema().toString());\n    }",
          "conflictNames": [
              "rowList",
              "fields",
              "rowDataList",
              "testResolvedSchema",
              "testResultSet",
              "objectMapper",
              "result",
              "resultSet",
              "deRowDataList",
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/960a253e8bd8c80d8fce1bd7eb55d6aab16936ca^1/flink-filesystems/flink-hadoop-fs/src/main/java/org/apache/flink/runtime/util/HadoopUtils.java",
      "locators": [
          {
              "line": 58,
              "column": 23
          },
          {
              "line": 79,
              "column": 65
          },
          {
              "line": 88,
              "column": 42
          },
          {
              "line": 98,
              "column": 21
          },
          {
              "line": 115,
              "column": 16
          }
      ],
      "old_name": "result",
      "new_name": "config",
      "ctx": {
          "symbolName": "result",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Configuration",
          "scopeHint": "in getHadoopConfiguration(...)",
          "filePath": "HadoopUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@SuppressWarnings(\"deprecation\")\n    public static Configuration getHadoopConfiguration(\n            org.apache.flink.configuration.Configuration flinkConfiguration) {\n\n        // Instantiate an HdfsConfiguration to load the hdfs-site.xml and hdfs-default.xml\n        // from the classpath\n\n        Configuration result = new HdfsConfiguration();\n        boolean foundHadoopConfiguration = false;\n\n        // We need to load both core-site.xml and hdfs-site.xml to determine the default fs path and\n        // the hdfs configuration.\n        // The properties of a newly added resource will override the ones in previous resources, so\n        // a configuration\n        // file with higher priority should be added later.\n\n        // Approach 1: HADOOP_HOME environment variables\n        String[] possibleHadoopConfPaths = new String[2];\n\n        final String hadoopHome = System.getenv(\"HADOOP_HOME\");\n        if (hadoopHome != null) {\n            LOG.debug(\"Searching Hadoop configuration files in HADOOP_HOME: {}\", hadoopHome);\n            possibleHadoopConfPaths[0] = hadoopHome + \"/conf\";\n            possibleHadoopConfPaths[1] = hadoopHome + \"/etc/hadoop\"; // hadoop 2.2\n        }\n\n        for (String possibleHadoopConfPath : possibleHadoopConfPaths) {\n            if (possibleHadoopConfPath != null) {\n                foundHadoopConfiguration = addHadoopConfIfFound(result, possibleHadoopConfPath);\n            }\n        }\n\n        // Approach 2: HADOOP_CONF_DIR environment variable\n        String hadoopConfDir = System.getenv(\"HADOOP_CONF_DIR\");\n        if (hadoopConfDir != null) {\n            LOG.debug(\"Searching Hadoop configuration files in HADOOP_CONF_DIR: {}\", hadoopConfDir);\n            foundHadoopConfiguration =\n                    addHadoopConfIfFound(result, hadoopConfDir) || foundHadoopConfiguration;\n        }\n\n        // Approach 3: Flink configuration\n        // add all configuration key with prefix 'flink.hadoop.' in flink conf to hadoop conf\n        for (String key : flinkConfiguration.keySet()) {\n            for (String prefix : FLINK_CONFIG_PREFIXES) {\n                if (key.startsWith(prefix)) {\n                    String newKey = key.substring(prefix.length());\n                    String value = flinkConfiguration.getString(key, null);\n                    result.set(newKey, value);\n                    LOG.debug(\n                            \"Adding Flink config entry for {} as {}={} to Hadoop config\",\n                            key,\n                            newKey,\n                            value);\n                    foundHadoopConfiguration = true;\n                }\n            }\n        }\n\n        if (!foundHadoopConfiguration) {\n            LOG.warn(\n                    \"Could not find Hadoop configuration via any of the supported methods \"\n                            + \"(Flink configuration, environment variables).\");\n        }\n\n        return result;\n    }",
          "conflictNames": [
              "flinkConfiguration",
              "foundHadoopConfiguration",
              "possibleHadoopConfPaths",
              "hadoopHome",
              "hadoopConfDir",
              "newKey",
              "value"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/963333795ae5bf0b6d6c8b1fa793be742a7c1af3^1/flink-runtime/src/test/java/org/apache/flink/runtime/metrics/groups/TaskIOMetricGroupTest.java",
      "locators": [
          {
              "line": 114,
              "column": 50
          },
          {
              "line": 117,
              "column": 20
          },
          {
              "line": 118,
              "column": 20
          },
          {
              "line": 119,
              "column": 20
          }
      ],
      "old_name": "numBytesProducedOfPartitions",
      "new_name": "resultPartitionBytes",
      "ctx": {
          "symbolName": "numBytesProducedOfPartitions",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Map<IntermediateResultPartitionID, Long>",
          "scopeHint": "in testNumBytesProducedOfPartitionsMetrics(...)",
          "filePath": "TaskIOMetricGroupTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testNumBytesProducedOfPartitionsMetrics() {\n        TaskMetricGroup task = UnregisteredMetricGroups.createUnregisteredTaskMetricGroup();\n        TaskIOMetricGroup taskIO = task.getIOMetricGroup();\n\n        Counter c1 = new SimpleCounter();\n        c1.inc(32L);\n        Counter c2 = new SimpleCounter();\n        c2.inc(64L);\n\n        IntermediateResultPartitionID resultPartitionID1 = new IntermediateResultPartitionID();\n        IntermediateResultPartitionID resultPartitionID2 = new IntermediateResultPartitionID();\n\n        taskIO.registerNumBytesProducedCounterForPartition(resultPartitionID1, c1);\n        taskIO.registerNumBytesProducedCounterForPartition(resultPartitionID2, c2);\n\n        Map<IntermediateResultPartitionID, Long> numBytesProducedOfPartitions =\n                taskIO.createSnapshot().getNumBytesProducedOfPartitions();\n\n        assertThat(numBytesProducedOfPartitions.size()).isEqualTo(2);\n        assertThat(numBytesProducedOfPartitions.get(resultPartitionID1).longValue()).isEqualTo(32L);\n        assertThat(numBytesProducedOfPartitions.get(resultPartitionID2).longValue()).isEqualTo(64L);\n    }",
          "conflictNames": [
              "task",
              "taskIO",
              "c1",
              "c2",
              "resultPartitionID1",
              "resultPartitionID2"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/972b1e6138eb3ec71544f6fa14b1d3f7545b4454^1/flink-metrics/flink-metrics-prometheus/src/main/java/org/apache/flink/metrics/prometheus/PrometheusPushGatewayReporterFactory.java",
      "locators": [
          {
              "line": 66,
              "column": 16
          },
          {
              "line": 69,
              "column": 49
          },
          {
              "line": 70,
              "column": 23
          }
      ],
      "old_name": "hostUrlConfig",
      "new_name": "hostUrl",
      "ctx": {
          "symbolName": "hostUrlConfig",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in createMetricReporter(...)",
          "filePath": "PrometheusPushGatewayReporterFactory.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public PrometheusPushGatewayReporter createMetricReporter(Properties properties) {\n        MetricConfig metricConfig = (MetricConfig) properties;\n        String host = metricConfig.getString(HOST.key(), HOST.defaultValue());\n        int port = metricConfig.getInteger(PORT.key(), PORT.defaultValue());\n        String configuredJobName = metricConfig.getString(JOB_NAME.key(), JOB_NAME.defaultValue());\n        boolean randomSuffix =\n                metricConfig.getBoolean(\n                        RANDOM_JOB_NAME_SUFFIX.key(), RANDOM_JOB_NAME_SUFFIX.defaultValue());\n        boolean deleteOnShutdown =\n                metricConfig.getBoolean(\n                        DELETE_ON_SHUTDOWN.key(), DELETE_ON_SHUTDOWN.defaultValue());\n        Map<String, String> groupingKey =\n                parseGroupingKey(\n                        metricConfig.getString(GROUPING_KEY.key(), GROUPING_KEY.defaultValue()));\n\n        String hostUrlConfig = metricConfig.getString(HOST_URL.key(), HOST_URL.defaultValue());\n\n        final String hostUrl;\n        if (!StringUtils.isNullOrWhitespaceOnly(hostUrlConfig)) {\n            hostUrl = hostUrlConfig;\n        } else {\n            if (StringUtils.isNullOrWhitespaceOnly(host) || port < 1) {\n                throw new IllegalArgumentException(\n                        \"Invalid host/port configuration. Host: \" + host + \" Port: \" + port);\n            } else {\n                hostUrl = \"http://\" + host + \":\" + port;\n            }\n        }\n\n        String jobName = configuredJobName;\n        if (randomSuffix) {\n            jobName = configuredJobName + new AbstractID();\n        }\n\n        LOG.info(\n                \"Configured PrometheusPushGatewayReporter with {hostUrl:{}, jobName:{}, randomJobNameSuffix:{}, deleteOnShutdown:{}, groupingKey:{}}\",\n                hostUrl,\n                jobName,\n                randomSuffix,\n                deleteOnShutdown,\n                groupingKey);\n\n        try {\n            return new PrometheusPushGatewayReporter(\n                    new URL(hostUrl), jobName, groupingKey, deleteOnShutdown);\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(e);\n        }\n    }",
          "conflictNames": [
              "properties",
              "metricConfig",
              "host",
              "port",
              "configuredJobName",
              "randomSuffix",
              "deleteOnShutdown",
              "groupingKey",
              "hostUrl",
              "jobName"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/98284c4d24e61d12425c8d5f5fa17cfe40e816f9^1/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/sink/SinkV2CommitterOperatorTest.java",
      "locators": [
          {
              "line": 83,
              "column": 25
          },
          {
              "line": 86,
              "column": 13
          },
          {
              "line": 88,
              "column": 13
          },
          {
              "line": 94,
              "column": 64
          },
          {
              "line": 107,
              "column": 20
          },
          {
              "line": 124,
              "column": 25
          },
          {
              "line": 127,
              "column": 49
          },
          {
              "line": 142,
              "column": 20
          },
          {
              "line": 149,
              "column": 20
          },
          {
              "line": 163,
              "column": 25
          },
          {
              "line": 166,
              "column": 49
          },
          {
              "line": 242,
              "column": 25
          },
          {
              "line": 247,
              "column": 33
          },
          {
              "line": 253,
              "column": 20
          },
          {
              "line": 307,
              "column": 31
          },
          {
              "line": 314,
              "column": 41
          }
      ],
      "old_name": "sinkAndCounters",
      "new_name": "restored",
      "ctx": {
          "symbolName": "sinkAndCounters",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SinkAndCounters",
          "scopeHint": "in testEmitCommittables(...)",
          "filePath": "SinkV2CommitterOperatorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@ParameterizedTest\n    @ValueSource(booleans = {true, false})\n    void testEmitCommittables(boolean withPostCommitTopology) throws Exception {\n        SinkAndCounters sinkAndCounters;\n        if (withPostCommitTopology) {\n            // Insert global committer to simulate post commit topology\n            sinkAndCounters = sinkWithPostCommit();\n        } else {\n            sinkAndCounters = sinkWithoutPostCommit();\n        }\n        final OneInputStreamOperatorTestHarness<\n                        CommittableMessage<String>, CommittableMessage<String>>\n                testHarness =\n                        new OneInputStreamOperatorTestHarness<>(\n                                new CommitterOperatorFactory<>(sinkAndCounters.sink, false, true));\n        testHarness.open();\n\n        final CommittableSummary<String> committableSummary =\n                new CommittableSummary<>(1, 1, 1L, 1, 0);\n        testHarness.processElement(new StreamRecord<>(committableSummary));\n        final CommittableWithLineage<String> committableWithLineage =\n                new CommittableWithLineage<>(\"1\", 1L, 1);\n        testHarness.processElement(new StreamRecord<>(committableWithLineage));\n\n        // Trigger commit\n        testHarness.notifyOfCompletedCheckpoint(1);\n\n        assertThat(sinkAndCounters.commitCounter.getAsInt()).isEqualTo(1);\n        if (withPostCommitTopology) {\n            ListAssert<CommittableMessage<String>> records =\n                    assertThat(testHarness.extractOutputValues()).hasSize(2);\n            records.element(0, as(committableSummary()))\n                    .hasFailedCommittables(committableSummary.getNumberOfFailedCommittables())\n                    .hasOverallCommittables(committableSummary.getNumberOfCommittables());\n            records.element(1, as(committableWithLineage()))\n                    .isEqualTo(committableWithLineage.withSubtaskId(0));\n        } else {\n            assertThat(testHarness.getOutput()).isEmpty();\n        }\n        testHarness.close();\n    }",
          "conflictNames": [
              "withPostCommitTopology",
              "testHarness",
              "committableSummary",
              "committableWithLineage",
              "records"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/98284c4d24e61d12425c8d5f5fa17cfe40e816f9^1/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/sink/SinkV2CommitterOperatorTest.java",
      "locators": [
          {
              "line": 245,
              "column": 17
          },
          {
              "line": 249,
              "column": 9
          },
          {
              "line": 250,
              "column": 9
          },
          {
              "line": 255,
              "column": 28
          },
          {
              "line": 272,
              "column": 9
          }
      ],
      "old_name": "restored",
      "new_name": "restoredHarness",
      "ctx": {
          "symbolName": "restored",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "OneInputStreamOperatorTestHarness<CommittableMessage<String>, CommittableMessage<String>>",
          "scopeHint": "in testStateRestore(...)",
          "filePath": "SinkV2CommitterOperatorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testStateRestore() throws Exception {\n\n        final int originalSubtaskId = 0;\n        final int subtaskIdAfterRecovery = 9;\n\n        final OneInputStreamOperatorTestHarness<\n                        CommittableMessage<String>, CommittableMessage<String>>\n                testHarness =\n                        createTestHarness(\n                                sinkWithPostCommitWithRetry().sink,\n                                false,\n                                true,\n                                1,\n                                1,\n                                originalSubtaskId);\n        testHarness.open();\n\n        // We cannot test a different checkpoint thant 0 because when using the OperatorTestHarness\n        // for recovery the lastCompleted checkpoint is always reset to 0.\n        long checkpointId = 0L;\n\n        final CommittableSummary<String> committableSummary =\n                new CommittableSummary<>(originalSubtaskId, 1, checkpointId, 1, 0);\n        testHarness.processElement(new StreamRecord<>(committableSummary));\n        final CommittableWithLineage<String> first =\n                new CommittableWithLineage<>(\"1\", checkpointId, originalSubtaskId);\n        testHarness.processElement(new StreamRecord<>(first));\n\n        // another committable for the same checkpointId but from different subtask.\n        final CommittableSummary<String> committableSummary2 =\n                new CommittableSummary<>(originalSubtaskId + 1, 1, checkpointId, 1, 0);\n        testHarness.processElement(new StreamRecord<>(committableSummary2));\n        final CommittableWithLineage<String> second =\n                new CommittableWithLineage<>(\"2\", checkpointId, originalSubtaskId + 1);\n        testHarness.processElement(new StreamRecord<>(second));\n\n        final OperatorSubtaskState snapshot = testHarness.snapshot(checkpointId, 2L);\n        assertThat(testHarness.getOutput()).isEmpty();\n        testHarness.close();\n\n        // create new testHarness but with different parallelism level and subtaskId that original\n        // one.\n        // we will make sure that new subtaskId was used during committable recovery.\n        SinkAndCounters sinkAndCounters = sinkWithPostCommit();\n        final OneInputStreamOperatorTestHarness<\n                        CommittableMessage<String>, CommittableMessage<String>>\n                restored =\n                        createTestHarness(\n                                sinkAndCounters.sink, false, true, 10, 10, subtaskIdAfterRecovery);\n\n        restored.initializeState(snapshot);\n        restored.open();\n\n        // Previous committables are immediately committed if possible\n        assertThat(sinkAndCounters.commitCounter.getAsInt()).isEqualTo(2);\n        ListAssert<CommittableMessage<String>> records =\n                assertThat(restored.extractOutputValues()).hasSize(3);\n        CommittableSummaryAssert<Object> objectCommittableSummaryAssert =\n                records.element(0, as(committableSummary()))\n                        .hasCheckpointId(checkpointId)\n                        .hasFailedCommittables(0)\n                        .hasSubtaskId(subtaskIdAfterRecovery);\n        objectCommittableSummaryAssert.hasOverallCommittables(2);\n\n        // Expect the same checkpointId that the original snapshot was made with.\n        records.element(1, as(committableWithLineage()))\n                .hasCheckpointId(checkpointId)\n                .hasSubtaskId(subtaskIdAfterRecovery)\n                .hasCommittable(first.getCommittable());\n        records.element(2, as(committableWithLineage()))\n                .hasCheckpointId(checkpointId)\n                .hasSubtaskId(subtaskIdAfterRecovery)\n                .hasCommittable(second.getCommittable());\n        restored.close();\n    }",
          "conflictNames": [
              "originalSubtaskId",
              "subtaskIdAfterRecovery",
              "testHarness",
              "checkpointId",
              "committableSummary",
              "first",
              "committableSummary2",
              "second",
              "snapshot",
              "sinkAndCounters",
              "records",
              "objectCommittableSummaryAssert"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/98284c4d24e61d12425c8d5f5fa17cfe40e816f9^1/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/sink/SinkV2SinkWriterOperatorTest.java",
      "locators": [
          {
              "line": 130,
              "column": 47
          },
          {
              "line": 131,
              "column": 79
          },
          {
              "line": 135,
              "column": 47
          },
          {
              "line": 139,
              "column": 36
          },
          {
              "line": 145,
              "column": 47
          },
          {
              "line": 148,
              "column": 36
          },
          {
              "line": 154,
              "column": 47
          },
          {
              "line": 160,
              "column": 36
          }
      ],
      "old_name": "sinkWriter",
      "new_name": "writer",
      "ctx": {
          "symbolName": "sinkWriter",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "DefaultSinkWriter<Integer>",
          "scopeHint": "in sinkWithoutCommitter(...)",
          "filePath": "SinkV2SinkWriterOperatorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "InspectableSink sinkWithoutCommitter() {\n        TestSinkV2.DefaultSinkWriter<Integer> sinkWriter = new TestSinkV2.DefaultSinkWriter<>();\n        return new InspectableSink(TestSinkV2.<Integer>newBuilder().setWriter(sinkWriter).build());\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/98284c4d24e61d12425c8d5f5fa17cfe40e816f9^1/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/sink/SinkV2SinkWriterOperatorTest.java",
      "locators": [
          {
              "line": 130,
              "column": 47
          },
          {
              "line": 131,
              "column": 79
          },
          {
              "line": 135,
              "column": 47
          },
          {
              "line": 139,
              "column": 36
          },
          {
              "line": 145,
              "column": 47
          },
          {
              "line": 148,
              "column": 36
          },
          {
              "line": 154,
              "column": 47
          },
          {
              "line": 160,
              "column": 36
          }
      ],
      "old_name": "sinkWriter",
      "new_name": "restoredWriter",
      "ctx": {
          "symbolName": "sinkWriter",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "DefaultSinkWriter<Integer>",
          "scopeHint": "in sinkWithoutCommitter(...)",
          "filePath": "SinkV2SinkWriterOperatorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "InspectableSink sinkWithoutCommitter() {\n        TestSinkV2.DefaultSinkWriter<Integer> sinkWriter = new TestSinkV2.DefaultSinkWriter<>();\n        return new InspectableSink(TestSinkV2.<Integer>newBuilder().setWriter(sinkWriter).build());\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/983764733ff43dacc084b841fc4956e09d8614a7^1/flink-python/src/main/java/org/apache/flink/table/runtime/typeutils/serializers/python/MapDataSerializer.java",
      "locators": [
          {
              "line": 244,
              "column": 31
          },
          {
              "line": 245,
              "column": 41
          },
          {
              "line": 246,
              "column": 50
          },
          {
              "line": 247,
              "column": 54
          },
          {
              "line": 248,
              "column": 56
          }
      ],
      "old_name": "newMapDataSerializer",
      "new_name": "oldBaseMapDataSerializerSnapshot",
      "ctx": {
          "symbolName": "newMapDataSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "MapDataSerializer",
          "scopeHint": "in resolveSchemaCompatibility(...)",
          "filePath": "MapDataSerializer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public TypeSerializerSchemaCompatibility<MapData> resolveSchemaCompatibility(\n                TypeSerializer<MapData> newSerializer) {\n            if (!(newSerializer instanceof MapDataSerializer)) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            }\n\n            MapDataSerializer newMapDataSerializer = (MapDataSerializer) newSerializer;\n            if (!previousKeyType.equals(newMapDataSerializer.keyType)\n                    || !previousValueType.equals(newMapDataSerializer.valueType)\n                    || !previousKeySerializer.equals(newMapDataSerializer.keyTypeSerializer)\n                    || !previousValueSerializer.equals(newMapDataSerializer.valueTypeSerializer)) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            } else {\n                return TypeSerializerSchemaCompatibility.compatibleAsIs();\n            }\n        }",
          "conflictNames": [
              "newSerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/983764733ff43dacc084b841fc4956e09d8614a7^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/typeutils/MapDataSerializer.java",
      "locators": [
          {
              "line": 324,
              "column": 31
          },
          {
              "line": 325,
              "column": 41
          },
          {
              "line": 326,
              "column": 50
          },
          {
              "line": 327,
              "column": 54
          },
          {
              "line": 328,
              "column": 56
          }
      ],
      "old_name": "newBaseMapSerializer",
      "new_name": "previousMapDataSerializerSnapshot",
      "ctx": {
          "symbolName": "newBaseMapSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "MapDataSerializer",
          "scopeHint": "in resolveSchemaCompatibility(...)",
          "filePath": "MapDataSerializer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public TypeSerializerSchemaCompatibility<MapData> resolveSchemaCompatibility(\n                TypeSerializer<MapData> newSerializer) {\n            if (!(newSerializer instanceof MapDataSerializer)) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            }\n\n            MapDataSerializer newBaseMapSerializer = (MapDataSerializer) newSerializer;\n            if (!previousKeyType.equals(newBaseMapSerializer.keyType)\n                    || !previousValueType.equals(newBaseMapSerializer.valueType)\n                    || !previousKeySerializer.equals(newBaseMapSerializer.keySerializer)\n                    || !previousValueSerializer.equals(newBaseMapSerializer.valueSerializer)) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            } else {\n                return TypeSerializerSchemaCompatibility.compatibleAsIs();\n            }\n        }",
          "conflictNames": [
              "newSerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/9878e561af30a90dd5491e9df9c99c8c17734a82^1/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/fs/ForStFlinkFileSystem.java",
      "locators": [
          {
              "line": 367,
              "column": 16
          },
          {
              "line": 368,
              "column": 54
          },
          {
              "line": 371,
              "column": 21
          },
          {
              "line": 373,
              "column": 51
          }
      ],
      "old_name": "remotePathStr",
      "new_name": "pathStr",
      "ctx": {
          "symbolName": "remotePathStr",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in tryBuildLocalPath(...)",
          "filePath": "ForStFlinkFileSystem.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private Tuple2<Boolean, Path> tryBuildLocalPath(Path path) {\n        String remotePathStr = path.toString();\n        if (localFileFilter.apply(path.getName()) && remotePathStr.startsWith(remoteBase)) {\n            return Tuple2.of(\n                    true,\n                    remotePathStr.length() == remoteBase.length()\n                            ? new Path(localBase)\n                            : new Path(localBase, remotePathStr.substring(remoteBase.length())));\n        }\n        return Tuple2.of(false, null);\n    }",
          "conflictNames": [
              "path"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/9878e561af30a90dd5491e9df9c99c8c17734a82^1/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/fs/ForStFlinkFileSystem.java",
      "locators": [
          {
              "line": 145,
              "column": 31
          },
          {
              "line": 146,
              "column": 13
          },
          {
              "line": 148,
              "column": 36
          },
          {
              "line": 160,
              "column": 31
          },
          {
              "line": 161,
              "column": 13
          },
          {
              "line": 163,
              "column": 40
          },
          {
              "line": 165,
              "column": 43
          },
          {
              "line": 181,
              "column": 31
          },
          {
              "line": 182,
              "column": 13
          },
          {
              "line": 184,
              "column": 40
          },
          {
              "line": 186,
              "column": 43
          },
          {
              "line": 206,
              "column": 31
          },
          {
              "line": 207,
              "column": 13
          },
          {
              "line": 208,
              "column": 29
          },
          {
              "line": 243,
              "column": 31
          },
          {
              "line": 244,
              "column": 13
          },
          {
              "line": 245,
              "column": 35
          },
          {
              "line": 252,
              "column": 31
          },
          {
              "line": 253,
              "column": 13
          },
          {
              "line": 254,
              "column": 42
          },
          {
              "line": 263,
              "column": 31
          },
          {
              "line": 264,
              "column": 13
          },
          {
              "line": 265,
              "column": 58
          },
          {
              "line": 274,
              "column": 31
          },
          {
              "line": 275,
              "column": 13
          },
          {
              "line": 276,
              "column": 45
          },
          {
              "line": 339,
              "column": 31
          },
          {
              "line": 340,
              "column": 13
          },
          {
              "line": 341,
              "column": 38
          },
          {
              "line": 353,
              "column": 31
          },
          {
              "line": 354,
              "column": 13
          },
          {
              "line": 355,
              "column": 39
          }
      ],
      "old_name": "localPathTuple",
      "new_name": "realPath",
      "ctx": {
          "symbolName": "localPathTuple",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Tuple2<Boolean, Path>",
          "scopeHint": "in create(...)",
          "filePath": "ForStFlinkFileSystem.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public ByteBufferWritableFSDataOutputStream create(Path path, WriteMode overwriteMode)\n            throws IOException {\n        Tuple2<Boolean, Path> localPathTuple = tryBuildLocalPath(path);\n        if (localPathTuple.f0) {\n            return new ByteBufferWritableFSDataOutputStream(\n                    localFS.create(localPathTuple.f1, overwriteMode));\n        }\n\n        FSDataOutputStream originalOutputStream = delegateFS.create(path, overwriteMode);\n        CachedDataOutputStream cachedDataOutputStream =\n                fileBasedCache == null ? null : fileBasedCache.create(originalOutputStream, path);\n        return new ByteBufferWritableFSDataOutputStream(\n                cachedDataOutputStream == null ? originalOutputStream : cachedDataOutputStream);\n    }",
          "conflictNames": [
              "path",
              "overwriteMode",
              "originalOutputStream",
              "cachedDataOutputStream"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/999b7a2f2e3a892ce16eaeaf38e99542b5a5c618^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/allocator/JobAllocationsInformation.java",
      "locators": [
          {
              "line": 66,
              "column": 18
          },
          {
              "line": 79,
              "column": 73
          }
      ],
      "old_name": "avgKgSize",
      "new_name": "stateSize",
      "ctx": {
          "symbolName": "avgKgSize",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "long",
          "scopeHint": "in calculateAllocations(...)",
          "filePath": "JobAllocationsInformation.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static Map<JobVertexID, List<VertexAllocationInformation>> calculateAllocations(\n            ExecutionGraph graph, StateSizeEstimates stateSizeEstimates) {\n        final Map<JobVertexID, List<VertexAllocationInformation>> allocations = new HashMap<>();\n        for (ExecutionJobVertex vertex : graph.getVerticesTopologically()) {\n            JobVertexID jobVertexId = vertex.getJobVertexId();\n            long avgKgSize = stateSizeEstimates.estimate(jobVertexId).orElse(0L);\n            for (ExecutionVertex executionVertex : vertex.getTaskVertices()) {\n                AllocationID allocationId =\n                        executionVertex.getCurrentExecutionAttempt().getAssignedAllocationID();\n                KeyGroupRange kgr =\n                        KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(\n                                vertex.getMaxParallelism(),\n                                vertex.getParallelism(),\n                                executionVertex.getParallelSubtaskIndex());\n                allocations\n                        .computeIfAbsent(jobVertexId, ignored -> new ArrayList<>())\n                        .add(\n                                new VertexAllocationInformation(\n                                        allocationId, jobVertexId, kgr, avgKgSize));\n            }\n        }\n        return allocations;\n    }",
          "conflictNames": [
              "graph",
              "stateSizeEstimates",
              "allocations",
              "jobVertexId",
              "allocationId",
              "kgr"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/99e459456b6714cb7febac603871b3f3773632aa^1/flink-libraries/flink-state-processing-api/src/main/java/org/apache/flink/state/api/input/SourceBuilder.java",
      "locators": [
          {
              "line": 27,
              "column": 39
          },
          {
              "line": 51,
              "column": 40
          },
          {
              "line": 54,
              "column": 19
          },
          {
              "line": 56,
              "column": 72
          }
      ],
      "old_name": "function",
      "new_name": "source",
      "ctx": {
          "symbolName": "function",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "InputFormatSourceFunction<OUT>",
          "scopeHint": "in fromFormat(...)",
          "filePath": "SourceBuilder.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Creates a new source that is bounded.\n     *\n     * @param env The stream execution environment.\n     * @param inputFormat The input source to consume.\n     * @param typeInfo The type of the output.\n     * @param <OUT> The output type.\n     * @return A source that is bounded.\n     */\n    public static <OUT> DataStreamSource<OUT> fromFormat(\n            StreamExecutionEnvironment env,\n            InputFormat<OUT, ?> inputFormat,\n            TypeInformation<OUT> typeInfo) {\n        InputFormatSourceFunction<OUT> function =\n                new InputFormatSourceFunction<>(inputFormat, typeInfo);\n\n        env.clean(function);\n\n        final StreamSource<OUT, ?> sourceOperator = new StreamSource<>(function);\n        return new DataStreamSource<>(\n                env, typeInfo, sourceOperator, true, SOURCE_NAME, Boundedness.BOUNDED);\n    }",
          "conflictNames": [
              "env",
              "inputFormat",
              "typeInfo",
              "sourceOperator"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/9b2b922a159dec767b7a76cf0aab35c3e12ef5c2^1/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBIncrementalCheckpointUtils.java",
      "locators": [
          {
              "line": 418,
              "column": 45
          },
          {
              "line": 431,
              "column": 46
          }
      ],
      "old_name": "stateMetaInfo",
      "new_name": "stateMetaInfoAsKey",
      "ctx": {
          "symbolName": "stateMetaInfo",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RegisteredStateMetaInfoBase",
          "scopeHint": "in exportColumnFamilies(...)",
          "filePath": "RocksDBIncrementalCheckpointUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Exports the data of the given column families in the given DB.\n     *\n     * @param db the DB to export from.\n     * @param columnFamilyHandles the column families to export.\n     * @param registeredStateMetaInfoBases meta information about the registered states in the DB.\n     * @param exportBasePath the path to which the export files go.\n     * @param resultOutput output parameter for the metadata of the export.\n     * @throws RocksDBException on problems inside RocksDB.\n     */\n    public static void exportColumnFamilies(\n            RocksDB db,\n            List<ColumnFamilyHandle> columnFamilyHandles,\n            List<RegisteredStateMetaInfoBase> registeredStateMetaInfoBases,\n            Path exportBasePath,\n            Map<RegisteredStateMetaInfoBase, List<ExportImportFilesMetaData>> resultOutput)\n            throws RocksDBException {\n\n        Preconditions.checkArgument(\n                columnFamilyHandles.size() == registeredStateMetaInfoBases.size(),\n                \"Lists are aligned by index and must be of the same size!\");\n\n        try (final Checkpoint checkpoint = Checkpoint.create(db)) {\n            for (int i = 0; i < columnFamilyHandles.size(); i++) {\n                RegisteredStateMetaInfoBase stateMetaInfo = registeredStateMetaInfoBases.get(i);\n\n                Path subPath = exportBasePath.resolve(UUID.randomUUID().toString());\n                ExportImportFilesMetaData exportedColumnFamilyMetaData =\n                        checkpoint.exportColumnFamily(\n                                columnFamilyHandles.get(i), subPath.toString());\n\n                File[] exportedSstFiles =\n                        subPath.toFile()\n                                .listFiles((file, name) -> name.toLowerCase().endsWith(\".sst\"));\n\n                if (exportedSstFiles != null && exportedSstFiles.length > 0) {\n                    resultOutput\n                            .computeIfAbsent(stateMetaInfo, (key) -> new ArrayList<>())\n                            .add(exportedColumnFamilyMetaData);\n                } else {\n                    // Close unused empty export result\n                    IOUtils.closeQuietly(exportedColumnFamilyMetaData);\n                }\n            }\n        }\n    }",
          "conflictNames": [
              "db",
              "columnFamilyHandles",
              "registeredStateMetaInfoBases",
              "exportBasePath",
              "resultOutput",
              "checkpoint",
              "i",
              "subPath",
              "exportedColumnFamilyMetaData",
              "exportedSstFiles"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/9b3c5ef4a42fc1249affd9a3a86306369978d5cd^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/FlinkFilterCalcMergeRule.java",
      "locators": [
          {
              "line": 37,
              "column": 4
          },
          {
              "line": 49,
              "column": 23
          },
          {
              "line": 57,
              "column": 9
          }
      ],
      "old_name": "filter",
      "new_name": "topFilter",
      "ctx": {
          "symbolName": "filter",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "LogicalFilter",
          "scopeHint": "in onMatch(...)",
          "filePath": "FlinkFilterCalcMergeRule.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void onMatch(RelOptRuleCall call) {\n        LogicalFilter filter = call.rel(0);\n        LogicalCalc calc = call.rel(1);\n\n        List<RexNode> expandProjects =\n                calc.getProgram().getProjectList().stream()\n                        .map(p -> calc.getProgram().expandLocalRef(p))\n                        .collect(Collectors.toList());\n        InputRefVisitor inputRefVisitor = new InputRefVisitor();\n        filter.getCondition().accept(inputRefVisitor);\n        boolean existNonDeterministicRef =\n                Arrays.stream(inputRefVisitor.getFields())\n                        .anyMatch(i -> !RexUtil.isDeterministic(expandProjects.get(i)));\n\n        if (!existNonDeterministicRef) {\n            super.onMatch(call);\n        }\n    }",
          "conflictNames": [
              "call",
              "calc",
              "expandProjects",
              "inputRefVisitor",
              "existNonDeterministicRef"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/9b3c5ef4a42fc1249affd9a3a86306369978d5cd^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/FlinkFilterCalcMergeRule.java",
      "locators": [
          {
              "line": 23,
              "column": 19
          },
          {
              "line": 24,
              "column": 19
          },
          {
              "line": 25,
              "column": 19
          },
          {
              "line": 26,
              "column": 19
          },
          {
              "line": 27,
              "column": 19
          },
          {
              "line": 28,
              "column": 19
          },
          {
              "line": 29,
              "column": 19
          },
          {
              "line": 36,
              "column": 12
          },
          {
              "line": 50,
              "column": 21
          },
          {
              "line": 53,
              "column": 17
          },
          {
              "line": 54,
              "column": 35
          }
      ],
      "old_name": "calc",
      "new_name": "bottomCalc",
      "ctx": {
          "symbolName": "calc",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "LogicalCalc",
          "scopeHint": "in onMatch(...)",
          "filePath": "FlinkFilterCalcMergeRule.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void onMatch(RelOptRuleCall call) {\n        LogicalFilter filter = call.rel(0);\n        LogicalCalc calc = call.rel(1);\n\n        List<RexNode> expandProjects =\n                calc.getProgram().getProjectList().stream()\n                        .map(p -> calc.getProgram().expandLocalRef(p))\n                        .collect(Collectors.toList());\n        InputRefVisitor inputRefVisitor = new InputRefVisitor();\n        filter.getCondition().accept(inputRefVisitor);\n        boolean existNonDeterministicRef =\n                Arrays.stream(inputRefVisitor.getFields())\n                        .anyMatch(i -> !RexUtil.isDeterministic(expandProjects.get(i)));\n\n        if (!existNonDeterministicRef) {\n            super.onMatch(call);\n        }\n    }",
          "conflictNames": [
              "call",
              "filter",
              "expandProjects",
              "inputRefVisitor",
              "existNonDeterministicRef"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/9b51711d00a2e1bd93f5a474b9c99b542aaf27cf^1/flink-table/flink-sql-gateway/src/main/java/org/apache/flink/table/gateway/service/materializedtable/MaterializedTableManager.java",
      "locators": [
          {
              "line": 336,
              "column": 34
          },
          {
              "line": 339,
              "column": 40
          },
          {
              "line": 388,
              "column": 38
          },
          {
              "line": 390,
              "column": 65
          },
          {
              "line": 397,
              "column": 21
          }
      ],
      "old_name": "continuousRefreshHandler",
      "new_name": "refreshHandler",
      "ctx": {
          "symbolName": "continuousRefreshHandler",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ContinuousRefreshHandler",
          "scopeHint": "in callAlterMaterializedTableResume(...)",
          "filePath": "MaterializedTableManager.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private ResultFetcher callAlterMaterializedTableResume(\n            OperationExecutor operationExecutor,\n            OperationHandle handle,\n            AlterMaterializedTableResumeOperation op) {\n        ObjectIdentifier tableIdentifier = op.getTableIdentifier();\n        CatalogMaterializedTable catalogMaterializedTable =\n                getCatalogMaterializedTable(operationExecutor, tableIdentifier);\n\n        if (CatalogMaterializedTable.RefreshMode.CONTINUOUS\n                != catalogMaterializedTable.getRefreshMode()) {\n            throw new SqlExecutionException(\n                    \"Only support resume continuous refresh job currently.\");\n        }\n\n        ContinuousRefreshHandler continuousRefreshHandler =\n                deserializeContinuousHandler(\n                        catalogMaterializedTable.getSerializedRefreshHandler());\n        Optional<String> restorePath = continuousRefreshHandler.getRestorePath();\n        executeContinuousRefreshJob(\n                operationExecutor,\n                handle,\n                catalogMaterializedTable,\n                tableIdentifier,\n                op.getDynamicOptions(),\n                restorePath);\n\n        return ResultFetcher.fromTableResult(handle, TABLE_RESULT_OK, false);\n    }",
          "conflictNames": [
              "operationExecutor",
              "handle",
              "op",
              "tableIdentifier",
              "catalogMaterializedTable",
              "restorePath"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/9ba5afc26057672fd0491bb3f3e50a55ce1c32b1^1/flink-formats/flink-orc/src/main/java/org/apache/flink/orc/writer/PhysicalWriterImpl.java",
      "locators": [
          {
              "line": 445,
              "column": 14
          },
          {
              "line": 448,
              "column": 57
          },
          {
              "line": 460,
              "column": 14
          },
          {
              "line": 462,
              "column": 44
          }
      ],
      "old_name": "startPosn",
      "new_name": "startPosition",
      "ctx": {
          "symbolName": "startPosn",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "long",
          "scopeHint": "in writeFileFooter(...)",
          "filePath": "PhysicalWriterImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void writeFileFooter(OrcProto.Footer.Builder builder) throws IOException {\n        if (!variants.isEmpty()) {\n            OrcProto.Encryption.Builder encryption = builder.getEncryptionBuilder();\n            setEncryptionStatistics(encryption, stripeNumber, variants.values());\n        }\n        addUnencryptedStatistics(builder, unencrypted.fileStats);\n        long bodyLength = rawWriter.getPos() - metadataLength - stripeStatisticsLength;\n        builder.setContentLength(bodyLength);\n        builder.setHeaderLength(headerLength);\n        long startPosn = rawWriter.getPos();\n        OrcProto.Footer footer = builder.build();\n        writeFileFooter(footer);\n        this.footerLength = (int) (rawWriter.getPos() - startPosn);\n    }",
          "conflictNames": [
              "builder",
              "encryption",
              "bodyLength",
              "footer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/9ba5afc26057672fd0491bb3f3e50a55ce1c32b1^1/flink-formats/flink-orc/src/main/java/org/apache/flink/orc/writer/PhysicalWriterImpl.java",
      "locators": [
          {
              "line": 179,
              "column": 28
          },
          {
              "line": 180,
              "column": 31
          },
          {
              "line": 181,
              "column": 20
          },
          {
              "line": 193,
              "column": 35
          },
          {
              "line": 206,
              "column": 21
          },
          {
              "line": 209,
              "column": 20
          },
          {
              "line": 234,
              "column": 18
          },
          {
              "line": 239,
              "column": 25
          },
          {
              "line": 243,
              "column": 20
          },
          {
              "line": 558,
              "column": 28
          },
          {
              "line": 560,
              "column": 21
          },
          {
              "line": 560,
              "column": 30
          },
          {
              "line": 563,
              "column": 24
          },
          {
              "line": 575,
              "column": 18
          },
          {
              "line": 577,
              "column": 17
          },
          {
              "line": 579,
              "column": 20
          },
          {
              "line": 672,
              "column": 24
          },
          {
              "line": 673,
              "column": 13
          },
          {
              "line": 674,
              "column": 13
          },
          {
              "line": 675,
              "column": 39
          },
          {
              "line": 677,
              "column": 16
          }
      ],
      "old_name": "result",
      "new_name": "size",
      "ctx": {
          "symbolName": "result",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "BufferedStream",
          "scopeHint": "in createStream(...)",
          "filePath": "PhysicalWriterImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public BufferedStream createStream(StreamName name) {\n            BufferedStream result = new BufferedStream();\n            streams.put(name, result);\n            return result;\n        }",
          "conflictNames": [
              "name"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/9ba5afc26057672fd0491bb3f3e50a55ce1c32b1^1/flink-formats/flink-orc/src/main/java/org/apache/flink/orc/writer/PhysicalWriterImpl.java",
      "locators": [
          {
              "line": 194,
              "column": 73
          },
          {
              "line": 219,
              "column": 73
          },
          {
              "line": 236,
              "column": 60
          },
          {
              "line": 236,
              "column": 76
          },
          {
              "line": 237,
              "column": 39
          },
          {
              "line": 239,
              "column": 35
          }
      ],
      "old_name": "entry",
      "new_name": "pair",
      "ctx": {
          "symbolName": "entry",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Entry<StreamName, BufferedStream>",
          "scopeHint": "in getFileBytes(...)",
          "filePath": "PhysicalWriterImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "am column a column id\n         * @return the total number of bytes\n         */\n        public long getFileBytes(int column) {\n            long result = 0;\n            if (column >= rootColumn && column <= lastColumn) {\n                for (Map.Entry<StreamName, BufferedStream> entry : streams.entrySet()) {\n                    StreamName name = entry.getKey();\n                    if (name.getColumn() == column && name.getArea() != StreamName.Area.INDEX) {\n                        result += entry.getValue().getOutputSize",
          "conflictNames": [
              "column",
              "result",
              "name"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/9c3b18b0320c7260f1fe6e9dbbf489423a729cb4^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueueTest.java",
      "locators": [
          {
              "line": 155,
              "column": 33
          },
          {
              "line": 164,
              "column": 40
          },
          {
              "line": 249,
              "column": 33
          },
          {
              "line": 258,
              "column": 40
          },
          {
              "line": 300,
              "column": 33
          },
          {
              "line": 310,
              "column": 40
          },
          {
              "line": 378,
              "column": 33
          },
          {
              "line": 387,
              "column": 40
          },
          {
              "line": 416,
              "column": 33
          },
          {
              "line": 425,
              "column": 40
          },
          {
              "line": 497,
              "column": 33
          },
          {
              "line": 506,
              "column": 40
          }
      ],
      "old_name": "partitionProvider",
      "new_name": "partition",
      "ctx": {
          "symbolName": "partitionProvider",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ResultPartitionProvider",
          "scopeHint": "in testBufferWriting(...)",
          "filePath": "PartitionRequestQueueTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void testBufferWriting(ResultSubpartitionView view) throws IOException {\n        // setup\n        ResultPartitionProvider partitionProvider =\n                (partitionId, index, availabilityListener) -> view;\n\n        final InputChannelID receiverId = new InputChannelID();\n        final PartitionRequestQueue queue = new PartitionRequestQueue();\n        final CreditBasedSequenceNumberingViewReader reader =\n                new CreditBasedSequenceNumberingViewReader(receiverId, Integer.MAX_VALUE, queue);\n        final EmbeddedChannel channel = new EmbeddedChannel(queue);\n\n        reader.requestSubpartitionView(partitionProvider, new ResultPartitionID(), 0);\n\n        // notify about buffer availability and encode one buffer\n        reader.notifyDataAvailable();\n\n        channel.runPendingTasks();\n\n        Object read = channel.readOutbound();\n        assertNotNull(read);\n        if (read instanceof NettyMessage.ErrorResponse) {\n            ((NettyMessage.ErrorResponse) read).cause.printStackTrace();\n        }\n        assertThat(read, instanceOf(NettyMessage.BufferResponse.class));\n        read = channel.readOutbound();\n        assertNull(read);\n    }",
          "conflictNames": [
              "view",
              "receiverId",
              "queue",
              "reader",
              "channel",
              "read"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/9c3b18b0320c7260f1fe6e9dbbf489423a729cb4^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/PartitionRequestServerHandlerTest.java",
      "locators": [
          {
              "line": 66,
              "column": 33
          },
          {
              "line": 69,
              "column": 51
          },
          {
              "line": 81,
              "column": 20
          },
          {
              "line": 112,
              "column": 18
          }
      ],
      "old_name": "partitionId",
      "new_name": "resultPartitionId",
      "ctx": {
          "symbolName": "partitionId",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ResultPartitionID",
          "scopeHint": "in testResponsePartitionNotFoundException(...)",
          "filePath": "PartitionRequestServerHandlerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Tests that {@link PartitionRequestServerHandler} responds {@link ErrorResponse} with wrapped\n     * {@link PartitionNotFoundException} after receiving invalid {@link PartitionRequest}.\n     */\n    @Test\n    public void testResponsePartitionNotFoundException() {\n        final PartitionRequestServerHandler serverHandler =\n                new PartitionRequestServerHandler(\n                        new ResultPartitionManager(),\n                        new TaskEventDispatcher(),\n                        new PartitionRequestQueue());\n        final EmbeddedChannel channel = new EmbeddedChannel(serverHandler);\n        final ResultPartitionID partitionId = new ResultPartitionID();\n\n        // Write the message of partition request to server\n        channel.writeInbound(new PartitionRequest(partitionId, 0, new InputChannelID(), 2));\n        channel.runPendingTasks();\n\n        // Read the response message after handling partition request\n        final Object msg = channel.readOutbound();\n        assertThat(msg, instanceOf(ErrorResponse.class));\n\n        final ErrorResponse err = (ErrorResponse) msg;\n        assertThat(err.cause, instanceOf(PartitionNotFoundException.class));\n\n        final ResultPartitionID actualPartitionId =\n                ((PartitionNotFoundException) err.cause).getPartitionId();\n        assertThat(partitionId, is(actualPartitionId));\n    }",
          "conflictNames": [
              "serverHandler",
              "channel",
              "msg",
              "err",
              "actualPartitionId"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/9c3b18b0320c7260f1fe6e9dbbf489423a729cb4^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/PartitionRequestServerHandlerTest.java",
      "locators": [
          {
              "line": 73,
              "column": 22
          },
          {
              "line": 74,
              "column": 20
          },
          {
              "line": 76,
              "column": 51
          }
      ],
      "old_name": "msg",
      "new_name": "read",
      "ctx": {
          "symbolName": "msg",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Object",
          "scopeHint": "in testResponsePartitionNotFoundException(...)",
          "filePath": "PartitionRequestServerHandlerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Tests that {@link PartitionRequestServerHandler} responds {@link ErrorResponse} with wrapped\n     * {@link PartitionNotFoundException} after receiving invalid {@link PartitionRequest}.\n     */\n    @Test\n    public void testResponsePartitionNotFoundException() {\n        final PartitionRequestServerHandler serverHandler =\n                new PartitionRequestServerHandler(\n                        new ResultPartitionManager(),\n                        new TaskEventDispatcher(),\n                        new PartitionRequestQueue());\n        final EmbeddedChannel channel = new EmbeddedChannel(serverHandler);\n        final ResultPartitionID partitionId = new ResultPartitionID();\n\n        // Write the message of partition request to server\n        channel.writeInbound(new PartitionRequest(partitionId, 0, new InputChannelID(), 2));\n        channel.runPendingTasks();\n\n        // Read the response message after handling partition request\n        final Object msg = channel.readOutbound();\n        assertThat(msg, instanceOf(ErrorResponse.class));\n\n        final ErrorResponse err = (ErrorResponse) msg;\n        assertThat(err.cause, instanceOf(PartitionNotFoundException.class));\n\n        final ResultPartitionID actualPartitionId =\n                ((PartitionNotFoundException) err.cause).getPartitionId();\n        assertThat(partitionId, is(actualPartitionId));\n    }",
          "conflictNames": [
              "serverHandler",
              "channel",
              "partitionId",
              "err",
              "actualPartitionId"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/9d0f9156f60329c19e5814e93505e4907adf1c92^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/operators/sink/ConstraintEnforcer.java",
      "locators": [
          {
              "line": 50,
              "column": 22
          },
          {
              "line": 50,
              "column": 46
          },
          {
              "line": 51,
              "column": 10
          },
          {
              "line": 118,
              "column": 58
          },
          {
              "line": 119,
              "column": 25
          },
          {
              "line": 141,
              "column": 41
          },
          {
              "line": 197,
              "column": 51
          },
          {
              "line": 212,
              "column": 76
          },
          {
              "line": 219,
              "column": 78
          },
          {
              "line": 285,
              "column": 46
          },
          {
              "line": 287,
              "column": 23
          },
          {
              "line": 291,
              "column": 63
          },
          {
              "line": 293,
              "column": 82
          },
          {
              "line": 296,
              "column": 68
          },
          {
              "line": 297,
              "column": 60
          },
          {
              "line": 302,
              "column": 42
          },
          {
              "line": 304,
              "column": 82
          },
          {
              "line": 306,
              "column": 75
          },
          {
              "line": 322,
              "column": 48
          },
          {
              "line": 324,
              "column": 23
          },
          {
              "line": 326,
              "column": 49
          },
          {
              "line": 328,
              "column": 61
          },
          {
              "line": 329,
              "column": 46
          },
          {
              "line": 330,
              "column": 33
          },
          {
              "line": 330,
              "column": 90
          },
          {
              "line": 332,
              "column": 82
          },
          {
              "line": 334,
              "column": 77
          },
          {
              "line": 348,
              "column": 31
          },
          {
              "line": 351,
              "column": 58
          },
          {
              "line": 353,
              "column": 18
          },
          {
              "line": 353,
              "column": 27
          }
      ],
      "old_name": "length",
      "new_name": "expectedLength",
      "ctx": {
          "symbolName": "length",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in processCharConstraint(...)",
          "filePath": "ConstraintEnforcer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private RowData processCharConstraint(RowData rowData) {\n        if (typeLengthEnforcer == null\n                || typeLengthEnforcer == TypeLengthEnforcer.IGNORE\n                || charFieldIndices == null) {\n            return rowData;\n        }\n\n        UpdatableRowData updatedRowData = null;\n\n        for (int i = 0; i < charFieldIndices.length; i++) {\n            final int fieldIdx = charFieldIndices[i];\n            final int length = charFieldLengths[i];\n            final BinaryStringData stringData = (BinaryStringData) rowData.getString(fieldIdx);\n            final int sourceStrLength = stringData.numChars();\n\n            if (charFieldCouldPad.get(i) && sourceStrLength < length) {\n                if (updatedRowData == null) {\n                    updatedRowData = new UpdatableRowData(rowData, allFieldNames.length);\n                }\n                final int srcSizeInBytes = stringData.getSizeInBytes();\n                final byte[] newString = new byte[srcSizeInBytes + length - sourceStrLength];\n                for (int j = srcSizeInBytes; j < newString.length; j++) {\n                    newString[j] = (byte) 32; // space\n                }\n                SegmentsUtil.copyToBytes(stringData.getSegments(), 0, newString, 0, srcSizeInBytes);\n                updatedRowData.setField(fieldIdx, StringData.fromBytes(newString));\n            } else if (sourceStrLength > length) {\n                if (updatedRowData == null) {\n                    updatedRowData = new UpdatableRowData(rowData, allFieldNames.length);\n                }\n                updatedRowData.setField(fieldIdx, stringData.substring(0, length));\n            }\n        }\n\n        return updatedRowData != null ? updatedRowData : rowData;\n    }",
          "conflictNames": [
              "rowData",
              "updatedRowData",
              "i",
              "fieldIdx",
              "stringData",
              "sourceStrLength",
              "srcSizeInBytes",
              "newString",
              "j"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/9d0f9156f60329c19e5814e93505e4907adf1c92^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/operators/sink/ConstraintEnforcer.java",
      "locators": [
          {
              "line": 326,
              "column": 23
          },
          {
              "line": 330,
              "column": 18
          },
          {
              "line": 330,
              "column": 75
          }
      ],
      "old_name": "sourceLength",
      "new_name": "actualLength",
      "ctx": {
          "symbolName": "sourceLength",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in processBinaryConstraint(...)",
          "filePath": "ConstraintEnforcer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private RowData processBinaryConstraint(RowData rowData) {\n        if (typeLengthEnforcer == null\n                || typeLengthEnforcer == TypeLengthEnforcer.IGNORE\n                || binaryFieldIndices == null) {\n            return rowData;\n        }\n\n        UpdatableRowData updatedRowData = null;\n\n        for (int i = 0; i < binaryFieldLengths.length; i++) {\n            final int fieldIdx = binaryFieldIndices[i];\n            final int length = binaryFieldLengths[i];\n            final byte[] binaryData = rowData.getBinary(fieldIdx);\n            final int sourceLength = binaryData.length;\n\n            // Trimming takes places because of the shorter length used in `Arrays.copyOf` and\n            // padding because of the longer length, as implicitly the trailing bytes are 0.\n            if ((sourceLength > length) || (binaryFieldCouldPad.get(i) && sourceLength < length)) {\n                if (updatedRowData == null) {\n                    updatedRowData = new UpdatableRowData(rowData, allFieldNames.length);\n                }\n                updatedRowData.setField(fieldIdx, Arrays.copyOf(binaryData, length));\n            }\n        }\n\n        return updatedRowData != null ? updatedRowData : rowData;\n    }",
          "conflictNames": [
              "rowData",
              "updatedRowData",
              "i",
              "fieldIdx",
              "length",
              "binaryData"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/9da368d6cb163e0b90c5be680282885e47ac3647^1/flink-runtime/src/main/java/org/apache/flink/runtime/asyncprocessing/AsyncExecutionController.java",
      "locators": [
          {
              "line": 267,
              "column": 26
          },
          {
              "line": 269,
              "column": 13
          },
          {
              "line": 270,
              "column": 51
          }
      ],
      "old_name": "nextRecordCtx",
      "new_name": "nextRequest",
      "ctx": {
          "symbolName": "nextRecordCtx",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RecordContext<K>",
          "scopeHint": "in disposeContext(...)",
          "filePath": "AsyncExecutionController.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Dispose a context.\n     *\n     * @param toDispose the context to dispose.\n     */\n    void disposeContext(RecordContext<K> toDispose) {\n        epochManager.completeOneRecord(toDispose.getEpoch());\n        keyAccountingUnit.release(toDispose.getRecord(), toDispose.getKey());\n        inFlightRecordNum.decrementAndGet();\n        RecordContext<K> nextRecordCtx =\n                stateRequestsBuffer.tryActivateOneByKey(toDispose.getKey());\n        if (nextRecordCtx != null) {\n            Preconditions.checkState(tryOccupyKey(nextRecordCtx));\n        }\n    }",
          "conflictNames": [
              "toDispose"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/9e6a8b47cfcf583928b7811e47912af0e3299cd8^1/flink-python/src/main/java/org/apache/flink/table/runtime/typeutils/serializers/python/DecimalDataSerializer.java",
      "locators": [
          {
              "line": 181,
              "column": 35
          },
          {
              "line": 182,
              "column": 38
          },
          {
              "line": 183,
              "column": 41
          }
      ],
      "old_name": "newDecimalDataSerializer",
      "new_name": "oldDecimalSerializerSnapshot",
      "ctx": {
          "symbolName": "newDecimalDataSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "DecimalDataSerializer",
          "scopeHint": "in resolveSchemaCompatibility(...)",
          "filePath": "DecimalDataSerializer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public TypeSerializerSchemaCompatibility<DecimalData> resolveSchemaCompatibility(\n                TypeSerializer<DecimalData> newSerializer) {\n            if (!(newSerializer instanceof DecimalDataSerializer)) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            }\n\n            DecimalDataSerializer newDecimalDataSerializer = (DecimalDataSerializer) newSerializer;\n            if (previousPrecision != newDecimalDataSerializer.precision\n                    || previousScale != newDecimalDataSerializer.scale) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            } else {\n                return TypeSerializerSchemaCompatibility.compatibleAsIs();\n            }\n        }",
          "conflictNames": [
              "newSerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/9e6a8b47cfcf583928b7811e47912af0e3299cd8^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/typeutils/DecimalDataSerializer.java",
      "locators": [
          {
              "line": 191,
              "column": 35
          },
          {
              "line": 192,
              "column": 38
          },
          {
              "line": 193,
              "column": 41
          }
      ],
      "old_name": "newDecimalDataSerializer",
      "new_name": "oldDecimalSerializerSnapshot",
      "ctx": {
          "symbolName": "newDecimalDataSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "DecimalDataSerializer",
          "scopeHint": "in resolveSchemaCompatibility(...)",
          "filePath": "DecimalDataSerializer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public TypeSerializerSchemaCompatibility<DecimalData> resolveSchemaCompatibility(\n                TypeSerializer<DecimalData> newSerializer) {\n            if (!(newSerializer instanceof DecimalDataSerializer)) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            }\n\n            DecimalDataSerializer newDecimalDataSerializer = (DecimalDataSerializer) newSerializer;\n            if (previousPrecision != newDecimalDataSerializer.precision\n                    || previousScale != newDecimalDataSerializer.scale) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            } else {\n                return TypeSerializerSchemaCompatibility.compatibleAsIs();\n            }\n        }",
          "conflictNames": [
              "newSerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/9e6f8e8e127e8dd81ded4a2214fd710c8ff8180a^1/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGeneratorTest.java",
      "locators": [
          {
              "line": 708,
              "column": 22
          },
          {
              "line": 709,
              "column": 31
          },
          {
              "line": 709,
              "column": 61
          },
          {
              "line": 712,
              "column": 17
          },
          {
              "line": 1659,
              "column": 19
          },
          {
              "line": 1660,
              "column": 48
          },
          {
              "line": 1667,
              "column": 19
          },
          {
              "line": 1673,
              "column": 20
          },
          {
              "line": 1673,
              "column": 52
          },
          {
              "line": 1674,
              "column": 20
          },
          {
              "line": 1675,
              "column": 34
          }
      ],
      "old_name": "head",
      "new_name": "iterator",
      "ctx": {
          "symbolName": "head",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobVertex",
          "scopeHint": "in testNamingOfChainedMultipleInputs(...)",
          "filePath": "StreamingJobGraphGeneratorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testNamingOfChainedMultipleInputs() {\n        String[] sources = new String[] {\"source-1\", \"source-2\", \"source-3\"};\n        JobGraph graph = createGraphWithMultipleInputs(true, sources);\n        JobVertex head = graph.getVerticesSortedTopologicallyFromSources().iterator().next();\n        assertThat(sources).allMatch(source -> head.getOperatorPrettyName().contains(source));\n    }",
          "conflictNames": [
              "sources",
              "graph"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/9f20bc41db85b0928cd98c172a85cb43076e0ec0^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/exceptionhistory/RootExceptionHistoryEntryTest.java",
      "locators": [
          {
              "line": 86,
              "column": 20
          },
          {
              "line": 113,
              "column": 33
          },
          {
              "line": 124,
              "column": 20
          },
          {
              "line": 130,
              "column": 20
          },
          {
              "line": 156,
              "column": 25
          },
          {
              "line": 162,
              "column": 25
          }
      ],
      "old_name": "concurrentExceptionTimestamp",
      "new_name": "concurrentExceptionTimestamp0",
      "ctx": {
          "symbolName": "concurrentExceptionTimestamp",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "long",
          "scopeHint": "in testFromFailureHandlingResultSnapshot(...)",
          "filePath": "RootExceptionHistoryEntryTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testFromFailureHandlingResultSnapshot() throws ExecutionException, InterruptedException {\n        final Throwable rootException = new RuntimeException(\"Expected root failure\");\n        final ExecutionVertex rootExecutionVertex = extractExecutionVertex(0);\n        final long rootTimestamp = triggerFailure(rootExecutionVertex, rootException);\n        final CompletableFuture<Map<String, String>> rootFailureLabels =\n                CompletableFuture.completedFuture(Collections.singletonMap(\"key\", \"value\"));\n\n        final Throwable concurrentException = new IllegalStateException(\"Expected other failure\");\n        final ExecutionVertex concurrentlyFailedExecutionVertex = extractExecutionVertex(1);\n        final long concurrentExceptionTimestamp =\n                triggerFailure(concurrentlyFailedExecutionVertex, concurrentException);\n\n        final FailureHandlingResultSnapshot snapshot =\n                new FailureHandlingResultSnapshot(\n                        rootExecutionVertex.getCurrentExecutionAttempt(),\n                        rootException,\n                        rootTimestamp,\n                        rootFailureLabels,\n                        Collections.singleton(\n                                concurrentlyFailedExecutionVertex.getCurrentExecutionAttempt()));\n        final RootExceptionHistoryEntry actualEntry =\n                RootExceptionHistoryEntry.fromFailureHandlingResultSnapshot(snapshot);\n\n        assertThat(actualEntry)\n                .matches(\n                        ExceptionHistoryEntryMatcher.matchesFailure(\n                                rootException,\n                                rootTimestamp,\n                                rootFailureLabels.get(),\n                                rootExecutionVertex.getTaskNameWithSubtaskIndex(),\n                                rootExecutionVertex.getCurrentAssignedResourceLocation()));\n        assertThat(actualEntry.getConcurrentExceptions())\n                .hasSize(1)\n                .allMatch(\n                        ExceptionHistoryEntryMatcher.matchesFailure(\n                                concurrentException,\n                                concurrentExceptionTimestamp,\n                                concurrentlyFailedExecutionVertex.getTaskNameWithSubtaskIndex(),\n                                concurrentlyFailedExecutionVertex\n                                        .getCurrentAssignedResourceLocation()));\n    }",
          "conflictNames": [
              "rootException",
              "rootExecutionVertex",
              "rootTimestamp",
              "rootFailureLabels",
              "concurrentException",
              "concurrentlyFailedExecutionVertex",
              "snapshot",
              "actualEntry"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/9f20bc41db85b0928cd98c172a85cb43076e0ec0^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/exceptionhistory/RootExceptionHistoryEntryTest.java",
      "locators": [
          {
              "line": 85,
              "column": 31
          },
          {
              "line": 87,
              "column": 32
          },
          {
              "line": 96,
              "column": 33
          },
          {
              "line": 114,
              "column": 33
          },
          {
              "line": 115,
              "column": 33
          },
          {
              "line": 123,
              "column": 31
          },
          {
              "line": 125,
              "column": 32
          },
          {
              "line": 129,
              "column": 31
          },
          {
              "line": 131,
              "column": 32
          },
          {
              "line": 157,
              "column": 25
          },
          {
              "line": 158,
              "column": 25
          },
          {
              "line": 163,
              "column": 25
          },
          {
              "line": 164,
              "column": 25
          }
      ],
      "old_name": "concurrentlyFailedExecutionVertex",
      "new_name": "concurrentlyFailedExecutionVertex1",
      "ctx": {
          "symbolName": "concurrentlyFailedExecutionVertex",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ExecutionVertex",
          "scopeHint": "in testFromFailureHandlingResultSnapshot(...)",
          "filePath": "RootExceptionHistoryEntryTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testFromFailureHandlingResultSnapshot() throws ExecutionException, InterruptedException {\n        final Throwable rootException = new RuntimeException(\"Expected root failure\");\n        final ExecutionVertex rootExecutionVertex = extractExecutionVertex(0);\n        final long rootTimestamp = triggerFailure(rootExecutionVertex, rootException);\n        final CompletableFuture<Map<String, String>> rootFailureLabels =\n                CompletableFuture.completedFuture(Collections.singletonMap(\"key\", \"value\"));\n\n        final Throwable concurrentException = new IllegalStateException(\"Expected other failure\");\n        final ExecutionVertex concurrentlyFailedExecutionVertex = extractExecutionVertex(1);\n        final long concurrentExceptionTimestamp =\n                triggerFailure(concurrentlyFailedExecutionVertex, concurrentException);\n\n        final FailureHandlingResultSnapshot snapshot =\n                new FailureHandlingResultSnapshot(\n                        rootExecutionVertex.getCurrentExecutionAttempt(),\n                        rootException,\n                        rootTimestamp,\n                        rootFailureLabels,\n                        Collections.singleton(\n                                concurrentlyFailedExecutionVertex.getCurrentExecutionAttempt()));\n        final RootExceptionHistoryEntry actualEntry =\n                RootExceptionHistoryEntry.fromFailureHandlingResultSnapshot(snapshot);\n\n        assertThat(actualEntry)\n                .matches(\n                        ExceptionHistoryEntryMatcher.matchesFailure(\n                                rootException,\n                                rootTimestamp,\n                                rootFailureLabels.get(),\n                                rootExecutionVertex.getTaskNameWithSubtaskIndex(),\n                                rootExecutionVertex.getCurrentAssignedResourceLocation()));\n        assertThat(actualEntry.getConcurrentExceptions())\n                .hasSize(1)\n                .allMatch(\n                        ExceptionHistoryEntryMatcher.matchesFailure(\n                                concurrentException,\n                                concurrentExceptionTimestamp,\n                                concurrentlyFailedExecutionVertex.getTaskNameWithSubtaskIndex(),\n                                concurrentlyFailedExecutionVertex\n                                        .getCurrentAssignedResourceLocation()));\n    }",
          "conflictNames": [
              "rootException",
              "rootExecutionVertex",
              "rootTimestamp",
              "rootFailureLabels",
              "concurrentException",
              "concurrentExceptionTimestamp",
              "snapshot",
              "actualEntry"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/9f20bc41db85b0928cd98c172a85cb43076e0ec0^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/exceptionhistory/RootExceptionHistoryEntryTest.java",
      "locators": [
          {
              "line": 84,
              "column": 25
          },
          {
              "line": 86,
              "column": 20
          },
          {
              "line": 87,
              "column": 67
          },
          {
              "line": 112,
              "column": 33
          },
          {
              "line": 113,
              "column": 33
          },
          {
              "line": 121,
              "column": 25
          },
          {
              "line": 124,
              "column": 20
          },
          {
              "line": 125,
              "column": 68
          },
          {
              "line": 127,
              "column": 25
          },
          {
              "line": 130,
              "column": 20
          },
          {
              "line": 131,
              "column": 68
          },
          {
              "line": 155,
              "column": 25
          },
          {
              "line": 156,
              "column": 25
          },
          {
              "line": 161,
              "column": 25
          },
          {
              "line": 162,
              "column": 25
          }
      ],
      "old_name": "concurrentException",
      "new_name": "concurrentException1",
      "ctx": {
          "symbolName": "concurrentException",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Throwable",
          "scopeHint": "in testFromFailureHandlingResultSnapshot(...)",
          "filePath": "RootExceptionHistoryEntryTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testFromFailureHandlingResultSnapshot() throws ExecutionException, InterruptedException {\n        final Throwable rootException = new RuntimeException(\"Expected root failure\");\n        final ExecutionVertex rootExecutionVertex = extractExecutionVertex(0);\n        final long rootTimestamp = triggerFailure(rootExecutionVertex, rootException);\n        final CompletableFuture<Map<String, String>> rootFailureLabels =\n                CompletableFuture.completedFuture(Collections.singletonMap(\"key\", \"value\"));\n\n        final Throwable concurrentException = new IllegalStateException(\"Expected other failure\");\n        final ExecutionVertex concurrentlyFailedExecutionVertex = extractExecutionVertex(1);\n        final long concurrentExceptionTimestamp =\n                triggerFailure(concurrentlyFailedExecutionVertex, concurrentException);\n\n        final FailureHandlingResultSnapshot snapshot =\n                new FailureHandlingResultSnapshot(\n                        rootExecutionVertex.getCurrentExecutionAttempt(),\n                        rootException,\n                        rootTimestamp,\n                        rootFailureLabels,\n                        Collections.singleton(\n                                concurrentlyFailedExecutionVertex.getCurrentExecutionAttempt()));\n        final RootExceptionHistoryEntry actualEntry =\n                RootExceptionHistoryEntry.fromFailureHandlingResultSnapshot(snapshot);\n\n        assertThat(actualEntry)\n                .matches(\n                        ExceptionHistoryEntryMatcher.matchesFailure(\n                                rootException,\n                                rootTimestamp,\n                                rootFailureLabels.get(),\n                                rootExecutionVertex.getTaskNameWithSubtaskIndex(),\n                                rootExecutionVertex.getCurrentAssignedResourceLocation()));\n        assertThat(actualEntry.getConcurrentExceptions())\n                .hasSize(1)\n                .allMatch(\n                        ExceptionHistoryEntryMatcher.matchesFailure(\n                                concurrentException,\n                                concurrentExceptionTimestamp,\n                                concurrentlyFailedExecutionVertex.getTaskNameWithSubtaskIndex(),\n                                concurrentlyFailedExecutionVertex\n                                        .getCurrentAssignedResourceLocation()));\n    }",
          "conflictNames": [
              "rootException",
              "rootExecutionVertex",
              "rootTimestamp",
              "rootFailureLabels",
              "concurrentlyFailedExecutionVertex",
              "concurrentExceptionTimestamp",
              "snapshot",
              "actualEntry"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/a0aa4813b9fe3db37cabe38fa47f1d1096c879dc^1/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManagerTest.java",
      "locators": [
          {
              "line": 197,
              "column": 25
          },
          {
              "line": 203,
              "column": 54
          },
          {
              "line": 221,
              "column": 25
          },
          {
              "line": 233,
              "column": 33
          },
          {
              "line": 261,
              "column": 25
          },
          {
              "line": 272,
              "column": 63
          },
          {
              "line": 435,
              "column": 31
          },
          {
              "line": 457,
              "column": 73
          },
          {
              "line": 552,
              "column": 31
          },
          {
              "line": 559,
              "column": 54
          },
          {
              "line": 1193,
              "column": 25
          },
          {
              "line": 1207,
              "column": 33
          },
          {
              "line": 1588,
              "column": 66
          },
          {
              "line": 1589,
              "column": 53
          },
          {
              "line": 1594,
              "column": 29
          },
          {
              "line": 1600,
              "column": 65
          }
      ],
      "old_name": "resourceManagerActions",
      "new_name": "resourceAllocator",
      "ctx": {
          "symbolName": "resourceManagerActions",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ResourceActions",
          "scopeHint": "in testRequirementDeclarationWithoutFreeSlotsTriggersWorkerAllocation(...)",
          "filePath": "DeclarativeSlotManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Tests that a slot request with no free slots will trigger the resource allocation. */\n    @Test\n    void testRequirementDeclarationWithoutFreeSlotsTriggersWorkerAllocation() throws Exception {\n        final ResourceManagerId resourceManagerId = ResourceManagerId.generate();\n\n        final ResourceRequirements resourceRequirements = createResourceRequirementsForSingleSlot();\n\n        CompletableFuture<WorkerResourceSpec> allocateResourceFuture = new CompletableFuture<>();\n        ResourceActions resourceManagerActions =\n                new TestingResourceActionsBuilder()\n                        .setAllocateResourceConsumer(allocateResourceFuture::complete)\n                        .build();\n\n        try (SlotManager slotManager =\n                createSlotManager(resourceManagerId, resourceManagerActions)) {\n\n            slotManager.processResourceRequirements(resourceRequirements);\n\n            allocateResourceFuture.get();\n        }\n    }",
          "conflictNames": [
              "resourceManagerId",
              "resourceRequirements",
              "allocateResourceFuture",
              "slotManager"
          ]
      },
      "suggestions": [
          {
              "name": "resourceAllocator",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/a0aa4813b9fe3db37cabe38fa47f1d1096c879dc^1/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManagerTest.java",
      "locators": [
          {
              "line": 1076,
              "column": 38
          },
          {
              "line": 1087,
              "column": 55
          }
      ],
      "old_name": "testingResourceActions",
      "new_name": "testingResourceAllocator",
      "ctx": {
          "symbolName": "testingResourceActions",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestingResourceActions",
          "scopeHint": "in testRequestNewResources(...)",
          "filePath": "DeclarativeSlotManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Tests that we only request new resources/containers once we have assigned all pending task\n     * manager slots.\n     */\n    @Test\n    void testRequestNewResources() throws Exception {\n        final int numberSlots = 2;\n        final AtomicInteger resourceRequests = new AtomicInteger(0);\n        final TestingResourceActions testingResourceActions =\n                new TestingResourceActionsBuilder()\n                        .setAllocateResourceFunction(\n                                ignored -> {\n                                    resourceRequests.incrementAndGet();\n                                    return true;\n                                })\n                        .build();\n\n        try (final DeclarativeSlotManager slotManager =\n                createSlotManager(\n                        ResourceManagerId.generate(), testingResourceActions, numberSlots)) {\n\n            final JobID jobId = new JobID();\n\n            // the first 2 requirements should be fulfillable with the pending slots of the first\n            // allocation (2 slots per worker)\n            slotManager.processResourceRequirements(createResourceRequirements(jobId, 1));\n            assertThat(resourceRequests.get()).isEqualTo(1);\n\n            slotManager.processResourceRequirements(createResourceRequirements(jobId, 2));\n            assertThat(resourceRequests.get()).isEqualTo(1);\n\n            slotManager.processResourceRequirements(createResourceRequirements(jobId, 3));\n            assertThat(resourceRequests.get()).isEqualTo(2);\n        }\n    }",
          "conflictNames": [
              "numberSlots",
              "resourceRequests",
              "slotManager",
              "jobId"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/a0aa4813b9fe3db37cabe38fa47f1d1096c879dc^1/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/TaskExecutorManagerTest.java",
      "locators": [
          {
              "line": 146,
              "column": 31
          },
          {
              "line": 157,
              "column": 45
          },
          {
              "line": 251,
              "column": 25
          },
          {
              "line": 265,
              "column": 45
          },
          {
              "line": 284,
              "column": 25
          },
          {
              "line": 297,
              "column": 45
          },
          {
              "line": 320,
              "column": 25
          },
          {
              "line": 330,
              "column": 45
          }
      ],
      "old_name": "resourceActions",
      "new_name": "resourceAllocator",
      "ctx": {
          "symbolName": "resourceActions",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ResourceActions",
          "scopeHint": "in testTaskManagerTimeoutDoesNotRemoveSlots(...)",
          "filePath": "TaskExecutorManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Tests that a task manager timeout does not remove the slots from the SlotManager. A timeout\n     * should only trigger the {@link ResourceActions#releaseResource(InstanceID, Exception)}\n     * callback. The receiver of the callback can then decide what to do with the TaskManager.\n     *\n     * <p>See FLINK-7793\n     */\n    @Test\n    public void testTaskManagerTimeoutDoesNotRemoveSlots() throws Exception {\n        final Time taskManagerTimeout = Time.milliseconds(10L);\n\n        final CompletableFuture<InstanceID> releaseResourceFuture = new CompletableFuture<>();\n        final ResourceActions resourceActions =\n                createResourceActionsBuilder()\n                        .setReleaseResourceConsumer(\n                                (instanceId, ignored) -> releaseResourceFuture.complete(instanceId))\n                        .build();\n\n        final Executor mainThreadExecutor = EXECUTOR_RESOURCE.getExecutor();\n\n        try (final TaskExecutorManager taskExecutorManager =\n                createTaskExecutorManagerBuilder()\n                        .setTaskManagerTimeout(taskManagerTimeout)\n                        .setResourceActions(resourceActions)\n                        .setMainThreadExecutor(mainThreadExecutor)\n                        .createTaskExecutorManager()) {\n\n            CompletableFuture.supplyAsync(\n                            () -> {\n                                InstanceID newTaskExecutorId =\n                                        createAndRegisterTaskExecutor(\n                                                taskExecutorManager, 1, ResourceProfile.ANY);\n                                assertEquals(1, taskExecutorManager.getNumberRegisteredSlots());\n                                return newTaskExecutorId;\n                            },\n                            mainThreadExecutor)\n                    // wait for the timeout to occur\n                    .thenCombine(\n                            releaseResourceFuture,\n                            (registeredInstance, releasedInstance) -> {\n                                assertThat(registeredInstance, is(releasedInstance));\n                                assertEquals(1, taskExecutorManager.getNumberRegisteredSlots());\n                                return registeredInstance;\n                            })\n                    .thenAccept(\n                            taskExecutorId -> {\n                                taskExecutorManager.unregisterTaskExecutor(taskExecutorId);\n                                assertEquals(0, taskExecutorManager.getNumberRegisteredSlots());\n                            })\n                    .get();\n        }\n    }",
          "conflictNames": [
              "taskManagerTimeout",
              "releaseResourceFuture",
              "mainThreadExecutor",
              "taskExecutorManager",
              "newTaskExecutorId"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/a0aa4813b9fe3db37cabe38fa47f1d1096c879dc^1/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/TaskExecutorManagerTest.java",
      "locators": [
          {
              "line": 198,
              "column": 31
          },
          {
              "line": 210,
              "column": 45
          }
      ],
      "old_name": "resourceManagerActions",
      "new_name": "resourceAllocator",
      "ctx": {
          "symbolName": "resourceManagerActions",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ResourceActions",
          "scopeHint": "in testTimeoutForUnusedTaskManager(...)",
          "filePath": "TaskExecutorManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Tests that formerly used task managers can timeout after all of their slots have been freed.\n     */\n    @Test\n    public void testTimeoutForUnusedTaskManager() throws Exception {\n        WorkerResourceSpec workerResourceSpec =\n                new WorkerResourceSpec.Builder().setCpuCores(1).build();\n        final ResourceProfile resourceProfile = ResourceProfile.newBuilder().setCpuCores(1).build();\n        final Time taskManagerTimeout = Time.milliseconds(50L);\n\n        final CompletableFuture<InstanceID> releaseResourceFuture = new CompletableFuture<>();\n        final ResourceActions resourceManagerActions =\n                new TestingResourceActionsBuilder()\n                        .setReleaseResourceConsumer(\n                                (instanceID, e) -> releaseResourceFuture.complete(instanceID))\n                        .build();\n\n        final Executor mainThreadExecutor = EXECUTOR_RESOURCE.getExecutor();\n\n        try (final TaskExecutorManager taskExecutorManager =\n                createTaskExecutorManagerBuilder()\n                        .setTaskManagerTimeout(taskManagerTimeout)\n                        .setDefaultWorkerResourceSpec(workerResourceSpec)\n                        .setResourceActions(resourceManagerActions)\n                        .setMainThreadExecutor(mainThreadExecutor)\n                        .createTaskExecutorManager()) {\n\n            CompletableFuture.supplyAsync(\n                            () -> {\n                                taskExecutorManager.allocateWorker(resourceProfile);\n                                InstanceID taskExecutorId =\n                                        createAndRegisterTaskExecutor(\n                                                taskExecutorManager, 1, resourceProfile);\n\n                                taskExecutorManager.occupySlot(taskExecutorId);\n                                taskExecutorManager.freeSlot(taskExecutorId);\n\n                                return taskExecutorId;\n                            },\n                            mainThreadExecutor)\n                    // wait for the timeout to occur\n                    .thenAcceptBoth(\n                            releaseResourceFuture,\n                            (registeredInstance, releasedInstance) ->\n                                    assertThat(registeredInstance, is(releasedInstance)))\n                    .get();\n        }\n    }",
          "conflictNames": [
              "workerResourceSpec",
              "resourceProfile",
              "taskManagerTimeout",
              "releaseResourceFuture",
              "mainThreadExecutor",
              "taskExecutorManager",
              "taskExecutorId"
          ]
      },
      "suggestions": [
          {
              "name": "resourceAllocator",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/a0aa4813b9fe3db37cabe38fa47f1d1096c879dc^1/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManager.java",
      "locators": [
          {
              "line": 101,
              "column": 39
          },
          {
              "line": 134,
              "column": 28
          },
          {
              "line": 144,
              "column": 33
          },
          {
              "line": 147,
              "column": 9
          },
          {
              "line": 215,
              "column": 9
          },
          {
              "line": 256,
              "column": 9
          },
          {
              "line": 726,
              "column": 25
          }
      ],
      "old_name": "resourceActions",
      "new_name": "resourceAllocator",
      "ctx": {
          "symbolName": "resourceActions",
          "symbolKind": "field",
          "language": "JAVA",
          "type": "ResourceActions",
          "scopeHint": "in DeclarativeSlotManager",
          "filePath": "DeclarativeSlotManager.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "eduledExecutor;\n\n    /** ResourceManager's id. */\n    @Nullable private ResourceManagerId resourceManagerId;\n\n    /** Executor for future callbacks which have to be \"synchronized\". */\n    @Nullable private Executor mainThreadExecutor;\n\n    /** Callbacks for resource (de-)allocations. */\n    @Nullable private ResourceActions resourceActions;\n\n    /** The future of the requirements delay check. */\n    @Nullable private CompletableFuture<Void> requirementsCheckFuture;\n\n    /** Blocked task manager checker. */\n    @Nullable private BlockedTaskManagerChecker blockedTaskManagerChec",
          "conflictNames": [
              "LOG",
              "slotTracker",
              "resourceTracker",
              "taskExecutorManagerFactory",
              "taskExecutorManager",
              "taskManagerRequestTimeout",
              "slotMatchingStrategy",
              "slotManagerMetricGroup",
              "jobMasterTargetAddresses",
              "pendingSlotAllocations",
              "requirementsCheckDelay",
              "sendNotEnoughResourceNotifications",
              "scheduledExecutor",
              "resourceManagerId",
              "mainThreadExecutor",
              "requirementsCheckFuture",
              "blockedTaskManagerChecker",
              "started"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/a0ace618ad1df15c5d906d7d0ecc0f9d7f3ea685^1/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackendBuilder.java",
      "locators": [
          {
              "line": 333,
              "column": 27
          },
          {
              "line": 438,
              "column": 34
          },
          {
              "line": 490,
              "column": 17
          }
      ],
      "old_name": "cancelStreamRegistryForBackend",
      "new_name": "cancelRegistryForBackend",
      "ctx": {
          "symbolName": "cancelStreamRegistryForBackend",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CloseableRegistry",
          "scopeHint": "in build(...)",
          "filePath": "RocksDBKeyedStateBackendBuilder.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public RocksDBKeyedStateBackend<K> build() throws BackendBuildingException {\n        RocksDBWriteBatchWrapper writeBatchWrapper = null;\n        ColumnFamilyHandle defaultColumnFamilyHandle = null;\n        RocksDBNativeMetricMonitor nativeMetricMonitor = null;\n        CloseableRegistry cancelStreamRegistryForBackend = new CloseableRegistry();\n        LinkedHashMap<String, RocksDBKeyedStateBackend.RocksDbKvStateInfo> kvStateInformation =\n                new LinkedHashMap<>();\n        LinkedHashMap<String, HeapPriorityQueueSnapshotRestoreWrapper<?>> registeredPQStates =\n                new LinkedHashMap<>();\n        RocksDB db = null;\n        RocksDBRestoreOperation restoreOperation = null;\n        CompletableFuture<Void> asyncCompactAfterRestoreFuture = null;\n\n        RocksDbTtlCompactFiltersManager ttlCompactFiltersManager =\n                new RocksDbTtlCompactFiltersManager(\n                        ttlTimeProvider,\n                        optionsContainer.getQueryTimeAfterNumEntries(),\n                        optionsContainer.getPeriodicCompactionTime());\n\n        ResourceGuard rocksDBResourceGuard = new ResourceGuard();\n        RocksDBSnapshotStrategyBase<K, ?> checkpointStrategy = null;\n        PriorityQueueSetFactory priorityQueueFactory;\n        SerializedCompositeKeyBuilder<K> sharedRocksKeyBuilder;\n        // Number of bytes required to prefix the key groups.\n        int keyGroupPrefixBytes =\n                CompositeKeySerializationUtils.computeRequiredBytesInKeyGroupPrefix(\n                        numberOfKeyGroups);\n        RocksDBManualCompactionManager manualCompactionManager;\n\n        try {\n            // Variables for snapshot strategy when incremental checkpoint is enabled\n            UUID backendUID = UUID.randomUUID();\n            SortedMap<Long, Collection<HandleAndLocalPath>> materializedSstFiles = new TreeMap<>();\n            long lastCompletedCheckpointId = -1L;\n            if (injectedTestDB != null) {\n                db = injectedTestDB;\n                defaultColumnFamilyHandle = injectedDefaultColumnFamilyHandle;\n                nativeMetricMonitor =\n                        nativeMetricOptions.isEnabled()\n                                ? new RocksDBNativeMetricMonitor(\n                                        nativeMetricOptions, metricGroup, db, null)\n                                : null;\n            } else {\n                prepareDirectories();\n                restoreOperation =\n                        getRocksDBRestoreOperation(\n                                keyGroupPrefixBytes,\n                                rocksDBResourceGuard,\n                                cancelStreamRegistry,\n                                kvStateInformation,\n                                registeredPQStates,\n                                ttlCompactFiltersManager);\n                RocksDBRestoreResult restoreResult = restoreOperation.restore();\n                db = restoreResult.getDb();\n                defaultColumnFamilyHandle = restoreResult.getDefaultColumnFamilyHandle();\n                nativeMetricMonitor = restoreResult.getNativeMetricMonitor();\n                if (ioExecutor != null) {\n                    asyncCompactAfterRestoreFuture =\n                            restoreResult\n                                    .getAsyncCompactTaskAfterRestore()\n                                    .map((task) -> CompletableFuture.runAsync(task, ioExecutor))\n                                    .orElse(null);\n                }\n                if (restoreOperation instanceof RocksDBIncrementalRestoreOperation) {\n                    backendUID = restoreResult.getBackendUID();\n                    materializedSstFiles = restoreResult.getRestoredSstFiles();\n                    lastCompletedCheckpointId = restoreResult.getLastCompletedCheckpointId();\n                }\n            }\n\n            writeBatchWrapper =\n                    new RocksDBWriteBatchWrapper(\n                            db, optionsContainer.getWriteOptions(), writeBatchSize);\n\n            // it is important that we only create the key builder after the restore, and not\n            // before;\n            // restore operations may reconfigure the key serializer, so accessing the key\n            // serializer\n            // only now we can be certain that the key serializer used in the builder is final.\n            sharedRocksKeyBuilder =\n                    new SerializedCompositeKeyBuilder<>(\n                            keySerializerProvider.currentSchemaSerializer(),\n                            keyGroupPrefixBytes,\n                            32);\n            // init snapshot strategy after db is assured to be initialized\n            checkpointStrategy =\n                    initializeSavepointAndCheckpointStrategies(\n                            rocksDBResourceGuard,\n                            kvStateInformation,\n                            keyGroupPrefixBytes,\n                            db,\n                            backendUID,\n                            materializedSstFiles,\n                            lastCompletedCheckpointId);\n            // init priority queue factory\n            manualCompactionManager =\n                    RocksDBManualCompactionManager.create(db, manualCompactionConfig, ioExecutor);\n            priorityQueueFactory =\n                    initPriorityQueueFactory(\n                            keyGroupPrefixBytes,\n                            kvStateInformation,\n                            db,\n                            writeBatchWrapper,\n                            nativeMetricMonitor,\n                            manualCompactionManager);\n        } catch (Throwable e) {\n            // Do clean up\n            List<ColumnFamilyOptions> columnFamilyOptions =\n                    new ArrayList<>(kvStateInformation.values().size());\n            IOUtils.closeQuietly(cancelStreamRegistryForBackend);\n            IOUtils.closeQuietly(writeBatchWrapper);\n            IOUtils.closeQuietly(rocksDBResourceGuard);\n            RocksDBOperationUtils.addColumnFamilyOptionsToCloseLater(\n                    columnFamilyOptions, defaultColumnFamilyHandle);\n            IOUtils.closeQuietly(defaultColumnFamilyHandle);\n            IOUtils.closeQuietly(nativeMetricMonitor);\n            for (RocksDBKeyedStateBackend.RocksDbKvStateInfo kvStateInfo :\n                    kvStateInformation.values()) {\n                RocksDBOperationUtils.addColumnFamilyOptionsToCloseLater(\n                        columnFamilyOptions, kvStateInfo.columnFamilyHandle);\n                IOUtils.closeQuietly(kvStateInfo.columnFamilyHandle);\n            }\n            IOUtils.closeQuietly(db);\n            // it's possible that db has been initialized but later restore steps failed\n            IOUtils.closeQuietly(restoreOperation);\n            IOUtils.closeAllQuietly(columnFamilyOptions);\n            IOUtils.closeQuietly(optionsContainer);\n            ttlCompactFiltersManager.disposeAndClearRegisteredCompactionFactories();\n            kvStateInformation.clear();\n            IOUtils.closeQuietly(checkpointStrategy);\n            try {\n                FileUtils.deleteDirectory(instanceBasePath);\n            } catch (Exception ex) {\n                logger.warn(\"Failed to delete base path for RocksDB: \" + instanceBasePath, ex);\n            }\n            // Log and rethrow\n            if (e instanceof BackendBuildingException) {\n                throw (BackendBuildingException) e;\n            } else {\n                String errMsg = \"Caught unexpected exception.\";\n                logger.error(errMsg, e);\n                throw new BackendBuildingException(errMsg, e);\n            }\n        }\n        InternalKeyContext<K> keyContext =\n                new InternalKeyContextImpl<>(keyGroupRange, numberOfKeyGroups);\n        logger.info(\"Finished building RocksDB keyed state-backend at {}.\", instanceBasePath);\n        return new RocksDBKeyedStateBackend<>(\n                this.userCodeClassLoader,\n                this.instanceBasePath,\n                this.optionsContainer,\n                columnFamilyOptionsFactory,\n                this.kvStateRegistry,\n                this.keySerializerProvider.currentSchemaSerializer(),\n                this.executionConfig,\n                this.ttlTimeProvider,\n                latencyTrackingStateConfig,\n                db,\n                kvStateInformation,\n                registeredPQStates,\n                keyGroupPrefixBytes,\n                cancelStreamRegistryForBackend,\n                this.keyGroupCompressionDecorator,\n                rocksDBResourceGuard,\n                checkpointStrategy,\n                writeBatchWrapper,\n                defaultColumnFamilyHandle,\n                nativeMetricMonitor,\n                sharedRocksKeyBuilder,\n                priorityQueueFactory,\n                ttlCompactFiltersManager,\n                keyContext,\n                writeBatchSize,\n                asyncCompactAfterRestoreFuture,\n                manualCompactionManager);\n    }",
          "conflictNames": [
              "writeBatchWrapper",
              "defaultColumnFamilyHandle",
              "nativeMetricMonitor",
              "kvStateInformation",
              "registeredPQStates",
              "db",
              "restoreOperation",
              "asyncCompactAfterRestoreFuture",
              "ttlCompactFiltersManager",
              "rocksDBResourceGuard",
              "checkpointStrategy",
              "priorityQueueFactory",
              "sharedRocksKeyBuilder",
              "keyGroupPrefixBytes",
              "manualCompactionManager",
              "backendUID",
              "materializedSstFiles",
              "lastCompletedCheckpointId",
              "restoreResult",
              "columnFamilyOptions",
              "errMsg",
              "keyContext"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/a1476843d378edbf3695a4873710b61f24d3e597^1/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/fs/ByteBufferReadableFSDataInputStream.java",
      "locators": [
          {
              "line": 30,
              "column": 77
          },
          {
              "line": 42,
              "column": 44
          },
          {
              "line": 52,
              "column": 14
          },
          {
              "line": 57,
              "column": 25
          },
          {
              "line": 57,
              "column": 73
          },
          {
              "line": 58,
              "column": 26
          },
          {
              "line": 60,
              "column": 52
          },
          {
              "line": 61,
              "column": 42
          },
          {
              "line": 62,
              "column": 59
          },
          {
              "line": 65,
              "column": 16
          },
          {
              "line": 72,
              "column": 16
          },
          {
              "line": 77,
              "column": 41
          },
          {
              "line": 77,
              "column": 81
          },
          {
              "line": 78,
              "column": 44
          },
          {
              "line": 80,
              "column": 78
          },
          {
              "line": 81,
              "column": 52
          },
          {
              "line": 82,
              "column": 42
          },
          {
              "line": 83,
              "column": 59
          },
          {
              "line": 86,
              "column": 16
          },
          {
              "line": 87,
              "column": 38
          },
          {
              "line": 88,
              "column": 47
          },
          {
              "line": 93,
              "column": 22
          },
          {
              "line": 94,
              "column": 14
          },
          {
              "line": 100,
              "column": 17
          },
          {
              "line": 105,
              "column": 17
          },
          {
              "line": 105,
              "column": 44
          },
          {
              "line": 106,
              "column": 17
          },
          {
              "line": 109,
              "column": 18
          },
          {
              "line": 138,
              "column": 16
          },
          {
              "line": 140,
              "column": 36
          },
          {
              "line": 144,
              "column": 16
          },
          {
              "line": 146,
              "column": 36
          },
          {
              "line": 150,
              "column": 16
          },
          {
              "line": 152,
              "column": 36
          },
          {
              "line": 171,
              "column": 52
          },
          {
              "line": 177,
              "column": 39
          },
          {
              "line": 178,
              "column": 34
          }
      ],
      "old_name": "read",
      "new_name": "c",
      "ctx": {
          "symbolName": "read",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in readFullyFromFSDataInputStream(...)",
          "filePath": "ByteBufferReadableFSDataInputStream.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private int readFullyFromFSDataInputStream(FSDataInputStream originalInputStream, ByteBuffer bb)\n            throws IOException {\n        byte[] tmp = new byte[bb.remaining()];\n        int n = 0;\n        while (n < tmp.length) {\n            int read = originalInputStream.read(tmp, n, tmp.length - n);\n            if (read == -1) {\n                break;\n            }\n            n += read;\n        }\n        if (n > 0) {\n            bb.put(tmp, 0, n);\n        }\n        return n;\n    }",
          "conflictNames": [
              "originalInputStream",
              "bb",
              "tmp",
              "n"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/a2681f6a85aaad21179f91e03a91b4a05158841e^1/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OperatorChain.java",
      "locators": [
          {
              "line": 168,
              "column": 36
          },
          {
              "line": 210,
              "column": 29
          },
          {
              "line": 212,
              "column": 17
          },
          {
              "line": 215,
              "column": 33
          },
          {
              "line": 645,
              "column": 34
          },
          {
              "line": 654,
              "column": 13
          }
      ],
      "old_name": "operatorFactory",
      "new_name": "streamOperatorFactoryClassName",
      "ctx": {
          "symbolName": "operatorFactory",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "StreamOperatorFactory<OUT>",
          "scopeHint": "in OperatorChain(...)",
          "filePath": "OperatorChain.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public OperatorChain(\n            StreamTask<OUT, OP> containingTask,\n            RecordWriterDelegate<SerializationDelegate<StreamRecord<OUT>>> recordWriterDelegate) {\n\n        this.operatorEventDispatcher =\n                new OperatorEventDispatcherImpl(\n                        containingTask.getEnvironment().getUserCodeClassLoader().asClassLoader(),\n                        containingTask.getEnvironment().getOperatorCoordinatorEventGateway());\n\n        final ClassLoader userCodeClassloader = containingTask.getUserCodeClassLoader();\n        final StreamConfig configuration = containingTask.getConfiguration();\n\n        StreamOperatorFactory<OUT> operatorFactory =\n                configuration.getStreamOperatorFactory(userCodeClassloader);\n\n        // we read the chained configs, and the order of record writer registrations by output name\n        Map<Integer, StreamConfig> chainedConfigs =\n                configuration.getTransitiveChainedTaskConfigsWithSelf(userCodeClassloader);\n\n        // create the final output stream writers\n        // we iterate through all the out edges from this job vertex and create a stream output\n        List<NonChainedOutput> outputsInOrder =\n                configuration.getVertexNonChainedOutputs(userCodeClassloader);\n        Map<IntermediateDataSetID, RecordWriterOutput<?>> recordWriterOutputs =\n                CollectionUtil.newHashMapWithExpectedSize(outputsInOrder.size());\n        this.streamOutputs = new RecordWriterOutput<?>[outputsInOrder.size()];\n        this.finishedOnRestoreInput =\n                this.isTaskDeployedAsFinished()\n                        ? new FinishedOnRestoreInput(\n                                streamOutputs, configuration.getInputs(userCodeClassloader).length)\n                        : null;\n\n        // from here on, we need to make sure that the output writers are shut down again on failure\n        boolean success = false;\n        try {\n            createChainOutputs(\n                    outputsInOrder,\n                    recordWriterDelegate,\n                    chainedConfigs,\n                    containingTask,\n                    recordWriterOutputs);\n\n            // we create the chain of operators and grab the collector that leads into the chain\n            List<StreamOperatorWrapper<?, ?>> allOpWrappers =\n                    new ArrayList<>(chainedConfigs.size());\n            this.mainOperatorOutput =\n                    createOutputCollector(\n                            containingTask,\n                            configuration,\n                            chainedConfigs,\n                            userCodeClassloader,\n                            recordWriterOutputs,\n                            allOpWrappers,\n                            containingTask.getMailboxExecutorFactory(),\n                            operatorFactory != null);\n\n            if (operatorFactory != null) {\n                Tuple2<OP, Optional<ProcessingTimeService>> mainOperatorAndTimeService =\n                        StreamOperatorFactoryUtil.createOperator(\n                                operatorFactory,\n                                containingTask,\n                                configuration,\n                                mainOperatorOutput,\n                                operatorEventDispatcher);\n\n                OP mainOperator = mainOperatorAndTimeService.f0;\n                mainOperator\n                        .getMetricGroup()\n                        .gauge(\n                                MetricNames.IO_CURRENT_OUTPUT_WATERMARK,\n                                mainOperatorOutput.getWatermarkGauge());\n                this.mainOperatorWrapper =\n                        createOperatorWrapper(\n                                mainOperator,\n                                containingTask,\n                                configuration,\n                                mainOperatorAndTimeService.f1,\n                                true);\n\n                // add main operator to end of chain\n                allOpWrappers.add(mainOperatorWrapper);\n\n                this.tailOperatorWrapper = allOpWrappers.get(0);\n            } else {\n                checkState(allOpWrappers.size() == 0);\n                this.mainOperatorWrapper = null;\n                this.tailOperatorWrapper = null;\n            }\n\n            this.chainedSources =\n                    createChainedSources(\n                            containingTask,\n                            configuration.getInputs(userCodeClassloader),\n                            chainedConfigs,\n                            userCodeClassloader,\n                            allOpWrappers);\n\n            this.numOperators = allOpWrappers.size();\n\n            firstOperatorWrapper = linkOperatorWrappers(allOpWrappers);\n\n            success = true;\n        } finally {\n            // make sure we clean up after ourselves in case of a failure after acquiring\n            // the first resources\n            if (!success) {\n                for (int i = 0; i < streamOutputs.length; i++) {\n                    if (streamOutputs[i] != null) {\n                        streamOutputs[i].close();\n                    }\n                    streamOutputs[i] = null;\n                }\n            }\n        }\n    }",
          "conflictNames": [
              "containingTask",
              "recordWriterDelegate",
              "userCodeClassloader",
              "configuration",
              "chainedConfigs",
              "outputsInOrder",
              "recordWriterOutputs",
              "success",
              "allOpWrappers",
              "mainOperatorAndTimeService",
              "mainOperator",
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/a2b402d66de9ecde75881796a6d7ee09fc4d6963^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/HsSubpartitionViewTest.java",
      "locators": [
          {
              "line": 363,
              "column": 33
          },
          {
              "line": 366,
              "column": 59
          },
          {
              "line": 372,
              "column": 20
          }
      ],
      "old_name": "releaseDataViewFuture",
      "new_name": "releaseDiskViewFuture",
      "ctx": {
          "symbolName": "releaseDataViewFuture",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CompletableFuture<Void>",
          "scopeHint": "in testRelease(...)",
          "filePath": "HsSubpartitionViewTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testRelease() throws Exception {\n        HsSubpartitionView subpartitionView = createSubpartitionView();\n        CompletableFuture<Void> releaseDataViewFuture = new CompletableFuture<>();\n        TestingHsDataView diskDataView =\n                TestingHsDataView.builder()\n                        .setReleaseDataViewRunnable(() -> releaseDataViewFuture.complete(null))\n                        .build();\n        subpartitionView.setDiskDataView(diskDataView);\n        subpartitionView.setMemoryDataView(TestingHsDataView.NO_OP);\n        subpartitionView.releaseAllResources();\n        assertThat(subpartitionView.isReleased()).isTrue();\n        assertThat(releaseDataViewFuture).isCompleted();\n    }",
          "conflictNames": [
              "subpartitionView",
              "diskDataView"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/a2b402d66de9ecde75881796a6d7ee09fc4d6963^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/HsMemoryDataManager.java",
      "locators": [
          {
              "line": 284,
              "column": 46
          },
          {
              "line": 286,
              "column": 13
          },
          {
              "line": 287,
              "column": 13
          }
      ],
      "old_name": "subpartitionViewInternalOperations",
      "new_name": "consumerView",
      "ctx": {
          "symbolName": "subpartitionViewInternalOperations",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "HsSubpartitionViewInternalOperations",
          "scopeHint": "in onDataAvailable(...)",
          "filePath": "HsMemoryDataManager.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void onDataAvailable(int subpartitionId) {\n        HsSubpartitionViewInternalOperations subpartitionViewInternalOperations =\n                subpartitionViewOperationsMap.get(subpartitionId);\n        if (subpartitionViewInternalOperations != null) {\n            subpartitionViewInternalOperations.notifyDataAvailable();\n        }\n    }",
          "conflictNames": [
              "subpartitionId"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/a2b402d66de9ecde75881796a6d7ee09fc4d6963^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/HsSubpartitionView.java",
      "locators": [
          {
              "line": 273,
              "column": 17
          },
          {
              "line": 281,
              "column": 17
          },
          {
              "line": 285,
              "column": 13
          }
      ],
      "old_name": "releaseSubpartitionReader",
      "new_name": "releaseDiskView",
      "ctx": {
          "symbolName": "releaseSubpartitionReader",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "boolean",
          "scopeHint": "in releaseInternal(...)",
          "filePath": "HsSubpartitionView.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void releaseInternal(@Nullable Throwable throwable) {\n        boolean releaseSubpartitionReader = false;\n        synchronized (lock) {\n            if (isReleased) {\n                return;\n            }\n            isReleased = true;\n            failureCause = throwable;\n            if (diskDataView != null) {\n                releaseSubpartitionReader = true;\n            }\n        }\n        // release subpartition reader outside of lock to avoid deadlock.\n        if (releaseSubpartitionReader) {\n            //noinspection FieldAccessNotGuarded\n            diskDataView.releaseDataView();\n        }\n    }",
          "conflictNames": [
              "throwable"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/a2b402d66de9ecde75881796a6d7ee09fc4d6963^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/HsSubpartitionMemoryDataManagerTest.java",
      "locators": [
          {
              "line": 83,
              "column": 41
          },
          {
              "line": 85,
              "column": 9
          },
          {
              "line": 100,
              "column": 41
          },
          {
              "line": 102,
              "column": 9
          },
          {
              "line": 115,
              "column": 41
          },
          {
              "line": 117,
              "column": 9
          },
          {
              "line": 118,
              "column": 9
          },
          {
              "line": 120,
              "column": 9
          },
          {
              "line": 130,
              "column": 41
          },
          {
              "line": 133,
              "column": 9
          },
          {
              "line": 135,
              "column": 20
          },
          {
              "line": 145,
              "column": 41
          },
          {
              "line": 148,
              "column": 9
          },
          {
              "line": 149,
              "column": 9
          },
          {
              "line": 150,
              "column": 9
          },
          {
              "line": 154,
              "column": 9
          },
          {
              "line": 156,
              "column": 20
          },
          {
              "line": 166,
              "column": 41
          },
          {
              "line": 169,
              "column": 9
          },
          {
              "line": 171,
              "column": 20
          },
          {
              "line": 180,
              "column": 41
          },
          {
              "line": 183,
              "column": 9
          },
          {
              "line": 184,
              "column": 9
          },
          {
              "line": 185,
              "column": 9
          },
          {
              "line": 189,
              "column": 9
          },
          {
              "line": 191,
              "column": 20
          },
          {
              "line": 200,
              "column": 41
          },
          {
              "line": 203,
              "column": 9
          },
          {
              "line": 205,
              "column": 48
          },
          {
              "line": 236,
              "column": 41
          },
          {
              "line": 243,
              "column": 17
          },
          {
              "line": 248,
              "column": 9
          },
          {
              "line": 253,
              "column": 38
          },
          {
              "line": 277,
              "column": 41
          },
          {
              "line": 281,
              "column": 13
          },
          {
              "line": 288,
              "column": 9
          },
          {
              "line": 291,
              "column": 9
          },
          {
              "line": 292,
              "column": 9
          },
          {
              "line": 295,
              "column": 17
          },
          {
              "line": 298,
              "column": 17
          },
          {
              "line": 303,
              "column": 17
          },
          {
              "line": 308,
              "column": 17
          },
          {
              "line": 311,
              "column": 17
          },
          {
              "line": 315,
              "column": 17
          },
          {
              "line": 320,
              "column": 17
          },
          {
              "line": 325,
              "column": 17
          },
          {
              "line": 330,
              "column": 17
          },
          {
              "line": 343,
              "column": 41
          },
          {
              "line": 347,
              "column": 13
          },
          {
              "line": 353,
              "column": 17
          },
          {
              "line": 388,
              "column": 41
          },
          {
              "line": 393,
              "column": 13
          },
          {
              "line": 399,
              "column": 9
          },
          {
              "line": 401,
              "column": 9
          },
          {
              "line": 421,
              "column": 41
          },
          {
              "line": 423,
              "column": 9
          },
          {
              "line": 425,
              "column": 9
          },
          {
              "line": 428,
              "column": 9
          },
          {
              "line": 515,
              "column": 41
          },
          {
              "line": 522,
              "column": 9
          },
          {
              "line": 523,
              "column": 16
          }
      ],
      "old_name": "subpartitionMemoryDataManager",
      "new_name": "subpartitionConsumerMemoryDataManager",
      "ctx": {
          "symbolName": "subpartitionMemoryDataManager",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "HsSubpartitionMemoryDataManager",
          "scopeHint": "in testAppendDataRequestBuffer(...)",
          "filePath": "HsSubpartitionMemoryDataManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testAppendDataRequestBuffer() throws Exception {\n        CompletableFuture<Void> requestBufferFuture = new CompletableFuture<>();\n        HsMemoryDataManagerOperation memoryDataManagerOperation =\n                TestingMemoryDataManagerOperation.builder()\n                        .setRequestBufferFromPoolSupplier(\n                                () -> {\n                                    requestBufferFuture.complete(null);\n                                    return createBufferBuilder(bufferSize);\n                                })\n                        .build();\n        HsSubpartitionMemoryDataManager subpartitionMemoryDataManager =\n                createSubpartitionMemoryDataManager(memoryDataManagerOperation);\n        subpartitionMemoryDataManager.append(createRecord(0), DataType.DATA_BUFFER);\n        assertThat(requestBufferFuture).isCompleted();\n    }",
          "conflictNames": [
              "requestBufferFuture",
              "memoryDataManagerOperation"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/a2cd64c7ea57db6137a86caa7e6f9f99c7f77743^1/flink-runtime/src/test/java/org/apache/flink/runtime/asyncprocessing/AsyncExecutionControllerTest.java",
      "locators": [
          {
              "line": 573,
              "column": 31
          },
          {
              "line": 574,
              "column": 31
          }
      ],
      "old_name": "recordContext5",
      "new_name": "recordContext",
      "ctx": {
          "symbolName": "recordContext5",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RecordContext<String>",
          "scopeHint": "in testBufferTimeout(...)",
          "filePath": "AsyncExecutionControllerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testBufferTimeout() throws IOException {\n        int batchSize = 5;\n        int timeout = 1000;\n        CloseableRegistry resourceRegistry = new CloseableRegistry();\n        setup(\n                batchSize,\n                timeout,\n                1000,\n                new SyncMailboxExecutor(),\n                new TestAsyncFrameworkExceptionHandler(),\n                resourceRegistry);\n        ManuallyTriggeredScheduledExecutorService scheduledExecutor =\n                new ManuallyTriggeredScheduledExecutorService();\n        aec.stateRequestsBuffer.scheduledExecutor = scheduledExecutor;\n        Runnable userCode = () -> valueState.asyncValue();\n\n        // ------------ basic timeout -------------------\n        for (int i = 0; i < batchSize - 1; i++) {\n            String record = String.format(\"key%d-r%d\", i, i);\n            String key = String.format(\"key%d\", batchSize + i);\n            RecordContext<String> recordContext = aec.buildContext(record, key);\n            aec.setCurrentContext(recordContext);\n            userCode.run();\n        }\n        assertThat(aec.stateRequestsBuffer.currentSeq.get()).isEqualTo(0);\n        assertThat(aec.stateRequestsBuffer.scheduledSeq.get()).isEqualTo(0);\n        assertThat(aec.stateRequestsBuffer.currentScheduledFuture.isDone()).isFalse();\n        assertThat(aec.inFlightRecordNum.get()).isEqualTo(batchSize - 1);\n        assertThat(aec.stateRequestsBuffer.activeQueueSize()).isEqualTo(batchSize - 1);\n        assertThat(aec.stateRequestsBuffer.blockingQueueSize()).isEqualTo(0);\n\n        // buffer timeout, trigger\n        scheduledExecutor.triggerNonPeriodicScheduledTasks();\n        assertThat(aec.stateRequestsBuffer.activeQueueSize()).isEqualTo(0);\n        assertThat(aec.stateRequestsBuffer.currentScheduledFuture.isDone()).isTrue();\n        assertThat(aec.inFlightRecordNum.get()).isEqualTo(0);\n        assertThat(aec.stateRequestsBuffer.currentSeq.get()).isEqualTo(1);\n        assertThat(aec.stateRequestsBuffer.scheduledSeq.get()).isEqualTo(0);\n\n        // ----------------- oldest state request timeout ------------------\n        // r5 and r6 should be triggered due to r5 exceeding timeout\n        String record5 = \"key5-r5\";\n        String key5 = \"key5\";\n        RecordContext<String> recordContext5 = aec.buildContext(record5, key5);\n        aec.setCurrentContext(recordContext5);\n        // execute user code\n        userCode.run();\n        assertThat(aec.inFlightRecordNum.get()).isEqualTo(1);\n        assertThat(aec.stateRequestsBuffer.activeQueueSize()).isEqualTo(1);\n        assertThat(aec.stateRequestsBuffer.currentScheduledFuture.isDone()).isFalse();\n        ScheduledFuture<Void> scheduledFuture = aec.stateRequestsBuffer.currentScheduledFuture;\n        String record6 = \"key6-r6\";\n        String key6 = \"key6\";\n        RecordContext<String> recordContext6 = aec.buildContext(record6, key6);\n        aec.setCurrentContext(recordContext6);\n        // execute user code\n        userCode.run();\n        assertThat(aec.inFlightRecordNum.get()).isEqualTo(2);\n        assertThat(aec.stateRequestsBuffer.activeQueueSize()).isEqualTo(2);\n\n        assertThat(scheduledExecutor.getActiveNonPeriodicScheduledTask().size()).isEqualTo(1);\n        assertThat(scheduledExecutor.getAllNonPeriodicScheduledTask().size()).isEqualTo(1);\n        assertThat(aec.stateRequestsBuffer.currentSeq.get()).isEqualTo(1);\n        assertThat(aec.stateRequestsBuffer.scheduledSeq.get()).isEqualTo(1);\n        scheduledExecutor.triggerNonPeriodicScheduledTasks();\n\n        assertThat(aec.inFlightRecordNum.get()).isEqualTo(0);\n        assertThat(aec.stateRequestsBuffer.activeQueueSize()).isEqualTo(0);\n        assertThat(scheduledFuture).isEqualTo(aec.stateRequestsBuffer.currentScheduledFuture);\n        assertThat(scheduledFuture.isDone()).isTrue();\n        assertThat(aec.stateRequestsBuffer.currentSeq.get()).isEqualTo(2);\n        assertThat(aec.stateRequestsBuffer.scheduledSeq.get()).isEqualTo(1);\n\n        resourceRegistry.close();\n    }",
          "conflictNames": [
              "batchSize",
              "timeout",
              "resourceRegistry",
              "scheduledExecutor",
              "userCode",
              "i",
              "record",
              "key",
              "recordContext",
              "record5",
              "key5",
              "scheduledFuture",
              "record6",
              "key6",
              "recordContext6"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/a2cd64c7ea57db6137a86caa7e6f9f99c7f77743^1/flink-runtime/src/test/java/org/apache/flink/runtime/asyncprocessing/AsyncExecutionControllerTest.java",
      "locators": [
          {
              "line": 583,
              "column": 31
          },
          {
              "line": 584,
              "column": 31
          }
      ],
      "old_name": "recordContext6",
      "new_name": "recordContext",
      "ctx": {
          "symbolName": "recordContext6",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RecordContext<String>",
          "scopeHint": "in testBufferTimeout(...)",
          "filePath": "AsyncExecutionControllerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testBufferTimeout() throws IOException {\n        int batchSize = 5;\n        int timeout = 1000;\n        CloseableRegistry resourceRegistry = new CloseableRegistry();\n        setup(\n                batchSize,\n                timeout,\n                1000,\n                new SyncMailboxExecutor(),\n                new TestAsyncFrameworkExceptionHandler(),\n                resourceRegistry);\n        ManuallyTriggeredScheduledExecutorService scheduledExecutor =\n                new ManuallyTriggeredScheduledExecutorService();\n        aec.stateRequestsBuffer.scheduledExecutor = scheduledExecutor;\n        Runnable userCode = () -> valueState.asyncValue();\n\n        // ------------ basic timeout -------------------\n        for (int i = 0; i < batchSize - 1; i++) {\n            String record = String.format(\"key%d-r%d\", i, i);\n            String key = String.format(\"key%d\", batchSize + i);\n            RecordContext<String> recordContext = aec.buildContext(record, key);\n            aec.setCurrentContext(recordContext);\n            userCode.run();\n        }\n        assertThat(aec.stateRequestsBuffer.currentSeq.get()).isEqualTo(0);\n        assertThat(aec.stateRequestsBuffer.scheduledSeq.get()).isEqualTo(0);\n        assertThat(aec.stateRequestsBuffer.currentScheduledFuture.isDone()).isFalse();\n        assertThat(aec.inFlightRecordNum.get()).isEqualTo(batchSize - 1);\n        assertThat(aec.stateRequestsBuffer.activeQueueSize()).isEqualTo(batchSize - 1);\n        assertThat(aec.stateRequestsBuffer.blockingQueueSize()).isEqualTo(0);\n\n        // buffer timeout, trigger\n        scheduledExecutor.triggerNonPeriodicScheduledTasks();\n        assertThat(aec.stateRequestsBuffer.activeQueueSize()).isEqualTo(0);\n        assertThat(aec.stateRequestsBuffer.currentScheduledFuture.isDone()).isTrue();\n        assertThat(aec.inFlightRecordNum.get()).isEqualTo(0);\n        assertThat(aec.stateRequestsBuffer.currentSeq.get()).isEqualTo(1);\n        assertThat(aec.stateRequestsBuffer.scheduledSeq.get()).isEqualTo(0);\n\n        // ----------------- oldest state request timeout ------------------\n        // r5 and r6 should be triggered due to r5 exceeding timeout\n        String record5 = \"key5-r5\";\n        String key5 = \"key5\";\n        RecordContext<String> recordContext5 = aec.buildContext(record5, key5);\n        aec.setCurrentContext(recordContext5);\n        // execute user code\n        userCode.run();\n        assertThat(aec.inFlightRecordNum.get()).isEqualTo(1);\n        assertThat(aec.stateRequestsBuffer.activeQueueSize()).isEqualTo(1);\n        assertThat(aec.stateRequestsBuffer.currentScheduledFuture.isDone()).isFalse();\n        ScheduledFuture<Void> scheduledFuture = aec.stateRequestsBuffer.currentScheduledFuture;\n        String record6 = \"key6-r6\";\n        String key6 = \"key6\";\n        RecordContext<String> recordContext6 = aec.buildContext(record6, key6);\n        aec.setCurrentContext(recordContext6);\n        // execute user code\n        userCode.run();\n        assertThat(aec.inFlightRecordNum.get()).isEqualTo(2);\n        assertThat(aec.stateRequestsBuffer.activeQueueSize()).isEqualTo(2);\n\n        assertThat(scheduledExecutor.getActiveNonPeriodicScheduledTask().size()).isEqualTo(1);\n        assertThat(scheduledExecutor.getAllNonPeriodicScheduledTask().size()).isEqualTo(1);\n        assertThat(aec.stateRequestsBuffer.currentSeq.get()).isEqualTo(1);\n        assertThat(aec.stateRequestsBuffer.scheduledSeq.get()).isEqualTo(1);\n        scheduledExecutor.triggerNonPeriodicScheduledTasks();\n\n        assertThat(aec.inFlightRecordNum.get()).isEqualTo(0);\n        assertThat(aec.stateRequestsBuffer.activeQueueSize()).isEqualTo(0);\n        assertThat(scheduledFuture).isEqualTo(aec.stateRequestsBuffer.currentScheduledFuture);\n        assertThat(scheduledFuture.isDone()).isTrue();\n        assertThat(aec.stateRequestsBuffer.currentSeq.get()).isEqualTo(2);\n        assertThat(aec.stateRequestsBuffer.scheduledSeq.get()).isEqualTo(1);\n\n        resourceRegistry.close();\n    }",
          "conflictNames": [
              "batchSize",
              "timeout",
              "resourceRegistry",
              "scheduledExecutor",
              "userCode",
              "i",
              "record",
              "key",
              "recordContext",
              "record5",
              "key5",
              "recordContext5",
              "scheduledFuture",
              "record6",
              "key6"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/a5c12c5589b92d5e8b22a4aa952a0c06543424a3^1/flink-state-backends/flink-statebackend-changelog/src/main/java/org/apache/flink/state/changelog/KvStateChangeLoggerImpl.java",
      "locators": [
          {
              "line": 2,
              "column": 14
          },
          {
              "line": 2,
              "column": 28
          },
          {
              "line": 2,
              "column": 37
          },
          {
              "line": 2,
              "column": 44
          },
          {
              "line": 2,
              "column": 59
          },
          {
              "line": 2,
              "column": 63
          },
          {
              "line": 2,
              "column": 67
          },
          {
              "line": 3,
              "column": 5
          },
          {
              "line": 3,
              "column": 13
          },
          {
              "line": 4,
              "column": 10
          },
          {
              "line": 4,
              "column": 15
          },
          {
              "line": 4,
              "column": 24
          },
          {
              "line": 4,
              "column": 32
          },
          {
              "line": 4,
              "column": 38
          },
          {
              "line": 4,
              "column": 52
          },
          {
              "line": 4,
              "column": 61
          },
          {
              "line": 5,
              "column": 32
          },
          {
              "line": 5,
              "column": 35
          },
          {
              "line": 5,
              "column": 69
          },
          {
              "line": 6,
              "column": 22
          },
          {
              "line": 6,
              "column": 30
          },
          {
              "line": 6,
              "column": 58
          },
          {
              "line": 7,
              "column": 19
          },
          {
              "line": 7,
              "column": 26
          },
          {
              "line": 7,
              "column": 36
          },
          {
              "line": 7,
              "column": 40
          },
          {
              "line": 9,
              "column": 25
          },
          {
              "line": 11,
              "column": 38
          },
          {
              "line": 11,
              "column": 49
          },
          {
              "line": 11,
              "column": 64
          },
          {
              "line": 12,
              "column": 49
          },
          {
              "line": 13,
              "column": 65
          },
          {
              "line": 14,
              "column": 21
          },
          {
              "line": 14,
              "column": 47
          },
          {
              "line": 14,
              "column": 64
          },
          {
              "line": 15,
              "column": 12
          },
          {
              "line": 18,
              "column": 9
          },
          {
              "line": 18,
              "column": 39
          },
          {
              "line": 20,
              "column": 4
          },
          {
              "line": 20,
              "column": 8
          },
          {
              "line": 20,
              "column": 30
          },
          {
              "line": 20,
              "column": 33
          },
          {
              "line": 20,
              "column": 51
          },
          {
              "line": 21,
              "column": 4
          },
          {
              "line": 21,
              "column": 8
          },
          {
              "line": 21,
              "column": 30
          },
          {
              "line": 21,
              "column": 33
          },
          {
              "line": 22,
              "column": 4
          },
          {
              "line": 22,
              "column": 8
          },
          {
              "line": 22,
              "column": 26
          },
          {
              "line": 22,
              "column": 33
          },
          {
              "line": 23,
              "column": 4
          },
          {
              "line": 23,
              "column": 8
          },
          {
              "line": 23,
              "column": 76
          },
          {
              "line": 24,
              "column": 4
          },
          {
              "line": 24,
              "column": 8
          },
          {
              "line": 24,
              "column": 61
          },
          {
              "line": 25,
              "column": 4
          },
          {
              "line": 25,
              "column": 8
          },
          {
              "line": 25,
              "column": 46
          },
          {
              "line": 25,
              "column": 61
          },
          {
              "line": 26,
              "column": 4
          },
          {
              "line": 26,
              "column": 8
          },
          {
              "line": 26,
              "column": 56
          },
          {
              "line": 28,
              "column": 4
          },
          {
              "line": 28,
              "column": 17
          },
          {
              "line": 28,
              "column": 22
          },
          {
              "line": 29,
              "column": 4
          },
          {
              "line": 29,
              "column": 17
          },
          {
              "line": 29,
              "column": 22
          },
          {
              "line": 29,
              "column": 26
          },
          {
              "line": 29,
              "column": 37
          },
          {
              "line": 31,
              "column": 4
          },
          {
              "line": 31,
              "column": 14
          },
          {
              "line": 31,
              "column": 25
          },
          {
              "line": 32,
              "column": 4
          },
          {
              "line": 32,
              "column": 14
          },
          {
              "line": 33,
              "column": 4
          },
          {
              "line": 33,
              "column": 19
          },
          {
              "line": 33,
              "column": 26
          },
          {
              "line": 35,
              "column": 4
          },
          {
              "line": 35,
              "column": 15
          },
          {
              "line": 35,
              "column": 45
          },
          {
              "line": 35,
              "column": 66
          },
          {
              "line": 36,
              "column": 4
          },
          {
              "line": 36,
              "column": 15
          },
          {
              "line": 36,
              "column": 41
          },
          {
              "line": 36,
              "column": 47
          },
          {
              "line": 36,
              "column": 57
          },
          {
              "line": 38,
              "column": 3
          },
          {
              "line": 39,
              "column": 21
          },
          {
              "line": 39,
              "column": 75
          },
          {
              "line": 40,
              "column": 34
          },
          {
              "line": 43,
              "column": 7
          },
          {
              "line": 45,
              "column": 22
          },
          {
              "line": 45,
              "column": 32
          },
          {
              "line": 48,
              "column": 19
          },
          {
              "line": 52,
              "column": 25
          },
          {
              "line": 52,
              "column": 41
          },
          {
              "line": 53,
              "column": 25
          },
          {
              "line": 53,
              "column": 49
          },
          {
              "line": 54,
              "column": 35
          },
          {
              "line": 54,
              "column": 48
          },
          {
              "line": 55,
              "column": 22
          },
          {
              "line": 55,
              "column": 32
          },
          {
              "line": 57,
              "column": 15
          },
          {
              "line": 58,
              "column": 27
          },
          {
              "line": 58,
              "column": 41
          },
          {
              "line": 58,
              "column": 56
          },
          {
              "line": 59,
              "column": 36
          },
          {
              "line": 60,
              "column": 38
          },
          {
              "line": 61,
              "column": 42
          },
          {
              "line": 62,
              "column": 18
          },
          {
              "line": 62,
              "column": 32
          },
          {
              "line": 62,
              "column": 43
          },
          {
              "line": 67,
              "column": 13
          },
          {
              "line": 67,
              "column": 46
          },
          {
              "line": 67,
              "column": 53
          },
          {
              "line": 67,
              "column": 61
          },
          {
              "line": 67,
              "column": 72
          },
          {
              "line": 67,
              "column": 85
          },
          {
              "line": 68,
              "column": 10
          },
          {
              "line": 70,
              "column": 17
          },
          {
              "line": 71,
              "column": 59
          },
          {
              "line": 72,
              "column": 21
          },
          {
              "line": 72,
              "column": 35
          },
          {
              "line": 73,
              "column": 22
          },
          {
              "line": 73,
              "column": 35
          },
          {
              "line": 74,
              "column": 59
          },
          {
              "line": 81,
              "column": 7
          },
          {
              "line": 81,
              "column": 16
          },
          {
              "line": 81,
              "column": 76
          },
          {
              "line": 81,
              "column": 84
          },
          {
              "line": 81,
              "column": 97
          },
          {
              "line": 82,
              "column": 42
          },
          {
              "line": 86,
              "column": 7
          },
          {
              "line": 86,
              "column": 16
          },
          {
              "line": 86,
              "column": 31
          },
          {
              "line": 86,
              "column": 70
          },
          {
              "line": 86,
              "column": 78
          },
          {
              "line": 86,
              "column": 91
          },
          {
              "line": 87,
              "column": 37
          },
          {
              "line": 87,
              "column": 61
          },
          {
              "line": 88,
              "column": 43
          },
          {
              "line": 91,
              "column": 7
          },
          {
              "line": 91,
              "column": 16
          },
          {
              "line": 91,
              "column": 72
          },
          {
              "line": 91,
              "column": 80
          },
          {
              "line": 91,
              "column": 93
          },
          {
              "line": 92,
              "column": 9
          },
          {
              "line": 92,
              "column": 19
          },
          {
              "line": 92,
              "column": 20
          },
          {
              "line": 92,
              "column": 30
          },
          {
              "line": 93,
              "column": 17
          },
          {
              "line": 94,
              "column": 37
          },
          {
              "line": 94,
              "column": 64
          },
          {
              "line": 95,
              "column": 17
          },
          {
              "line": 95,
              "column": 35
          },
          {
              "line": 98,
              "column": 9
          },
          {
              "line": 98,
              "column": 19
          },
          {
              "line": 98,
              "column": 20
          },
          {
              "line": 100,
              "column": 42
          },
          {
              "line": 105,
              "column": 7
          },
          {
              "line": 105,
              "column": 29
          },
          {
              "line": 105,
              "column": 65
          },
          {
              "line": 106,
              "column": 35
          },
          {
              "line": 106,
              "column": 48
          },
          {
              "line": 107,
              "column": 25
          },
          {
              "line": 107,
              "column": 34
          },
          {
              "line": 109,
              "column": 46
          },
          {
              "line": 109,
              "column": 68
          },
          {
              "line": 110,
              "column": 55
          },
          {
              "line": 110,
              "column": 76
          },
          {
              "line": 111,
              "column": 45
          },
          {
              "line": 112,
              "column": 41
          },
          {
              "line": 116,
              "column": 19
          },
          {
              "line": 116,
              "column": 57
          },
          {
              "line": 116,
              "column": 72
          },
          {
              "line": 116,
              "column": 82
          },
          {
              "line": 117,
              "column": 18
          },
          {
              "line": 117,
              "column": 30
          },
          {
              "line": 121,
              "column": 19
          }
      ],
      "old_name": "o",
      "new_name": "objectOutputStream",
      "ctx": {
          "symbolName": "o",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ObjectOutputStream",
          "scopeHint": "in writeDefaultValueAndTtl(...)",
          "filePath": "KvStateChangeLoggerImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "protected void writeDefaultValueAndTtl(DataOutputViewStreamWrapper out) throws IOException {\n        out.writeBoolean(ttlConfig.isEnabled());\n        if (ttlConfig.isEnabled()) {\n            try (ObjectOutputStream o = new ObjectOutputStream(out)) {\n                o.writeObject(ttlConfig);\n            }\n        }\n        out.writeBoolean(defaultValue != null);\n        if (defaultValue != null) {\n            serializeValue(defaultValue, out);\n        }\n    }",
          "conflictNames": [
              "out"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/a69f96514f3da893f6a048b107ea287411f58714^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultAllocatedSlotPoolTest.java",
      "locators": [
          {
              "line": 313,
              "column": 53
          },
          {
              "line": 316,
              "column": 48
          },
          {
              "line": 318,
              "column": 48
          },
          {
              "line": 320,
              "column": 48
          },
          {
              "line": 322,
              "column": 48
          }
      ],
      "old_name": "slotInfoWithUtilization",
      "new_name": "slotInfo",
      "ctx": {
          "symbolName": "slotInfoWithUtilization",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SlotInfoWithUtilization",
          "scopeHint": "in assertSlotPoolContainsFreeSlots(...)",
          "filePath": "DefaultAllocatedSlotPoolTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void assertSlotPoolContainsFreeSlots(\n            DefaultAllocatedSlotPool slotPool, Collection<AllocatedSlot> allocatedSlots) {\n        final Collection<AllocatedSlotPool.FreeSlotInfo> freeSlotsInformation =\n                slotPool.getFreeSlotsInformation();\n\n        assertThat(freeSlotsInformation).hasSize(allocatedSlots.size());\n\n        final Map<AllocationID, AllocatedSlot> allocatedSlotMap =\n                allocatedSlots.stream()\n                        .collect(\n                                Collectors.toMap(\n                                        AllocatedSlot::getAllocationId, Function.identity()));\n\n        assertThat(freeSlotsInformation)\n                .allSatisfy(\n                        freeSlotInfo -> {\n                            AllocatedSlot allocatedSlot =\n                                    allocatedSlotMap.get(freeSlotInfo.getAllocationId());\n                            assertThat(allocatedSlot).isNotNull();\n                            SlotInfoWithUtilization slotInfoWithUtilization =\n                                    freeSlotInfo.asSlotInfo();\n                            assertThat(allocatedSlot.getAllocationId())\n                                    .isEqualTo(slotInfoWithUtilization.getAllocationId());\n                            assertThat(allocatedSlot.getPhysicalSlotNumber())\n                                    .isEqualTo(slotInfoWithUtilization.getPhysicalSlotNumber());\n                            assertThat(allocatedSlot.getResourceProfile())\n                                    .isEqualTo(slotInfoWithUtilization.getResourceProfile());\n                            assertThat(allocatedSlot.getTaskManagerLocation())\n                                    .isEqualTo(slotInfoWithUtilization.getTaskManagerLocation());\n                        });\n    }",
          "conflictNames": [
              "slotPool",
              "allocatedSlots",
              "freeSlotsInformation",
              "allocatedSlotMap",
              "allocatedSlot"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/a6a321777a53b8d7807078cb8d98c7b3de242fed^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/strategy/VertexwiseSchedulingStrategy.java",
      "locators": [
          {
              "line": 128,
              "column": 38
          },
          {
              "line": 140,
              "column": 34
          },
          {
              "line": 141,
              "column": 34
          },
          {
              "line": 144,
              "column": 72
          },
          {
              "line": 145,
              "column": 13
          },
          {
              "line": 150,
              "column": 45
          }
      ],
      "old_name": "verticesToDeploy",
      "new_name": "verticesToSchedule",
      "ctx": {
          "symbolName": "verticesToDeploy",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Set<ExecutionVertexID>",
          "scopeHint": "in maybeScheduleVertices(...)",
          "filePath": "VertexwiseSchedulingStrategy.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void maybeScheduleVertices(final Set<ExecutionVertexID> vertices) {\n        final Map<ConsumedPartitionGroup, Boolean> consumableStatusCache = new HashMap<>();\n\n        Set<ExecutionVertexID> allCandidates;\n        if (newVertices.isEmpty()) {\n            allCandidates = vertices;\n        } else {\n            allCandidates = new HashSet<>(vertices);\n            allCandidates.addAll(newVertices);\n            newVertices.clear();\n        }\n\n        final Set<ExecutionVertexID> verticesToDeploy =\n                allCandidates.stream()\n                        .filter(\n                                vertexId -> {\n                                    SchedulingExecutionVertex vertex =\n                                            schedulingTopology.getVertex(vertexId);\n                                    checkState(vertex.getState() == ExecutionState.CREATED);\n                                    return inputConsumableDecider.isInputConsumable(\n                                            vertex, Collections.emptySet(), consumableStatusCache);\n                                })\n                        .collect(Collectors.toSet());\n\n        scheduleVerticesOneByOne(verticesToDeploy);\n        scheduledVertices.addAll(verticesToDeploy);\n    }",
          "conflictNames": [
              "vertices",
              "consumableStatusCache",
              "allCandidates",
              "vertex"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/a6a321777a53b8d7807078cb8d98c7b3de242fed^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/strategy/VertexwiseSchedulingStrategy.java",
      "locators": [
          {
              "line": 148,
              "column": 39
          },
          {
              "line": 152,
              "column": 9
          }
      ],
      "old_name": "sortedVerticesToDeploy",
      "new_name": "sortedVerticesToSchedule",
      "ctx": {
          "symbolName": "sortedVerticesToDeploy",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<ExecutionVertexID>",
          "scopeHint": "in scheduleVerticesOneByOne(...)",
          "filePath": "VertexwiseSchedulingStrategy.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void scheduleVerticesOneByOne(final Set<ExecutionVertexID> verticesToDeploy) {\n        if (verticesToDeploy.isEmpty()) {\n            return;\n        }\n        final List<ExecutionVertexID> sortedVerticesToDeploy =\n                SchedulingStrategyUtils.sortExecutionVerticesInTopologicalOrder(\n                        schedulingTopology, verticesToDeploy);\n\n        sortedVerticesToDeploy.forEach(\n                id -> schedulerOperations.allocateSlotsAndDeploy(Collections.singletonList(id)));\n    }",
          "conflictNames": [
              "verticesToDeploy"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/a6ae370b194fb216b35e9a50ba144e100d02d6df^1/flink-runtime/src/main/java/org/apache/flink/runtime/throughput/BufferDebloatConfiguration.java",
      "locators": [
          {
              "line": 34,
              "column": 28
          },
          {
              "line": 43,
              "column": 22
          },
          {
              "line": 48,
              "column": 14
          },
          {
              "line": 48,
              "column": 51
          },
          {
              "line": 61,
              "column": 16
          },
          {
              "line": 81,
              "column": 18
          },
          {
              "line": 96,
              "column": 23
          },
          {
              "line": 99,
              "column": 17
          }
      ],
      "old_name": "targetTotalBufferSize",
      "new_name": "targetTotalTime",
      "ctx": {
          "symbolName": "targetTotalBufferSize",
          "symbolKind": "field",
          "language": "JAVA",
          "type": "Duration",
          "scopeHint": "in BufferDebloatConfiguration",
          "filePath": "BufferDebloatConfiguration.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "NTAGES;\nimport static org.apache.flink.util.Preconditions.checkArgument;\nimport static org.apache.flink.util.Preconditions.checkNotNull;\n\n/** Configuration for {@link BufferDebloater}. */\npublic final class BufferDebloatConfiguration {\n    private final Duration targetTotalBufferSize;\n    private final int maxBufferSize;\n    private final int minBufferSize;\n    private final int bufferDebloatThresholdPercentages;\n    private final int numberOfSamples;\n    private final boolean enabled;\n\n    private BufferDebloatConfigur",
          "conflictNames": [
              "maxBufferSize",
              "minBufferSize",
              "bufferDebloatThresholdPercentages",
              "numberOfSamples",
              "enabled"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/a70ca9c029bae9f1f4f11b989d257d8d1dc9408d^1/flink-clients/src/test/java/org/apache/flink/client/program/DefaultPackagedProgramRetrieverITCase.java",
      "locators": [
          {
              "line": 210,
              "column": 24
          },
          {
              "line": 212,
              "column": 20
          },
          {
              "line": 217,
              "column": 20
          },
          {
              "line": 219,
              "column": 20
          },
          {
              "line": 220,
              "column": 20
          },
          {
              "line": 235,
              "column": 24
          },
          {
              "line": 237,
              "column": 20
          },
          {
              "line": 257,
              "column": 24
          },
          {
              "line": 259,
              "column": 20
          },
          {
              "line": 282,
              "column": 24
          },
          {
              "line": 284,
              "column": 20
          },
          {
              "line": 285,
              "column": 20
          },
          {
              "line": 405,
              "column": 24
          },
          {
              "line": 407,
              "column": 17
          },
          {
              "line": 425,
              "column": 24
          },
          {
              "line": 427,
              "column": 17
          },
          {
              "line": 453,
              "column": 24
          },
          {
              "line": 454,
              "column": 20
          },
          {
              "line": 467,
              "column": 24
          },
          {
              "line": 469,
              "column": 20
          },
          {
              "line": 473,
              "column": 20
          },
          {
              "line": 487,
              "column": 24
          },
          {
              "line": 489,
              "column": 20
          },
          {
              "line": 494,
              "column": 17
          },
          {
              "line": 514,
              "column": 24
          },
          {
              "line": 516,
              "column": 20
          },
          {
              "line": 521,
              "column": 17
          },
          {
              "line": 542,
              "column": 24
          },
          {
              "line": 544,
              "column": 20
          },
          {
              "line": 549,
              "column": 17
          },
          {
              "line": 570,
              "column": 24
          },
          {
              "line": 572,
              "column": 20
          },
          {
              "line": 577,
              "column": 17
          },
          {
              "line": 598,
              "column": 24
          },
          {
              "line": 600,
              "column": 20
          },
          {
              "line": 605,
              "column": 17
          },
          {
              "line": 629,
              "column": 24
          },
          {
              "line": 632,
              "column": 17
          }
      ],
      "old_name": "jobGraph",
      "new_name": "streamGraph",
      "ctx": {
          "symbolName": "jobGraph",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraph",
          "scopeHint": "in testJobGraphRetrieval(...)",
          "filePath": "DefaultPackagedProgramRetrieverITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testJobGraphRetrieval() throws IOException, FlinkException, ProgramInvocationException {\n        final int parallelism = 42;\n        final JobID jobId = new JobID();\n\n        final Configuration configuration = new Configuration();\n        configuration.set(CoreOptions.DEFAULT_PARALLELISM, parallelism);\n        configuration.set(PipelineOptionsInternal.PIPELINE_FIXED_JOB_ID, jobId.toHexString());\n\n        final String expectedSuffix = \"suffix\";\n        final PackagedProgramRetriever retriever =\n                DefaultPackagedProgramRetriever.create(\n                        null,\n                        testJobEntryClassClasspathProvider.getJobClassName(),\n                        ClasspathProviderExtension.parametersForTestJob(expectedSuffix),\n                        new Configuration());\n\n        final JobGraph jobGraph = retrieveJobGraph(retriever, configuration);\n\n        assertThat(jobGraph.getName())\n                .isEqualTo(\n                        testJobEntryClassClasspathProvider.getJobClassName()\n                                + \"-\"\n                                + expectedSuffix);\n        assertThat(jobGraph.getSavepointRestoreSettings())\n                .isEqualTo(SavepointRestoreSettings.none());\n        assertThat(jobGraph.getMaximumParallelism()).isEqualTo(parallelism);\n        assertThat(jobGraph.getJobID()).isEqualTo(jobId);\n    }",
          "conflictNames": [
              "parallelism",
              "jobId",
              "configuration",
              "expectedSuffix",
              "retriever"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/a85bcb47d853a30b78cb5f17cd53f5c033110a60^1/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/entrypoint/KubernetesApplicationClusterEntrypoint.java",
      "locators": [
          {
              "line": 111,
              "column": 26
          },
          {
              "line": 114,
              "column": 30
          },
          {
              "line": 116,
              "column": 41
          },
          {
              "line": 118,
              "column": 33
          }
      ],
      "old_name": "pipelineJars",
      "new_name": "pipelineJarFiles",
      "ctx": {
          "symbolName": "pipelineJars",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<File>",
          "scopeHint": "in getPackagedProgramRetriever(...)",
          "filePath": "KubernetesApplicationClusterEntrypoint.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static PackagedProgramRetriever getPackagedProgramRetriever(\n            final Configuration configuration,\n            final String[] programArguments,\n            @Nullable final String jobClassName)\n            throws FlinkException {\n\n        final File userLibDir = ClusterEntrypointUtils.tryFindUserLibDirectory().orElse(null);\n\n        // No need to do pipelineJars validation if it is a PyFlink job.\n        if (!(PackagedProgramUtils.isPython(jobClassName)\n                || PackagedProgramUtils.isPython(programArguments))) {\n            final List<File> pipelineJars =\n                    KubernetesUtils.checkJarFileForApplicationMode(configuration);\n            Preconditions.checkArgument(pipelineJars.size() == 1, \"Should only have one jar\");\n            return DefaultPackagedProgramRetriever.create(\n                    userLibDir, pipelineJars.get(0), jobClassName, programArguments, configuration);\n        }\n\n        return DefaultPackagedProgramRetriever.create(\n                userLibDir, jobClassName, programArguments, configuration);\n    }",
          "conflictNames": [
              "configuration",
              "programArguments",
              "jobClassName",
              "userLibDir"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ab6a81118b45c06e822f3c77468dd7d0afb66b9e^1/flink-table/flink-table-planner/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java",
      "locators": [
          {
              "line": 195,
              "column": 34
          },
          {
              "line": 207,
              "column": 30
          },
          {
              "line": 235,
              "column": 44
          },
          {
              "line": 238,
              "column": 57
          },
          {
              "line": 408,
              "column": 28
          },
          {
              "line": 489,
              "column": 23
          },
          {
              "line": 490,
              "column": 13
          },
          {
              "line": 491,
              "column": 49
          },
          {
              "line": 577,
              "column": 23
          },
          {
              "line": 578,
              "column": 13
          },
          {
              "line": 579,
              "column": 53
          },
          {
              "line": 589,
              "column": 21
          },
          {
              "line": 590,
              "column": 15
          },
          {
              "line": 593,
              "column": 58
          },
          {
              "line": 708,
              "column": 39
          },
          {
              "line": 710,
              "column": 19
          },
          {
              "line": 712,
              "column": 44
          },
          {
              "line": 780,
              "column": 33
          },
          {
              "line": 799,
              "column": 23
          },
          {
              "line": 800,
              "column": 13
          },
          {
              "line": 801,
              "column": 43
          },
          {
              "line": 806,
              "column": 31
          },
          {
              "line": 810,
              "column": 13
          },
          {
              "line": 814,
              "column": 62
          },
          {
              "line": 832,
              "column": 17
          },
          {
              "line": 834,
              "column": 43
          },
          {
              "line": 1004,
              "column": 21
          },
          {
              "line": 1005,
              "column": 62
          },
          {
              "line": 1006,
              "column": 13
          },
          {
              "line": 1007,
              "column": 49
          },
          {
              "line": 1010,
              "column": 61
          },
          {
              "line": 1013,
              "column": 69
          },
          {
              "line": 1018,
              "column": 17
          },
          {
              "line": 1021,
              "column": 60
          },
          {
              "line": 1026,
              "column": 13
          },
          {
              "line": 1027,
              "column": 30
          },
          {
              "line": 1029,
              "column": 24
          },
          {
              "line": 1031,
              "column": 26
          },
          {
              "line": 1043,
              "column": 17
          },
          {
              "line": 1044,
              "column": 13
          },
          {
              "line": 1045,
              "column": 34
          },
          {
              "line": 1110,
              "column": 71
          },
          {
              "line": 1111,
              "column": 32
          },
          {
              "line": 1115,
              "column": 61
          },
          {
              "line": 1116,
              "column": 35
          },
          {
              "line": 1120,
              "column": 51
          },
          {
              "line": 1121,
              "column": 32
          },
          {
              "line": 1124,
              "column": 55
          },
          {
              "line": 1125,
              "column": 42
          },
          {
              "line": 1125,
              "column": 70
          },
          {
              "line": 1129,
              "column": 21
          },
          {
              "line": 1130,
              "column": 13
          },
          {
              "line": 1131,
              "column": 54
          },
          {
              "line": 1134,
              "column": 20
          },
          {
              "line": 1136,
              "column": 44
          },
          {
              "line": 1162,
              "column": 29
          },
          {
              "line": 1180,
              "column": 65
          },
          {
              "line": 1181,
              "column": 17
          },
          {
              "line": 1185,
              "column": 65
          },
          {
              "line": 1196,
              "column": 48
          },
          {
              "line": 1198,
              "column": 39
          },
          {
              "line": 1203,
              "column": 32
          },
          {
              "line": 1205,
              "column": 15
          },
          {
              "line": 1205,
              "column": 20
          },
          {
              "line": 1206,
              "column": 40
          },
          {
              "line": 1210,
              "column": 55
          },
          {
              "line": 1211,
              "column": 44
          },
          {
              "line": 1211,
              "column": 76
          },
          {
              "line": 1215,
              "column": 32
          },
          {
              "line": 1217,
              "column": 15
          },
          {
              "line": 1217,
              "column": 20
          },
          {
              "line": 1219,
              "column": 40
          },
          {
              "line": 1223,
              "column": 55
          },
          {
              "line": 1225,
              "column": 30
          },
          {
              "line": 1225,
              "column": 69
          },
          {
              "line": 1229,
              "column": 32
          },
          {
              "line": 1233,
              "column": 40
          },
          {
              "line": 1258,
              "column": 15
          },
          {
              "line": 1259,
              "column": 33
          },
          {
              "line": 1263,
              "column": 31
          },
          {
              "line": 1264,
              "column": 13
          },
          {
              "line": 1269,
              "column": 13
          },
          {
              "line": 1270,
              "column": 17
          },
          {
              "line": 1273,
              "column": 38
          },
          {
              "line": 1313,
              "column": 17
          },
          {
              "line": 1315,
              "column": 20
          },
          {
              "line": 1316,
              "column": 52
          },
          {
              "line": 1326,
              "column": 26
          },
          {
              "line": 1327,
              "column": 30
          },
          {
              "line": 1336,
              "column": 24
          },
          {
              "line": 1339,
              "column": 55
          },
          {
              "line": 1372,
              "column": 60
          },
          {
              "line": 1412,
              "column": 46
          },
          {
              "line": 1432,
              "column": 50
          },
          {
              "line": 1440,
              "column": 50
          },
          {
              "line": 1451,
              "column": 29
          },
          {
              "line": 1459,
              "column": 48
          },
          {
              "line": 1466,
              "column": 16
          },
          {
              "line": 1469,
              "column": 63
          },
          {
              "line": 1471,
              "column": 17
          },
          {
              "line": 1472,
              "column": 36
          },
          {
              "line": 1473,
              "column": 24
          },
          {
              "line": 1474,
              "column": 17
          },
          {
              "line": 1474,
              "column": 38
          },
          {
              "line": 1475,
              "column": 24
          },
          {
              "line": 1476,
              "column": 17
          },
          {
              "line": 1476,
              "column": 35
          },
          {
              "line": 1754,
              "column": 53
          },
          {
              "line": 1755,
              "column": 56
          },
          {
              "line": 1757,
              "column": 17
          },
          {
              "line": 1758,
              "column": 42
          },
          {
              "line": 1758,
              "column": 75
          },
          {
              "line": 1760,
              "column": 40
          },
          {
              "line": 1767,
              "column": 70
          },
          {
              "line": 1768,
              "column": 34
          },
          {
              "line": 1768,
              "column": 52
          },
          {
              "line": 1772,
              "column": 55
          },
          {
              "line": 1776,
              "column": 52
          },
          {
              "line": 1777,
              "column": 45
          },
          {
              "line": 1780,
              "column": 13
          },
          {
              "line": 1781,
              "column": 68
          },
          {
              "line": 1797,
              "column": 15
          },
          {
              "line": 1797,
              "column": 37
          },
          {
              "line": 1801,
              "column": 52
          },
          {
              "line": 1803,
              "column": 24
          },
          {
              "line": 1803,
              "column": 31
          },
          {
              "line": 1809,
              "column": 9
          },
          {
              "line": 1809,
              "column": 27
          },
          {
              "line": 1813,
              "column": 49
          },
          {
              "line": 1814,
              "column": 9
          },
          {
              "line": 1814,
              "column": 30
          },
          {
              "line": 1844,
              "column": 28
          },
          {
              "line": 1858,
              "column": 31
          },
          {
              "line": 1953,
              "column": 72
          },
          {
              "line": 1956,
              "column": 24
          },
          {
              "line": 1956,
              "column": 31
          },
          {
              "line": 1957,
              "column": 55
          },
          {
              "line": 1961,
              "column": 55
          },
          {
              "line": 1962,
              "column": 14
          },
          {
              "line": 1967,
              "column": 43
          },
          {
              "line": 1970,
              "column": 50
          },
          {
              "line": 1973,
              "column": 46
          },
          {
              "line": 1986,
              "column": 34
          },
          {
              "line": 1987,
              "column": 20
          },
          {
              "line": 1988,
              "column": 25
          },
          {
              "line": 1988,
              "column": 50
          },
          {
              "line": 1990,
              "column": 53
          },
          {
              "line": 1998,
              "column": 34
          },
          {
              "line": 2008,
              "column": 20
          },
          {
              "line": 2009,
              "column": 48
          },
          {
              "line": 2016,
              "column": 56
          },
          {
              "line": 2028,
              "column": 20
          },
          {
              "line": 2030,
              "column": 63
          },
          {
              "line": 2031,
              "column": 20
          },
          {
              "line": 2032,
              "column": 44
          },
          {
              "line": 2075,
              "column": 49
          },
          {
              "line": 2076,
              "column": 42
          },
          {
              "line": 2079,
              "column": 47
          },
          {
              "line": 2081,
              "column": 29
          },
          {
              "line": 2082,
              "column": 52
          },
          {
              "line": 2082,
              "column": 63
          },
          {
              "line": 2213,
              "column": 54
          },
          {
              "line": 2214,
              "column": 23
          },
          {
              "line": 2215,
              "column": 82
          },
          {
              "line": 2221,
              "column": 15
          },
          {
              "line": 2222,
              "column": 39
          },
          {
              "line": 2230,
              "column": 27
          },
          {
              "line": 2230,
              "column": 60
          },
          {
              "line": 2236,
              "column": 27
          },
          {
              "line": 2242,
              "column": 30
          },
          {
              "line": 2248,
              "column": 27
          },
          {
              "line": 2253,
              "column": 41
          },
          {
              "line": 2255,
              "column": 52
          },
          {
              "line": 2258,
              "column": 61
          },
          {
              "line": 2276,
              "column": 48
          },
          {
              "line": 2282,
              "column": 61
          },
          {
              "line": 2295,
              "column": 27
          },
          {
              "line": 2295,
              "column": 61
          },
          {
              "line": 2296,
              "column": 71
          },
          {
              "line": 2311,
              "column": 34
          },
          {
              "line": 2348,
              "column": 24
          },
          {
              "line": 2354,
              "column": 45
          },
          {
              "line": 2358,
              "column": 24
          },
          {
              "line": 2364,
              "column": 36
          },
          {
              "line": 2368,
              "column": 24
          },
          {
              "line": 2374,
              "column": 38
          },
          {
              "line": 2378,
              "column": 24
          },
          {
              "line": 2381,
              "column": 34
          },
          {
              "line": 2397,
              "column": 24
          },
          {
              "line": 2400,
              "column": 48
          },
          {
              "line": 2455,
              "column": 58
          },
          {
              "line": 2460,
              "column": 62
          },
          {
              "line": 2473,
              "column": 36
          },
          {
              "line": 2481,
              "column": 34
          },
          {
              "line": 2504,
              "column": 36
          },
          {
              "line": 2511,
              "column": 28
          },
          {
              "line": 2520,
              "column": 29
          },
          {
              "line": 2536,
              "column": 48
          },
          {
              "line": 2541,
              "column": 25
          },
          {
              "line": 2551,
              "column": 34
          },
          {
              "line": 2581,
              "column": 34
          },
          {
              "line": 2598,
              "column": 50
          },
          {
              "line": 2611,
              "column": 34
          },
          {
              "line": 2630,
              "column": 28
          },
          {
              "line": 2643,
              "column": 54
          },
          {
              "line": 2646,
              "column": 29
          },
          {
              "line": 2647,
              "column": 39
          },
          {
              "line": 2659,
              "column": 39
          },
          {
              "line": 2671,
              "column": 15
          },
          {
              "line": 2671,
              "column": 26
          },
          {
              "line": 2677,
              "column": 21
          },
          {
              "line": 2682,
              "column": 48
          },
          {
              "line": 2690,
              "column": 15
          },
          {
              "line": 2690,
              "column": 26
          },
          {
              "line": 2698,
              "column": 21
          },
          {
              "line": 2703,
              "column": 24
          },
          {
              "line": 2703,
              "column": 31
          },
          {
              "line": 2709,
              "column": 17
          },
          {
              "line": 2711,
              "column": 54
          },
          {
              "line": 2785,
              "column": 61
          },
          {
              "line": 2786,
              "column": 56
          },
          {
              "line": 2786,
              "column": 62
          },
          {
              "line": 2790,
              "column": 64
          },
          {
              "line": 2791,
              "column": 56
          },
          {
              "line": 2791,
              "column": 62
          },
          {
              "line": 2795,
              "column": 56
          },
          {
              "line": 2795,
              "column": 62
          },
          {
              "line": 2802,
              "column": 35
          },
          {
              "line": 2810,
              "column": 34
          },
          {
              "line": 2827,
              "column": 52
          },
          {
              "line": 2841,
              "column": 52
          },
          {
              "line": 2856,
              "column": 68
          },
          {
              "line": 2858,
              "column": 52
          },
          {
              "line": 2872,
              "column": 61
          },
          {
              "line": 2873,
              "column": 49
          },
          {
              "line": 2909,
              "column": 34
          },
          {
              "line": 2914,
              "column": 28
          },
          {
              "line": 2917,
              "column": 34
          },
          {
              "line": 2926,
              "column": 61
          },
          {
              "line": 2927,
              "column": 34
          },
          {
              "line": 2931,
              "column": 58
          },
          {
              "line": 2940,
              "column": 39
          },
          {
              "line": 2947,
              "column": 21
          },
          {
              "line": 2951,
              "column": 34
          },
          {
              "line": 3006,
              "column": 55
          },
          {
              "line": 3009,
              "column": 40
          },
          {
              "line": 3012,
              "column": 53
          },
          {
              "line": 3013,
              "column": 34
          },
          {
              "line": 3017,
              "column": 31
          },
          {
              "line": 3020,
              "column": 15
          },
          {
              "line": 3020,
              "column": 89
          },
          {
              "line": 3024,
              "column": 17
          },
          {
              "line": 3025,
              "column": 13
          },
          {
              "line": 3026,
              "column": 20
          },
          {
              "line": 3028,
              "column": 9
          },
          {
              "line": 3029,
              "column": 13
          },
          {
              "line": 3030,
              "column": 20
          },
          {
              "line": 3053,
              "column": 46
          },
          {
              "line": 3054,
              "column": 17
          },
          {
              "line": 3056,
              "column": 61
          },
          {
              "line": 3063,
              "column": 86
          },
          {
              "line": 3064,
              "column": 13
          },
          {
              "line": 3067,
              "column": 13
          },
          {
              "line": 3068,
              "column": 20
          },
          {
              "line": 3069,
              "column": 20
          },
          {
              "line": 3070,
              "column": 46
          },
          {
              "line": 3070,
              "column": 52
          },
          {
              "line": 3071,
              "column": 20
          },
          {
              "line": 3072,
              "column": 33
          },
          {
              "line": 3073,
              "column": 38
          },
          {
              "line": 3077,
              "column": 20
          },
          {
              "line": 3078,
              "column": 46
          },
          {
              "line": 3090,
              "column": 23
          },
          {
              "line": 3259,
              "column": 71
          },
          {
              "line": 3262,
              "column": 15
          },
          {
              "line": 3267,
              "column": 41
          },
          {
              "line": 3269,
              "column": 17
          },
          {
              "line": 3272,
              "column": 41
          },
          {
              "line": 3275,
              "column": 42
          },
          {
              "line": 3278,
              "column": 40
          },
          {
              "line": 3281,
              "column": 40
          },
          {
              "line": 3284,
              "column": 42
          },
          {
              "line": 3287,
              "column": 31
          },
          {
              "line": 3291,
              "column": 57
          },
          {
              "line": 3293,
              "column": 29
          },
          {
              "line": 3355,
              "column": 30
          },
          {
              "line": 3356,
              "column": 56
          },
          {
              "line": 3457,
              "column": 15
          },
          {
              "line": 3460,
              "column": 62
          },
          {
              "line": 3461,
              "column": 47
          },
          {
              "line": 3598,
              "column": 26
          },
          {
              "line": 3599,
              "column": 43
          },
          {
              "line": 3607,
              "column": 26
          },
          {
              "line": 3608,
              "column": 43
          },
          {
              "line": 3615,
              "column": 26
          },
          {
              "line": 3616,
              "column": 43
          },
          {
              "line": 3619,
              "column": 26
          },
          {
              "line": 3620,
              "column": 43
          },
          {
              "line": 3631,
              "column": 65
          },
          {
              "line": 3632,
              "column": 13
          },
          {
              "line": 3632,
              "column": 29
          },
          {
              "line": 3633,
              "column": 40
          },
          {
              "line": 3635,
              "column": 16
          },
          {
              "line": 3691,
              "column": 46
          },
          {
              "line": 3692,
              "column": 17
          },
          {
              "line": 3694,
              "column": 35
          },
          {
              "line": 3696,
              "column": 24
          },
          {
              "line": 3828,
              "column": 41
          },
          {
              "line": 3830,
              "column": 41
          },
          {
              "line": 3861,
              "column": 37
          },
          {
              "line": 3863,
              "column": 37
          },
          {
              "line": 3918,
              "column": 72
          },
          {
              "line": 3919,
              "column": 17
          },
          {
              "line": 3921,
              "column": 59
          },
          {
              "line": 3925,
              "column": 68
          },
          {
              "line": 4191,
              "column": 22
          },
          {
              "line": 4192,
              "column": 21
          },
          {
              "line": 4196,
              "column": 21
          },
          {
              "line": 4199,
              "column": 21
          },
          {
              "line": 4247,
              "column": 22
          },
          {
              "line": 4248,
              "column": 61
          },
          {
              "line": 4420,
              "column": 21
          },
          {
              "line": 4421,
              "column": 9
          },
          {
              "line": 4421,
              "column": 58
          },
          {
              "line": 4422,
              "column": 38
          },
          {
              "line": 4452,
              "column": 22
          },
          {
              "line": 4453,
              "column": 48
          },
          {
              "line": 4603,
              "column": 44
          },
          {
              "line": 4645,
              "column": 62
          },
          {
              "line": 4647,
              "column": 15
          },
          {
              "line": 4652,
              "column": 29
          },
          {
              "line": 4653,
              "column": 43
          },
          {
              "line": 4659,
              "column": 21
          },
          {
              "line": 4675,
              "column": 21
          },
          {
              "line": 4685,
              "column": 50
          },
          {
              "line": 4696,
              "column": 33
          },
          {
              "line": 4765,
              "column": 72
          },
          {
              "line": 4816,
              "column": 25
          },
          {
              "line": 4817,
              "column": 21
          },
          {
              "line": 4830,
              "column": 25
          },
          {
              "line": 4970,
              "column": 21
          },
          {
              "line": 4975,
              "column": 25
          },
          {
              "line": 4985,
              "column": 15
          },
          {
              "line": 4985,
              "column": 24
          },
          {
              "line": 4990,
              "column": 21
          },
          {
              "line": 4991,
              "column": 13
          },
          {
              "line": 4992,
              "column": 50
          },
          {
              "line": 5022,
              "column": 15
          },
          {
              "line": 5027,
              "column": 21
          },
          {
              "line": 5028,
              "column": 16
          },
          {
              "line": 5030,
              "column": 40
          },
          {
              "line": 5058,
              "column": 33
          },
          {
              "line": 5082,
              "column": 29
          },
          {
              "line": 5107,
              "column": 29
          },
          {
              "line": 5160,
              "column": 21
          },
          {
              "line": 5161,
              "column": 16
          },
          {
              "line": 5162,
              "column": 34
          },
          {
              "line": 5279,
              "column": 26
          },
          {
              "line": 5280,
              "column": 60
          },
          {
              "line": 5291,
              "column": 26
          },
          {
              "line": 5292,
              "column": 17
          },
          {
              "line": 5294,
              "column": 21
          },
          {
              "line": 5295,
              "column": 66
          },
          {
              "line": 5300,
              "column": 45
          },
          {
              "line": 5369,
              "column": 26
          },
          {
              "line": 5370,
              "column": 53
          },
          {
              "line": 5444,
              "column": 22
          },
          {
              "line": 5445,
              "column": 26
          },
          {
              "line": 5453,
              "column": 49
          },
          {
              "line": 5454,
              "column": 36
          },
          {
              "line": 5456,
              "column": 46
          },
          {
              "line": 5463,
              "column": 13
          },
          {
              "line": 5466,
              "column": 9
          },
          {
              "line": 5466,
              "column": 44
          },
          {
              "line": 5467,
              "column": 16
          },
          {
              "line": 5507,
              "column": 22
          },
          {
              "line": 5508,
              "column": 26
          },
          {
              "line": 5578,
              "column": 25
          },
          {
              "line": 5579,
              "column": 25
          },
          {
              "line": 5581,
              "column": 33
          },
          {
              "line": 5583,
              "column": 41
          },
          {
              "line": 5589,
              "column": 29
          },
          {
              "line": 5635,
              "column": 18
          },
          {
              "line": 5638,
              "column": 25
          },
          {
              "line": 5640,
              "column": 33
          },
          {
              "line": 5641,
              "column": 68
          },
          {
              "line": 5653,
              "column": 21
          },
          {
              "line": 5653,
              "column": 38
          },
          {
              "line": 5653,
              "column": 64
          },
          {
              "line": 5674,
              "column": 41
          },
          {
              "line": 5676,
              "column": 30
          },
          {
              "line": 5677,
              "column": 55
          },
          {
              "line": 5678,
              "column": 33
          },
          {
              "line": 5684,
              "column": 33
          },
          {
              "line": 5757,
              "column": 48
          },
          {
              "line": 5758,
              "column": 30
          },
          {
              "line": 5760,
              "column": 9
          },
          {
              "line": 5760,
              "column": 44
          },
          {
              "line": 5761,
              "column": 9
          },
          {
              "line": 5761,
              "column": 49
          },
          {
              "line": 5762,
              "column": 16
          },
          {
              "line": 5856,
              "column": 21
          },
          {
              "line": 5857,
              "column": 20
          },
          {
              "line": 5859,
              "column": 56
          },
          {
              "line": 6074,
              "column": 33
          },
          {
              "line": 6078,
              "column": 27
          },
          {
              "line": 6081,
              "column": 30
          },
          {
              "line": 6082,
              "column": 18
          },
          {
              "line": 6082,
              "column": 40
          },
          {
              "line": 6082,
              "column": 47
          },
          {
              "line": 6087,
              "column": 20
          },
          {
              "line": 6093,
              "column": 33
          },
          {
              "line": 6097,
              "column": 27
          },
          {
              "line": 6100,
              "column": 30
          },
          {
              "line": 6101,
              "column": 18
          },
          {
              "line": 6101,
              "column": 40
          },
          {
              "line": 6101,
              "column": 47
          },
          {
              "line": 6106,
              "column": 20
          },
          {
              "line": 6112,
              "column": 33
          },
          {
              "line": 6116,
              "column": 27
          },
          {
              "line": 6119,
              "column": 30
          },
          {
              "line": 6120,
              "column": 18
          },
          {
              "line": 6120,
              "column": 40
          },
          {
              "line": 6120,
              "column": 47
          },
          {
              "line": 6125,
              "column": 20
          },
          {
              "line": 6131,
              "column": 32
          },
          {
              "line": 6135,
              "column": 26
          },
          {
              "line": 6138,
              "column": 30
          },
          {
              "line": 6139,
              "column": 18
          },
          {
              "line": 6139,
              "column": 40
          },
          {
              "line": 6139,
              "column": 47
          },
          {
              "line": 6144,
              "column": 20
          },
          {
              "line": 6170,
              "column": 39
          },
          {
              "line": 6171,
              "column": 40
          },
          {
              "line": 6222,
              "column": 46
          },
          {
              "line": 6227,
              "column": 40
          },
          {
              "line": 6505,
              "column": 27
          },
          {
              "line": 6507,
              "column": 17
          },
          {
              "line": 6508,
              "column": 24
          },
          {
              "line": 6572,
              "column": 25
          },
          {
              "line": 6573,
              "column": 21
          },
          {
              "line": 6574,
              "column": 28
          },
          {
              "line": 6592,
              "column": 38
          },
          {
              "line": 6593,
              "column": 33
          },
          {
              "line": 6663,
              "column": 20
          },
          {
              "line": 6665,
              "column": 35
          },
          {
              "line": 6667,
              "column": 21
          },
          {
              "line": 6667,
              "column": 83
          },
          {
              "line": 6737,
              "column": 30
          },
          {
              "line": 6738,
              "column": 25
          },
          {
              "line": 6739,
              "column": 43
          },
          {
              "line": 6887,
              "column": 26
          },
          {
              "line": 6888,
              "column": 21
          },
          {
              "line": 6891,
              "column": 37
          },
          {
              "line": 6897,
              "column": 44
          },
          {
              "line": 6897,
              "column": 78
          },
          {
              "line": 6897,
              "column": 87
          }
      ],
      "old_name": "node",
      "new_name": "id",
      "ctx": {
          "symbolName": "node",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SqlNode",
          "scopeHint": "in expandExprFromJoin(...)",
          "filePath": "SqlValidatorImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static SqlNode expandExprFromJoin(\n            SqlJoin join, SqlIdentifier identifier, @Nullable SelectScope scope) {\n        if (join.getConditionType() != JoinConditionType.USING) {\n            return identifier;\n        }\n\n        for (String name : SqlIdentifier.simpleNames((SqlNodeList) getCondition(join))) {\n            if (identifier.getSimple().equals(name)) {\n                final List<SqlNode> qualifiedNode = new ArrayList<>();\n                for (ScopeChild child : requireNonNull(scope, \"scope\").children) {\n                    if (child.namespace.getRowType().getFieldNames().indexOf(name) >= 0) {\n                        final SqlIdentifier exp =\n                                new SqlIdentifier(\n                                        ImmutableList.of(child.name, name),\n                                        identifier.getParserPosition());\n                        qualifiedNode.add(exp);\n                    }\n                }\n\n                assert qualifiedNode.size() == 2;\n                final SqlNode finalNode =\n                        SqlStdOperatorTable.AS.createCall(\n                                SqlParserPos.ZERO,\n                                SqlStdOperatorTable.COALESCE.createCall(\n                                        SqlParserPos.ZERO,\n                                        qualifiedNode.get(0),\n                                        qualifiedNode.get(1)),\n                                new SqlIdentifier(name, SqlParserPos.ZERO));\n                return finalNode;\n            }\n        }\n\n        // Only need to try to expand the expr from the left input of join\n        // since it is always left-deep join.\n        final SqlNode node = join.getLeft();\n        if (node instanceof SqlJoin) {\n            return expandExprFromJoin((SqlJoin) node, identifier, scope);\n        } else {\n            return identifier;\n        }\n    }",
          "conflictNames": [
              "join",
              "identifier",
              "scope",
              "qualifiedNode",
              "exp",
              "finalNode"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ab8286e8b5c7895cc0d009521eb9c660eeb01609^1/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/extraction/BaseMappingExtractor.java",
      "locators": [
          {
              "line": 374,
              "column": 50
          },
          {
              "line": 383,
              "column": 21
          }
      ],
      "old_name": "parameterTypes",
      "new_name": "argumentTemplates",
      "ctx": {
          "symbolName": "parameterTypes",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<FunctionArgumentTemplate>",
          "scopeHint": "in createParameterSignatureExtraction(...)",
          "filePath": "BaseMappingExtractor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Extraction that uses the method parameters for producing a {@link FunctionSignatureTemplate}.\n     */\n    static SignatureExtraction createParameterSignatureExtraction(int offset) {\n        return (extractor, method) -> {\n            final List<FunctionArgumentTemplate> parameterTypes =\n                    extractArgumentTemplates(\n                            extractor.typeFactory, extractor.getFunctionClass(), method, offset);\n\n            final String[] argumentNames = extractArgumentNames(method, offset);\n\n            final Boolean[] argumentOptionals = extractArgumentOptionals(method, offset);\n\n            return FunctionSignatureTemplate.of(\n                    parameterTypes, method.isVarArgs(), argumentNames, argumentOptionals);\n        };\n    }",
          "conflictNames": [
              "offset",
              "argumentNames",
              "argumentOptionals"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ab8286e8b5c7895cc0d009521eb9c660eeb01609^1/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/extraction/BaseMappingExtractor.java",
      "locators": [
          {
              "line": 207,
              "column": 41
          },
          {
              "line": 207,
              "column": 81
          },
          {
              "line": 316,
              "column": 33
          },
          {
              "line": 321,
              "column": 67
          },
          {
              "line": 342,
              "column": 47
          },
          {
              "line": 407,
              "column": 28
          },
          {
              "line": 409,
              "column": 13
          },
          {
              "line": 411,
              "column": 44
          },
          {
              "line": 419,
              "column": 20
          },
          {
              "line": 420,
              "column": 79
          },
          {
              "line": 483,
              "column": 34
          }
      ],
      "old_name": "hint",
      "new_name": "dataTypehint",
      "ctx": {
          "symbolName": "hint",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "DataTypeHint",
          "scopeHint": "in tryExtractInputGroupArgument(...)",
          "filePath": "BaseMappingExtractor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "static Optional<FunctionArgumentTemplate> tryExtractInputGroupArgument(\n            Method method, int paramPos) {\n        final Parameter parameter = method.getParameters()[paramPos];\n        final DataTypeHint hint = parameter.getAnnotation(DataTypeHint.class);\n        final ArgumentHint argumentHint = parameter.getAnnotation(ArgumentHint.class);\n        if (hint != null && argumentHint != null) {\n            throw extractionError(\n                    \"Argument and dataType hints cannot be declared in the same parameter at position %d.\",\n                    paramPos);\n        }\n        if (argumentHint != null) {\n            final DataTypeTemplate template = DataTypeTemplate.fromAnnotation(argumentHint, null);\n            if (template.inputGroup != null) {\n                return Optional.of(FunctionArgumentTemplate.of(template.inputGroup));\n            }\n        } else if (hint != null) {\n            final DataTypeTemplate template = DataTypeTemplate.fromAnnotation(hint, null);\n            if (template.inputGroup != null) {\n                return Optional.of(FunctionArgumentTemplate.of(template.inputGroup));\n            }\n        }\n        return Optional.empty();\n    }",
          "conflictNames": [
              "method",
              "paramPos",
              "parameter",
              "argumentHint",
              "template"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ab8286e8b5c7895cc0d009521eb9c660eeb01609^1/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/extraction/TypeInferenceExtractor.java",
      "locators": [
          {
              "line": 214,
              "column": 70
          },
          {
              "line": 216,
              "column": 31
          },
          {
              "line": 227,
              "column": 78
          },
          {
              "line": 237,
              "column": 13
          },
          {
              "line": 239,
              "column": 18
          },
          {
              "line": 244,
              "column": 73
          }
      ],
      "old_name": "accumulatorMapping",
      "new_name": "stateMapping",
      "ctx": {
          "symbolName": "accumulatorMapping",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Map<FunctionSignatureTemplate, FunctionResultTemplate>",
          "scopeHint": "in extractTypeInferenceOrError(...)",
          "filePath": "TypeInferenceExtractor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static TypeInference extractTypeInferenceOrError(\n            FunctionMappingExtractor mappingExtractor) {\n        final Map<FunctionSignatureTemplate, FunctionResultTemplate> outputMapping =\n                mappingExtractor.extractOutputMapping();\n\n        if (!mappingExtractor.hasAccumulator()) {\n            return buildInference(null, outputMapping);\n        }\n\n        final Map<FunctionSignatureTemplate, FunctionResultTemplate> accumulatorMapping =\n                mappingExtractor.extractAccumulatorMapping();\n        return buildInference(accumulatorMapping, outputMapping);\n    }",
          "conflictNames": [
              "mappingExtractor",
              "outputMapping"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ab8286e8b5c7895cc0d009521eb9c660eeb01609^1/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/extraction/FunctionTemplate.java",
      "locators": [
          {
              "line": 233,
              "column": 21
          },
          {
              "line": 243,
              "column": 21
          },
          {
              "line": 244,
              "column": 29
          },
          {
              "line": 249,
              "column": 17
          }
      ],
      "old_name": "allArgumentNameNotSet",
      "new_name": "allArgumentNamesNotSet",
      "ctx": {
          "symbolName": "allArgumentNameNotSet",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "boolean",
          "scopeHint": "in createSignatureTemplate(...)",
          "filePath": "FunctionTemplate.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static @Nullable FunctionSignatureTemplate createSignatureTemplate(\n            DataTypeFactory typeFactory,\n            @Nullable DataTypeHint[] inputs,\n            @Nullable String[] argumentNames,\n            @Nullable ArgumentHint[] singularArgumentHints,\n            @Nullable ArgumentHint[] pluralArgumentHints,\n            boolean isVarArg) {\n        // Deal with #argument() and #arguments()\n        if (singularArgumentHints != null && pluralArgumentHints != null) {\n            throw extractionError(\n                    \"Argument hints should only be defined once in the same function hint.\");\n        }\n        final ArgumentHint[] argumentHints;\n        if (singularArgumentHints != null) {\n            argumentHints = singularArgumentHints;\n        } else {\n            argumentHints = pluralArgumentHints;\n        }\n\n        String[] argumentHintNames;\n        DataTypeHint[] argumentHintTypes;\n\n        // Deal with #arguments() and #input()\n        if (argumentHints != null && inputs != null) {\n            throw extractionError(\n                    \"Argument and input hints cannot be declared in the same function hint.\");\n        }\n\n        Boolean[] argumentOptionals;\n        if (argumentHints != null) {\n            final boolean allScalar =\n                    Arrays.stream(argumentHints)\n                            .allMatch(\n                                    h -> {\n                                        final ArgumentTrait[] traits = h.value();\n                                        return traits.length == 1\n                                                && traits[0] == ArgumentTrait.SCALAR;\n                                    });\n            if (!allScalar) {\n                throw extractionError(\"Only scalar arguments are supported so far.\");\n            }\n\n            argumentHintNames = new String[argumentHints.length];\n            argumentHintTypes = new DataTypeHint[argumentHints.length];\n            argumentOptionals = new Boolean[argumentHints.length];\n            boolean allArgumentNameNotSet = true;\n            for (int i = 0; i < argumentHints.length; i++) {\n                ArgumentHint argumentHint = argumentHints[i];\n                argumentHintNames[i] = defaultAsNull(argumentHint, ArgumentHint::name);\n                argumentHintTypes[i] = defaultAsNull(argumentHint, ArgumentHint::type);\n                argumentOptionals[i] = argumentHint.isOptional();\n                if (argumentHintTypes[i] == null) {\n                    throw extractionError(\"The type of the argument at position %d is not set.\", i);\n                }\n                if (argumentHintNames[i] != null) {\n                    allArgumentNameNotSet = false;\n                } else if (!allArgumentNameNotSet) {\n                    throw extractionError(\n                            \"The argument name in function hint must be either fully set or not set at all.\");\n                }\n            }\n            if (allArgumentNameNotSet) {\n                argumentHintNames = null;\n            }\n        } else {\n            if (inputs == null) {\n                return null;\n            }\n            argumentHintTypes = inputs;\n            argumentHintNames = argumentNames;\n            argumentOptionals = new Boolean[inputs.length];\n            Arrays.fill(argumentOptionals, false);\n        }\n\n        return FunctionSignatureTemplate.of(\n                Arrays.stream(argumentHintTypes)\n                        .map(dataTypeHint -> createArgumentTemplate(typeFactory, dataTypeHint))\n                        .collect(Collectors.toList()),\n                isVarArg,\n                argumentHintNames,\n                argumentOptionals);\n    }",
          "conflictNames": [
              "typeFactory",
              "inputs",
              "argumentNames",
              "singularArgumentHints",
              "pluralArgumentHints",
              "isVarArg",
              "argumentHints",
              "argumentHintNames",
              "argumentHintTypes",
              "argumentOptionals",
              "allScalar",
              "traits",
              "i",
              "argumentHint"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ab8286e8b5c7895cc0d009521eb9c660eeb01609^1/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/extraction/FunctionTemplate.java",
      "locators": [
          {
              "line": 216,
              "column": 19
          },
          {
              "line": 232,
              "column": 13
          },
          {
              "line": 238,
              "column": 17
          },
          {
              "line": 258,
              "column": 13
          },
          {
              "line": 259,
              "column": 25
          },
          {
              "line": 268,
              "column": 17
          }
      ],
      "old_name": "argumentOptionals",
      "new_name": "argumentTraits",
      "ctx": {
          "symbolName": "argumentOptionals",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Boolean[]",
          "scopeHint": "in createSignatureTemplate(...)",
          "filePath": "FunctionTemplate.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static @Nullable FunctionSignatureTemplate createSignatureTemplate(\n            DataTypeFactory typeFactory,\n            @Nullable DataTypeHint[] inputs,\n            @Nullable String[] argumentNames,\n            @Nullable ArgumentHint[] singularArgumentHints,\n            @Nullable ArgumentHint[] pluralArgumentHints,\n            boolean isVarArg) {\n        // Deal with #argument() and #arguments()\n        if (singularArgumentHints != null && pluralArgumentHints != null) {\n            throw extractionError(\n                    \"Argument hints should only be defined once in the same function hint.\");\n        }\n        final ArgumentHint[] argumentHints;\n        if (singularArgumentHints != null) {\n            argumentHints = singularArgumentHints;\n        } else {\n            argumentHints = pluralArgumentHints;\n        }\n\n        String[] argumentHintNames;\n        DataTypeHint[] argumentHintTypes;\n\n        // Deal with #arguments() and #input()\n        if (argumentHints != null && inputs != null) {\n            throw extractionError(\n                    \"Argument and input hints cannot be declared in the same function hint.\");\n        }\n\n        Boolean[] argumentOptionals;\n        if (argumentHints != null) {\n            final boolean allScalar =\n                    Arrays.stream(argumentHints)\n                            .allMatch(\n                                    h -> {\n                                        final ArgumentTrait[] traits = h.value();\n                                        return traits.length == 1\n                                                && traits[0] == ArgumentTrait.SCALAR;\n                                    });\n            if (!allScalar) {\n                throw extractionError(\"Only scalar arguments are supported so far.\");\n            }\n\n            argumentHintNames = new String[argumentHints.length];\n            argumentHintTypes = new DataTypeHint[argumentHints.length];\n            argumentOptionals = new Boolean[argumentHints.length];\n            boolean allArgumentNameNotSet = true;\n            for (int i = 0; i < argumentHints.length; i++) {\n                ArgumentHint argumentHint = argumentHints[i];\n                argumentHintNames[i] = defaultAsNull(argumentHint, ArgumentHint::name);\n                argumentHintTypes[i] = defaultAsNull(argumentHint, ArgumentHint::type);\n                argumentOptionals[i] = argumentHint.isOptional();\n                if (argumentHintTypes[i] == null) {\n                    throw extractionError(\"The type of the argument at position %d is not set.\", i);\n                }\n                if (argumentHintNames[i] != null) {\n                    allArgumentNameNotSet = false;\n                } else if (!allArgumentNameNotSet) {\n                    throw extractionError(\n                            \"The argument name in function hint must be either fully set or not set at all.\");\n                }\n            }\n            if (allArgumentNameNotSet) {\n                argumentHintNames = null;\n            }\n        } else {\n            if (inputs == null) {\n                return null;\n            }\n            argumentHintTypes = inputs;\n            argumentHintNames = argumentNames;\n            argumentOptionals = new Boolean[inputs.length];\n            Arrays.fill(argumentOptionals, false);\n        }\n\n        return FunctionSignatureTemplate.of(\n                Arrays.stream(argumentHintTypes)\n                        .map(dataTypeHint -> createArgumentTemplate(typeFactory, dataTypeHint))\n                        .collect(Collectors.toList()),\n                isVarArg,\n                argumentHintNames,\n                argumentOptionals);\n    }",
          "conflictNames": [
              "typeFactory",
              "inputs",
              "argumentNames",
              "singularArgumentHints",
              "pluralArgumentHints",
              "isVarArg",
              "argumentHints",
              "argumentHintNames",
              "argumentHintTypes",
              "allScalar",
              "traits",
              "allArgumentNameNotSet",
              "i",
              "argumentHint"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ab8286e8b5c7895cc0d009521eb9c660eeb01609^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/functions/inference/TypeInferenceOperandChecker.java",
      "locators": [
          {
              "line": 136,
              "column": 33
          },
          {
              "line": 137,
              "column": 13
          },
          {
              "line": 138,
              "column": 20
          }
      ],
      "old_name": "optionalArguments",
      "new_name": "staticArgs",
      "ctx": {
          "symbolName": "optionalArguments",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Optional<List<Boolean>>",
          "scopeHint": "in isOptional(...)",
          "filePath": "TypeInferenceOperandChecker.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public boolean isOptional(int i) {\n        Optional<List<Boolean>> optionalArguments = typeInference.getOptionalArguments();\n        if (optionalArguments.isPresent()) {\n            return optionalArguments.get().get(i);\n        } else {\n            return false;\n        }\n    }",
          "conflictNames": [
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ab8286e8b5c7895cc0d009521eb9c660eeb01609^1/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/extraction/ExtractionUtils.java",
      "locators": [
          {
              "line": 767,
              "column": 50
          },
          {
              "line": 769,
              "column": 41
          },
          {
              "line": 769,
              "column": 66
          },
          {
              "line": 770,
              "column": 48
          }
      ],
      "old_name": "argumentHint",
      "new_name": "argHint",
      "ctx": {
          "symbolName": "argumentHint",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ArgumentHint",
          "scopeHint": "in extractExecutableNames(...)",
          "filePath": "ExtractionUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@VisibleForTesting\n    static @Nullable List<String> extractExecutableNames(Executable executable) {\n        final int offset;\n        if (!Modifier.isStatic(executable.getModifiers())) {\n            // remove \"this\" as first parameter\n            offset = 1;\n        } else {\n            offset = 0;\n        }\n        // by default parameter names are \"arg0, arg1, arg2, ...\" if compiler flag is not set\n        // so we need to extract them manually if possible\n        List<String> parameterNames =\n                Stream.of(executable.getParameters())\n                        .map(\n                                parameter -> {\n                                    ArgumentHint argumentHint =\n                                            parameter.getAnnotation(ArgumentHint.class);\n                                    if (argumentHint != null && !argumentHint.name().isEmpty()) {\n                                        return argumentHint.name();\n                                    } else {\n                                        return parameter.getName();\n                                    }\n                                })\n                        .collect(Collectors.toList());\n        if (parameterNames.stream().allMatch(n -> n.startsWith(\"arg\"))) {\n            final ParameterExtractor extractor;\n            if (executable instanceof Constructor) {\n                extractor = new ParameterExtractor((Constructor<?>) executable);\n            } else {\n                extractor = new ParameterExtractor((Method) executable);\n            }\n            getClassReader(executable.getDeclaringClass()).accept(extractor, 0);\n\n            final List<String> extractedNames = extractor.getParameterNames();\n            if (extractedNames.isEmpty()) {\n                return null;\n            }\n            // remove \"this\" and additional local variables\n            // select less names if class file has not the required information\n            parameterNames =\n                    extractedNames.subList(\n                            offset,\n                            Math.min(\n                                    executable.getParameterCount() + offset,\n                                    extractedNames.size()));\n        }\n\n        if (parameterNames.size() != executable.getParameterCount()) {\n            return null;\n        }\n\n        return parameterNames;\n    }",
          "conflictNames": [
              "executable",
              "offset",
              "parameterNames",
              "extractor",
              "extractedNames"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ab8286e8b5c7895cc0d009521eb9c660eeb01609^1/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/extraction/BaseMappingExtractor.java",
      "locators": [
          {
              "line": 148,
              "column": 69
          },
          {
              "line": 339,
              "column": 89
          },
          {
              "line": 370,
              "column": 40
          },
          {
              "line": 374,
              "column": 50
          },
          {
              "line": 383,
              "column": 21
          },
          {
              "line": 406,
              "column": 25
          },
          {
              "line": 407,
              "column": 35
          },
          {
              "line": 408,
              "column": 43
          },
          {
              "line": 411,
              "column": 81
          },
          {
              "line": 464,
              "column": 22
          },
          {
              "line": 464,
              "column": 35
          },
          {
              "line": 481,
              "column": 43
          },
          {
              "line": 484,
              "column": 57
          }
      ],
      "old_name": "parameter",
      "new_name": "arg",
      "ctx": {
          "symbolName": "parameter",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Parameter",
          "scopeHint": "in tryExtractInputGroupArgument(...)",
          "filePath": "BaseMappingExtractor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "static Optional<FunctionArgumentTemplate> tryExtractInputGroupArgument(\n            Method method, int paramPos) {\n        final Parameter parameter = method.getParameters()[paramPos];\n        final DataTypeHint hint = parameter.getAnnotation(DataTypeHint.class);\n        final ArgumentHint argumentHint = parameter.getAnnotation(ArgumentHint.class);\n        if (hint != null && argumentHint != null) {\n            throw extractionError(\n                    \"Argument and dataType hints cannot be declared in the same parameter at position %d.\",\n                    paramPos);\n        }\n        if (argumentHint != null) {\n            final DataTypeTemplate template = DataTypeTemplate.fromAnnotation(argumentHint, null);\n            if (template.inputGroup != null) {\n                return Optional.of(FunctionArgumentTemplate.of(template.inputGroup));\n            }\n        } else if (hint != null) {\n            final DataTypeTemplate template = DataTypeTemplate.fromAnnotation(hint, null);\n            if (template.inputGroup != null) {\n                return Optional.of(FunctionArgumentTemplate.of(template.inputGroup));\n            }\n        }\n        return Optional.empty();\n    }",
          "conflictNames": [
              "method",
              "paramPos",
              "hint",
              "argumentHint",
              "template"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ac16648281c014c33b2d6fe50688944035ec2240^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/typeutils/SortedMapSerializerSnapshot.java",
      "locators": [
          {
              "line": 107,
              "column": 29
          },
          {
              "line": 108,
              "column": 32
          }
      ],
      "old_name": "newSortedMapSerializer",
      "new_name": "oldSortedMapSerializerSnapshot",
      "ctx": {
          "symbolName": "newSortedMapSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SortedMapSerializer",
          "scopeHint": "in resolveSchemaCompatibility(...)",
          "filePath": "SortedMapSerializerSnapshot.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public TypeSerializerSchemaCompatibility<SortedMap<K, V>> resolveSchemaCompatibility(\n            TypeSerializer<SortedMap<K, V>> newSerializer) {\n        if (!(newSerializer instanceof SortedMapSerializer)) {\n            return TypeSerializerSchemaCompatibility.incompatible();\n        }\n        SortedMapSerializer newSortedMapSerializer = (SortedMapSerializer) newSerializer;\n        if (!comparator.equals(newSortedMapSerializer.getComparator())) {\n            return TypeSerializerSchemaCompatibility.incompatible();\n        } else {\n            return TypeSerializerSchemaCompatibility.compatibleAsIs();\n        }\n    }",
          "conflictNames": [
              "newSerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ac910542ccb78108cb130fe2368e97557afd9cc6^1/flink-tests/src/test/java/org/apache/flink/runtime/util/ExceptionUtilsITCase.java",
      "locators": [
          {
              "line": 45,
              "column": 92
          },
          {
              "line": 77,
              "column": 48
          },
          {
              "line": 89,
              "column": 21
          },
          {
              "line": 89,
              "column": 27
          },
          {
              "line": 90,
              "column": 55
          },
          {
              "line": 128,
              "column": 42
          },
          {
              "line": 150,
              "column": 42
          },
          {
              "line": 156,
              "column": 58
          },
          {
              "line": 159,
              "column": 55
          }
      ],
      "old_name": "arg",
      "new_name": "parameterValue",
      "ctx": {
          "symbolName": "arg",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in run(...)",
          "filePath": "ExceptionUtilsITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "aceSize > 0) {\n            taskManagerProcessBuilder.addJvmArg(\"-XX:-UseCompressedOops\");\n            taskManagerProcessBuilder.addJvmArg(\n                    String.format(\"-XX:MaxMetaspaceSize=%d\", metaspaceSize));\n        }\n        for (String arg : args) {\n            taskManagerProcessBuilder.addMainClassArg(arg);\n        }\n        // JAVA_TOOL_OPTIONS is configured on CI which would affect the process output\n        taskManagerProcessBuilder.withCleanEnvironment();\n        TestPr",
          "conflictNames": [
              "className",
              "args",
              "directMemorySize",
              "metaspaceSize",
              "taskManagerProcessBuilder",
              "p"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ac9d3436fa42ba36e1ea014b2a581e9ea11816ad^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/schema/CatalogSourceTable.java",
      "locators": [
          {
              "line": 110,
              "column": 36
          },
          {
              "line": 115,
              "column": 51
          },
          {
              "line": 154,
              "column": 56
          },
          {
              "line": 178,
              "column": 17
          }
      ],
      "old_name": "catalogTable",
      "new_name": "contextTableWithHints",
      "ctx": {
          "symbolName": "catalogTable",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ContextResolvedTable",
          "scopeHint": "in toRel(...)",
          "filePath": "CatalogSourceTable.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public RelNode toRel(ToRelContext toRelContext) {\n        final RelOptCluster cluster = toRelContext.getCluster();\n        final List<RelHint> hints = toRelContext.getTableHints();\n        final FlinkContext context = ShortcutUtils.unwrapContext(cluster);\n        final FlinkRelBuilder relBuilder = FlinkRelBuilder.of(cluster, relOptSchema);\n\n        // finalize catalog table with option hints\n        final Map<String, String> hintedOptions = FlinkHints.getHintedOptions(hints);\n        final ContextResolvedTable catalogTable =\n                computeContextResolvedTable(context, hintedOptions);\n\n        // create table source\n        final DynamicTableSource tableSource =\n                createDynamicTableSource(context, catalogTable.getResolvedTable());\n\n        // prepare table source and convert to RelNode\n        return DynamicSourceUtils.convertSourceToRel(\n                !schemaTable.isStreamingMode(),\n                context.getTableConfig(),\n                relBuilder,\n                schemaTable.getContextResolvedTable(),\n                schemaTable.getStatistic(),\n                hints,\n                tableSource);\n    }",
          "conflictNames": [
              "toRelContext",
              "cluster",
              "hints",
              "context",
              "relBuilder",
              "hintedOptions",
              "tableSource"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ade583cf80478ac60e9b83fc0a97f36bc2b26f1c^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/file/ProducerMergedPartitionFileReaderTest.java",
      "locators": [
          {
              "line": 23,
              "column": 44
          },
          {
              "line": 24,
              "column": 44
          },
          {
              "line": 84,
              "column": 18
          },
          {
              "line": 98,
              "column": 18
          },
          {
              "line": 98,
              "column": 35
          },
          {
              "line": 98,
              "column": 74
          },
          {
              "line": 99,
              "column": 20
          },
          {
              "line": 99,
              "column": 40
          },
          {
              "line": 100,
              "column": 24
          },
          {
              "line": 101,
              "column": 13
          },
          {
              "line": 119,
              "column": 18
          },
          {
              "line": 119,
              "column": 35
          },
          {
              "line": 119,
              "column": 74
          },
          {
              "line": 120,
              "column": 20
          },
          {
              "line": 120,
              "column": 40
          },
          {
              "line": 121,
              "column": 24
          },
          {
              "line": 127,
              "column": 37
          },
          {
              "line": 130,
              "column": 13
          },
          {
              "line": 160,
              "column": 26
          },
          {
              "line": 173,
              "column": 35
          },
          {
              "line": 181,
              "column": 17
          }
      ],
      "old_name": "buffer",
      "new_name": "buffers",
      "ctx": {
          "symbolName": "buffer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Buffer",
          "scopeHint": "in testReadBuffer(...)",
          "filePath": "ProducerMergedPartitionFileReaderTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testReadBuffer() throws IOException {\n        for (int bufferIndex = 0; bufferIndex < DEFAULT_BUFFER_NUMBER; ++bufferIndex) {\n            Buffer buffer = readBuffer(bufferIndex, DEFAULT_SUBPARTITION_ID);\n            assertThat(buffer).isNotNull();\n            buffer.recycleBuffer();\n        }\n        MemorySegment memorySegment =\n                MemorySegmentFactory.allocateUnpooledSegment(DEFAULT_BUFFER_SIZE);\n        assertThat(\n                        partitionFileReader.readBuffer(\n                                DEFAULT_PARTITION_ID,\n                                DEFAULT_SUBPARTITION_ID,\n                                DEFAULT_SEGMENT_ID,\n                                DEFAULT_BUFFER_NUMBER + 1,\n                                memorySegment,\n                                FreeingBufferRecycler.INSTANCE))\n                .isNull();\n    }",
          "conflictNames": [
              "bufferIndex",
              "memorySegment"
          ]
      },
      "suggestions": [
          {
              "name": "readBufferResult",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/ade583cf80478ac60e9b83fc0a97f36bc2b26f1c^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/file/ProducerMergedPartitionFileReaderTest.java",
      "locators": [
          {
              "line": 23,
              "column": 44
          },
          {
              "line": 24,
              "column": 44
          },
          {
              "line": 84,
              "column": 18
          },
          {
              "line": 98,
              "column": 18
          },
          {
              "line": 98,
              "column": 35
          },
          {
              "line": 98,
              "column": 74
          },
          {
              "line": 99,
              "column": 20
          },
          {
              "line": 99,
              "column": 40
          },
          {
              "line": 100,
              "column": 24
          },
          {
              "line": 101,
              "column": 13
          },
          {
              "line": 119,
              "column": 18
          },
          {
              "line": 119,
              "column": 35
          },
          {
              "line": 119,
              "column": 74
          },
          {
              "line": 120,
              "column": 20
          },
          {
              "line": 120,
              "column": 40
          },
          {
              "line": 121,
              "column": 24
          },
          {
              "line": 127,
              "column": 37
          },
          {
              "line": 130,
              "column": 13
          },
          {
              "line": 160,
              "column": 26
          },
          {
              "line": 173,
              "column": 35
          },
          {
              "line": 181,
              "column": 17
          }
      ],
      "old_name": "buffer",
      "new_name": "readBufferResult",
      "ctx": {
          "symbolName": "buffer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Buffer",
          "scopeHint": "in testReadBuffer(...)",
          "filePath": "ProducerMergedPartitionFileReaderTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testReadBuffer() throws IOException {\n        for (int bufferIndex = 0; bufferIndex < DEFAULT_BUFFER_NUMBER; ++bufferIndex) {\n            Buffer buffer = readBuffer(bufferIndex, DEFAULT_SUBPARTITION_ID);\n            assertThat(buffer).isNotNull();\n            buffer.recycleBuffer();\n        }\n        MemorySegment memorySegment =\n                MemorySegmentFactory.allocateUnpooledSegment(DEFAULT_BUFFER_SIZE);\n        assertThat(\n                        partitionFileReader.readBuffer(\n                                DEFAULT_PARTITION_ID,\n                                DEFAULT_SUBPARTITION_ID,\n                                DEFAULT_SEGMENT_ID,\n                                DEFAULT_BUFFER_NUMBER + 1,\n                                memorySegment,\n                                FreeingBufferRecycler.INSTANCE))\n                .isNull();\n    }",
          "conflictNames": [
              "bufferIndex",
              "memorySegment"
          ]
      },
      "suggestions": [
          {
              "name": "readBufferResult",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/ade583cf80478ac60e9b83fc0a97f36bc2b26f1c^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/file/ProducerMergedPartitionFileReaderTest.java",
      "locators": [
          {
              "line": 118,
              "column": 13
          },
          {
              "line": 128,
              "column": 32
          },
          {
              "line": 129,
              "column": 13
          }
      ],
      "old_name": "currentFileOffset",
      "new_name": "expectedBufferOffset",
      "ctx": {
          "symbolName": "currentFileOffset",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in testGetPriority(...)",
          "filePath": "ProducerMergedPartitionFileReaderTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testGetPriority() throws IOException {\n        int currentFileOffset = 0;\n        for (int bufferIndex = 0; bufferIndex < DEFAULT_BUFFER_NUMBER; ++bufferIndex) {\n            Buffer buffer = readBuffer(bufferIndex, DEFAULT_SUBPARTITION_ID);\n            assertThat(buffer).isNotNull();\n            assertThat(\n                            partitionFileReader.getPriority(\n                                    DEFAULT_PARTITION_ID,\n                                    DEFAULT_SUBPARTITION_ID,\n                                    DEFAULT_SEGMENT_ID,\n                                    bufferIndex))\n                    .isEqualTo(currentFileOffset);\n            currentFileOffset += (HEADER_LENGTH + DEFAULT_BUFFER_SIZE);\n            buffer.recycleBuffer();\n        }\n    }",
          "conflictNames": [
              "bufferIndex",
              "buffer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ade583cf80478ac60e9b83fc0a97f36bc2b26f1c^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/disk/DiskIOScheduler.java",
      "locators": [
          {
              "line": 24,
              "column": 44
          },
          {
              "line": 25,
              "column": 44
          },
          {
              "line": 60,
              "column": 36
          },
          {
              "line": 61,
              "column": 70
          },
          {
              "line": 77,
              "column": 12
          },
          {
              "line": 79,
              "column": 46
          },
          {
              "line": 82,
              "column": 30
          },
          {
              "line": 88,
              "column": 30
          },
          {
              "line": 90,
              "column": 46
          },
          {
              "line": 95,
              "column": 54
          },
          {
              "line": 95,
              "column": 71
          },
          {
              "line": 98,
              "column": 28
          },
          {
              "line": 101,
              "column": 39
          },
          {
              "line": 101,
              "column": 73
          },
          {
              "line": 102,
              "column": 58
          },
          {
              "line": 123,
              "column": 40
          },
          {
              "line": 126,
              "column": 22
          },
          {
              "line": 131,
              "column": 14
          },
          {
              "line": 131,
              "column": 40
          },
          {
              "line": 134,
              "column": 14
          },
          {
              "line": 134,
              "column": 50
          },
          {
              "line": 138,
              "column": 9
          },
          {
              "line": 179,
              "column": 13
          },
          {
              "line": 193,
              "column": 13
          },
          {
              "line": 206,
              "column": 30
          },
          {
              "line": 208,
              "column": 13
          },
          {
              "line": 211,
              "column": 42
          },
          {
              "line": 215,
              "column": 35
          },
          {
              "line": 221,
              "column": 17
          },
          {
              "line": 225,
              "column": 55
          },
          {
              "line": 231,
              "column": 52
          },
          {
              "line": 232,
              "column": 24
          },
          {
              "line": 254,
              "column": 33
          },
          {
              "line": 254,
              "column": 43
          },
          {
              "line": 255,
              "column": 18
          },
          {
              "line": 256,
              "column": 41
          },
          {
              "line": 282,
              "column": 54
          },
          {
              "line": 283,
              "column": 14
          },
          {
              "line": 285,
              "column": 17
          },
          {
              "line": 285,
              "column": 36
          },
          {
              "line": 286,
              "column": 17
          },
          {
              "line": 299,
              "column": 46
          },
          {
              "line": 301,
              "column": 46
          },
          {
              "line": 320,
              "column": 16
          },
          {
              "line": 320,
              "column": 63
          },
          {
              "line": 348,
              "column": 65
          },
          {
              "line": 357,
              "column": 21
          },
          {
              "line": 360,
              "column": 47
          },
          {
              "line": 361,
              "column": 24
          },
          {
              "line": 363,
              "column": 26
          },
          {
              "line": 372,
              "column": 25
          },
          {
              "line": 376,
              "column": 21
          },
          {
              "line": 381,
              "column": 33
          },
          {
              "line": 382,
              "column": 21
          }
      ],
      "old_name": "buffer",
      "new_name": "readBufferResult",
      "ctx": {
          "symbolName": "buffer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Buffer",
          "scopeHint": "in loadDiskDataToBuffers(...)",
          "filePath": "DiskIOScheduler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void loadDiskDataToBuffers(Queue<MemorySegment> buffers, BufferRecycler recycler)\n                throws IOException {\n\n            if (isFailed) {\n                throw new IOException(\n                        \"The scheduled subpartition reader for \"\n                                + subpartitionId\n                                + \" has already been failed.\");\n            }\n            while (!buffers.isEmpty()\n                    && nettyConnectionWriter.numQueuedBufferPayloads() < maxBufferReadAhead\n                    && nextSegmentId >= 0) {\n                MemorySegment memorySegment = buffers.poll();\n                Buffer buffer;\n                try {\n                    if ((buffer =\n                                    partitionFileReader.readBuffer(\n                                            partitionId,\n                                            subpartitionId,\n                                            nextSegmentId,\n                                            nextBufferIndex,\n                                            memorySegment,\n                                            recycler))\n                            == null) {\n                        buffers.add(memorySegment);\n                        break;\n                    }\n                } catch (Throwable throwable) {\n                    buffers.add(memorySegment);\n                    throw throwable;\n                }\n                writeToNettyConnectionWriter(\n                        NettyPayload.newBuffer(\n                                buffer, nextBufferIndex++, subpartitionId.getSubpartitionId()));\n                if (buffer.getDataType() == Buffer.DataType.END_OF_SEGMENT) {\n                    nextSegmentId = -1;\n                    updateSegmentId();\n                }\n            }\n        }",
          "conflictNames": [
              "buffers",
              "recycler",
              "memorySegment"
          ]
      },
      "suggestions": [
          {
              "name": "readBufferResult",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/ade583cf80478ac60e9b83fc0a97f36bc2b26f1c^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/RemoteTierConsumerAgent.java",
      "locators": [
          {
              "line": 24,
              "column": 44
          },
          {
              "line": 25,
              "column": 44
          },
          {
              "line": 46,
              "column": 28
          },
          {
              "line": 48,
              "column": 69
          },
          {
              "line": 55,
              "column": 23
          },
          {
              "line": 60,
              "column": 17
          },
          {
              "line": 64,
              "column": 14
          },
          {
              "line": 64,
              "column": 32
          },
          {
              "line": 77,
              "column": 39
          },
          {
              "line": 78,
              "column": 34
          },
          {
              "line": 82,
              "column": 34
          },
          {
              "line": 83,
              "column": 32
          },
          {
              "line": 88,
              "column": 17
          },
          {
              "line": 89,
              "column": 84
          },
          {
              "line": 90,
              "column": 16
          },
          {
              "line": 92,
              "column": 13
          },
          {
              "line": 102,
              "column": 55
          },
          {
              "line": 104,
              "column": 13
          },
          {
              "line": 108,
              "column": 32
          }
      ],
      "old_name": "buffer",
      "new_name": "readBufferResult",
      "ctx": {
          "symbolName": "buffer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Buffer",
          "scopeHint": "in getNextBuffer(...)",
          "filePath": "RemoteTierConsumerAgent.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public Optional<Buffer> getNextBuffer(\n            TieredStoragePartitionId partitionId,\n            TieredStorageSubpartitionId subpartitionId,\n            int segmentId) {\n        // Get current segment id and buffer index.\n        Tuple2<Integer, Integer> bufferIndexAndSegmentId =\n                currentBufferIndexAndSegmentIds\n                        .computeIfAbsent(partitionId, ignore -> new HashMap<>())\n                        .getOrDefault(subpartitionId, Tuple2.of(0, -1));\n        int currentBufferIndex = bufferIndexAndSegmentId.f0;\n        int currentSegmentId = bufferIndexAndSegmentId.f1;\n        if (segmentId != currentSegmentId) {\n            remoteStorageScanner.watchSegment(partitionId, subpartitionId, segmentId);\n        }\n\n        // Read buffer from the partition file in remote storage.\n        MemorySegment memorySegment = MemorySegmentFactory.allocateUnpooledSegment(bufferSizeBytes);\n        Buffer buffer = null;\n        try {\n            buffer =\n                    partitionFileReader.readBuffer(\n                            partitionId,\n                            subpartitionId,\n                            segmentId,\n                            currentBufferIndex,\n                            memorySegment,\n                            FreeingBufferRecycler.INSTANCE);\n        } catch (IOException e) {\n            memorySegment.free();\n            ExceptionUtils.rethrow(e, \"Failed to read buffer from partition file.\");\n        }\n        if (buffer != null) {\n            currentBufferIndexAndSegmentIds\n                    .get(partitionId)\n                    .put(subpartitionId, Tuple2.of(++currentBufferIndex, segmentId));\n            return Optional.of(buffer);\n        } else {\n            memorySegment.free();\n        }\n        return Optional.empty();\n    }",
          "conflictNames": [
              "partitionId",
              "subpartitionId",
              "segmentId",
              "bufferIndexAndSegmentId",
              "currentBufferIndex",
              "currentSegmentId",
              "memorySegment"
          ]
      },
      "suggestions": [
          {
              "name": "readBufferResult",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/ae8de97ef2acc798dae34ad2096ece8886bcf308^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SsgNetworkMemoryCalculationUtils.java",
      "locators": [
          {
              "line": 168,
              "column": 49
          },
          {
              "line": 179,
              "column": 17
          },
          {
              "line": 185,
              "column": 68
          }
      ],
      "old_name": "tmp",
      "new_name": "partitionReuseCount",
      "ctx": {
          "symbolName": "tmp",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Map<IntermediateDataSetID, Integer>",
          "scopeHint": "in getMaxInputChannelInfoForDynamicGraph(...)",
          "filePath": "SsgNetworkMemoryCalculationUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@VisibleForTesting\n    static void getMaxInputChannelInfoForDynamicGraph(\n            ExecutionJobVertex ejv, Map<IntermediateDataSetID, Integer> maxInputChannelNums) {\n\n        for (ExecutionVertex vertex : ejv.getTaskVertices()) {\n            Map<IntermediateDataSetID, Integer> tmp = new HashMap<>();\n\n            for (ConsumedPartitionGroup partitionGroup : vertex.getAllConsumedPartitionGroups()) {\n\n                IntermediateResultPartition resultPartition =\n                        ejv.getGraph().getResultPartitionOrThrow((partitionGroup.getFirst()));\n                IndexRange subpartitionIndexRange =\n                        vertex.getExecutionVertexInputInfo(\n                                        resultPartition.getIntermediateResult().getId())\n                                .getSubpartitionIndexRange();\n\n                tmp.merge(\n                        partitionGroup.getIntermediateDataSetID(),\n                        subpartitionIndexRange.size() * partitionGroup.size(),\n                        Integer::sum);\n            }\n\n            for (Map.Entry<IntermediateDataSetID, Integer> entry : tmp.entrySet()) {\n                maxInputChannelNums.merge(entry.getKey(), entry.getValue(), Integer::max);\n            }\n        }\n    }",
          "conflictNames": [
              "ejv",
              "maxInputChannelNums",
              "resultPartition",
              "subpartitionIndexRange"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/af22a07e7810fa120178ffce964016f459e51547^1/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/hooks/MasterHooksTest.java",
      "locators": [
          {
              "line": 56,
              "column": 24
          },
          {
              "line": 100,
              "column": 50
          },
          {
              "line": 135,
              "column": 36
          },
          {
              "line": 136,
              "column": 22
          },
          {
              "line": 137,
              "column": 16
          },
          {
              "line": 157,
              "column": 18
          },
          {
              "line": 160,
              "column": 38
          },
          {
              "line": 161,
              "column": 18
          },
          {
              "line": 161,
              "column": 28
          }
      ],
      "old_name": "command",
      "new_name": "onceRunnable",
      "ctx": {
          "symbolName": "command",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Runnable",
          "scopeHint": "in wrapHook(...)",
          "filePath": "MasterHooksTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void wrapHook() throws Exception {\n        final String id = \"id\";\n\n        Thread thread = Thread.currentThread();\n        final ClassLoader originalClassLoader = thread.getContextClassLoader();\n        final ClassLoader userClassLoader = new URLClassLoader(new URL[0]);\n\n        final Runnable command =\n                spy(\n                        new Runnable() {\n                            @Override\n                            public void run() {\n                                assertEquals(\n                                        userClassLoader,\n                                        Thread.currentThread().getContextClassLoader());\n                            }\n                        });\n\n        MasterTriggerRestoreHook<String> hook =\n                spy(\n                        new MasterTriggerRestoreHook<String>() {\n                            @Override\n                            public String getIdentifier() {\n                                assertEquals(\n                                        userClassLoader,\n                                        Thread.currentThread().getContextClassLoader());\n                                return id;\n                            }\n\n                            @Override\n                            public void reset() throws Exception {\n                                assertEquals(\n                                        userClassLoader,\n                                        Thread.currentThread().getContextClassLoader());\n                            }\n\n                            @Override\n                            public void close() throws Exception {\n                                assertEquals(\n                                        userClassLoader,\n                                        Thread.currentThread().getContextClassLoader());\n                            }\n\n                            @Nullable\n                            @Override\n                            public CompletableFuture<String> triggerCheckpoint(\n                                    long checkpointId, long timestamp, Executor executor)\n                                    throws Exception {\n                                assertEquals(\n                                        userClassLoader,\n                                        Thread.currentThread().getContextClassLoader());\n                                executor.execute(command);\n                                return null;\n                            }\n\n                            @Override\n                            public void restoreCheckpoint(\n                                    long checkpointId, @Nullable String checkpointData)\n                                    throws Exception {\n                                assertEquals(\n                                        userClassLoader,\n                                        Thread.currentThread().getContextClassLoader());\n                            }\n\n                            @Nullable\n                            @Override\n                            public SimpleVersionedSerializer<String>\n                                    createCheckpointDataSerializer() {\n                                assertEquals(\n                                        userClassLoader,\n                                        Thread.currentThread().getContextClassLoader());\n                                return null;\n                            }\n                        });\n\n        MasterTriggerRestoreHook<String> wrapped = MasterHooks.wrapHook(hook, userClassLoader);\n\n        // verify getIdentifier\n        wrapped.getIdentifier();\n        verify(hook, times(1)).getIdentifier();\n        assertEquals(originalClassLoader, thread.getContextClassLoader());\n\n        // verify triggerCheckpoint and its wrapped executor\n        TestExecutor testExecutor = new TestExecutor();\n        wrapped.triggerCheckpoint(0L, 0, testExecutor);\n        assertEquals(originalClassLoader, thread.getContextClassLoader());\n        assertNotNull(testExecutor.command);\n        testExecutor.command.run();\n        verify(command, times(1)).run();\n        assertEquals(originalClassLoader, thread.getContextClassLoader());\n\n        // verify restoreCheckpoint\n        wrapped.restoreCheckpoint(0L, \"\");\n        verify(hook, times(1)).restoreCheckpoint(eq(0L), eq(\"\"));\n        assertEquals(originalClassLoader, thread.getContextClassLoader());\n\n        // verify createCheckpointDataSerializer\n        wrapped.createCheckpointDataSerializer();\n        verify(hook, times(1)).createCheckpointDataSerializer();\n        assertEquals(originalClassLoader, thread.getContextClassLoader());\n\n        // verify close\n        wrapped.close();\n        verify(hook, times(1)).close();\n        assertEquals(originalClassLoader, thread.getContextClassLoader());\n    }",
          "conflictNames": [
              "id",
              "thread",
              "originalClassLoader",
              "userClassLoader",
              "hook",
              "wrapped",
              "testExecutor"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/af9a1128f728c691b896bc9c591e9be1327601c4^1/flink-table/flink-table-code-splitter/src/main/java/org/apache/flink/table/codesplit/IfStatementRewriter.java",
      "locators": [
          {
              "line": 155,
              "column": 32
          },
          {
              "line": 164,
              "column": 32
          },
          {
              "line": 174,
              "column": 41
          },
          {
              "line": 175,
              "column": 75
          },
          {
              "line": 191,
              "column": 32
          },
          {
              "line": 200,
              "column": 32
          },
          {
              "line": 210,
              "column": 41
          },
          {
              "line": 211,
              "column": 75
          }
      ],
      "old_name": "newMethod",
      "new_name": "newMethodDefinitions",
      "ctx": {
          "symbolName": "newMethod",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in visitMethodDeclaration(...)",
          "filePath": "IfStatementRewriter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public Void visitMethodDeclaration(JavaParser.MethodDeclarationContext ctx) {\n\n            if (!\"void\".equals(ctx.typeTypeOrVoid().getText())) {\n                return null;\n            }\n\n            // function real parameters\n            LinkedHashSet<String> declarationContext = new LinkedHashSet<>();\n            new JavaParserBaseVisitor<Void>() {\n                @Override\n                public Void visitFormalParameter(JavaParser.FormalParameterContext ctx) {\n                    declarationContext.add(ctx.variableDeclaratorId().getText());\n                    return null;\n                }\n            }.visit(ctx);\n\n            String type = CodeSplitUtil.getContextString(ctx.typeTypeOrVoid());\n            String functionName = ctx.IDENTIFIER().getText();\n            String parameters = CodeSplitUtil.getContextString(ctx.formalParameters());\n\n            String methodQualifier = \"\";\n            if (ctx.THROWS() != null) {\n                methodQualifier =\n                        \" throws \" + CodeSplitUtil.getContextString(ctx.qualifiedNameList());\n            }\n\n            for (JavaParser.BlockStatementContext blockStatementContext :\n                    ctx.methodBody().block().blockStatement()) {\n\n                if (blockStatementContext.statement() != null\n                        && blockStatementContext.statement().IF() != null\n                        && blockStatementContext.statement().getText().length() > maxMethodLength) {\n                    if (shouldExtract(blockStatementContext.statement().statement(0))) {\n                        long counter = CodeSplitUtil.getCounter().incrementAndGet();\n\n                        String methodDef =\n                                type\n                                        + \" \"\n                                        + functionName\n                                        + \"_trueFilter\"\n                                        + counter\n                                        + parameters\n                                        + methodQualifier;\n\n                        String newMethod =\n                                methodDef\n                                        + CodeSplitUtil.getContextString(\n                                                blockStatementContext\n                                                        .statement()\n                                                        .statement(0)\n                                                        .block())\n                                        + \"\\n\";\n\n                        String newMethodCall =\n                                functionName\n                                        + \"_trueFilter\"\n                                        + counter\n                                        + \"(\"\n                                        + String.join(\", \", declarationContext)\n                                        + \");\\n\";\n                        rewriter.replace(\n                                blockStatementContext.statement().statement(0).block().start,\n                                blockStatementContext.statement().statement(0).block().stop,\n                                \"{\\n\" + newMethodCall + \"\\n}\\n\");\n                        rewriter.insertAfter(ctx.getParent().stop, \"\\n\" + newMethod + \"\\n\");\n                        rewriteCount++;\n                    }\n\n                    if (shouldExtract(blockStatementContext.statement().statement(1))) {\n                        long counter = CodeSplitUtil.getCounter().incrementAndGet();\n\n                        String methodDef =\n                                type\n                                        + \" \"\n                                        + functionName\n                                        + \"_falseFilter\"\n                                        + counter\n                                        + parameters\n                                        + methodQualifier;\n\n                        String newMethod =\n                                methodDef\n                                        + CodeSplitUtil.getContextString(\n                                                blockStatementContext\n                                                        .statement()\n                                                        .statement(1)\n                                                        .block())\n                                        + \"\\n\";\n\n                        String newMethodCall =\n                                functionName\n                                        + \"_falseFilter\"\n                                        + counter\n                                        + \"(\"\n                                        + String.join(\", \", declarationContext)\n                                        + \");\\n\";\n                        rewriter.replace(\n                                blockStatementContext.statement().statement(1).block().start,\n                                blockStatementContext.statement().statement(1).block().stop,\n                                \"{\\n\" + newMethodCall + \"\\n}\\n\");\n                        rewriter.insertAfter(ctx.getParent().stop, \"\\n\" + newMethod + \"\\n\");\n                        rewriteCount++;\n                    }\n                }\n            }\n            return null;\n        }",
          "conflictNames": [
              "ctx",
              "declarationContext",
              "type",
              "functionName",
              "parameters",
              "methodQualifier",
              "counter",
              "methodDef",
              "newMethodCall",
              "newMethod"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/b1148f0e2cf3671b4e02b725603ab34dbc37a3bc^1/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/nodes/exec/serde/LookupKeySerdeTest.java",
      "locators": [
          {
              "line": 43,
              "column": 36
          },
          {
              "line": 50,
              "column": 39
          },
          {
              "line": 50,
              "column": 51
          },
          {
              "line": 53,
              "column": 61
          },
          {
              "line": 55,
              "column": 42
          }
      ],
      "old_name": "lookupKey",
      "new_name": "param",
      "ctx": {
          "symbolName": "lookupKey",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "LookupKey",
          "scopeHint": "in testLookupKey(...)",
          "filePath": "LookupKeySerdeTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "ntLookupKey(\n                            new BigIntType(),\n                            new RexBuilder(serdeCtx.getTypeFactory()).makeLiteral(\"a\")),\n                    new LookupJoinUtil.FieldRefLookupKey(3)\n                };\n        for (LookupJoinUtil.LookupKey lookupKey : lookupKeys) {\n            LookupJoinUtil.LookupKey result =\n                    objectReader.readValue(\n                            objectWriter.writeValueAsString(lookupKey),\n                            LookupJoinUtil.LookupKey.class);\n",
          "conflictNames": [
              "serdeCtx",
              "objectReader",
              "objectWriter",
              "lookupKeys",
              "result"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/b1148f0e2cf3671b4e02b725603ab34dbc37a3bc^1/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/nodes/exec/serde/LookupKeySerdeTest.java",
      "locators": [
          {
              "line": 43,
              "column": 36
          },
          {
              "line": 50,
              "column": 51
          }
      ],
      "old_name": "lookupKeys",
      "new_name": "functionParams",
      "ctx": {
          "symbolName": "lookupKeys",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "LookupKey[]",
          "scopeHint": "in testLookupKey(...)",
          "filePath": "LookupKeySerdeTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testLookupKey() throws IOException {\n        SerdeContext serdeCtx = JsonSerdeTestUtil.configuredSerdeContext();\n        ObjectReader objectReader = CompiledPlanSerdeUtil.createJsonObjectReader(serdeCtx);\n        ObjectWriter objectWriter = CompiledPlanSerdeUtil.createJsonObjectWriter(serdeCtx);\n\n        LookupJoinUtil.LookupKey[] lookupKeys =\n                new LookupJoinUtil.LookupKey[] {\n                    new LookupJoinUtil.ConstantLookupKey(\n                            new BigIntType(),\n                            new RexBuilder(serdeCtx.getTypeFactory()).makeLiteral(\"a\")),\n                    new LookupJoinUtil.FieldRefLookupKey(3)\n                };\n        for (LookupJoinUtil.LookupKey lookupKey : lookupKeys) {\n            LookupJoinUtil.LookupKey result =\n                    objectReader.readValue(\n                            objectWriter.writeValueAsString(lookupKey),\n                            LookupJoinUtil.LookupKey.class);\n            assertThat(result).isEqualTo(lookupKey);\n        }\n    }",
          "conflictNames": [
              "serdeCtx",
              "objectReader",
              "objectWriter",
              "result"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/b1786ba952bb81e8180cac9c5c95c2fc46e44fb7^1/flink-runtime/src/test/java/org/apache/flink/runtime/deployment/TaskDeploymentDescriptorTest.java",
      "locators": [
          {
              "line": 139,
              "column": 41
          },
          {
              "line": 141,
              "column": 20
          }
      ],
      "old_name": "actualSerializedJobInformation",
      "new_name": "actualJobInformation",
      "ctx": {
          "symbolName": "actualSerializedJobInformation",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SerializedValue<JobInformation>",
          "scopeHint": "in testOffLoadedAndNonOffLoadedPayload(...)",
          "filePath": "TaskDeploymentDescriptorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testOffLoadedAndNonOffLoadedPayload() {\n        final TaskDeploymentDescriptor taskDeploymentDescriptor =\n                createTaskDeploymentDescriptor(\n                        new TaskDeploymentDescriptor.NonOffloaded<>(serializedJobInformation),\n                        new TaskDeploymentDescriptor.Offloaded<>(new PermanentBlobKey()));\n\n        SerializedValue<JobInformation> actualSerializedJobInformation =\n                taskDeploymentDescriptor.getSerializedJobInformation();\n        assertThat(actualSerializedJobInformation).isSameAs(serializedJobInformation);\n\n        assertThatThrownBy(taskDeploymentDescriptor::getSerializedTaskInformation)\n                .isInstanceOf(IllegalStateException.class);\n    }",
          "conflictNames": [
              "taskDeploymentDescriptor"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/b48cddf12a3171cf1b6ddaa675a6b81eea1254bf^1/flink-table/flink-sql-gateway/src/test/java/org/apache/flink/table/gateway/rest/SqlGatewayRestEndpointITCase.java",
      "locators": [
          {
              "line": 169,
              "column": 41
          },
          {
              "line": 178,
              "column": 38
          }
      ],
      "old_name": "unspecifiedVersionResponse",
      "new_name": "unspecifiedVersionResponse0",
      "ctx": {
          "symbolName": "unspecifiedVersionResponse",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CompletableFuture<TestResponse>",
          "scopeHint": "in testSqlGatewayMessageHeaders(...)",
          "filePath": "SqlGatewayRestEndpointITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Test that {@link SqlGatewayMessageHeaders} can identify the version correctly. */\n    @Test\n    void testSqlGatewayMessageHeaders() throws Exception {\n        // The header only support V1, but send request by V0\n        assertThatThrownBy(\n                        () ->\n                                restClient.sendRequest(\n                                        serverAddress.getHostName(),\n                                        serverAddress.getPort(),\n                                        header2,\n                                        EmptyMessageParameters.getInstance(),\n                                        EmptyRequestBody.getInstance(),\n                                        Collections.emptyList(),\n                                        SqlGatewayRestAPIVersion.V0))\n                .isInstanceOf(IllegalArgumentException.class);\n\n        // The header only support V1, send request by V1\n        CompletableFuture<TestResponse> specifiedVersionResponse =\n                restClient.sendRequest(\n                        serverAddress.getHostName(),\n                        serverAddress.getPort(),\n                        header2,\n                        EmptyMessageParameters.getInstance(),\n                        EmptyRequestBody.getInstance(),\n                        Collections.emptyList(),\n                        SqlGatewayRestAPIVersion.V1);\n\n        TestResponse testResponse1 = specifiedVersionResponse.get(5, TimeUnit.SECONDS);\n        assertThat(testResponse1.getStatus()).isEqualTo(\"V1\");\n\n        // The header only support V1, send request by latest version V1\n        CompletableFuture<TestResponse> unspecifiedVersionResponse =\n                restClient.sendRequest(\n                        serverAddress.getHostName(),\n                        serverAddress.getPort(),\n                        header2,\n                        EmptyMessageParameters.getInstance(),\n                        EmptyRequestBody.getInstance(),\n                        Collections.emptyList());\n\n        TestResponse testResponse2 = unspecifiedVersionResponse.get(5, TimeUnit.SECONDS);\n        assertThat(testResponse2.getStatus()).isEqualTo(\"V1\");\n    }",
          "conflictNames": [
              "specifiedVersionResponse",
              "testResponse1",
              "testResponse2"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/b48cddf12a3171cf1b6ddaa675a6b81eea1254bf^1/flink-table/flink-sql-gateway/src/test/java/org/apache/flink/table/gateway/rest/SqlGatewayRestEndpointITCase.java",
      "locators": [
          {
              "line": 185,
              "column": 41
          },
          {
              "line": 195,
              "column": 37
          }
      ],
      "old_name": "version1Response",
      "new_name": "versionResponse",
      "ctx": {
          "symbolName": "version1Response",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CompletableFuture<TestResponse>",
          "scopeHint": "in testVersionSelection(...)",
          "filePath": "SqlGatewayRestEndpointITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Test that requests of different version are routed to correct handlers. */\n    @Test\n    void testVersionSelection() throws Exception {\n        CompletableFuture<TestResponse> version1Response =\n                restClient.sendRequest(\n                        serverAddress.getHostName(),\n                        serverAddress.getPort(),\n                        header1,\n                        EmptyMessageParameters.getInstance(),\n                        EmptyRequestBody.getInstance(),\n                        Collections.emptyList(),\n                        SqlGatewayRestAPIVersion.V0);\n\n        TestResponse testResponse = version1Response.get(5, TimeUnit.SECONDS);\n        assertThat(testResponse.getStatus()).isEqualTo(\"V0\");\n\n        CompletableFuture<TestResponse> version2Response =\n                restClient.sendRequest(\n                        serverAddress.getHostName(),\n                        serverAddress.getPort(),\n                        header2,\n                        EmptyMessageParameters.getInstance(),\n                        EmptyRequestBody.getInstance(),\n                        Collections.emptyList(),\n                        SqlGatewayRestAPIVersion.V1);\n        TestResponse testResponse2 = version2Response.get(5, TimeUnit.SECONDS);\n        assertThat(testResponse2.getStatus()).isEqualTo(\"V1\");\n    }",
          "conflictNames": [
              "testResponse",
              "version2Response",
              "testResponse2"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/b4eb8ac503f41fd793db1ac662fbedc46af92fd5^1/flink-yarn/src/test/java/org/apache/flink/yarn/UtilsTest.java",
      "locators": [
          {
              "line": 228,
              "column": 22
          },
          {
              "line": 456,
              "column": 54
          },
          {
              "line": 473,
              "column": 33
          },
          {
              "line": 498,
              "column": 33
          },
          {
              "line": 526,
              "column": 33
          },
          {
              "line": 552,
              "column": 33
          },
          {
              "line": 586,
              "column": 33
          },
          {
              "line": 622,
              "column": 33
          }
      ],
      "old_name": "jvmOpts",
      "new_name": "defaultJvmOpts",
      "ctx": {
          "symbolName": "jvmOpts",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in testGetTaskManagerShellCommand(...)",
          "filePath": "UtilsTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testGetTaskManagerShellCommand() {\n        final Configuration cfg = new Configuration();\n        final TaskExecutorProcessSpec taskExecutorProcessSpec =\n                new TaskExecutorProcessSpec(\n                        new CPUResource(1.0),\n                        new MemorySize(0), // frameworkHeapSize\n                        new MemorySize(0), // frameworkOffHeapSize\n                        new MemorySize(111), // taskHeapSize\n                        new MemorySize(0), // taskOffHeapSize\n                        new MemorySize(222), // networkMemSize\n                        new MemorySize(0), // managedMemorySize\n                        new MemorySize(333), // jvmMetaspaceSize\n                        new MemorySize(0), // jvmOverheadSize\n                        Collections.emptyList());\n        final ContaineredTaskManagerParameters containeredParams =\n                new ContaineredTaskManagerParameters(taskExecutorProcessSpec, new HashMap<>());\n\n        // no logging, with/out krb5\n        final String java = \"$JAVA_HOME/bin/java\";\n        final String jvmmem =\n                \"-Xmx111 -Xms111 -XX:MaxDirectMemorySize=222 -XX:MaxMetaspaceSize=333\";\n        final String jvmOpts = \"-Djvm\"; // if set\n        final String tmJvmOpts = \"-DtmJvm\"; // if set\n        final String logfile = \"-Dlog.file=./logs/taskmanager.log\"; // if set\n        final String logback = \"-Dlogback.configurationFile=file:./conf/logback.xml\"; // if set\n        final String log4j =\n                \"-Dlog4j.configuration=file:./conf/log4j.properties\"\n                        + \" -Dlog4j.configurationFile=file:./conf/log4j.properties\"; // if set\n        final String mainClass = \"org.apache.flink.yarn.UtilsTest\";\n        final String dynamicConfigs =\n                TaskExecutorProcessUtils.generateDynamicConfigsStr(taskExecutorProcessSpec).trim();\n        final String basicArgs = \"--configDir ./conf\";\n        final String mainArgs = \"-Djobmanager.rpc.address=host1 -Dkey.a=v1\";\n        final String args = dynamicConfigs + \" \" + basicArgs + \" \" + mainArgs;\n        final String redirects = \"1> ./logs/taskmanager.out 2> ./logs/taskmanager.err\";\n\n        assertThat(\n                        Utils.getTaskManagerShellCommand(\n                                cfg,\n                                containeredParams,\n                                \"./conf\",\n                                \"./logs\",\n                                false,\n                                false,\n                                false,\n                                this.getClass(),\n                                \"\"))\n                .isEqualTo(\n                        String.join(\n                                \" \",\n                                java,\n                                jvmmem,\n                                Utils.IGNORE_UNRECOGNIZED_VM_OPTIONS,\n                                mainClass,\n                                dynamicConfigs,\n                                basicArgs,\n                                redirects));\n\n        assertThat(\n                        Utils.getTaskManagerShellCommand(\n                                cfg,\n                                containeredParams,\n                                \"./conf\",\n                                \"./logs\",\n                                false,\n                                false,\n                                false,\n                                this.getClass(),\n                                mainArgs))\n                .isEqualTo(\n                        String.join(\n                                \" \",\n                                java,\n                                jvmmem,\n                                Utils.IGNORE_UNRECOGNIZED_VM_OPTIONS,\n                                mainClass,\n                                args,\n                                redirects));\n\n        final String krb5 = \"-Djava.security.krb5.conf=krb5.conf\";\n        assertThat(\n                        Utils.getTaskManagerShellCommand(\n                                cfg,\n                                containeredParams,\n                                \"./conf\",\n                                \"./logs\",\n                                false,\n                                false,\n                                true,\n                                this.getClass(),\n                                mainArgs))\n                .isEqualTo(\n                        String.join(\n                                \" \",\n                                java,\n                                jvmmem,\n                                Utils.IGNORE_UNRECOGNIZED_VM_OPTIONS,\n                                krb5,\n                                mainClass,\n                                args,\n                                redirects));\n\n        // logback only, with/out krb5\n        assertThat(\n                        Utils.getTaskManagerShellCommand(\n                                cfg,\n                                containeredParams,\n                                \"./conf\",\n                                \"./logs\",\n                                true,\n                                false,\n                                false,\n                                this.getClass(),\n                                mainArgs))\n                .isEqualTo(\n                        String.join(\n                                \" \",\n                                java,\n                                jvmmem,\n                                Utils.IGNORE_UNRECOGNIZED_VM_OPTIONS,\n                                logfile,\n                                logback,\n                                mainClass,\n                                args,\n                                redirects));\n\n        assertThat(\n                        Utils.getTaskManagerShellCommand(\n                                cfg,\n                                containeredParams,\n                                \"./conf\",\n                                \"./logs\",\n                                true,\n                                false,\n                                true,\n                                this.getClass(),\n                                mainArgs))\n                .isEqualTo(\n                        String.join(\n                                \" \",\n                                java,\n                                jvmmem,\n                                Utils.IGNORE_UNRECOGNIZED_VM_OPTIONS,\n                                krb5,\n                                logfile,\n                                logback,\n                                mainClass,\n                                args,\n                                redirects));\n\n        // log4j, with/out krb5\n        assertThat(\n                        Utils.getTaskManagerShellCommand(\n                                cfg,\n                                containeredParams,\n                                \"./conf\",\n                                \"./logs\",\n                                false,\n                                true,\n                                false,\n                                this.getClass(),\n                                mainArgs))\n                .isEqualTo(\n                        String.join(\n                                \" \",\n                                java,\n                                jvmmem,\n                                Utils.IGNORE_UNRECOGNIZED_VM_OPTIONS,\n                                logfile,\n                                log4j,\n                                mainClass,\n                                args,\n                                redirects));\n\n        assertThat(\n                        Utils.getTaskManagerShellCommand(\n                                cfg,\n                                containeredParams,\n                                \"./conf\",\n                                \"./logs\",\n                                false,\n                                true,\n                                true,\n                                this.getClass(),\n                                mainArgs))\n                .isEqualTo(\n                        String.join(\n                                \" \",\n                                java,\n                                jvmmem,\n                                Utils.IGNORE_UNRECOGNIZED_VM_OPTIONS,\n                                krb5,\n                                logfile,\n                                log4j,\n                                mainClass,\n                                args,\n                                redirects));\n\n        // logback + log4j, with/out krb5\n        assertThat(\n                        Utils.getTaskManagerShellCommand(\n                                cfg,\n                                containeredParams,\n                                \"./conf\",\n                                \"./logs\",\n                                true,\n                                true,\n                                false,\n                                this.getClass(),\n                                mainArgs))\n                .isEqualTo(\n                        String.join(\n                                \" \",\n                                java,\n                                jvmmem,\n                                Utils.IGNORE_UNRECOGNIZED_VM_OPTIONS,\n                                logfile,\n                                logback,\n                                log4j,\n                                mainClass,\n                                args,\n                                redirects));\n\n        assertThat(\n                        Utils.getTaskManagerShellCommand(\n                                cfg,\n                                containeredParams,\n                                \"./conf\",\n                                \"./logs\",\n                                true,\n                                true,\n                                true,\n                                this.getClass(),\n                                mainArgs))\n                .isEqualTo(\n                        String.join(\n                                \" \",\n                                java,\n                                jvmmem,\n                                Utils.IGNORE_UNRECOGNIZED_VM_OPTIONS,\n                                krb5,\n                                logfile,\n                                logback,\n                                log4j,\n                                mainClass,\n                                args,\n                                redirects));\n\n        // logback + log4j, with/out krb5, different JVM opts\n        cfg.setString(CoreOptions.FLINK_JVM_OPTIONS, jvmOpts);\n        assertThat(\n                        Utils.getTaskManagerShellCommand(\n                                cfg,\n                                containeredParams,\n                                \"./conf\",\n                                \"./logs\",\n                                true,\n                                true,\n                                false,\n                                this.getClass(),\n                                mainArgs))\n                .isEqualTo(\n                        String.join(\n                                \" \",\n                                java,\n                                jvmmem,\n                                jvmOpts,\n                                Utils.IGNORE_UNRECOGNIZED_VM_OPTIONS,\n                                logfile,\n                                logback,\n                                log4j,\n                                mainClass,\n                                args,\n                                redirects));\n\n        assertThat(\n                        Utils.getTaskManagerShellCommand(\n                                cfg,\n                                containeredParams,\n                                \"./conf\",\n                                \"./logs\",\n                                true,\n                                true,\n                                true,\n                                this.getClass(),\n                                mainArgs))\n                .isEqualTo(\n                        String.join(\n                                \" \",\n                                java,\n                                jvmmem,\n                                jvmOpts,\n                                Utils.IGNORE_UNRECOGNIZED_VM_OPTIONS,\n                                krb5,\n                                logfile,\n                                logback,\n                                log4j,\n                                mainClass,\n                                args,\n                                redirects));\n\n        // logback + log4j, with/out krb5, different JVM opts\n        cfg.setString(CoreOptions.FLINK_TM_JVM_OPTIONS, tmJvmOpts);\n        assertThat(\n                        Utils.getTaskManagerShellCommand(\n                                cfg,\n                                containeredParams,\n                                \"./conf\",\n                                \"./logs\",\n                                true,\n                                true,\n                                false,\n                                this.getClass(),\n                                mainArgs))\n                .isEqualTo(\n                        String.join(\n                                \" \",\n                                java,\n                                jvmmem,\n                                jvmOpts,\n                                tmJvmOpts,\n                                Utils.IGNORE_UNRECOGNIZED_VM_OPTIONS,\n                                logfile,\n                                logback,\n                                log4j,\n                                mainClass,\n                                args,\n                                redirects));\n\n        assertThat(\n                        Utils.getTaskManagerShellCommand(\n                                cfg,\n                                containeredParams,\n                                \"./conf\",\n                                \"./logs\",\n                                true,\n                                true,\n                                true,\n                                this.getClass(),\n                                mainArgs))\n                .isEqualTo(\n                        String.join(\n                                \" \",\n                                java,\n                                jvmmem,\n                                jvmOpts,\n                                tmJvmOpts,\n                                Utils.IGNORE_UNRECOGNIZED_VM_OPTIONS,\n                                krb5,\n                                logfile,\n                                logback,\n                                log4j,\n                                mainClass,\n                                args,\n                                redirects));\n\n        // now try some configurations with different yarn.container-start-command-template\n\n        cfg.set(\n                YARN_CONTAINER_START_COMMAND_TEMPLATE,\n                \"%java% 1 %jvmmem% 2 %jvmopts% 3 %logging% 4 %class% 5 %args% 6 %redirects%\");\n        assertThat(\n                        Utils.getTaskManagerShellCommand(\n                                cfg,\n                                containeredParams,\n                                \"./conf\",\n                                \"./logs\",\n                                true,\n                                true,\n                                true,\n                                this.getClass(),\n                                mainArgs))\n                .isEqualTo(\n                        String.join(\n                                \" \",\n                                java,\n                                \"1\",\n                                jvmmem,\n                                \"2\",\n                                jvmOpts,\n                                tmJvmOpts,\n                                Utils.IGNORE_UNRECOGNIZED_VM_OPTIONS,\n                                krb5,\n                                \"3\",\n                                logfile,\n                                logback,\n                                log4j,\n                                \"4\",\n                                mainClass,\n                                \"5\",\n                                args,\n                                \"6\",\n                                redirects));\n\n        cfg.set(\n                YARN_CONTAINER_START_COMMAND_TEMPLATE,\n                \"%java% %logging% %jvmopts% %jvmmem% %class% %args% %redirects%\");\n        assertThat(\n                        Utils.getTaskManagerShellCommand(\n                                cfg,\n                                containeredParams,\n                                \"./conf\",\n                                \"./logs\",\n                                true,\n                                true,\n                                true,\n                                this.getClass(),\n                                mainArgs))\n                .isEqualTo(\n                        String.join(\n                                \" \",\n                                java,\n                                logfile,\n                                logback,\n                                log4j,\n                                jvmOpts,\n                                tmJvmOpts,\n                                Utils.IGNORE_UNRECOGNIZED_VM_OPTIONS,\n                                krb5,\n                                jvmmem,\n                                mainClass,\n                                args,\n                                redirects));\n    }",
          "conflictNames": [
              "cfg",
              "taskExecutorProcessSpec",
              "containeredParams",
              "java",
              "jvmmem",
              "tmJvmOpts",
              "logfile",
              "logback",
              "log4j",
              "mainClass",
              "dynamicConfigs",
              "basicArgs",
              "mainArgs",
              "args",
              "redirects",
              "krb5"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/b51ee30c3d1a212947398d880a676f07f46f36be^1/flink-runtime/src/main/java/org/apache/flink/runtime/failure/FailureEnricherUtils.java",
      "locators": [
          {
              "line": 78,
              "column": 21
          },
          {
              "line": 80,
              "column": 13
          },
          {
              "line": 90,
              "column": 17
          },
          {
              "line": 105,
              "column": 25
          },
          {
              "line": 120,
              "column": 22
          },
          {
              "line": 123,
              "column": 32
          }
      ],
      "old_name": "includedEnrichers",
      "new_name": "enrichersToLoad",
      "ctx": {
          "symbolName": "includedEnrichers",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Set<String>",
          "scopeHint": "in getFailureEnrichers(...)",
          "filePath": "FailureEnricherUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@VisibleForTesting\n    static Collection<FailureEnricher> getFailureEnrichers(\n            final Configuration configuration, final PluginManager pluginManager) {\n        Set<String> includedEnrichers = getIncludedFailureEnrichers(configuration);\n        //  When empty, NO enrichers will be started.\n        if (includedEnrichers.isEmpty()) {\n            return Collections.emptySet();\n        }\n        final Iterator<FailureEnricherFactory> factoryIterator =\n                pluginManager.load(FailureEnricherFactory.class);\n        final Set<FailureEnricher> failureEnrichers = new HashSet<>();\n        while (factoryIterator.hasNext()) {\n            final FailureEnricherFactory failureEnricherFactory = factoryIterator.next();\n            final FailureEnricher failureEnricher =\n                    failureEnricherFactory.createFailureEnricher(configuration);\n            if (includedEnrichers.contains(failureEnricher.getClass().getName())) {\n                failureEnrichers.add(failureEnricher);\n                LOG.info(\n                        \"Found failure enricher {} at {}.\",\n                        failureEnricherFactory.getClass().getName(),\n                        failureEnricher\n                                .getClass()\n                                .getProtectionDomain()\n                                .getCodeSource()\n                                .getLocation()\n                                .getPath());\n            } else {\n                LOG.debug(\n                        \"Excluding failure enricher {}, not configured in enricher list ({}).\",\n                        failureEnricherFactory.getClass().getName(),\n                        includedEnrichers);\n            }\n        }\n\n        return filterInvalidEnrichers(failureEnrichers);\n    }",
          "conflictNames": [
              "configuration",
              "pluginManager",
              "factoryIterator",
              "failureEnrichers",
              "failureEnricherFactory",
              "failureEnricher"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/b5f465036d28ed422a1218bfb8549cbf3e6ecd2e^1/flink-connectors/flink-connector-files/src/main/java/org/apache/flink/connector/file/table/PartitionLoader.java",
      "locators": [
          {
              "line": 79,
              "column": 82
          },
          {
              "line": 89,
              "column": 31
          },
          {
              "line": 94,
              "column": 45
          },
          {
              "line": 96,
              "column": 31
          },
          {
              "line": 128,
              "column": 51
          },
          {
              "line": 133,
              "column": 19
          },
          {
              "line": 150,
              "column": 26
          },
          {
              "line": 151,
              "column": 39
          },
          {
              "line": 152,
              "column": 19
          },
          {
              "line": 152,
              "column": 28
          },
          {
              "line": 153,
              "column": 18
          },
          {
              "line": 154,
              "column": 69
          }
      ],
      "old_name": "srcDir",
      "new_name": "srcPath",
      "ctx": {
          "symbolName": "srcDir",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Path",
          "scopeHint": "in moveFiles(...)",
          "filePath": "PartitionLoader.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "      destFS.delete(existingFile.getPath(), true);\n                }\n            }\n        }\n    }\n\n    /** Moves files from srcDir to destDir. */\n    private void moveFiles(List<Path> srcDirs, Path destDir) throws Exception {\n        for (Path srcDir : srcDirs) {\n            if (!srcDir.equals(destDir)) {\n                FileStatus[] srcFiles = listStatusWithoutHidden(fs, srcDir);\n                if (srcFiles != null) {\n                    for (FileStatus srcFile : srcFiles) {\n        ",
          "conflictNames": [
              "srcDirs",
              "destDir",
              "srcFiles",
              "srcPath",
              "destPath"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/b71dd7695caca4beed63cb7fc9afe36ea8c83710^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/functions/inference/TypeInferenceReturnInference.java",
      "locators": [
          {
              "line": 88,
              "column": 34
          },
          {
              "line": 90,
              "column": 48
          },
          {
              "line": 91,
              "column": 52
          }
      ],
      "old_name": "binding",
      "new_name": "callBinding",
      "ctx": {
          "symbolName": "binding",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SqlCallBinding",
          "scopeHint": "in extractExpectedOutputType(...)",
          "filePath": "TypeInferenceReturnInference.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private @Nullable RelDataType extractExpectedOutputType(SqlOperatorBinding opBinding) {\n        if (opBinding instanceof SqlCallBinding) {\n            final SqlCallBinding binding = (SqlCallBinding) opBinding;\n            final FlinkCalciteSqlValidator validator =\n                    (FlinkCalciteSqlValidator) binding.getValidator();\n            return validator.getExpectedOutputType(binding.getCall()).orElse(null);\n        }\n        return null;\n    }",
          "conflictNames": [
              "opBinding",
              "validator"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/b92a5944c42a66f88ae63127ae1ff1483a8c40fd^1/flink-table/flink-sql-gateway/src/main/java/org/apache/flink/table/gateway/service/materializedtable/MaterializedTableManager.java",
      "locators": [
          {
              "line": 128,
              "column": 29
          },
          {
              "line": 130,
              "column": 26
          },
          {
              "line": 131,
              "column": 23
          }
      ],
      "old_name": "restEndpointConfigMap",
      "new_name": "restEndpointConfig",
      "ctx": {
          "symbolName": "restEndpointConfigMap",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Map<String, String>",
          "scopeHint": "in buildRestEndpointUrl(...)",
          "filePath": "MaterializedTableManager.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private String buildRestEndpointUrl(Configuration configuration) {\n        Map<String, String> restEndpointConfigMap =\n                getEndpointConfig(configuration, SqlGatewayRestEndpointFactory.IDENTIFIER);\n        String address = restEndpointConfigMap.get(SqlGatewayRestOptions.ADDRESS.key());\n        String port = restEndpointConfigMap.get(SqlGatewayRestOptions.PORT.key());\n        return String.format(\"http://%s:%s\", address, port);\n    }",
          "conflictNames": [
              "configuration",
              "address",
              "port"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/b957480112c00d9d777247fc48b602e9908652a2^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/FlinkAggregateProjectMergeRule.java",
      "locators": [
          {
              "line": 87,
              "column": 21
          },
          {
              "line": 93,
              "column": 18
          }
      ],
      "old_name": "isProcTime",
      "new_name": "isProctimeWindowAgg",
      "ctx": {
          "symbolName": "isProcTime",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "boolean",
          "scopeHint": "in newApply(...)",
          "filePath": "FlinkAggregateProjectMergeRule.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static @Nullable RelNode newApply(\n            RelOptRuleCall call, Aggregate aggregate, Project project) {\n        // Find all fields which we need to be straightforward field projections.\n        final Set<Integer> interestingFields = RelOptUtil.getAllFields(aggregate);\n\n        // Should add the field of timeAttribute in a LogicalWindowAggregate node which uses rowTime\n        if (aggregate instanceof LogicalWindowAggregate) {\n            LogicalWindowAggregate winAgg = (LogicalWindowAggregate) aggregate;\n            // isRowtimeAttribute can't be used here because the time_indicator phase comes later\n            boolean isProcTime =\n                    LogicalTypeChecks.isProctimeAttribute(\n                            winAgg.getWindow()\n                                    .timeAttribute()\n                                    .getOutputDataType()\n                                    .getLogicalType());\n            if (!isProcTime) {\n                // no need to consider the inputIndex because LogicalWindowAggregate is single input\n                interestingFields.add(\n                        ((LogicalWindowAggregate) aggregate)\n                                .getWindow()\n                                .timeAttribute()\n                                .getFieldIndex());\n            }\n        }\n\n        // Build the map from old to new; abort if any entry is not a\n        // straightforward field projection.\n        final Map<Integer, Integer> map = new HashMap<>();\n        for (int source : interestingFields) {\n            final RexNode rex = project.getProjects().get(source);\n            if (!(rex instanceof RexInputRef)) {\n                return null;\n            }\n            map.put(source, ((RexInputRef) rex).getIndex());\n        }\n\n        final ImmutableBitSet newGroupSet = aggregate.getGroupSet().permute(map);\n        ImmutableList<ImmutableBitSet> newGroupingSets = null;\n        if (aggregate.getGroupType() != Aggregate.Group.SIMPLE) {\n            newGroupingSets =\n                    ImmutableBitSet.ORDERING.immutableSortedCopy(\n                            ImmutableBitSet.permute(aggregate.getGroupSets(), map));\n        }\n\n        final ImmutableList.Builder<AggregateCall> aggCalls = ImmutableList.builder();\n        final int sourceCount = aggregate.getInput().getRowType().getFieldCount();\n        final int targetCount = project.getInput().getRowType().getFieldCount();\n        final Mappings.TargetMapping targetMapping = Mappings.target(map, sourceCount, targetCount);\n        for (AggregateCall aggregateCall : aggregate.getAggCallList()) {\n            aggCalls.add(aggregateCall.transform(targetMapping));\n        }\n\n        final Aggregate newAggregate =\n                aggregate.copy(\n                        aggregate.getTraitSet(),\n                        project.getInput(),\n                        newGroupSet,\n                        newGroupingSets,\n                        aggCalls.build());\n\n        // Add a project if the group set is not in the same order or\n        // contains duplicates.\n        final RelBuilder relBuilder = call.builder();\n        relBuilder.push(newAggregate);\n        final List<Integer> newKeys =\n                Util.transform(\n                        aggregate.getGroupSet().asList(),\n                        key ->\n                                requireNonNull(\n                                        map.get(key),\n                                        () -> \"no value found for key \" + key + \" in \" + map));\n        if (!newKeys.equals(newGroupSet.asList())) {\n            final List<Integer> posList = new ArrayList<>();\n            for (int newKey : newKeys) {\n                posList.add(newGroupSet.indexOf(newKey));\n            }\n            for (int i = newAggregate.getGroupCount();\n                    i < newAggregate.getRowType().getFieldCount();\n                    i++) {\n                posList.add(i);\n            }\n            relBuilder.project(relBuilder.fields(posList));\n        }\n\n        return relBuilder.build();\n    }",
          "conflictNames": [
              "call",
              "aggregate",
              "project",
              "interestingFields",
              "winAgg",
              "map",
              "rex",
              "newGroupSet",
              "newGroupingSets",
              "aggCalls",
              "sourceCount",
              "targetCount",
              "targetMapping",
              "newAggregate",
              "relBuilder",
              "newKeys",
              "posList",
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/b987ae18d0bc353c631bc54871b0c16be39dbad2^1/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/forwardgroup/ForwardGroup.java",
      "locators": [
          {
              "line": 46,
              "column": 22
          },
          {
              "line": 56,
              "column": 20
          },
          {
              "line": 57,
              "column": 13
          },
          {
              "line": 58,
              "column": 32
          }
      ],
      "old_name": "decidedParallelisms",
      "new_name": "configuredParallelisms",
      "ctx": {
          "symbolName": "decidedParallelisms",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Set<Integer>",
          "scopeHint": "in ForwardGroup(...)",
          "filePath": "ForwardGroup.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public ForwardGroup(final Set<JobVertex> jobVertices) {\n        checkNotNull(jobVertices);\n\n        Set<Integer> decidedParallelisms =\n                jobVertices.stream()\n                        .filter(\n                                jobVertex -> {\n                                    jobVertexIds.add(jobVertex.getID());\n                                    return jobVertex.getParallelism() > 0;\n                                })\n                        .map(JobVertex::getParallelism)\n                        .collect(Collectors.toSet());\n\n        checkState(decidedParallelisms.size() <= 1);\n        if (decidedParallelisms.size() == 1) {\n            this.parallelism = decidedParallelisms.iterator().next();\n        }\n    }",
          "conflictNames": [
              "jobVertices"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/b9ffa7ac1ff5db3e9e9189d242149a01e543256d^1/flink-runtime/src/test/java/org/apache/flink/runtime/webmonitor/threadinfo/JobVertexThreadInfoTrackerTest.java",
      "locators": [
          {
              "line": 337,
              "column": 17
          },
          {
              "line": 342,
              "column": 13
          },
          {
              "line": 349,
              "column": 17
          }
      ],
      "old_name": "threadInfoRatiosByTask",
      "new_name": "samples",
      "ctx": {
          "symbolName": "threadInfoRatiosByTask",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Map<ImmutableSet<ExecutionAttemptID>, Collection<ThreadInfoSample>>",
          "scopeHint": "in createThreadInfoStats(...)",
          "filePath": "JobVertexThreadInfoTrackerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static JobVertexThreadInfoStats createThreadInfoStats(\n            Instant startTime,\n            int requestId,\n            Duration timeGap,\n            List<ThreadInfoSample> threadInfoSamples) {\n        Instant endTime = startTime.plus(timeGap);\n\n        final Map<ImmutableSet<ExecutionAttemptID>, Collection<ThreadInfoSample>>\n                threadInfoRatiosByTask = new HashMap<>();\n\n        for (ExecutionVertex vertex : TASK_VERTICES) {\n            Set<ExecutionAttemptID> attemptIds = new HashSet<>();\n            attemptIds.add(vertex.getCurrentExecutionAttempt().getAttemptId());\n            threadInfoRatiosByTask.put(ImmutableSet.copyOf(attemptIds), threadInfoSamples);\n        }\n\n        return new JobVertexThreadInfoStats(\n                requestId,\n                startTime.toEpochMilli(),\n                endTime.toEpochMilli(),\n                threadInfoRatiosByTask);\n    }",
          "conflictNames": [
              "startTime",
              "requestId",
              "timeGap",
              "threadInfoSamples",
              "endTime",
              "attemptIds"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/b9ffa7ac1ff5db3e9e9189d242149a01e543256d^1/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/ThreadInfoSampleServiceTest.java",
      "locators": [
          {
              "line": 69,
              "column": 38
          },
          {
              "line": 85,
              "column": 43
          },
          {
              "line": 86,
              "column": 54
          },
          {
              "line": 116,
              "column": 43
          },
          {
              "line": 117,
              "column": 36
          },
          {
              "line": 121,
              "column": 43
          },
          {
              "line": 122,
              "column": 36
          },
          {
              "line": 156,
              "column": 63
          },
          {
              "line": 159,
              "column": 20
          },
          {
              "line": 160,
              "column": 20
          }
      ],
      "old_name": "sample",
      "new_name": "samples",
      "ctx": {
          "symbolName": "sample",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "ThreadInfoSample",
          "scopeHint": "in testSampleTaskThreadInfo(...)",
          "filePath": "ThreadInfoSampleServiceTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "ce\n                                    .requestThreadInfoSamples(tasks, requestParams)\n                                    .get();\n\n                    assertThat(threadInfoSamples).hasSize(NUMBER_OF_SAMPLES * 2);\n\n                    for (ThreadInfoSample sample : threadInfoSamples) {\n                        StackTraceElement[] traces = sample.getStackTrace();\n                        assertThat(traces).hasSizeLessThanOrEqualTo(MAX_STACK_TRACK_DEPTH);\n                    }\n                },\n      ",
          "conflictNames": [
              "tasks",
              "threadInfoSamples",
              "traces"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/b9ffa7ac1ff5db3e9e9189d242149a01e543256d^1/flink-runtime/src/test/java/org/apache/flink/runtime/webmonitor/threadinfo/ThreadInfoRequestCoordinatorTest.java",
      "locators": [
          {
              "line": 241,
              "column": 40
          },
          {
              "line": 246,
              "column": 69
          }
      ],
      "old_name": "threadIds",
      "new_name": "threads",
      "ctx": {
          "symbolName": "threadIds",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<Long>",
          "scopeHint": "in createMockTaskManagerGateway(...)",
          "filePath": "ThreadInfoRequestCoordinatorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static CompletableFuture<TaskExecutorThreadInfoGateway> createMockTaskManagerGateway(\n            CompletionType completionType) throws Exception {\n\n        final CompletableFuture<TaskThreadInfoResponse> responseFuture = new CompletableFuture<>();\n        switch (completionType) {\n            case SUCCESSFULLY:\n                Set<IdleTestTask> tasks = new HashSet<>();\n                executeWithTerminationGuarantee(\n                        () -> {\n                            tasks.add(new IdleTestTask());\n                            tasks.add(new IdleTestTask());\n                            //                            Thread.sleep(100);\n                            List<Long> threadIds =\n                                    tasks.stream()\n                                            .map(t -> t.getExecutingThread().getId())\n                                            .collect(Collectors.toList());\n                            Collection<ThreadInfoSample> threadInfoSample =\n                                    JvmUtils.createThreadInfoSample(threadIds, 100);\n                            responseFuture.complete(\n                                    new TaskThreadInfoResponse(new ArrayList<>(threadInfoSample)));\n                        },\n                        tasks);\n\n                break;\n            case EXCEPTIONALLY:\n                responseFuture.completeExceptionally(new RuntimeException(\"Request failed.\"));\n                break;\n            case TIMEOUT:\n                executorService.schedule(\n                        () ->\n                                responseFuture.completeExceptionally(\n                                        new TimeoutException(REQUEST_TIMEOUT_MESSAGE)),\n                        REQUEST_TIMEOUT.toMillis(),\n                        TimeUnit.MILLISECONDS);\n                break;\n            case NEVER_COMPLETE:\n                // do nothing\n                break;\n            default:\n                throw new RuntimeException(\"Unknown completion type.\");\n        }\n\n        final TaskExecutorThreadInfoGateway executorGateway =\n                (taskExecutionAttemptId, requestParams, timeout) -> responseFuture;\n\n        return CompletableFuture.completedFuture(executorGateway);\n    }",
          "conflictNames": [
              "completionType",
              "responseFuture",
              "tasks",
              "threadInfoSample",
              "executorGateway"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/bb0f4429598db703e69d951986291862cbd5416b^1/flink-core/src/main/java/org/apache/flink/core/state/StateFutureImpl.java",
      "locators": [
          {
              "line": 2,
              "column": 7
          },
          {
              "line": 2,
              "column": 10
          },
          {
              "line": 2,
              "column": 18
          },
          {
              "line": 2,
              "column": 25
          },
          {
              "line": 2,
              "column": 34
          },
          {
              "line": 2,
              "column": 56
          },
          {
              "line": 2,
              "column": 61
          },
          {
              "line": 3,
              "column": 10
          },
          {
              "line": 3,
              "column": 27
          },
          {
              "line": 3,
              "column": 30
          },
          {
              "line": 3,
              "column": 35
          },
          {
              "line": 3,
              "column": 36
          },
          {
              "line": 3,
              "column": 38
          },
          {
              "line": 3,
              "column": 46
          },
          {
              "line": 3,
              "column": 47
          },
          {
              "line": 3,
              "column": 51
          },
          {
              "line": 3,
              "column": 63
          },
          {
              "line": 4,
              "column": 13
          },
          {
              "line": 5,
              "column": 5
          },
          {
              "line": 5,
              "column": 27
          },
          {
              "line": 5,
              "column": 38
          },
          {
              "line": 5,
              "column": 47
          },
          {
              "line": 5,
              "column": 50
          },
          {
              "line": 5,
              "column": 61
          },
          {
              "line": 6,
              "column": 14
          },
          {
              "line": 6,
              "column": 19
          },
          {
              "line": 6,
              "column": 26
          },
          {
              "line": 6,
              "column": 31
          },
          {
              "line": 6,
              "column": 34
          },
          {
              "line": 6,
              "column": 38
          },
          {
              "line": 6,
              "column": 52
          },
          {
              "line": 7,
              "column": 8
          },
          {
              "line": 7,
              "column": 11
          },
          {
              "line": 7,
              "column": 30
          },
          {
              "line": 7,
              "column": 40
          },
          {
              "line": 7,
              "column": 42
          },
          {
              "line": 7,
              "column": 45
          },
          {
              "line": 7,
              "column": 61
          },
          {
              "line": 8,
              "column": 11
          },
          {
              "line": 8,
              "column": 16
          },
          {
              "line": 8,
              "column": 19
          },
          {
              "line": 8,
              "column": 50
          },
          {
              "line": 8,
              "column": 55
          },
          {
              "line": 8,
              "column": 58
          },
          {
              "line": 10,
              "column": 24
          },
          {
              "line": 10,
              "column": 33
          },
          {
              "line": 10,
              "column": 36
          },
          {
              "line": 12,
              "column": 7
          },
          {
              "line": 12,
              "column": 12
          },
          {
              "line": 12,
              "column": 17
          },
          {
              "line": 12,
              "column": 32
          },
          {
              "line": 12,
              "column": 44
          },
          {
              "line": 12,
              "column": 45
          },
          {
              "line": 12,
              "column": 70
          },
          {
              "line": 13,
              "column": 13
          },
          {
              "line": 13,
              "column": 19
          },
          {
              "line": 13,
              "column": 24
          },
          {
              "line": 13,
              "column": 29
          },
          {
              "line": 13,
              "column": 32
          },
          {
              "line": 13,
              "column": 46
          },
          {
              "line": 14,
              "column": 50
          },
          {
              "line": 14,
              "column": 54
          },
          {
              "line": 14,
              "column": 57
          },
          {
              "line": 14,
              "column": 61
          },
          {
              "line": 14,
              "column": 73
          },
          {
              "line": 15,
              "column": 5
          },
          {
              "line": 15,
              "column": 6
          },
          {
              "line": 15,
              "column": 10
          },
          {
              "line": 15,
              "column": 15
          },
          {
              "line": 15,
              "column": 18
          },
          {
              "line": 15,
              "column": 26
          },
          {
              "line": 15,
              "column": 30
          },
          {
              "line": 15,
              "column": 44
          },
          {
              "line": 15,
              "column": 49
          },
          {
              "line": 15,
              "column": 57
          },
          {
              "line": 16,
              "column": 19
          },
          {
              "line": 16,
              "column": 24
          },
          {
              "line": 16,
              "column": 29
          },
          {
              "line": 16,
              "column": 32
          },
          {
              "line": 19,
              "column": 7
          },
          {
              "line": 19,
              "column": 18
          },
          {
              "line": 19,
              "column": 29
          },
          {
              "line": 19,
              "column": 35
          },
          {
              "line": 21,
              "column": 17
          },
          {
              "line": 21,
              "column": 39
          },
          {
              "line": 22,
              "column": 17
          },
          {
              "line": 22,
              "column": 40
          },
          {
              "line": 22,
              "column": 49
          },
          {
              "line": 22,
              "column": 55
          },
          {
              "line": 23,
              "column": 17
          },
          {
              "line": 23,
              "column": 41
          },
          {
              "line": 23,
              "column": 45
          },
          {
              "line": 25,
              "column": 25
          },
          {
              "line": 25,
              "column": 34
          },
          {
              "line": 25,
              "column": 39
          },
          {
              "line": 25,
              "column": 45
          },
          {
              "line": 27,
              "column": 33
          },
          {
              "line": 31,
              "column": 6
          },
          {
              "line": 31,
              "column": 9
          },
          {
              "line": 31,
              "column": 20
          },
          {
              "line": 31,
              "column": 22
          },
          {
              "line": 31,
              "column": 45
          },
          {
              "line": 31,
              "column": 51
          },
          {
              "line": 31,
              "column": 68
          },
          {
              "line": 31,
              "column": 76
          },
          {
              "line": 31,
              "column": 84
          },
          {
              "line": 31,
              "column": 90
          },
          {
              "line": 32,
              "column": 12
          },
          {
              "line": 32,
              "column": 14
          },
          {
              "line": 32,
              "column": 18
          },
          {
              "line": 32,
              "column": 23
          },
          {
              "line": 32,
              "column": 31
          },
          {
              "line": 32,
              "column": 34
          },
          {
              "line": 32,
              "column": 42
          },
          {
              "line": 32,
              "column": 48
          },
          {
              "line": 32,
              "column": 64
          },
          {
              "line": 32,
              "column": 68
          },
          {
              "line": 32,
              "column": 75
          },
          {
              "line": 33,
              "column": 9
          },
          {
              "line": 33,
              "column": 27
          },
          {
              "line": 33,
              "column": 30
          },
          {
              "line": 33,
              "column": 38
          },
          {
              "line": 33,
              "column": 46
          },
          {
              "line": 33,
              "column": 56
          },
          {
              "line": 33,
              "column": 70
          },
          {
              "line": 33,
              "column": 75
          },
          {
              "line": 33,
              "column": 81
          },
          {
              "line": 33,
              "column": 90
          },
          {
              "line": 34,
              "column": 5
          },
          {
              "line": 34,
              "column": 24
          },
          {
              "line": 34,
              "column": 26
          },
          {
              "line": 34,
              "column": 37
          },
          {
              "line": 34,
              "column": 56
          },
          {
              "line": 34,
              "column": 61
          },
          {
              "line": 34,
              "column": 67
          },
          {
              "line": 35,
              "column": 5
          },
          {
              "line": 35,
              "column": 9
          },
          {
              "line": 35,
              "column": 16
          },
          {
              "line": 35,
              "column": 21
          },
          {
              "line": 35,
              "column": 27
          },
          {
              "line": 37,
              "column": 38
          },
          {
              "line": 37,
              "column": 47
          },
          {
              "line": 37,
              "column": 53
          },
          {
              "line": 37,
              "column": 56
          },
          {
              "line": 37,
              "column": 61
          },
          {
              "line": 37,
              "column": 66
          },
          {
              "line": 37,
              "column": 73
          },
          {
              "line": 37,
              "column": 76
          },
          {
              "line": 37,
              "column": 85
          },
          {
              "line": 37,
              "column": 91
          },
          {
              "line": 37,
              "column": 100
          },
          {
              "line": 38,
              "column": 15
          },
          {
              "line": 38,
              "column": 22
          },
          {
              "line": 38,
              "column": 35
          },
          {
              "line": 38,
              "column": 43
          },
          {
              "line": 38,
              "column": 47
          },
          {
              "line": 40,
              "column": 5
          },
          {
              "line": 41,
              "column": 18
          },
          {
              "line": 41,
              "column": 24
          },
          {
              "line": 41,
              "column": 37
          },
          {
              "line": 41,
              "column": 39
          },
          {
              "line": 41,
              "column": 47
          },
          {
              "line": 41,
              "column": 56
          },
          {
              "line": 41,
              "column": 62
          },
          {
              "line": 43,
              "column": 11
          },
          {
              "line": 43,
              "column": 18
          },
          {
              "line": 43,
              "column": 28
          },
          {
              "line": 43,
              "column": 31
          },
          {
              "line": 43,
              "column": 52
          },
          {
              "line": 43,
              "column": 54
          },
          {
              "line": 43,
              "column": 68
          },
          {
              "line": 44,
              "column": 11
          },
          {
              "line": 44,
              "column": 24
          },
          {
              "line": 44,
              "column": 29
          },
          {
              "line": 44,
              "column": 35
          },
          {
              "line": 44,
              "column": 45
          },
          {
              "line": 44,
              "column": 50
          },
          {
              "line": 44,
              "column": 56
          },
          {
              "line": 46,
              "column": 11
          },
          {
              "line": 46,
              "column": 26
          },
          {
              "line": 47,
              "column": 9
          },
          {
              "line": 47,
              "column": 12
          },
          {
              "line": 47,
              "column": 33
          },
          {
              "line": 47,
              "column": 48
          },
          {
              "line": 49,
              "column": 16
          },
          {
              "line": 49,
              "column": 22
          },
          {
              "line": 49,
              "column": 40
          },
          {
              "line": 49,
              "column": 55
          },
          {
              "line": 50,
              "column": 19
          },
          {
              "line": 50,
              "column": 24
          },
          {
              "line": 50,
              "column": 30
          },
          {
              "line": 50,
              "column": 35
          },
          {
              "line": 50,
              "column": 43
          },
          {
              "line": 50,
              "column": 48
          },
          {
              "line": 50,
              "column": 54
          },
          {
              "line": 51,
              "column": 26
          },
          {
              "line": 51,
              "column": 43
          },
          {
              "line": 54,
              "column": 8
          },
          {
              "line": 54,
              "column": 13
          },
          {
              "line": 55,
              "column": 20
          },
          {
              "line": 55,
              "column": 26
          },
          {
              "line": 55,
              "column": 33
          },
          {
              "line": 55,
              "column": 55
          },
          {
              "line": 55,
              "column": 63
          },
          {
              "line": 55,
              "column": 66
          },
          {
              "line": 56,
              "column": 18
          },
          {
              "line": 56,
              "column": 23
          },
          {
              "line": 56,
              "column": 25
          },
          {
              "line": 58,
              "column": 22
          },
          {
              "line": 58,
              "column": 27
          },
          {
              "line": 58,
              "column": 33
          },
          {
              "line": 58,
              "column": 40
          },
          {
              "line": 59,
              "column": 37
          },
          {
              "line": 59,
              "column": 42
          },
          {
              "line": 59,
              "column": 48
          },
          {
              "line": 59,
              "column": 51
          },
          {
              "line": 60,
              "column": 31
          },
          {
              "line": 61,
              "column": 18
          },
          {
              "line": 61,
              "column": 28
          },
          {
              "line": 61,
              "column": 34
          },
          {
              "line": 61,
              "column": 46
          },
          {
              "line": 61,
              "column": 48
          },
          {
              "line": 61,
              "column": 55
          },
          {
              "line": 62,
              "column": 15
          },
          {
              "line": 62,
              "column": 18
          },
          {
              "line": 63,
              "column": 21
          },
          {
              "line": 63,
              "column": 27
          },
          {
              "line": 63,
              "column": 37
          },
          {
              "line": 63,
              "column": 45
          },
          {
              "line": 63,
              "column": 47
          },
          {
              "line": 63,
              "column": 53
          },
          {
              "line": 63,
              "column": 59
          },
          {
              "line": 64,
              "column": 22
          },
          {
              "line": 64,
              "column": 27
          },
          {
              "line": 64,
              "column": 33
          },
          {
              "line": 64,
              "column": 37
          },
          {
              "line": 64,
              "column": 42
          },
          {
              "line": 66,
              "column": 41
          },
          {
              "line": 68,
              "column": 42
          },
          {
              "line": 68,
              "column": 50
          },
          {
              "line": 68,
              "column": 52
          },
          {
              "line": 68,
              "column": 67
          },
          {
              "line": 69,
              "column": 55
          },
          {
              "line": 72,
              "column": 18
          },
          {
              "line": 72,
              "column": 25
          },
          {
              "line": 74,
              "column": 26
          },
          {
              "line": 74,
              "column": 28
          },
          {
              "line": 75,
              "column": 20
          },
          {
              "line": 75,
              "column": 34
          },
          {
              "line": 75,
              "column": 38
          },
          {
              "line": 75,
              "column": 63
          },
          {
              "line": 75,
              "column": 65
          },
          {
              "line": 75,
              "column": 84
          },
          {
              "line": 79,
              "column": 8
          },
          {
              "line": 79,
              "column": 13
          },
          {
              "line": 80,
              "column": 16
          },
          {
              "line": 80,
              "column": 22
          },
          {
              "line": 80,
              "column": 32
          },
          {
              "line": 80,
              "column": 37
          },
          {
              "line": 80,
              "column": 47
          },
          {
              "line": 80,
              "column": 55
          },
          {
              "line": 81,
              "column": 18
          },
          {
              "line": 81,
              "column": 23
          },
          {
              "line": 81,
              "column": 25
          },
          {
              "line": 83,
              "column": 22
          },
          {
              "line": 83,
              "column": 27
          },
          {
              "line": 83,
              "column": 33
          },
          {
              "line": 83,
              "column": 40
          },
          {
              "line": 84,
              "column": 27
          },
          {
              "line": 84,
              "column": 36
          },
          {
              "line": 84,
              "column": 41
          },
          {
              "line": 84,
              "column": 47
          },
          {
              "line": 84,
              "column": 50
          },
          {
              "line": 85,
              "column": 31
          },
          {
              "line": 86,
              "column": 18
          },
          {
              "line": 86,
              "column": 28
          },
          {
              "line": 86,
              "column": 34
          },
          {
              "line": 86,
              "column": 46
          },
          {
              "line": 86,
              "column": 48
          },
          {
              "line": 86,
              "column": 59
          },
          {
              "line": 87,
              "column": 15
          },
          {
              "line": 87,
              "column": 18
          },
          {
              "line": 88,
              "column": 21
          },
          {
              "line": 88,
              "column": 27
          },
          {
              "line": 88,
              "column": 40
          },
          {
              "line": 88,
              "column": 48
          },
          {
              "line": 88,
              "column": 50
          },
          {
              "line": 88,
              "column": 56
          },
          {
              "line": 88,
              "column": 62
          },
          {
              "line": 89,
              "column": 22
          },
          {
              "line": 89,
              "column": 27
          },
          {
              "line": 89,
              "column": 33
          },
          {
              "line": 89,
              "column": 37
          },
          {
              "line": 89,
              "column": 42
          },
          {
              "line": 91,
              "column": 41
          },
          {
              "line": 93,
              "column": 51
          },
          {
              "line": 94,
              "column": 42
          },
          {
              "line": 94,
              "column": 50
          },
          {
              "line": 94,
              "column": 52
          },
          {
              "line": 94,
              "column": 67
          },
          {
              "line": 95,
              "column": 55
          },
          {
              "line": 98,
              "column": 18
          },
          {
              "line": 98,
              "column": 25
          },
          {
              "line": 100,
              "column": 26
          },
          {
              "line": 100,
              "column": 28
          },
          {
              "line": 101,
              "column": 20
          },
          {
              "line": 101,
              "column": 34
          },
          {
              "line": 101,
              "column": 38
          },
          {
              "line": 101,
              "column": 63
          },
          {
              "line": 101,
              "column": 65
          },
          {
              "line": 101,
              "column": 84
          },
          {
              "line": 105,
              "column": 8
          },
          {
              "line": 105,
              "column": 13
          },
          {
              "line": 106,
              "column": 20
          },
          {
              "line": 106,
              "column": 26
          },
          {
              "line": 106,
              "column": 33
          },
          {
              "line": 106,
              "column": 41
          },
          {
              "line": 106,
              "column": 57
          },
          {
              "line": 106,
              "column": 65
          },
          {
              "line": 106,
              "column": 68
          },
          {
              "line": 106,
              "column": 77
          },
          {
              "line": 106,
              "column": 83
          },
          {
              "line": 107,
              "column": 18
          },
          {
              "line": 107,
              "column": 23
          },
          {
              "line": 107,
              "column": 25
          },
          {
              "line": 109,
              "column": 22
          },
          {
              "line": 109,
              "column": 27
          },
          {
              "line": 109,
              "column": 33
          },
          {
              "line": 109,
              "column": 40
          },
          {
              "line": 110,
              "column": 31
          },
          {
              "line": 111,
              "column": 18
          },
          {
              "line": 111,
              "column": 42
          },
          {
              "line": 111,
              "column": 47
          },
          {
              "line": 111,
              "column": 53
          },
          {
              "line": 111,
              "column": 56
          },
          {
              "line": 112,
              "column": 15
          },
          {
              "line": 112,
              "column": 18
          },
          {
              "line": 113,
              "column": 21
          },
          {
              "line": 113,
              "column": 27
          },
          {
              "line": 113,
              "column": 37
          },
          {
              "line": 113,
              "column": 45
          },
          {
              "line": 113,
              "column": 47
          },
          {
              "line": 113,
              "column": 53
          },
          {
              "line": 113,
              "column": 59
          },
          {
              "line": 114,
              "column": 22
          },
          {
              "line": 114,
              "column": 27
          },
          {
              "line": 114,
              "column": 33
          },
          {
              "line": 114,
              "column": 37
          },
          {
              "line": 114,
              "column": 42
          },
          {
              "line": 116,
              "column": 41
          },
          {
              "line": 118,
              "column": 45
          },
          {
              "line": 118,
              "column": 51
          },
          {
              "line": 119,
              "column": 46
          },
          {
              "line": 119,
              "column": 51
          },
          {
              "line": 119,
              "column": 56
          },
          {
              "line": 119,
              "column": 65
          },
          {
              "line": 119,
              "column": 67
          },
          {
              "line": 119,
              "column": 82
          },
          {
              "line": 120,
              "column": 55
          },
          {
              "line": 123,
              "column": 18
          },
          {
              "line": 123,
              "column": 25
          },
          {
              "line": 125,
              "column": 26
          },
          {
              "line": 125,
              "column": 28
          },
          {
              "line": 126,
              "column": 20
          },
          {
              "line": 126,
              "column": 34
          },
          {
              "line": 126,
              "column": 38
          },
          {
              "line": 126,
              "column": 63
          },
          {
              "line": 126,
              "column": 65
          },
          {
              "line": 126,
              "column": 84
          },
          {
              "line": 130,
              "column": 8
          },
          {
              "line": 130,
              "column": 13
          },
          {
              "line": 131,
              "column": 23
          },
          {
              "line": 131,
              "column": 29
          },
          {
              "line": 131,
              "column": 36
          },
          {
              "line": 131,
              "column": 44
          },
          {
              "line": 132,
              "column": 17
          },
          {
              "line": 132,
              "column": 23
          },
          {
              "line": 132,
              "column": 27
          },
          {
              "line": 132,
              "column": 30
          },
          {
              "line": 132,
              "column": 41
          },
          {
              "line": 132,
              "column": 61
          },
          {
              "line": 132,
              "column": 72
          },
          {
              "line": 132,
              "column": 80
          },
          {
              "line": 132,
              "column": 83
          },
          {
              "line": 133,
              "column": 18
          },
          {
              "line": 133,
              "column": 23
          },
          {
              "line": 133,
              "column": 25
          },
          {
              "line": 135,
              "column": 22
          },
          {
              "line": 135,
              "column": 27
          },
          {
              "line": 135,
              "column": 33
          },
          {
              "line": 135,
              "column": 40
          },
          {
              "line": 136,
              "column": 18
          },
          {
              "line": 136,
              "column": 27
          },
          {
              "line": 136,
              "column": 32
          },
          {
              "line": 136,
              "column": 40
          },
          {
              "line": 139,
              "column": 53
          },
          {
              "line": 139,
              "column": 58
          },
          {
              "line": 139,
              "column": 64
          },
          {
              "line": 139,
              "column": 67
          },
          {
              "line": 140,
              "column": 47
          },
          {
              "line": 141,
              "column": 34
          },
          {
              "line": 141,
              "column": 44
          },
          {
              "line": 141,
              "column": 50
          },
          {
              "line": 141,
              "column": 62
          },
          {
              "line": 141,
              "column": 64
          },
          {
              "line": 141,
              "column": 71
          },
          {
              "line": 142,
              "column": 46
          },
          {
              "line": 142,
              "column": 48
          },
          {
              "line": 143,
              "column": 40
          },
          {
              "line": 143,
              "column": 54
          },
          {
              "line": 143,
              "column": 58
          },
          {
              "line": 144,
              "column": 59
          },
          {
              "line": 144,
              "column": 61
          },
          {
              "line": 144,
              "column": 80
          },
          {
              "line": 147,
              "column": 15
          },
          {
              "line": 147,
              "column": 18
          },
          {
              "line": 148,
              "column": 21
          },
          {
              "line": 148,
              "column": 27
          },
          {
              "line": 148,
              "column": 37
          },
          {
              "line": 148,
              "column": 45
          },
          {
              "line": 148,
              "column": 47
          },
          {
              "line": 148,
              "column": 53
          },
          {
              "line": 148,
              "column": 59
          },
          {
              "line": 149,
              "column": 22
          },
          {
              "line": 149,
              "column": 31
          },
          {
              "line": 149,
              "column": 37
          },
          {
              "line": 149,
              "column": 41
          },
          {
              "line": 149,
              "column": 44
          },
          {
              "line": 149,
              "column": 56
          },
          {
              "line": 150,
              "column": 28
          },
          {
              "line": 150,
              "column": 37
          },
          {
              "line": 152,
              "column": 42
          },
          {
              "line": 152,
              "column": 47
          },
          {
              "line": 152,
              "column": 53
          },
          {
              "line": 152,
              "column": 57
          },
          {
              "line": 152,
              "column": 62
          },
          {
              "line": 154,
              "column": 61
          },
          {
              "line": 156,
              "column": 62
          },
          {
              "line": 156,
              "column": 70
          },
          {
              "line": 156,
              "column": 72
          },
          {
              "line": 156,
              "column": 87
          },
          {
              "line": 158,
              "column": 75
          },
          {
              "line": 162,
              "column": 18
          },
          {
              "line": 162,
              "column": 25
          },
          {
              "line": 164,
              "column": 26
          },
          {
              "line": 164,
              "column": 28
          },
          {
              "line": 165,
              "column": 20
          },
          {
              "line": 165,
              "column": 34
          },
          {
              "line": 165,
              "column": 38
          },
          {
              "line": 165,
              "column": 63
          },
          {
              "line": 165,
              "column": 65
          },
          {
              "line": 165,
              "column": 84
          },
          {
              "line": 170,
              "column": 11
          },
          {
              "line": 170,
              "column": 16
          },
          {
              "line": 170,
              "column": 24
          },
          {
              "line": 170,
              "column": 29
          },
          {
              "line": 170,
              "column": 39
          },
          {
              "line": 170,
              "column": 56
          },
          {
              "line": 170,
              "column": 67
          },
          {
              "line": 170,
              "column": 71
          },
          {
              "line": 170,
              "column": 72
          },
          {
              "line": 170,
              "column": 80
          },
          {
              "line": 170,
              "column": 93
          },
          {
              "line": 171,
              "column": 9
          },
          {
              "line": 171,
              "column": 11
          },
          {
              "line": 171,
              "column": 15
          },
          {
              "line": 171,
              "column": 19
          },
          {
              "line": 171,
              "column": 34
          },
          {
              "line": 171,
              "column": 42
          },
          {
              "line": 171,
              "column": 43
          },
          {
              "line": 171,
              "column": 45
          },
          {
              "line": 173,
              "column": 10
          },
          {
              "line": 173,
              "column": 18
          },
          {
              "line": 173,
              "column": 21
          },
          {
              "line": 173,
              "column": 26
          },
          {
              "line": 173,
              "column": 29
          },
          {
              "line": 173,
              "column": 37
          },
          {
              "line": 175,
              "column": 20
          },
          {
              "line": 175,
              "column": 26
          },
          {
              "line": 175,
              "column": 38
          },
          {
              "line": 175,
              "column": 40
          },
          {
              "line": 175,
              "column": 46
          },
          {
              "line": 175,
              "column": 52
          },
          {
              "line": 176,
              "column": 10
          },
          {
              "line": 176,
              "column": 17
          },
          {
              "line": 176,
              "column": 24
          },
          {
              "line": 176,
              "column": 30
          },
          {
              "line": 176,
              "column": 50
          },
          {
              "line": 179,
              "column": 8
          },
          {
              "line": 179,
              "column": 13
          },
          {
              "line": 180,
              "column": 22
          },
          {
              "line": 180,
              "column": 24
          },
          {
              "line": 180,
              "column": 29
          },
          {
              "line": 181,
              "column": 14
          },
          {
              "line": 181,
              "column": 19
          },
          {
              "line": 181,
              "column": 25
          },
          {
              "line": 181,
              "column": 32
          },
          {
              "line": 181,
              "column": 34
          },
          {
              "line": 181,
              "column": 37
          },
          {
              "line": 182,
              "column": 18
          },
          {
              "line": 182,
              "column": 20
          },
          {
              "line": 182,
              "column": 26
          },
          {
              "line": 185,
              "column": 11
          },
          {
              "line": 185,
              "column": 23
          },
          {
              "line": 185,
              "column": 25
          },
          {
              "line": 185,
              "column": 40
          },
          {
              "line": 185,
              "column": 46
          },
          {
              "line": 186,
              "column": 14
          },
          {
              "line": 186,
              "column": 19
          },
          {
              "line": 186,
              "column": 25
          },
          {
              "line": 186,
              "column": 32
          },
          {
              "line": 186,
              "column": 34
          },
          {
              "line": 186,
              "column": 37
          },
          {
              "line": 187,
              "column": 18
          },
          {
              "line": 187,
              "column": 20
          },
          {
              "line": 187,
              "column": 25
          },
          {
              "line": 190,
              "column": 15
          },
          {
              "line": 190,
              "column": 22
          },
          {
              "line": 190,
              "column": 24
          },
          {
              "line": 190,
              "column": 29
          },
          {
              "line": 190,
              "column": 47
          },
          {
              "line": 190,
              "column": 52
          },
          {
              "line": 190,
              "column": 54
          },
          {
              "line": 191,
              "column": 26
          },
          {
              "line": 191,
              "column": 31
          },
          {
              "line": 191,
              "column": 33
          },
          {
              "line": 192,
              "column": 14
          },
          {
              "line": 192,
              "column": 29
          },
          {
              "line": 195,
              "column": 15
          },
          {
              "line": 195,
              "column": 22
          },
          {
              "line": 195,
              "column": 24
          },
          {
              "line": 195,
              "column": 29
          },
          {
              "line": 195,
              "column": 42
          },
          {
              "line": 195,
              "column": 49
          },
          {
              "line": 195,
              "column": 51
          },
          {
              "line": 196,
              "column": 26
          },
          {
              "line": 196,
              "column": 28
          },
          {
              "line": 196,
              "column": 34
          },
          {
              "line": 196,
              "column": 52
          },
          {
              "line": 197,
              "column": 14
          },
          {
              "line": 197,
              "column": 29
          },
          {
              "line": 200,
              "column": 15
          },
          {
              "line": 200,
              "column": 22
          },
          {
              "line": 200,
              "column": 24
          },
          {
              "line": 200,
              "column": 29
          },
          {
              "line": 200,
              "column": 49
          },
          {
              "line": 200,
              "column": 56
          },
          {
              "line": 201,
              "column": 31
          },
          {
              "line": 202,
              "column": 14
          },
          {
              "line": 202,
              "column": 29
          },
          {
              "line": 205,
              "column": 8
          },
          {
              "line": 205,
              "column": 13
          },
          {
              "line": 206,
              "column": 19
          },
          {
              "line": 206,
              "column": 28
          },
          {
              "line": 206,
              "column": 38
          },
          {
              "line": 206,
              "column": 46
          },
          {
              "line": 207,
              "column": 14
          },
          {
              "line": 207,
              "column": 19
          },
          {
              "line": 207,
              "column": 25
          },
          {
              "line": 207,
              "column": 29
          },
          {
              "line": 207,
              "column": 34
          },
          {
              "line": 210,
              "column": 11
          },
          {
              "line": 210,
              "column": 13
          },
          {
              "line": 210,
              "column": 29
          },
          {
              "line": 210,
              "column": 36
          },
          {
              "line": 211,
              "column": 15
          },
          {
              "line": 211,
              "column": 20
          },
          {
              "line": 211,
              "column": 34
          },
          {
              "line": 212,
              "column": 28
          }
      ],
      "old_name": "e",
      "new_name": "t",
      "ctx": {
          "symbolName": "e",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Throwable",
          "scopeHint": "in thenApply(...)",
          "filePath": "StateFutureImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "          ret.completeInCallbackRunner(fn.apply(t));\n                                        callbackFinished();\n                                    });\n                        });\n                return ret;\n            }\n        } catch (Throwable e) {\n            throw new FlinkRuntimeException(\"Error binding or executing callback\", e);\n        }\n    }\n\n    @Override\n    public StateFuture<Void> thenAccept(Consumer<? super T> action) {\n        callbackRegistered();\n        try {\n    ",
          "conflictNames": [
              "fn",
              "r",
              "ret"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/bc0f241b86799a39d7ce08e5902e47c71bdaf68f^1/flink-runtime/src/main/java/org/apache/flink/streaming/runtime/operators/sink/CommitterOperator.java",
      "locators": [
          {
              "line": 168,
              "column": 54
          },
          {
              "line": 170,
              "column": 31
          }
      ],
      "old_name": "manager",
      "new_name": "checkpointManager",
      "ctx": {
          "symbolName": "manager",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "CheckpointCommittableManager<CommT>",
          "scopeHint": "in commitAndEmitCheckpoints(...)",
          "filePath": "CommitterOperator.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "       commitAndEmitCheckpoints();\n    }\n\n    private void commitAndEmitCheckpoints() throws IOException, InterruptedException {\n        long completedCheckpointId = endInput ? EOI : lastCompletedCheckpointId;\n        do {\n            for (CheckpointCommittableManager<CommT> manager :\n                    committableCollector.getCheckpointCommittablesUpTo(completedCheckpointId)) {\n                commitAndEmit(manager);\n            }\n            // !committableCollector.isFinished() indicates that we should retry\n     ",
          "conflictNames": [
              "completedCheckpointId"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/bc3afba5cb97265c4833818563f61b3fb6b48b6a^1/flink-examples/flink-examples-streaming/src/main/java/org/apache/flink/streaming/examples/datagen/DataGenerator.java",
      "locators": [
          {
              "line": 38,
              "column": 37
          },
          {
              "line": 46,
              "column": 32
          }
      ],
      "old_name": "generatorSource",
      "new_name": "source",
      "ctx": {
          "symbolName": "generatorSource",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "DataGeneratorSource<String>",
          "scopeHint": "in main(...)",
          "filePath": "DataGenerator.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static void main(String[] args) throws Exception {\n        final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n        env.setParallelism(4);\n\n        GeneratorFunction<Long, String> generatorFunction = index -> \"Number: \" + index;\n\n        DataGeneratorSource<String> generatorSource =\n                new DataGeneratorSource<>(\n                        generatorFunction,\n                        Long.MAX_VALUE,\n                        RateLimiterStrategy.perSecond(4),\n                        Types.STRING);\n\n        DataStreamSource<String> streamSource =\n                env.fromSource(generatorSource, WatermarkStrategy.noWatermarks(), \"Data Generator\");\n        streamSource.print();\n\n        env.execute(\"Data Generator Source Example\");\n    }",
          "conflictNames": [
              "args",
              "env",
              "generatorFunction",
              "streamSource"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/bf6333cfa228defb1990459d77c775e2cc9f9f5c^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/functions/sql/ml/SqlMLTableFunction.java",
      "locators": [
          {
              "line": 250,
              "column": 21
          },
          {
              "line": 251,
              "column": 17
          },
          {
              "line": 251,
              "column": 37
          },
          {
              "line": 256,
              "column": 63
          }
      ],
      "old_name": "capacity",
      "new_name": "maxConcurrentOperations",
      "ctx": {
          "symbolName": "capacity",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Integer",
          "scopeHint": "in checkConfigValue(...)",
          "filePath": "SqlMLTableFunction.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static Optional<RuntimeException> checkConfigValue(Map<String, String> runtimeConfig) {\n        Configuration config = Configuration.fromMap(runtimeConfig);\n        try {\n            MLPredictRuntimeConfigOptions.getSupportedOptions().forEach(config::get);\n        } catch (Throwable t) {\n            return Optional.of(new ValidationException(\"Failed to parse the config.\", t));\n        }\n\n        // option value check\n        // async options are all optional\n        Boolean async = config.get(ASYNC);\n        if (Boolean.TRUE.equals(async)) {\n            Integer capacity = config.get(ASYNC_CAPACITY);\n            if (capacity != null && capacity <= 0) {\n                return Optional.of(\n                        new ValidationException(\n                                String.format(\n                                        \"Invalid runtime config option '%s'. Its value should be positive integer but was %s.\",\n                                        ASYNC_CAPACITY.key(), capacity)));\n            }\n        }\n\n        return Optional.empty();\n    }",
          "conflictNames": [
              "runtimeConfig",
              "config",
              "async"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c0176fd6794295dc3706ed7f536f3f70b6110923^1/flink-core/src/main/java/org/apache/flink/configuration/GlobalConfiguration.java",
      "locators": [
          {
              "line": 196,
              "column": 69
          },
          {
              "line": 197,
              "column": 15
          },
          {
              "line": 221,
              "column": 20
          },
          {
              "line": 222,
              "column": 17
          },
          {
              "line": 223,
              "column": 21
          },
          {
              "line": 224,
              "column": 17
          },
          {
              "line": 226,
              "column": 37
          },
          {
              "line": 233,
              "column": 29
          },
          {
              "line": 239,
              "column": 43
          },
          {
              "line": 253,
              "column": 43
          }
      ],
      "old_name": "line",
      "new_name": "configuration",
      "ctx": {
          "symbolName": "line",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in loadLegacyYAMLResource(...)",
          "filePath": "GlobalConfiguration.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Loads a YAML-file of key-value pairs.\n     *\n     * <p>Colon and whitespace \": \" separate key and value (one per line). The hash tag \"#\" starts a\n     * single-line comment.\n     *\n     * <p>Example:\n     *\n     * <pre>\n     * jobmanager.rpc.address: localhost # network address for communication with the job manager\n     * jobmanager.rpc.port   : 6123      # network port to connect to for communication with the job manager\n     * taskmanager.rpc.port  : 6122      # network port the task manager expects incoming IPC connections\n     * </pre>\n     *\n     * <p>This does not span the whole YAML specification, but only the *syntax* of simple YAML\n     * key-value pairs (see issue #113 on GitHub). If at any point in time, there is a need to go\n     * beyond simple key-value pairs syntax compatibility will allow to introduce a YAML parser\n     * library.\n     *\n     * @param file the YAML file to read from\n     * @see <a href=\"http://www.yaml.org/spec/1.2/spec.html\">YAML 1.2 specification</a>\n     */\n    private static Configuration loadLegacyYAMLResource(File file) {\n        final Configuration config = new Configuration();\n\n        try (BufferedReader reader =\n                new BufferedReader(new InputStreamReader(new FileInputStream(file)))) {\n\n            String line;\n            int lineNo = 0;\n            while ((line = reader.readLine()) != null) {\n                lineNo++;\n                // 1. check for comments\n                String[] comments = line.split(\"#\", 2);\n                String conf = comments[0].trim();\n\n                // 2. get key and value\n                if (conf.length() > 0) {\n                    String[] kv = conf.split(\": \", 2);\n\n                    // skip line with no valid key-value pair\n                    if (kv.length == 1) {\n                        LOG.warn(\n                                \"Error while trying to split key and value in configuration file \"\n                                        + file\n                                        + \":\"\n                                        + lineNo\n                                        + \": Line is not a key-value pair (missing space after ':'?)\");\n                        continue;\n                    }\n\n                    String key = kv[0].trim();\n                    String value = kv[1].trim();\n\n                    // sanity check\n                    if (key.length() == 0 || value.length() == 0) {\n                        LOG.warn(\n                                \"Error after splitting key and value in configuration file \"\n                                        + file\n                                        + \":\"\n                                        + lineNo\n                                        + \": Key or value was empty\");\n                        continue;\n                    }\n\n                    config.setString(key, value);\n                }\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error parsing YAML configuration.\", e);\n        }\n\n        return config;\n    }",
          "conflictNames": [
              "file",
              "config",
              "reader",
              "lineNo",
              "comments",
              "conf",
              "kv",
              "key",
              "value"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c0176fd6794295dc3706ed7f536f3f70b6110923^1/flink-core/src/main/java/org/apache/flink/configuration/GlobalConfiguration.java",
      "locators": [
          {
              "line": 19,
              "column": 26
          },
          {
              "line": 40,
              "column": 11
          },
          {
              "line": 40,
              "column": 70
          },
          {
              "line": 41,
              "column": 61
          },
          {
              "line": 50,
              "column": 55
          },
          {
              "line": 66,
              "column": 23
          },
          {
              "line": 82,
              "column": 25
          },
          {
              "line": 83,
              "column": 25
          },
          {
              "line": 94,
              "column": 25
          },
          {
              "line": 94,
              "column": 77
          },
          {
              "line": 97,
              "column": 42
          },
          {
              "line": 100,
              "column": 22
          },
          {
              "line": 101,
              "column": 13
          },
          {
              "line": 105,
              "column": 34
          },
          {
              "line": 109,
              "column": 18
          },
          {
              "line": 111,
              "column": 39
          },
          {
              "line": 113,
              "column": 15
          },
          {
              "line": 113,
              "column": 58
          },
          {
              "line": 115,
              "column": 64
          },
          {
              "line": 116,
              "column": 34
          },
          {
              "line": 120,
              "column": 18
          },
          {
              "line": 121,
              "column": 8
          },
          {
              "line": 121,
              "column": 66
          },
          {
              "line": 123,
              "column": 15
          },
          {
              "line": 123,
              "column": 47
          },
          {
              "line": 124,
              "column": 33
          },
          {
              "line": 125,
              "column": 20
          },
          {
              "line": 125,
              "column": 56
          },
          {
              "line": 128,
              "column": 26
          },
          {
              "line": 130,
              "column": 13
          },
          {
              "line": 132,
              "column": 28
          },
          {
              "line": 132,
              "column": 73
          },
          {
              "line": 135,
              "column": 43
          },
          {
              "line": 138,
              "column": 32
          },
          {
              "line": 139,
              "column": 31
          },
          {
              "line": 145,
              "column": 27
          },
          {
              "line": 147,
              "column": 23
          },
          {
              "line": 153,
              "column": 36
          },
          {
              "line": 161,
              "column": 67
          },
          {
              "line": 163,
              "column": 17
          },
          {
              "line": 168,
              "column": 61
          },
          {
              "line": 170,
              "column": 13
          },
          {
              "line": 173,
              "column": 37
          },
          {
              "line": 177,
              "column": 13
          },
          {
              "line": 180,
              "column": 16
          },
          {
              "line": 183,
              "column": 71
          },
          {
              "line": 184,
              "column": 9
          },
          {
              "line": 187,
              "column": 37
          },
          {
              "line": 216,
              "column": 29
          },
          {
              "line": 236,
              "column": 79
          },
          {
              "line": 250,
              "column": 73
          },
          {
              "line": 258,
              "column": 21
          },
          {
              "line": 262,
              "column": 60
          },
          {
              "line": 265,
              "column": 16
          },
          {
              "line": 269,
              "column": 26
          },
          {
              "line": 287,
              "column": 15
          },
          {
              "line": 287,
              "column": 44
          },
          {
              "line": 288,
              "column": 70
          },
          {
              "line": 292,
              "column": 68
          },
          {
              "line": 295,
              "column": 9
          },
          {
              "line": 313,
              "column": 68
          },
          {
              "line": 315,
              "column": 24
          },
          {
              "line": 322,
              "column": 35
          },
          {
              "line": 344,
              "column": 29
          },
          {
              "line": 347,
              "column": 33
          },
          {
              "line": 348,
              "column": 13
          },
          {
              "line": 348,
              "column": 46
          },
          {
              "line": 350,
              "column": 20
          },
          {
              "line": 352,
              "column": 60
          },
          {
              "line": 359,
              "column": 23
          }
      ],
      "old_name": "config",
      "new_name": "standardYamlConfig",
      "ctx": {
          "symbolName": "config",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Configuration",
          "scopeHint": "in logConfiguration(...)",
          "filePath": "GlobalConfiguration.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "ies != null) {\n            logConfiguration(\"Loading dynamic\", dynamicProperties);\n            configuration.addAll(dynamicProperties);\n        }\n\n        return configuration;\n    }\n\n    private static void logConfiguration(String prefix, Configuration config) {\n        config.confData.forEach(\n                (key, value) ->\n                        LOG.info(\n                                \"{} configuration property: {}, {}\",\n                                prefix,\n                            ",
          "conflictNames": [
              "prefix"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c0576e5a907af68c4b45126d3380fd22e59a9b36^1/flink-runtime/src/test/java/org/apache/flink/runtime/rest/RestClientTest.java",
      "locators": [
          {
              "line": 91,
              "column": 29
          },
          {
              "line": 92,
              "column": 24
          },
          {
              "line": 93,
              "column": 24
          }
      ],
      "old_name": "throwable",
      "new_name": "cause",
      "ctx": {
          "symbolName": "throwable",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Throwable",
          "scopeHint": "in testConnectionTimeout(...)",
          "filePath": "RestClientTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testConnectionTimeout() throws Exception {\n        final Configuration config = new Configuration();\n        config.setLong(RestOptions.CONNECTION_TIMEOUT, 1);\n        try (final RestClient restClient = new RestClient(config, Executors.directExecutor())) {\n            restClient\n                    .sendRequest(\n                            unroutableIp,\n                            80,\n                            new TestMessageHeaders(),\n                            EmptyMessageParameters.getInstance(),\n                            EmptyRequestBody.getInstance())\n                    .get(60, TimeUnit.SECONDS);\n        } catch (final ExecutionException e) {\n            final Throwable throwable = ExceptionUtils.stripExecutionException(e);\n            assertThat(throwable, instanceOf(ConnectTimeoutException.class));\n            assertThat(throwable.getMessage(), containsString(unroutableIp));\n        }\n    }",
          "conflictNames": [
              "config",
              "restClient"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c05eab6bd6e8932f9f1ca0b78b5d6c206e7ae04b^1/flink-table/flink-table-planner/src/main/java/org/apache/calcite/sql2rel/RelDecorrelator.java",
      "locators": [
          {
              "line": 125,
              "column": 50
          },
          {
              "line": 1221,
              "column": 41
          },
          {
              "line": 1368,
              "column": 41
          },
          {
              "line": 1772,
              "column": 21
          },
          {
              "line": 1793,
              "column": 24
          },
          {
              "line": 1874,
              "column": 24
          },
          {
              "line": 1963,
              "column": 27
          },
          {
              "line": 1964,
              "column": 48
          }
      ],
      "old_name": "cast",
      "new_name": "newProjectExp",
      "ctx": {
          "symbolName": "cast",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RexNode",
          "scopeHint": "in onMatch(...)",
          "filePath": "RelDecorrelator.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public void onMatch(RelOptRuleCall call) {\n            Aggregate singleAggregate = call.rel(0);\n            Project project = call.rel(1);\n            Aggregate aggregate = call.rel(2);\n\n            // check singleAggRel is single_value agg\n            if (!singleAggregate.getGroupSet().isEmpty()\n                    || (singleAggregate.getAggCallList().size() != 1)\n                    || !(singleAggregate.getAggCallList().get(0).getAggregation()\n                            instanceof SqlSingleValueAggFunction)) {\n                return;\n            }\n\n            // check projRel only projects one expression\n            // check this project only projects one expression, i.e. scalar\n            // sub-queries.\n            List<RexNode> projExprs = project.getProjects();\n            if (projExprs.size() != 1) {\n                return;\n            }\n\n            // check the input to project is an aggregate on the entire input\n            if (!aggregate.getGroupSet().isEmpty()) {\n                return;\n            }\n\n            // BEGIN FLINK MODIFICATION\n            // Reason: fix the nullability mismatch issue\n            final RelBuilder relBuilder = call.builder();\n            final boolean nullable = singleAggregate.getAggCallList().get(0).getType().isNullable();\n            final RelDataType type =\n                    relBuilder\n                            .getTypeFactory()\n                            .createTypeWithNullability(projExprs.get(0).getType(), nullable);\n            // END FLINK MODIFICATION\n            final RexNode cast = relBuilder.getRexBuilder().makeCast(type, projExprs.get(0));\n            relBuilder.push(aggregate).project(cast);\n            call.transformTo(relBuilder.build());\n        }",
          "conflictNames": [
              "call",
              "singleAggregate",
              "project",
              "aggregate",
              "projExprs",
              "relBuilder",
              "nullable",
              "type"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c0bfb0b04bb38411c390813fea1ff93f6638f409^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/strategy/TestingSchedulingTopology.java",
      "locators": [
          {
              "line": 182,
              "column": 52
          },
          {
              "line": 184,
              "column": 34
          },
          {
              "line": 189,
              "column": 46
          },
          {
              "line": 198,
              "column": 39
          },
          {
              "line": 202,
              "column": 9
          },
          {
              "line": 205,
              "column": 38
          },
          {
              "line": 214,
              "column": 58
          },
          {
              "line": 216,
              "column": 74
          },
          {
              "line": 221,
              "column": 58
          },
          {
              "line": 223,
              "column": 73
          },
          {
              "line": 231,
              "column": 64
          },
          {
              "line": 240,
              "column": 62
          },
          {
              "line": 242,
              "column": 18
          },
          {
              "line": 242,
              "column": 30
          },
          {
              "line": 262,
              "column": 13
          },
          {
              "line": 285,
              "column": 62
          },
          {
              "line": 286,
              "column": 30
          },
          {
              "line": 288,
              "column": 44
          },
          {
              "line": 298,
              "column": 56
          },
          {
              "line": 298,
              "column": 67
          },
          {
              "line": 308,
              "column": 17
          },
          {
              "line": 310,
              "column": 47
          },
          {
              "line": 327,
              "column": 62
          },
          {
              "line": 328,
              "column": 30
          },
          {
              "line": 350,
              "column": 50
          },
          {
              "line": 356,
              "column": 29
          },
          {
              "line": 368,
              "column": 51
          },
          {
              "line": 368,
              "column": 62
          },
          {
              "line": 369,
              "column": 17
          }
      ],
      "old_name": "consumer",
      "new_name": "partitionId",
      "ctx": {
          "symbolName": "consumer",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "TestingSchedulingExecutionVertex",
          "scopeHint": "in connect(...)",
          "filePath": "TestingSchedulingTopology.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "onVertexID(jobVertexId, subtaskIndex);\n        addSchedulingExecutionVertex(newVertex);\n        return newVertex;\n    }\n\n    public TestingSchedulingTopology connect(\n            final TestingSchedulingExecutionVertex producer,\n            final TestingSchedulingExecutionVertex consumer) {\n\n        return connect(producer, consumer, ResultPartitionType.PIPELINED);\n    }\n\n    public TestingSchedulingTopology connect(\n            TestingSchedulingExecutionVertex producer,\n            TestingSchedulingExecutionVertex consume",
          "conflictNames": [
              "producer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c0bfb0b04bb38411c390813fea1ff93f6638f409^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/strategy/TestingSchedulingTopology.java",
      "locators": [
          {
              "line": 296,
              "column": 22
          },
          {
              "line": 296,
              "column": 31
          },
          {
              "line": 296,
              "column": 55
          },
          {
              "line": 297,
              "column": 81
          },
          {
              "line": 298,
              "column": 81
          },
          {
              "line": 304,
              "column": 51
          }
      ],
      "old_name": "idx",
      "new_name": "i",
      "ctx": {
          "symbolName": "idx",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in connect(...)",
          "filePath": "TestingSchedulingTopology.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        protected List<TestingSchedulingResultPartition> connect() {\n            final List<TestingSchedulingResultPartition> resultPartitions = new ArrayList<>();\n            final IntermediateDataSetID intermediateDataSetId = new IntermediateDataSetID();\n\n            for (int idx = 0; idx < producers.size(); idx++) {\n                final TestingSchedulingExecutionVertex producer = producers.get(idx);\n                final TestingSchedulingExecutionVertex consumer = consumers.get(idx);\n\n                final TestingSchedulingResultPartition resultPartition =\n                        initTestingSchedulingResultPartitionBuilder()\n                                .withIntermediateDataSetID(intermediateDataSetId)\n                                .withResultPartitionState(resultPartitionState)\n                                .withPartitionNum(idx)\n                                .build();\n                resultPartition.setProducer(producer);\n                producer.addProducedPartition(resultPartition);\n                consumer.addConsumedPartition(resultPartition);\n                resultPartition.addConsumerGroup(\n                        Collections.singleton(consumer), resultPartitionType);\n                resultPartitions.add(resultPartition);\n            }\n\n            return resultPartitions;\n        }",
          "conflictNames": [
              "resultPartitions",
              "intermediateDataSetId",
              "producer",
              "consumer",
              "resultPartition"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c11632674a8a9636a5f73d906141af578e153d4f^1/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/restore/RocksDBIncrementalRestoreOperation.java",
      "locators": [
          {
              "line": 7,
              "column": 42
          },
          {
              "line": 14,
              "column": 57
          },
          {
              "line": 97,
              "column": 58
          },
          {
              "line": 106,
              "column": 34
          },
          {
              "line": 262,
              "column": 76
          },
          {
              "line": 268,
              "column": 69
          },
          {
              "line": 269,
              "column": 67
          },
          {
              "line": 272,
              "column": 61
          },
          {
              "line": 276,
              "column": 77
          },
          {
              "line": 277,
              "column": 45
          },
          {
              "line": 323,
              "column": 34
          },
          {
              "line": 341,
              "column": 25
          },
          {
              "line": 444,
              "column": 37
          },
          {
              "line": 444,
              "column": 84
          },
          {
              "line": 459,
              "column": 20
          },
          {
              "line": 459,
              "column": 72
          },
          {
              "line": 460,
              "column": 33
          },
          {
              "line": 463,
              "column": 17
          },
          {
              "line": 470,
              "column": 27
          },
          {
              "line": 471,
              "column": 21
          },
          {
              "line": 472,
              "column": 29
          },
          {
              "line": 474,
              "column": 29
          },
          {
              "line": 477,
              "column": 17
          },
          {
              "line": 478,
              "column": 37
          },
          {
              "line": 483,
              "column": 67
          },
          {
              "line": 485,
              "column": 25
          },
          {
              "line": 485,
              "column": 55
          },
          {
              "line": 493,
              "column": 13
          },
          {
              "line": 494,
              "column": 24
          },
          {
              "line": 495,
              "column": 32
          },
          {
              "line": 500,
              "column": 43
          },
          {
              "line": 501,
              "column": 34
          },
          {
              "line": 502,
              "column": 8
          },
          {
              "line": 504,
              "column": 15
          },
          {
              "line": 504,
              "column": 54
          },
          {
              "line": 506,
              "column": 15
          },
          {
              "line": 506,
              "column": 88
          },
          {
              "line": 507,
              "column": 76
          },
          {
              "line": 508,
              "column": 12
          },
          {
              "line": 509,
              "column": 50
          },
          {
              "line": 510,
              "column": 33
          },
          {
              "line": 512,
              "column": 27
          },
          {
              "line": 513,
              "column": 18
          },
          {
              "line": 516,
              "column": 21
          },
          {
              "line": 521,
              "column": 35
          },
          {
              "line": 551,
              "column": 24
          },
          {
              "line": 552,
              "column": 55
          },
          {
              "line": 556,
              "column": 29
          },
          {
              "line": 557,
              "column": 29
          },
          {
              "line": 569,
              "column": 35
          },
          {
              "line": 574,
              "column": 50
          },
          {
              "line": 582,
              "column": 36
          },
          {
              "line": 635,
              "column": 61
          },
          {
              "line": 637,
              "column": 15
          },
          {
              "line": 637,
              "column": 48
          },
          {
              "line": 638,
              "column": 15
          },
          {
              "line": 638,
              "column": 69
          },
          {
              "line": 643,
              "column": 21
          },
          {
              "line": 644,
              "column": 27
          },
          {
              "line": 647,
              "column": 59
          },
          {
              "line": 649,
              "column": 37
          },
          {
              "line": 654,
              "column": 17
          },
          {
              "line": 664,
              "column": 17
          },
          {
              "line": 669,
              "column": 38
          },
          {
              "line": 852,
              "column": 31
          },
          {
              "line": 866,
              "column": 30
          },
          {
              "line": 867,
              "column": 60
          }
      ],
      "old_name": "ex",
      "new_name": "throwable",
      "ctx": {
          "symbolName": "ex",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Exception",
          "scopeHint": "in restore(...)",
          "filePath": "RocksDBIncrementalRestoreOperation.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "                                                      operatorIdentifier,\n                                                                    System.currentTimeMillis() - t);\n                                                        } catch (Exception ex) {\n                                                            logger.info(\n                                                                    \"Failed async compaction after restore for backend {} in operator {} after {} ms.\",\n           ",
          "conflictNames": [
              "allDownloadSpecs",
              "localKeyedStateHandles",
              "absolutInstanceBasePath",
              "asyncCompactFuture",
              "runWithLogging",
              "t",
              "executorService",
              "resultFuture"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c11632674a8a9636a5f73d906141af578e153d4f^1/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/restore/RocksDBIncrementalRestoreOperation.java",
      "locators": [
          {
              "line": 236,
              "column": 37
          },
          {
              "line": 238,
              "column": 17
          },
          {
              "line": 295,
              "column": 21
          }
      ],
      "old_name": "asyncCompactFuture",
      "new_name": "asyncRangeCompactionTask",
      "ctx": {
          "symbolName": "asyncCompactFuture",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CompletableFuture<Void>",
          "scopeHint": "in restore(...)",
          "filePath": "RocksDBIncrementalRestoreOperation.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Root method that branches for different implementations of {@link\n     * IncrementalKeyedStateHandle}.\n     */\n    @Override\n    public RocksDBRestoreResult restore() throws Exception {\n\n        if (restoreStateHandles == null || restoreStateHandles.isEmpty()) {\n            return null;\n        }\n\n        logger.info(\n                \"Starting RocksDB incremental recovery in operator {} \"\n                        + \"target key-group range {}. Use IngestDB={}, Use AsyncCompaction={}, State Handles={}\",\n                operatorIdentifier,\n                keyGroupRange.prettyPrintInterval(),\n                useIngestDbRestoreMode,\n                asyncCompactAfterRescale,\n                restoreStateHandles);\n\n        final List<StateHandleDownloadSpec> allDownloadSpecs =\n                new ArrayList<>(restoreStateHandles.size());\n\n        final List<IncrementalLocalKeyedStateHandle> localKeyedStateHandles =\n                new ArrayList<>(restoreStateHandles.size());\n\n        final Path absolutInstanceBasePath = instanceBasePath.getAbsoluteFile().toPath();\n\n        try {\n            runAndReportDuration(\n                    () ->\n                            makeAllStateHandlesLocal(\n                                    absolutInstanceBasePath,\n                                    localKeyedStateHandles,\n                                    allDownloadSpecs),\n                    DOWNLOAD_STATE_DURATION);\n\n            runAndReportDuration(\n                    () -> restoreFromLocalState(localKeyedStateHandles), RESTORE_STATE_DURATION);\n\n            CompletableFuture<Void> asyncCompactFuture = null;\n            if (asyncCompactAfterRescale) {\n                asyncCompactFuture =\n                        RocksDBIncrementalCheckpointUtils.createRangeCompactionTaskIfNeeded(\n                                        rocksHandle.getDb(),\n                                        rocksHandle.getColumnFamilyHandles(),\n                                        keyGroupPrefixBytes,\n                                        keyGroupRange)\n                                .map(\n                                        (run) -> {\n                                            RunnableWithException runWithLogging =\n                                                    () -> {\n                                                        long t = System.currentTimeMillis();\n                                                        logger.info(\n                                                                \"Starting async compaction after restore for backend {} in operator {}\",\n                                                                backendUID,\n                                                                operatorIdentifier);\n                                                        try {\n                                                            runAndReportDuration(\n                                                                    run,\n                                                                    RESTORE_ASYNC_COMPACTION_DURATION);\n                                                            logger.info(\n                                                                    \"Completed async compaction after restore for backend {} in operator {} after {} ms.\",\n                                                                    backendUID,\n                                                                    operatorIdentifier,\n                                                                    System.currentTimeMillis() - t);\n                                                        } catch (Exception ex) {\n                                                            logger.info(\n                                                                    \"Failed async compaction after restore for backend {} in operator {} after {} ms.\",\n                                                                    backendUID,\n                                                                    operatorIdentifier,\n                                                                    System.currentTimeMillis() - t,\n                                                                    ex);\n                                                            throw ex;\n                                                        }\n                                                    };\n                                            ExecutorService executorService =\n                                                    Executors.newSingleThreadExecutor();\n                                            CompletableFuture<Void> resultFuture =\n                                                    FutureUtils.runAsync(\n                                                            runWithLogging, executorService);\n                                            executorService.shutdown();\n                                            return resultFuture;\n                                        })\n                                .orElse(null);\n                logger.info(\n                        \"Finished RocksDB incremental recovery in operator {} with \"\n                                + \"target key-group range range {}.\",\n                        operatorIdentifier,\n                        keyGroupRange.prettyPrintInterval());\n            }\n\n            return new RocksDBRestoreResult(\n                    this.rocksHandle.getDb(),\n                    this.rocksHandle.getDefaultColumnFamilyHandle(),\n                    this.rocksHandle.getNativeMetricMonitor(),\n                    lastCompletedCheckpointId,\n                    backendUID,\n                    restoredSstFiles,\n                    asyncCompactFuture);\n        } finally {\n            // Cleanup all download directories\n            allDownloadSpecs.stream()\n                    .map(StateHandleDownloadSpec::getDownloadDestination)\n                    .forEach(this::cleanUpPathQuietly);\n        }\n    }",
          "conflictNames": [
              "allDownloadSpecs",
              "localKeyedStateHandles",
              "absolutInstanceBasePath",
              "runWithLogging",
              "t",
              "executorService",
              "resultFuture"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c1fa29ac91aeef64701d8d97b13644a4267e8f8e^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/operations/converters/SqlReplaceTableAsConverter.java",
      "locators": [
          {
              "line": 74,
              "column": 22
          },
          {
              "line": 84,
              "column": 25
          }
      ],
      "old_name": "catalogTable",
      "new_name": "tableWithResolvedSchema",
      "ctx": {
          "symbolName": "catalogTable",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CatalogTable",
          "scopeHint": "in convertSqlNode(...)",
          "filePath": "SqlReplaceTableAsConverter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public Operation convertSqlNode(SqlReplaceTableAs sqlReplaceTableAs, ConvertContext context) {\n        CatalogManager catalogManager = context.getCatalogManager();\n        UnresolvedIdentifier unresolvedIdentifier =\n                UnresolvedIdentifier.of(sqlReplaceTableAs.fullTableName());\n        ObjectIdentifier identifier = catalogManager.qualifyIdentifier(unresolvedIdentifier);\n\n        SqlNode asQuerySqlNode = sqlReplaceTableAs.getAsQuery();\n        SqlNode validated = context.getSqlValidator().validate(asQuerySqlNode);\n        QueryOperation query =\n                new PlannerQueryOperation(\n                        context.toRelRoot(validated).project(),\n                        () -> context.toQuotedSqlString(asQuerySqlNode));\n\n        // get table comment\n        String tableComment =\n                OperationConverterUtils.getTableComment(sqlReplaceTableAs.getComment());\n\n        // get table properties\n        Map<String, String> properties = new HashMap<>();\n        sqlReplaceTableAs\n                .getPropertyList()\n                .getList()\n                .forEach(\n                        p ->\n                                properties.put(\n                                        ((SqlTableOption) p).getKeyString(),\n                                        ((SqlTableOption) p).getValueString()));\n\n        // get table\n        CatalogTable catalogTable =\n                CatalogTable.of(\n                        Schema.newBuilder().fromResolvedSchema(query.getResolvedSchema()).build(),\n                        tableComment,\n                        Collections.emptyList(),\n                        properties);\n\n        CreateTableOperation createTableOperation =\n                new CreateTableOperation(\n                        identifier,\n                        catalogTable,\n                        sqlReplaceTableAs.isIfNotExists(),\n                        sqlReplaceTableAs.isTemporary());\n\n        return new ReplaceTableAsOperation(\n                createTableOperation, query, sqlReplaceTableAs.isCreateOrReplace());\n    }",
          "conflictNames": [
              "sqlReplaceTableAs",
              "context",
              "catalogManager",
              "unresolvedIdentifier",
              "identifier",
              "asQuerySqlNode",
              "validated",
              "query",
              "tableComment",
              "properties",
              "createTableOperation"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c418b57870aaf5b4f4f9d0f69a70366b583ae166^1/flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/taskmanager/AbstractTaskManagerFileHandlerTest.java",
      "locators": [
          {
              "line": 165,
              "column": 42
          },
          {
              "line": 173,
              "column": 9
          },
          {
              "line": 206,
              "column": 42
          },
          {
              "line": 214,
              "column": 9
          },
          {
              "line": 220,
              "column": 9
          }
      ],
      "old_name": "testTaskManagerFileHandler",
      "new_name": "testingTaskManagerFileHandler",
      "ctx": {
          "symbolName": "testTaskManagerFileHandler",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestTaskManagerFileHandler",
          "scopeHint": "in testFileServing(...)",
          "filePath": "AbstractTaskManagerFileHandlerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Tests that the {@link AbstractTaskManagerFileHandler} serves the requested file. */\n    @Test\n    public void testFileServing() throws Exception {\n        final Time cacheEntryDuration = Time.milliseconds(1000L);\n\n        final Queue<CompletableFuture<TransientBlobKey>> requestFileUploads = new ArrayDeque<>(1);\n\n        requestFileUploads.add(CompletableFuture.completedFuture(transientBlobKey1));\n\n        final TestTaskManagerFileHandler testTaskManagerFileHandler =\n                createTestTaskManagerFileHandler(\n                        cacheEntryDuration, requestFileUploads, EXPECTED_TASK_MANAGER_ID);\n\n        final File outputFile = temporaryFolder.newFile();\n        final TestingChannelHandlerContext testingContext =\n                new TestingChannelHandlerContext(outputFile);\n\n        testTaskManagerFileHandler.respondToRequest(\n                testingContext, HTTP_REQUEST, handlerRequest, null);\n\n        assertThat(outputFile.length(), is(greaterThan(0L)));\n        assertThat(FileUtils.readFileUtf8(outputFile), is(equalTo(fileContent1)));\n    }",
          "conflictNames": [
              "cacheEntryDuration",
              "requestFileUploads",
              "outputFile",
              "testingContext"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c4c633e843920bbf18b2ac2242ee48ada408f6ac^1/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/ZooKeeperLeaderElectionTest.java",
      "locators": [
          {
              "line": 361,
              "column": 41
          },
          {
              "line": 363,
              "column": 71
          },
          {
              "line": 378,
              "column": 30
          },
          {
              "line": 382,
              "column": 37
          }
      ],
      "old_name": "leaderInformationConsumer",
      "new_name": "electionEventHandler",
      "ctx": {
          "symbolName": "leaderInformationConsumer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "LeaderInformationConsumer",
          "scopeHint": "in testLeaderChangeWriteLeaderInformationOnlyOnce(...)",
          "filePath": "ZooKeeperLeaderElectionTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Tests that the leader update information will not be notified repeatedly. */\n    @Test\n    void testLeaderChangeWriteLeaderInformationOnlyOnce() throws Exception {\n        final LeaderInformationConsumer leaderInformationConsumer = new LeaderInformationConsumer();\n        final TestingLeaderElectionEventHandler electionEventHandler =\n                new TestingLeaderElectionEventHandler(LEADER_ADDRESS, leaderInformationConsumer);\n\n        @SuppressWarnings(\"deprecation\")\n        ZooKeeperLeaderElectionDriver leaderElectionDriver = null;\n        try {\n            leaderElectionDriver =\n                    createAndInitLeaderElectionDriver(\n                            createZooKeeperClient(), electionEventHandler);\n\n            electionEventHandler.waitForLeader();\n            final LeaderInformation confirmedLeaderInformation =\n                    electionEventHandler.getConfirmedLeaderInformation();\n            assertThat(confirmedLeaderInformation.getLeaderAddress()).isEqualTo(LEADER_ADDRESS);\n\n            // First update will successfully complete.\n            assertThatFuture(leaderInformationConsumer.getFirstUpdateFuture()).eventuallySucceeds();\n            // Wait for a while to make sure other updates don't appear.\n            assertThatThrownBy(\n                            () ->\n                                    leaderInformationConsumer\n                                            .getAnotherUpdateFuture()\n                                            .get(5, TimeUnit.MILLISECONDS),\n                            \"Another leader information update is not expected.\")\n                    .isInstanceOf(TimeoutException.class);\n        } finally {\n            electionEventHandler.close();\n            if (leaderElectionDriver != null) {\n                leaderElectionDriver.close();\n            }\n        }\n    }",
          "conflictNames": [
              "electionEventHandler",
              "leaderElectionDriver",
              "confirmedLeaderInformation"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c58a6ebbae50e95c59ad5cdcc7c2f2023c5d38f3^1/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/ForStStateRequestClassifier.java",
      "locators": [
          {
              "line": 59,
              "column": 46
          },
          {
              "line": 61,
              "column": 39
          },
          {
              "line": 66,
              "column": 46
          },
          {
              "line": 68,
              "column": 39
          },
          {
              "line": 74,
              "column": 50
          },
          {
              "line": 76,
              "column": 43
          }
      ],
      "old_name": "forStValueState",
      "new_name": "innerTable",
      "ctx": {
          "symbolName": "forStValueState",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ForStValueState<?, ?, ?>",
          "scopeHint": "in convertStateRequestsToForStDBRequests(...)",
          "filePath": "ForStStateRequestClassifier.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@SuppressWarnings(\"ConstantConditions\")\n    private void convertStateRequestsToForStDBRequests(StateRequest<?, ?, ?> stateRequest) {\n        StateRequestType stateRequestType = stateRequest.getRequestType();\n        switch (stateRequestType) {\n            case VALUE_GET:\n                {\n                    ForStValueState<?, ?, ?> forStValueState =\n                            (ForStValueState<?, ?, ?>) stateRequest.getState();\n                    dbGetRequests.add(forStValueState.buildDBGetRequest(stateRequest));\n                    return;\n                }\n            case VALUE_UPDATE:\n                {\n                    ForStValueState<?, ?, ?> forStValueState =\n                            (ForStValueState<?, ?, ?>) stateRequest.getState();\n                    dbPutRequests.add(forStValueState.buildDBPutRequest(stateRequest));\n                    return;\n                }\n            case CLEAR:\n                {\n                    if (stateRequest.getState() instanceof ForStValueState) {\n                        ForStValueState<?, ?, ?> forStValueState =\n                                (ForStValueState<?, ?, ?>) stateRequest.getState();\n                        dbPutRequests.add(forStValueState.buildDBPutRequest(stateRequest));\n                        return;\n                    } else {\n                        throw new UnsupportedOperationException(\n                                \"The State \"\n                                        + stateRequest.getState().getClass()\n                                        + \" doesn't yet support the clear method.\");\n                    }\n                }\n            default:\n                throw new UnsupportedOperationException(\n                        \"Unsupported state request type:\" + stateRequestType);\n        }\n    }",
          "conflictNames": [
              "stateRequest",
              "stateRequestType",
              "forStValueState"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c65d5f18ad5dfe91ca01bfda86d36f09ba11a78a^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java",
      "locators": [
          {
              "line": 996,
              "column": 31
          },
          {
              "line": 997,
              "column": 52
          }
      ],
      "old_name": "subpartitionInfo",
      "new_name": "inputChannel",
      "ctx": {
          "symbolName": "subpartitionInfo",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "SubpartitionInfo",
          "scopeHint": "in assertChannelsType(...)",
          "filePath": "SingleInputGateTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "o3, info4));\n        assertChannelsType(gate, LocalInputChannel.class, Arrays.asList(info5, info6));\n    }\n\n    private void assertChannelsType(\n            SingleInputGate gate, Class<?> clazz, List<SubpartitionInfo> infos) {\n        for (SubpartitionInfo subpartitionInfo : infos) {\n            assertThat(gate.getInputChannels().get(subpartitionInfo)).isInstanceOf(clazz);\n        }\n    }\n\n    @Test\n    void testQueuedBuffers() throws Exception {\n        final NettyShuffleEnvironment network = createNettyShu",
          "conflictNames": [
              "gate",
              "clazz",
              "infos"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c65d5f18ad5dfe91ca01bfda86d36f09ba11a78a^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java",
      "locators": [
          {
              "line": 358,
              "column": 56
          },
          {
              "line": 358,
              "column": 78
          },
          {
              "line": 359,
              "column": 41
          },
          {
              "line": 365,
              "column": 21
          }
      ],
      "old_name": "entry",
      "new_name": "inputChannelsForCurrentPartition",
      "ctx": {
          "symbolName": "entry",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Entry<SubpartitionInfo, InputChannel>",
          "scopeHint": "in convertRecoveredInputChannels(...)",
          "filePath": "SingleInputGate.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "onsumerClient.start();\n            }\n        }\n    }\n\n    @VisibleForTesting\n    public void convertRecoveredInputChannels() {\n        LOG.debug(\"Converting recovered input channels ({} channels)\", getNumberOfInputChannels());\n        for (Map.Entry<SubpartitionInfo, InputChannel> entry : inputChannels.entrySet()) {\n            InputChannel inputChannel = entry.getValue();\n            if (inputChannel instanceof RecoveredInputChannel) {\n                try {\n                    InputChannel realInputChannel =\n            ",
          "conflictNames": [
              "inputChannel",
              "realInputChannel"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c65d5f18ad5dfe91ca01bfda86d36f09ba11a78a^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java",
      "locators": [
          {
              "line": 548,
              "column": 72
          },
          {
              "line": 944,
              "column": 47
          },
          {
              "line": 1040,
              "column": 17
          },
          {
              "line": 1044,
              "column": 29
          },
          {
              "line": 1227,
              "column": 34
          },
          {
              "line": 1228,
              "column": 24
          },
          {
              "line": 1229,
              "column": 28
          }
      ],
      "old_name": "that",
      "new_name": "thatID",
      "ctx": {
          "symbolName": "that",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SubpartitionInfo",
          "scopeHint": "in equals(...)",
          "filePath": "SingleInputGate.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public boolean equals(Object obj) {\n            if (obj == this) {\n                return true;\n            } else if (obj != null && obj.getClass() == getClass()) {\n                SubpartitionInfo that = (SubpartitionInfo) obj;\n                return that.partitionID.equals(this.partitionID)\n                        && that.subpartitionIndex == this.subpartitionIndex;\n            } else {\n                return false;\n            }\n        }",
          "conflictNames": [
              "obj"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c6c8109d102f4b944aab6e835c553d834cc98f12^1/flink-runtime/src/test/java/org/apache/flink/runtime/webmonitor/threadinfo/JobVertexThreadInfoTrackerTest.java",
      "locators": [
          {
              "line": 162,
              "column": 70
          },
          {
              "line": 168,
              "column": 25
          },
          {
              "line": 197,
              "column": 70
          },
          {
              "line": 203,
              "column": 25
          },
          {
              "line": 291,
              "column": 74
          },
          {
              "line": 307,
              "column": 38
          }
      ],
      "old_name": "vertexStatsCache",
      "new_name": "jobVertexStatsCache",
      "ctx": {
          "symbolName": "vertexStatsCache",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Cache<Key, VertexThreadInfoStats>",
          "scopeHint": "in testCachedStatsUpdatedAfterRefreshInterval(...)",
          "filePath": "JobVertexThreadInfoTrackerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Tests that cached result is NOT reused after refresh interval. */\n    @Test\n    public void testCachedStatsUpdatedAfterRefreshInterval() throws Exception {\n        final Duration shortRefreshInterval = Duration.ofMillis(1);\n\n        // first entry is in the past, so refresh is triggered immediately upon fetching it\n        final VertexThreadInfoStats initialThreadInfoStats =\n                createThreadInfoStats(\n                        Instant.now().minus(10, ChronoUnit.SECONDS),\n                        REQUEST_ID,\n                        Duration.ofMillis(5));\n        final VertexThreadInfoStats threadInfoStatsAfterRefresh =\n                createThreadInfoStats(1, TIME_GAP);\n\n        // register a CountDownLatch with the cache so we can await refresh of the entry\n        CountDownLatch cacheRefreshed = new CountDownLatch(1);\n        Cache<JobVertexThreadInfoTracker.Key, VertexThreadInfoStats> vertexStatsCache =\n                createCache(CLEAN_UP_INTERVAL, new LatchRemovalListener<>(cacheRefreshed));\n        final JobVertexThreadInfoTracker<VertexThreadInfoStats> tracker =\n                createThreadInfoTracker(\n                        CLEAN_UP_INTERVAL,\n                        shortRefreshInterval,\n                        vertexStatsCache,\n                        initialThreadInfoStats,\n                        threadInfoStatsAfterRefresh);\n\n        // no stats yet, but the request triggers async collection of stats\n        assertThat(tracker.getVertexStats(JOB_ID, EXECUTION_JOB_VERTEX)).isNotPresent();\n        // block until the async call completes and the first result is available\n        tracker.getResultAvailableFuture().get();\n\n        // retrieve the entry, triggering the refresh as side effect\n        assertExpectedEqualsReceived(\n                initialThreadInfoStats, tracker.getVertexStats(JOB_ID, EXECUTION_JOB_VERTEX));\n\n        // wait until the entry is refreshed\n        cacheRefreshed.await();\n\n        // verify that we get the second result on the next request\n        Optional<VertexThreadInfoStats> result =\n                tracker.getVertexStats(JOB_ID, EXECUTION_JOB_VERTEX);\n        assertExpectedEqualsReceived(threadInfoStatsAfterRefresh, result);\n    }",
          "conflictNames": [
              "shortRefreshInterval",
              "initialThreadInfoStats",
              "threadInfoStatsAfterRefresh",
              "cacheRefreshed",
              "tracker",
              "result"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c6c8109d102f4b944aab6e835c553d834cc98f12^1/flink-runtime/src/main/java/org/apache/flink/runtime/webmonitor/threadinfo/JobVertexThreadInfoTracker.java",
      "locators": [
          {
              "line": 156,
              "column": 23
          },
          {
              "line": 158,
              "column": 59
          },
          {
              "line": 162,
              "column": 49
          },
          {
              "line": 172,
              "column": 15
          },
          {
              "line": 172,
              "column": 25
          },
          {
              "line": 176,
              "column": 23
          },
          {
              "line": 183,
              "column": 36
          },
          {
              "line": 184,
              "column": 30
          },
          {
              "line": 206,
              "column": 77
          },
          {
              "line": 325,
              "column": 17
          },
          {
              "line": 326,
              "column": 42
          },
          {
              "line": 326,
              "column": 84
          },
          {
              "line": 339,
              "column": 27
          },
          {
              "line": 342,
              "column": 48
          },
          {
              "line": 343,
              "column": 18
          },
          {
              "line": 343,
              "column": 24
          },
          {
              "line": 355,
              "column": 46
          },
          {
              "line": 366,
              "column": 41
          }
      ],
      "old_name": "key",
      "new_name": "jobVertexKey",
      "ctx": {
          "symbolName": "key",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Key",
          "scopeHint": "in getVertexStats(...)",
          "filePath": "JobVertexThreadInfoTracker.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public Optional<T> getVertexStats(JobID jobId, AccessExecutionJobVertex vertex) {\n        synchronized (lock) {\n            final Key key = getKey(jobId, vertex);\n\n            final T stats = vertexStatsCache.getIfPresent(key);\n            if (stats == null\n                    || System.currentTimeMillis()\n                            >= stats.getEndTime() + statsRefreshInterval.toMillis()) {\n                triggerThreadInfoSampleInternal(key, vertex);\n            }\n            return Optional.ofNullable(stats);\n        }\n    }",
          "conflictNames": [
              "jobId",
              "vertex",
              "stats"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c7011080223cf4fb021859a266415468f2f802e5^1/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/failover/partitionrelease/RegionPartitionGroupReleaseStrategy.java",
      "locators": [
          {
              "line": 73,
              "column": 44
          },
          {
              "line": 74,
              "column": 49
          },
          {
              "line": 121,
              "column": 58
          },
          {
              "line": 123,
              "column": 58
          },
          {
              "line": 124,
              "column": 46
          },
          {
              "line": 127,
              "column": 63
          },
          {
              "line": 132,
              "column": 37
          },
          {
              "line": 134,
              "column": 49
          },
          {
              "line": 138,
              "column": 17
          },
          {
              "line": 174,
              "column": 69
          },
          {
              "line": 176,
              "column": 58
          }
      ],
      "old_name": "executionVertexId",
      "new_name": "executionVertex",
      "ctx": {
          "symbolName": "executionVertexId",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "SchedulingExecutionVertex",
          "scopeHint": "in initRegionExecutionViewByVertex(...)",
          "filePath": "RegionPartitionGroupReleaseStrategy.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "wRegions) {\n        for (SchedulingPipelinedRegion pipelinedRegion : newRegions) {\n            final PipelinedRegionExecutionView regionExecutionView =\n                    new PipelinedRegionExecutionView(pipelinedRegion);\n            for (SchedulingExecutionVertex executionVertexId : pipelinedRegion.getVertices()) {\n                regionExecutionViewByVertex.put(executionVertexId.getId(), regionExecutionView);\n            }\n        }\n    }\n\n    private Iterable<ConsumerRegionGroupExecutionView> initPartitionGroupCon",
          "conflictNames": [
              "newRegions",
              "regionExecutionView"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c730292d645fc7ea24659f791eb8599b2c849408^1/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/inference/strategies/ToTimestampLtzTypeStrategy.java",
      "locators": [
          {
              "line": 36,
              "column": 23
          },
          {
              "line": 37,
              "column": 56
          }
      ],
      "old_name": "precision",
      "new_name": "argumentTypes",
      "ctx": {
          "symbolName": "precision",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in inferType(...)",
          "filePath": "ToTimestampLtzTypeStrategy.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public Optional<DataType> inferType(CallContext callContext) {\n        if (callContext.isArgumentLiteral(1)) {\n            final int precision = callContext.getArgumentValue(1, Integer.class).get();\n            return Optional.of(DataTypes.TIMESTAMP_LTZ(precision));\n        }\n        return Optional.of(DataTypes.TIMESTAMP_LTZ(3));\n    }",
          "conflictNames": [
              "callContext"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c868d2273086ab9c9deafe5936127ce858e2b1cf^1/flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/table/planner/delegation/hive/HiveParser.java",
      "locators": [
          {
              "line": 221,
              "column": 18
          },
          {
              "line": 222,
              "column": 9
          },
          {
              "line": 223,
              "column": 9
          },
          {
              "line": 224,
              "column": 9
          },
          {
              "line": 229,
              "column": 45
          },
          {
              "line": 231,
              "column": 48
          },
          {
              "line": 234,
              "column": 42
          },
          {
              "line": 279,
              "column": 72
          },
          {
              "line": 288,
              "column": 70
          },
          {
              "line": 374,
              "column": 34
          },
          {
              "line": 376,
              "column": 63
          },
          {
              "line": 380,
              "column": 76
          },
          {
              "line": 395,
              "column": 46
          },
          {
              "line": 411,
              "column": 49
          },
          {
              "line": 417,
              "column": 70
          },
          {
              "line": 433,
              "column": 52
          },
          {
              "line": 438,
              "column": 22
          },
          {
              "line": 445,
              "column": 29
          },
          {
              "line": 452,
              "column": 51
          },
          {
              "line": 454,
              "column": 40
          },
          {
              "line": 482,
              "column": 22
          },
          {
              "line": 499,
              "column": 48
          },
          {
              "line": 539,
              "column": 49
          },
          {
              "line": 542,
              "column": 72
          }
      ],
      "old_name": "hiveConf",
      "new_name": "hiveConfCopy",
      "ctx": {
          "symbolName": "hiveConf",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "HiveConf",
          "scopeHint": "in parse(...)",
          "filePath": "HiveParser.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public List<Operation> parse(String statement) {\n        // first try to use flink extended parser to parse some special commands\n        Optional<Operation> flinkExtendedOperation =\n                FlinkExtendedParser.parseFlinkExtendedCommand(trimSemicolon(statement));\n        if (flinkExtendedOperation.isPresent()) {\n            return Collections.singletonList(flinkExtendedOperation.get());\n        }\n\n        Catalog currentCatalog =\n                catalogRegistry.getCatalogOrError(catalogRegistry.getCurrentCatalog());\n        if (!(currentCatalog instanceof HiveCatalog)) {\n            // current, if it's not a hive catalog, we can't use hive dialect;\n            // but we try to parse it to set command, if it's a set command, we can return\n            // the SetOperation directly which enables users to switch dialect when hive dialect\n            // is not available in the case of current catalog is not a HiveCatalog\n            Optional<Operation> optionalOperation = FlinkExtendedParser.parseSet(statement);\n            if (optionalOperation.isPresent()) {\n                return Collections.singletonList(optionalOperation.get());\n            } else {\n                throw new TableException(\n                        String.format(\n                                \"Current catalog is %s, which not a HiveCatalog, \"\n                                        + \"but Hive dialect is only supported when the current catalog is HiveCatalog.\",\n                                catalogRegistry.getCurrentCatalog()));\n            }\n        }\n\n        Optional<Operation> nonSqlOperation =\n                tryProcessHiveNonSqlStatement(\n                        ((HiveCatalog) currentCatalog).getHiveConf(), statement);\n        if (nonSqlOperation.isPresent()) {\n            return Collections.singletonList(nonSqlOperation.get());\n        }\n        HiveConf hiveConf = new HiveConf(((HiveCatalog) currentCatalog).getHiveConf());\n        hiveConf.setVar(HiveConf.ConfVars.DYNAMICPARTITIONINGMODE, \"nonstrict\");\n        hiveConf.set(\"hive.allow.udf.load.on.demand\", \"false\");\n        hiveConf.setVar(HiveConf.ConfVars.HIVE_EXECUTION_ENGINE, \"mr\");\n        HiveShim hiveShim =\n                HiveShimLoader.loadHiveShim(((HiveCatalog) currentCatalog).getHiveVersion());\n        try {\n            // substitute variables for the statement\n            statement = substituteVariables(hiveConf, statement);\n            // creates SessionState\n            HiveSessionState.startSessionState(hiveConf, catalogRegistry);\n            // We override Hive's grouping function. Refer to the implementation for more details.\n            hiveShim.registerTemporaryFunction(\"grouping\", HiveGenericUDFGrouping.class);\n            return processCmd(statement, hiveConf, hiveShim, (HiveCatalog) currentCatalog);\n        } finally {\n            HiveSessionState.clearSessionState();\n        }\n    }",
          "conflictNames": [
              "statement",
              "flinkExtendedOperation",
              "currentCatalog",
              "optionalOperation",
              "nonSqlOperation",
              "hiveShim"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c869326d089705475481c2c2ea42a6efabb8c828^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/ExecutingTest.java",
      "locators": [
          {
              "line": 198,
              "column": 38
          },
          {
              "line": 203,
              "column": 55
          },
          {
              "line": 215,
              "column": 38
          },
          {
              "line": 221,
              "column": 55
          },
          {
              "line": 257,
              "column": 38
          },
          {
              "line": 263,
              "column": 55
          },
          {
              "line": 609,
              "column": 40
          },
          {
              "line": 629,
              "column": 40
          },
          {
              "line": 630,
              "column": 18
          },
          {
              "line": 630,
              "column": 42
          },
          {
              "line": 652,
              "column": 25
          }
      ],
      "old_name": "rescaleManagerFactory",
      "new_name": "stateTransitionManagerFactory",
      "ctx": {
          "symbolName": "rescaleManagerFactory",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Factory",
          "scopeHint": "in testTriggerRescaleOnCompletedCheckpoint(...)",
          "filePath": "ExecutingTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testTriggerRescaleOnCompletedCheckpoint() throws Exception {\n        final AtomicBoolean rescaleTriggered = new AtomicBoolean();\n        final RescaleManager.Factory rescaleManagerFactory =\n                new TestingRescaleManager.Factory(() -> {}, () -> rescaleTriggered.set(true));\n        try (MockExecutingContext ctx = new MockExecutingContext()) {\n            final Executing testInstance =\n                    new ExecutingStateBuilder()\n                            .setRescaleManagerFactory(rescaleManagerFactory)\n                            .build(ctx);\n\n            assertThat(rescaleTriggered).isFalse();\n            testInstance.onCompletedCheckpoint();\n            assertThat(rescaleTriggered).isTrue();\n        }\n    }",
          "conflictNames": [
              "rescaleTriggered",
              "ctx",
              "testInstance"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c869326d089705475481c2c2ea42a6efabb8c828^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/DefaultRescaleManagerTest.java",
      "locators": [
          {
              "line": 44,
              "column": 24
          },
          {
              "line": 49,
              "column": 77
          },
          {
              "line": 58,
              "column": 33
          },
          {
              "line": 58,
              "column": 63
          }
      ],
      "old_name": "scalingIntervalMin",
      "new_name": "cooldownTimeout",
      "ctx": {
          "symbolName": "scalingIntervalMin",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Duration",
          "scopeHint": "in testProperConfiguration(...)",
          "filePath": "DefaultRescaleManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testProperConfiguration() throws ConfigurationException {\n        final Duration scalingIntervalMin = Duration.ofMillis(1337);\n        final Duration scalingIntervalMax = Duration.ofMillis(7331);\n        final Duration maximumDelayForRescaleTrigger = Duration.ofMillis(4242);\n\n        final Configuration configuration = new Configuration();\n        configuration.set(JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MIN, scalingIntervalMin);\n        configuration.set(JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MAX, scalingIntervalMax);\n        configuration.set(\n                JobManagerOptions.MAXIMUM_DELAY_FOR_SCALE_TRIGGER, maximumDelayForRescaleTrigger);\n\n        final DefaultRescaleManager testInstance =\n                DefaultRescaleManager.Factory.fromSettings(\n                                AdaptiveScheduler.Settings.of(configuration))\n                        .create(TestingRescaleManagerContext.stableContext(), Instant.now());\n        assertThat(testInstance.scalingIntervalMin).isEqualTo(scalingIntervalMin);\n        assertThat(testInstance.scalingIntervalMax).isEqualTo(scalingIntervalMax);\n        assertThat(testInstance.maxTriggerDelay).isEqualTo(maximumDelayForRescaleTrigger);\n    }",
          "conflictNames": [
              "scalingIntervalMax",
              "maximumDelayForRescaleTrigger",
              "configuration",
              "testInstance"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c869326d089705475481c2c2ea42a6efabb8c828^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/DefaultRescaleManagerTest.java",
      "locators": [
          {
              "line": 45,
              "column": 24
          },
          {
              "line": 50,
              "column": 77
          },
          {
              "line": 59,
              "column": 33
          },
          {
              "line": 59,
              "column": 63
          },
          {
              "line": 631,
              "column": 53
          }
      ],
      "old_name": "scalingIntervalMax",
      "new_name": "resourceStabilizationTimeout",
      "ctx": {
          "symbolName": "scalingIntervalMax",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Duration",
          "scopeHint": "in testProperConfiguration(...)",
          "filePath": "DefaultRescaleManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testProperConfiguration() throws ConfigurationException {\n        final Duration scalingIntervalMin = Duration.ofMillis(1337);\n        final Duration scalingIntervalMax = Duration.ofMillis(7331);\n        final Duration maximumDelayForRescaleTrigger = Duration.ofMillis(4242);\n\n        final Configuration configuration = new Configuration();\n        configuration.set(JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MIN, scalingIntervalMin);\n        configuration.set(JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MAX, scalingIntervalMax);\n        configuration.set(\n                JobManagerOptions.MAXIMUM_DELAY_FOR_SCALE_TRIGGER, maximumDelayForRescaleTrigger);\n\n        final DefaultRescaleManager testInstance =\n                DefaultRescaleManager.Factory.fromSettings(\n                                AdaptiveScheduler.Settings.of(configuration))\n                        .create(TestingRescaleManagerContext.stableContext(), Instant.now());\n        assertThat(testInstance.scalingIntervalMin).isEqualTo(scalingIntervalMin);\n        assertThat(testInstance.scalingIntervalMax).isEqualTo(scalingIntervalMax);\n        assertThat(testInstance.maxTriggerDelay).isEqualTo(maximumDelayForRescaleTrigger);\n    }",
          "conflictNames": [
              "scalingIntervalMin",
              "maximumDelayForRescaleTrigger",
              "configuration",
              "testInstance"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c869326d089705475481c2c2ea42a6efabb8c828^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/DefaultRescaleManagerTest.java",
      "locators": [
          {
              "line": 240,
              "column": 44
          },
          {
              "line": 243,
              "column": 17
          },
          {
              "line": 247,
              "column": 47
          },
          {
              "line": 251,
              "column": 47
          },
          {
              "line": 253,
              "column": 9
          },
          {
              "line": 255,
              "column": 47
          },
          {
              "line": 257,
              "column": 9
          },
          {
              "line": 259,
              "column": 37
          },
          {
              "line": 264,
              "column": 44
          },
          {
              "line": 267,
              "column": 17
          },
          {
              "line": 271,
              "column": 47
          },
          {
              "line": 275,
              "column": 47
          },
          {
              "line": 277,
              "column": 9
          },
          {
              "line": 279,
              "column": 37
          },
          {
              "line": 284,
              "column": 44
          },
          {
              "line": 287,
              "column": 17
          },
          {
              "line": 291,
              "column": 47
          },
          {
              "line": 295,
              "column": 37
          }
      ],
      "old_name": "hardRescalePossibleCtx",
      "new_name": "ctx",
      "ctx": {
          "symbolName": "hardRescalePossibleCtx",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TestingRescaleManagerContext",
          "scopeHint": "in testSufficientChangeInCooldownPhase(...)",
          "filePath": "DefaultRescaleManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testSufficientChangeInCooldownPhase() {\n        final TestingRescaleManagerContext hardRescalePossibleCtx =\n                TestingRescaleManagerContext.stableContext().withSufficientRescaling();\n        final DefaultRescaleManager testInstance =\n                hardRescalePossibleCtx.createTestInstanceInCooldownPhase();\n\n        testInstance.onChange();\n\n        assertIntermediateStateWithoutRescale(hardRescalePossibleCtx);\n\n        testInstance.onTrigger();\n\n        assertIntermediateStateWithoutRescale(hardRescalePossibleCtx);\n\n        hardRescalePossibleCtx.transitionIntoSoftScalingTimeframe();\n\n        assertIntermediateStateWithoutRescale(hardRescalePossibleCtx);\n\n        hardRescalePossibleCtx.transitionIntoHardScalingTimeframe();\n\n        assertFinalStateWithRescale(hardRescalePossibleCtx);\n    }",
          "conflictNames": [
              "testInstance"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-runtime/src/main/java/org/apache/flink/runtime/webmonitor/WebMonitorEndpoint.java",
      "locators": [
          {
              "line": 258,
              "column": 24
          },
          {
              "line": 263,
              "column": 60
          }
      ],
      "old_name": "akkaTimeout",
      "new_name": "askTimeout",
      "ctx": {
          "symbolName": "akkaTimeout",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Duration",
          "scopeHint": "in initializeThreadInfoTracker(...)",
          "filePath": "WebMonitorEndpoint.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private VertexThreadInfoTracker initializeThreadInfoTracker(ScheduledExecutorService executor) {\n        final Duration akkaTimeout = clusterConfiguration.get(AkkaOptions.ASK_TIMEOUT_DURATION);\n\n        final Duration flameGraphCleanUpInterval =\n                clusterConfiguration.get(RestOptions.FLAMEGRAPH_CLEANUP_INTERVAL);\n        final ThreadInfoRequestCoordinator threadInfoRequestCoordinator =\n                new ThreadInfoRequestCoordinator(executor, akkaTimeout);\n\n        return VertexThreadInfoTrackerBuilder.newBuilder(\n                        resourceManagerRetriever, executor, restConfiguration.getTimeout())\n                .setCoordinator(threadInfoRequestCoordinator)\n                .setCleanUpInterval(flameGraphCleanUpInterval)\n                .setNumSamples(clusterConfiguration.getInteger(RestOptions.FLAMEGRAPH_NUM_SAMPLES))\n                .setStatsRefreshInterval(\n                        clusterConfiguration.get(RestOptions.FLAMEGRAPH_REFRESH_INTERVAL))\n                .setDelayBetweenSamples(clusterConfiguration.get(RestOptions.FLAMEGRAPH_DELAY))\n                .setMaxThreadInfoDepth(\n                        clusterConfiguration.getInteger(RestOptions.FLAMEGRAPH_STACK_TRACE_DEPTH))\n                .build();\n    }",
          "conflictNames": [
              "executor",
              "flameGraphCleanUpInterval",
              "threadInfoRequestCoordinator"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/SupervisorActor.java",
      "locators": [
          {
              "line": 95,
              "column": 71
          },
          {
              "line": 96,
              "column": 9
          },
          {
              "line": 101,
              "column": 33
          },
          {
              "line": 107,
              "column": 40
          },
          {
              "line": 113,
              "column": 33
          },
          {
              "line": 123,
              "column": 51
          },
          {
              "line": 130,
              "column": 45
          }
      ],
      "old_name": "akkaRpcActorRegistration",
      "new_name": "rpcActorRegistration",
      "ctx": {
          "symbolName": "akkaRpcActorRegistration",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "AkkaRpcActorRegistration",
          "scopeHint": "in terminateAkkaRpcActorOnStop(...)",
          "filePath": "SupervisorActor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "\n\n        registeredAkkaRpcActors.clear();\n    }\n\n    @Override\n    public SupervisorActorSupervisorStrategy supervisorStrategy() {\n        return new SupervisorActorSupervisorStrategy();\n    }\n\n    private void terminateAkkaRpcActorOnStop(AkkaRpcActorRegistration akkaRpcActorRegistration) {\n        akkaRpcActorRegistration.terminateExceptionally(\n                new AkkaRpcException(\n                        String.format(\n                                \"Unexpected closing of %s with name %s.\",\n                            "
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/SupervisorActor.java",
      "locators": [
          {
              "line": 110,
              "column": 21
          },
          {
              "line": 117,
              "column": 17
          },
          {
              "line": 121,
              "column": 60
          }
      ],
      "old_name": "akkaRpcActorProps",
      "new_name": "rpcActorProps",
      "ctx": {
          "symbolName": "akkaRpcActorProps",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Props",
          "scopeHint": "in createStartAkkaRpcActorMessage(...)",
          "filePath": "SupervisorActor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void createStartAkkaRpcActorMessage(StartAkkaRpcActor startAkkaRpcActor) {\n        final String endpointId = startAkkaRpcActor.getEndpointId();\n        final AkkaRpcActorRegistration akkaRpcActorRegistration =\n                new AkkaRpcActorRegistration(endpointId);\n\n        final Props akkaRpcActorProps =\n                startAkkaRpcActor\n                        .getPropsFactory()\n                        .create(akkaRpcActorRegistration.getInternalTerminationFuture());\n\n        LOG.debug(\n                \"Starting {} with name {}.\",\n                akkaRpcActorProps.actorClass().getSimpleName(),\n                endpointId);\n\n        try {\n            final ActorRef actorRef = getContext().actorOf(akkaRpcActorProps, endpointId);\n\n            registeredAkkaRpcActors.put(actorRef, akkaRpcActorRegistration);\n\n            getSender()\n                    .tell(\n                            StartAkkaRpcActorResponse.success(\n                                    ActorRegistration.create(\n                                            actorRef,\n                                            akkaRpcActorRegistration\n                                                    .getExternalTerminationFuture())),\n                            getSelf());\n        } catch (AkkaException akkaException) {\n            getSender().tell(StartAkkaRpcActorResponse.failure(akkaException), getSelf());\n        }\n    }",
          "conflictNames": [
              "startAkkaRpcActor",
              "endpointId",
              "akkaRpcActorRegistration",
              "actorRef"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/SupervisorActor.java",
      "locators": [
          {
              "line": 133,
              "column": 32
          },
          {
              "line": 134,
              "column": 64
          }
      ],
      "old_name": "akkaException",
      "new_name": "e",
      "ctx": {
          "symbolName": "akkaException",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "AkkaException",
          "scopeHint": "in createStartAkkaRpcActorMessage(...)",
          "filePath": "SupervisorActor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "                 actorRef,\n                                            akkaRpcActorRegistration\n                                                    .getExternalTerminationFuture())),\n                            getSelf());\n        } catch (AkkaException akkaException) {\n            getSender().tell(StartAkkaRpcActorResponse.failure(akkaException), getSelf());\n        }\n    }\n\n    private void akkaRpcActorTerminated(ActorRef actorRef) {\n        final AkkaRpcActorRegistration actorRegistration = removeAk",
          "conflictNames": [
              "startAkkaRpcActor",
              "endpointId",
              "akkaRpcActorRegistration",
              "akkaRpcActorProps",
              "actorRef"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/SupervisorActor.java",
      "locators": [
          {
              "line": 62,
              "column": 59
          },
          {
              "line": 66,
              "column": 14
          },
          {
              "line": 83,
              "column": 59
          },
          {
              "line": 87,
              "column": 9
          },
          {
              "line": 123,
              "column": 13
          },
          {
              "line": 148,
              "column": 60
          },
          {
              "line": 149,
              "column": 17
          },
          {
              "line": 150,
              "column": 44
          },
          {
              "line": 157,
              "column": 17
          },
          {
              "line": 164,
              "column": 17
          },
          {
              "line": 172,
              "column": 36
          }
      ],
      "old_name": "registeredAkkaRpcActor",
      "new_name": "registeredRpcActor",
      "ctx": {
          "symbolName": "registeredAkkaRpcActor",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Entry<ActorRef, AkkaRpcActorRegistration>",
          "scopeHint": "in akkaRpcActorFailed(...)",
          "filePath": "SupervisorActor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "egistration.terminate(terminationFutureExecutor);\n    }\n\n    private void akkaRpcActorFailed(ActorRef actorRef, Throwable cause) {\n        LOG.warn(\"AkkaRpcActor {} has failed. Shutting it down now.\", actorRef.path(), cause);\n\n        for (Map.Entry<ActorRef, AkkaRpcActorRegistration> registeredAkkaRpcActor :\n                registeredAkkaRpcActors.entrySet()) {\n            final ActorRef otherActorRef = registeredAkkaRpcActor.getKey();\n            if (otherActorRef.equals(actorRef)) {\n                final AkkaRpcException error =\n          ",
          "conflictNames": [
              "actorRef",
              "cause",
              "otherActorRef",
              "error",
              "siblingException"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/test/java/org/apache/flink/runtime/rpc/akka/ContextClassLoadingSettingTest.java",
      "locators": [
          {
              "line": 343,
              "column": 30
          },
          {
              "line": 362,
              "column": 38
          },
          {
              "line": 378,
              "column": 42
          }
      ],
      "old_name": "serverAkkaRpcService",
      "new_name": "serverPekkoRpcService",
      "ctx": {
          "symbolName": "serverAkkaRpcService",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "AkkaRpcService",
          "scopeHint": "in testAkkaRpcInvocationHandler_ContextClassLoaderUsedForDeserialization(...)",
          "filePath": "ContextClassLoadingSettingTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testAkkaRpcInvocationHandler_ContextClassLoaderUsedForDeserialization() throws Exception {\n        // setup 2 actor systems and rpc services that support remote connections (for which RPCs go\n        // through serialization)\n        final AkkaRpcService serverAkkaRpcService =\n                new AkkaRpcService(\n                        AkkaUtils.createActorSystem(\n                                \"serverActorSystem\",\n                                AkkaUtils.getAkkaConfig(\n                                        new Configuration(), new HostAndPort(\"localhost\", 0))),\n                        AkkaRpcServiceConfiguration.defaultConfiguration());\n\n        final AkkaRpcService clientAkkaRpcService =\n                new AkkaRpcService(\n                        AkkaUtils.createActorSystem(\n                                \"clientActorSystem\",\n                                AkkaUtils.getAkkaConfig(\n                                        new Configuration(), new HostAndPort(\"localhost\", 0))),\n                        AkkaRpcServiceConfiguration.defaultConfiguration(),\n                        pretendFlinkClassLoader);\n\n        try {\n            final TestEndpoint rpcEndpoint =\n                    new TestEndpoint(serverAkkaRpcService, new PickyObject());\n            rpcEndpoint.start();\n\n            final TestEndpointGateway rpcGateway =\n                    rpcEndpoint.getSelfGateway(TestEndpointGateway.class);\n\n            final TestEndpointGateway connect =\n                    clientAkkaRpcService\n                            .connect(rpcGateway.getAddress(), TestEndpointGateway.class)\n                            .get();\n\n            // if the wrong classloader is used the deserialization fails and get() throws an\n            // exception\n            connect.getPickyObject().get();\n        } finally {\n            RpcUtils.terminateRpcService(clientAkkaRpcService);\n            RpcUtils.terminateRpcService(serverAkkaRpcService);\n        }\n    }",
          "conflictNames": [
              "clientAkkaRpcService",
              "rpcEndpoint",
              "rpcGateway",
              "connect"
          ]
      },
      "suggestions": [
          {
              "name": "serverPekkoRpcService",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/test/java/org/apache/flink/runtime/rpc/akka/ContextClassLoadingSettingTest.java",
      "locators": [
          {
              "line": 351,
              "column": 30
          },
          {
              "line": 369,
              "column": 21
          },
          {
              "line": 377,
              "column": 42
          }
      ],
      "old_name": "clientAkkaRpcService",
      "new_name": "clientPekkoRpcService",
      "ctx": {
          "symbolName": "clientAkkaRpcService",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "AkkaRpcService",
          "scopeHint": "in testAkkaRpcInvocationHandler_ContextClassLoaderUsedForDeserialization(...)",
          "filePath": "ContextClassLoadingSettingTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testAkkaRpcInvocationHandler_ContextClassLoaderUsedForDeserialization() throws Exception {\n        // setup 2 actor systems and rpc services that support remote connections (for which RPCs go\n        // through serialization)\n        final AkkaRpcService serverAkkaRpcService =\n                new AkkaRpcService(\n                        AkkaUtils.createActorSystem(\n                                \"serverActorSystem\",\n                                AkkaUtils.getAkkaConfig(\n                                        new Configuration(), new HostAndPort(\"localhost\", 0))),\n                        AkkaRpcServiceConfiguration.defaultConfiguration());\n\n        final AkkaRpcService clientAkkaRpcService =\n                new AkkaRpcService(\n                        AkkaUtils.createActorSystem(\n                                \"clientActorSystem\",\n                                AkkaUtils.getAkkaConfig(\n                                        new Configuration(), new HostAndPort(\"localhost\", 0))),\n                        AkkaRpcServiceConfiguration.defaultConfiguration(),\n                        pretendFlinkClassLoader);\n\n        try {\n            final TestEndpoint rpcEndpoint =\n                    new TestEndpoint(serverAkkaRpcService, new PickyObject());\n            rpcEndpoint.start();\n\n            final TestEndpointGateway rpcGateway =\n                    rpcEndpoint.getSelfGateway(TestEndpointGateway.class);\n\n            final TestEndpointGateway connect =\n                    clientAkkaRpcService\n                            .connect(rpcGateway.getAddress(), TestEndpointGateway.class)\n                            .get();\n\n            // if the wrong classloader is used the deserialization fails and get() throws an\n            // exception\n            connect.getPickyObject().get();\n        } finally {\n            RpcUtils.terminateRpcService(clientAkkaRpcService);\n            RpcUtils.terminateRpcService(serverAkkaRpcService);\n        }\n    }",
          "conflictNames": [
              "serverAkkaRpcService",
              "rpcEndpoint",
              "rpcGateway",
              "connect"
          ]
      },
      "suggestions": [
          {
              "name": "clientPekkoRpcService",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/test/java/org/apache/flink/runtime/rpc/akka/MainThreadValidationTest.java",
      "locators": [
          {
              "line": 45,
              "column": 24
          },
          {
              "line": 51,
              "column": 58
          },
          {
              "line": 63,
              "column": 13
          }
      ],
      "old_name": "akkaRpcService",
      "new_name": "pekkoRpcService",
      "ctx": {
          "symbolName": "akkaRpcService",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "AkkaRpcService",
          "scopeHint": "in failIfNotInMainThread(...)",
          "filePath": "MainThreadValidationTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void failIfNotInMainThread() throws Exception {\n        // test if assertions are activated. The test only works if assertions are loaded.\n        try {\n            assert false;\n            // apparently they are not activated\n            return;\n        } catch (AssertionError ignored) {\n        }\n\n        // actual test\n        AkkaRpcService akkaRpcService =\n                new AkkaRpcService(\n                        AkkaUtils.createDefaultActorSystem(),\n                        AkkaRpcServiceConfiguration.defaultConfiguration());\n\n        try {\n            TestEndpoint testEndpoint = new TestEndpoint(akkaRpcService);\n            testEndpoint.start();\n\n            // this works, because it is executed as an RPC call\n            testEndpoint.getSelfGateway(TestGateway.class).someConcurrencyCriticalFunction();\n\n            // this fails, because it is executed directly\n            assertThatThrownBy(() -> testEndpoint.someConcurrencyCriticalFunction())\n                    .isInstanceOf(AssertionError.class);\n\n            testEndpoint.closeAsync();\n        } finally {\n            akkaRpcService.closeAsync().get();\n        }\n    }",
          "conflictNames": [
              "testEndpoint"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaBootstrapTools.java",
      "locators": [
          {
              "line": 176,
              "column": 20
          },
          {
              "line": 184,
              "column": 17
          },
          {
              "line": 184,
              "column": 56
          },
          {
              "line": 187,
              "column": 37
          },
          {
              "line": 228,
              "column": 20
          },
          {
              "line": 233,
              "column": 17
          },
          {
              "line": 233,
              "column": 56
          },
          {
              "line": 236,
              "column": 37
          },
          {
              "line": 245,
              "column": 15
          },
          {
              "line": 251,
              "column": 20
          },
          {
              "line": 252,
              "column": 55
          },
          {
              "line": 253,
              "column": 80
          }
      ],
      "old_name": "akkaConfig",
      "new_name": "pekkoConfig",
      "ctx": {
          "symbolName": "akkaConfig",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Config",
          "scopeHint": "in startRemoteActorSystem(...)",
          "filePath": "AkkaBootstrapTools.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Starts a remote Actor System at given address and specific port.\n     *\n     * @param configuration The Flink configuration.\n     * @param actorSystemName Name of the started {@link ActorSystem}\n     * @param externalAddress The external address to access the ActorSystem.\n     * @param externalPort The external port to access the ActorSystem.\n     * @param bindAddress The local address to bind to.\n     * @param bindPort The local port to bind to.\n     * @param logger the logger to output log information.\n     * @param actorSystemExecutorConfiguration configuration for the ActorSystem's underlying\n     *     executor\n     * @param customConfig Custom Akka config to be combined with the config derived from Flink\n     *     configuration.\n     * @return The ActorSystem which has been started.\n     * @throws Exception\n     */\n    private static ActorSystem startRemoteActorSystem(\n            Configuration configuration,\n            String actorSystemName,\n            String externalAddress,\n            int externalPort,\n            String bindAddress,\n            int bindPort,\n            Logger logger,\n            Config actorSystemExecutorConfiguration,\n            Config customConfig)\n            throws Exception {\n\n        String externalHostPortUrl =\n                NetUtils.unresolvedHostAndPortToNormalizedString(externalAddress, externalPort);\n        String bindHostPortUrl =\n                NetUtils.unresolvedHostAndPortToNormalizedString(bindAddress, bindPort);\n        logger.info(\n                \"Trying to start actor system, external address {}, bind address {}.\",\n                externalHostPortUrl,\n                bindHostPortUrl);\n\n        try {\n            Config akkaConfig =\n                    AkkaUtils.getAkkaConfig(\n                            configuration,\n                            new HostAndPort(externalAddress, externalPort),\n                            new HostAndPort(bindAddress, bindPort),\n                            actorSystemExecutorConfiguration);\n\n            if (customConfig != null) {\n                akkaConfig = customConfig.withFallback(akkaConfig);\n            }\n\n            return startActorSystem(akkaConfig, actorSystemName, logger);\n        } catch (Throwable t) {\n            if (t instanceof ChannelException) {\n                Throwable cause = t.getCause();\n                if (cause != null && t.getCause() instanceof BindException) {\n                    throw new IOException(\n                            \"Unable to create ActorSystem at address \"\n                                    + bindHostPortUrl\n                                    + \" : \"\n                                    + cause.getMessage(),\n                            t);\n                }\n            }\n            throw new Exception(\"Could not create actor system\", t);\n        }\n    }",
          "conflictNames": [
              "configuration",
              "actorSystemName",
              "externalAddress",
              "externalPort",
              "bindAddress",
              "bindPort",
              "logger",
              "actorSystemExecutorConfiguration",
              "customConfig",
              "externalHostPortUrl",
              "bindHostPortUrl",
              "cause"
          ]
      },
      "suggestions": [
          {
              "name": "config",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaRpcService.java",
      "locators": [
          {
              "line": 277,
              "column": 22
          },
          {
              "line": 298,
              "column": 29
          },
          {
              "line": 311,
              "column": 29
          }
      ],
      "old_name": "akkaAddress",
      "new_name": "address",
      "ctx": {
          "symbolName": "akkaAddress",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in startServer(...)",
          "filePath": "AkkaRpcService.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public <C extends RpcEndpoint & RpcGateway> RpcServer startServer(C rpcEndpoint) {\n        checkNotNull(rpcEndpoint, \"rpc endpoint\");\n\n        final SupervisorActor.ActorRegistration actorRegistration =\n                registerAkkaRpcActor(rpcEndpoint);\n        final ActorRef actorRef = actorRegistration.getActorRef();\n        final CompletableFuture<Void> actorTerminationFuture =\n                actorRegistration.getTerminationFuture();\n\n        LOG.info(\n                \"Starting RPC endpoint for {} at {} .\",\n                rpcEndpoint.getClass().getName(),\n                actorRef.path());\n\n        final String akkaAddress = AkkaUtils.getAkkaURL(actorSystem, actorRef);\n        final String hostname;\n        Option<String> host = actorRef.path().address().host();\n        if (host.isEmpty()) {\n            hostname = \"localhost\";\n        } else {\n            hostname = host.get();\n        }\n\n        Set<Class<?>> implementedRpcGateways =\n                new HashSet<>(RpcUtils.extractImplementedRpcGateways(rpcEndpoint.getClass()));\n\n        implementedRpcGateways.add(RpcServer.class);\n        implementedRpcGateways.add(AkkaBasedEndpoint.class);\n\n        final InvocationHandler akkaInvocationHandler;\n\n        if (rpcEndpoint instanceof FencedRpcEndpoint) {\n            // a FencedRpcEndpoint needs a FencedAkkaInvocationHandler\n            akkaInvocationHandler =\n                    new FencedAkkaInvocationHandler<>(\n                            akkaAddress,\n                            hostname,\n                            actorRef,\n                            configuration.getTimeout(),\n                            configuration.getMaximumFramesize(),\n                            configuration.isForceRpcInvocationSerialization(),\n                            actorTerminationFuture,\n                            ((FencedRpcEndpoint<?>) rpcEndpoint)::getFencingToken,\n                            captureAskCallstacks,\n                            flinkClassLoader);\n        } else {\n            akkaInvocationHandler =\n                    new AkkaInvocationHandler(\n                            akkaAddress,\n                            hostname,\n                            actorRef,\n                            configuration.getTimeout(),\n                            configuration.getMaximumFramesize(),\n                            configuration.isForceRpcInvocationSerialization(),\n                            actorTerminationFuture,\n                            captureAskCallstacks,\n                            flinkClassLoader);\n        }\n\n        // Rather than using the System ClassLoader directly, we derive the ClassLoader\n        // from this class . That works better in cases where Flink runs embedded and all Flink\n        // code is loaded dynamically (for example from an OSGI bundle) through a custom ClassLoader\n        ClassLoader classLoader = getClass().getClassLoader();\n\n        @SuppressWarnings(\"unchecked\")\n        RpcServer server =\n                (RpcServer)\n                        Proxy.newProxyInstance(\n                                classLoader,\n                                implementedRpcGateways.toArray(\n                                        new Class<?>[implementedRpcGateways.size()]),\n                                akkaInvocationHandler);\n\n        return server;\n    }",
          "conflictNames": [
              "rpcEndpoint",
              "actorRegistration",
              "actorRef",
              "actorTerminationFuture",
              "hostname",
              "host",
              "implementedRpcGateways",
              "akkaInvocationHandler",
              "classLoader",
              "server"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaRpcService.java",
      "locators": [
          {
              "line": 292,
              "column": 33
          },
          {
              "line": 296,
              "column": 13
          },
          {
              "line": 309,
              "column": 13
          },
          {
              "line": 334,
              "column": 33
          }
      ],
      "old_name": "akkaInvocationHandler",
      "new_name": "invocationHandler",
      "ctx": {
          "symbolName": "akkaInvocationHandler",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "InvocationHandler",
          "scopeHint": "in startServer(...)",
          "filePath": "AkkaRpcService.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public <C extends RpcEndpoint & RpcGateway> RpcServer startServer(C rpcEndpoint) {\n        checkNotNull(rpcEndpoint, \"rpc endpoint\");\n\n        final SupervisorActor.ActorRegistration actorRegistration =\n                registerAkkaRpcActor(rpcEndpoint);\n        final ActorRef actorRef = actorRegistration.getActorRef();\n        final CompletableFuture<Void> actorTerminationFuture =\n                actorRegistration.getTerminationFuture();\n\n        LOG.info(\n                \"Starting RPC endpoint for {} at {} .\",\n                rpcEndpoint.getClass().getName(),\n                actorRef.path());\n\n        final String akkaAddress = AkkaUtils.getAkkaURL(actorSystem, actorRef);\n        final String hostname;\n        Option<String> host = actorRef.path().address().host();\n        if (host.isEmpty()) {\n            hostname = \"localhost\";\n        } else {\n            hostname = host.get();\n        }\n\n        Set<Class<?>> implementedRpcGateways =\n                new HashSet<>(RpcUtils.extractImplementedRpcGateways(rpcEndpoint.getClass()));\n\n        implementedRpcGateways.add(RpcServer.class);\n        implementedRpcGateways.add(AkkaBasedEndpoint.class);\n\n        final InvocationHandler akkaInvocationHandler;\n\n        if (rpcEndpoint instanceof FencedRpcEndpoint) {\n            // a FencedRpcEndpoint needs a FencedAkkaInvocationHandler\n            akkaInvocationHandler =\n                    new FencedAkkaInvocationHandler<>(\n                            akkaAddress,\n                            hostname,\n                            actorRef,\n                            configuration.getTimeout(),\n                            configuration.getMaximumFramesize(),\n                            configuration.isForceRpcInvocationSerialization(),\n                            actorTerminationFuture,\n                            ((FencedRpcEndpoint<?>) rpcEndpoint)::getFencingToken,\n                            captureAskCallstacks,\n                            flinkClassLoader);\n        } else {\n            akkaInvocationHandler =\n                    new AkkaInvocationHandler(\n                            akkaAddress,\n                            hostname,\n                            actorRef,\n                            configuration.getTimeout(),\n                            configuration.getMaximumFramesize(),\n                            configuration.isForceRpcInvocationSerialization(),\n                            actorTerminationFuture,\n                            captureAskCallstacks,\n                            flinkClassLoader);\n        }\n\n        // Rather than using the System ClassLoader directly, we derive the ClassLoader\n        // from this class . That works better in cases where Flink runs embedded and all Flink\n        // code is loaded dynamically (for example from an OSGI bundle) through a custom ClassLoader\n        ClassLoader classLoader = getClass().getClassLoader();\n\n        @SuppressWarnings(\"unchecked\")\n        RpcServer server =\n                (RpcServer)\n                        Proxy.newProxyInstance(\n                                classLoader,\n                                implementedRpcGateways.toArray(\n                                        new Class<?>[implementedRpcGateways.size()]),\n                                akkaInvocationHandler);\n\n        return server;\n    }",
          "conflictNames": [
              "rpcEndpoint",
              "actorRegistration",
              "actorRef",
              "actorTerminationFuture",
              "akkaAddress",
              "hostname",
              "host",
              "implementedRpcGateways",
              "classLoader",
              "server"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaRpcService.java",
      "locators": [
          {
              "line": 385,
              "column": 37
          },
          {
              "line": 392,
              "column": 49
          },
          {
              "line": 397,
              "column": 39
          }
      ],
      "old_name": "akkaClient",
      "new_name": "client",
      "ctx": {
          "symbolName": "akkaClient",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "AkkaBasedEndpoint",
          "scopeHint": "in stopServer(...)",
          "filePath": "AkkaRpcService.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void stopServer(RpcServer selfGateway) {\n        if (selfGateway instanceof AkkaBasedEndpoint) {\n            final AkkaBasedEndpoint akkaClient = (AkkaBasedEndpoint) selfGateway;\n            final RpcEndpoint rpcEndpoint;\n\n            synchronized (lock) {\n                if (stopped) {\n                    return;\n                } else {\n                    rpcEndpoint = actors.remove(akkaClient.getActorRef());\n                }\n            }\n\n            if (rpcEndpoint != null) {\n                terminateAkkaRpcActor(akkaClient.getActorRef(), rpcEndpoint);\n            } else {\n                LOG.debug(\n                        \"RPC endpoint {} already stopped or from different RPC service\",\n                        selfGateway.getAddress());\n            }\n        }\n    }",
          "conflictNames": [
              "selfGateway",
              "rpcEndpoint"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaRpcService.java",
      "locators": [
          {
              "line": 408,
              "column": 39
          },
          {
              "line": 419,
              "column": 13
          },
          {
              "line": 424,
              "column": 25
          }
      ],
      "old_name": "akkaRpcActorsTerminationFuture",
      "new_name": "rpcActorsTerminationFuture",
      "ctx": {
          "symbolName": "akkaRpcActorsTerminationFuture",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CompletableFuture<Void>",
          "scopeHint": "in closeAsync(...)",
          "filePath": "AkkaRpcService.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public CompletableFuture<Void> closeAsync() {\n        final CompletableFuture<Void> akkaRpcActorsTerminationFuture;\n\n        synchronized (lock) {\n            if (stopped) {\n                return terminationFuture;\n            }\n\n            LOG.info(\"Stopping Akka RPC service.\");\n\n            stopped = true;\n\n            akkaRpcActorsTerminationFuture = terminateAkkaRpcActors();\n        }\n\n        final CompletableFuture<Void> supervisorTerminationFuture =\n                FutureUtils.composeAfterwards(\n                        akkaRpcActorsTerminationFuture, supervisor::closeAsync);\n\n        final CompletableFuture<Void> actorSystemTerminationFuture =\n                FutureUtils.composeAfterwards(\n                        supervisorTerminationFuture,\n                        () -> AkkaFutureUtils.toJava(actorSystem.terminate()));\n\n        actorSystemTerminationFuture.whenComplete(\n                (Void ignored, Throwable throwable) -> {\n                    runWithContextClassLoader(\n                            () -> FutureUtils.doForward(ignored, throwable, terminationFuture),\n                            flinkClassLoader);\n\n                    LOG.info(\"Stopped Akka RPC service.\");\n                });\n\n        return terminationFuture;\n    }",
          "conflictNames": [
              "supervisorTerminationFuture",
              "actorSystemTerminationFuture"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaRpcService.java",
      "locators": [
          {
              "line": 341,
              "column": 46
          },
          {
              "line": 344,
              "column": 13
          },
          {
              "line": 346,
              "column": 13
          },
          {
              "line": 357,
              "column": 45
          }
      ],
      "old_name": "akkaRpcActorType",
      "new_name": "rpcActorType",
      "ctx": {
          "symbolName": "akkaRpcActorType",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Class<? extends AbstractActor>",
          "scopeHint": "in registerAkkaRpcActor(...)",
          "filePath": "AkkaRpcService.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private <C extends RpcEndpoint & RpcGateway>\n            SupervisorActor.ActorRegistration registerAkkaRpcActor(C rpcEndpoint) {\n        final Class<? extends AbstractActor> akkaRpcActorType;\n\n        if (rpcEndpoint instanceof FencedRpcEndpoint) {\n            akkaRpcActorType = FencedAkkaRpcActor.class;\n        } else {\n            akkaRpcActorType = AkkaRpcActor.class;\n        }\n\n        synchronized (lock) {\n            checkState(!stopped, \"RpcService is stopped\");\n\n            final SupervisorActor.StartAkkaRpcActorResponse startAkkaRpcActorResponse =\n                    SupervisorActor.startAkkaRpcActor(\n                            supervisor.getActor(),\n                            actorTerminationFuture ->\n                                    Props.create(\n                                            akkaRpcActorType,\n                                            rpcEndpoint,\n                                            actorTerminationFuture,\n                                            getVersion(),\n                                            configuration.getMaximumFramesize(),\n                                            configuration.isForceRpcInvocationSerialization(),\n                                            flinkClassLoader),\n                            rpcEndpoint.getEndpointId());\n\n            final SupervisorActor.ActorRegistration actorRegistration =\n                    startAkkaRpcActorResponse.orElseThrow(\n                            cause ->\n                                    new AkkaRpcRuntimeException(\n                                            String.format(\n                                                    \"Could not create the %s for %s.\",\n                                                    AkkaRpcActor.class.getSimpleName(),\n                                                    rpcEndpoint.getEndpointId()),\n                                            cause));\n\n            actors.put(actorRegistration.getActorRef(), rpcEndpoint);\n\n            return actorRegistration;\n        }\n    }",
          "conflictNames": [
              "rpcEndpoint",
              "startAkkaRpcActorResponse",
              "actorRegistration"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaRpcService.java",
      "locators": [
          {
              "line": 352,
              "column": 61
          },
          {
              "line": 367,
              "column": 21
          }
      ],
      "old_name": "startAkkaRpcActorResponse",
      "new_name": "startRpcActorResponse",
      "ctx": {
          "symbolName": "startAkkaRpcActorResponse",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "StartAkkaRpcActorResponse",
          "scopeHint": "in registerAkkaRpcActor(...)",
          "filePath": "AkkaRpcService.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private <C extends RpcEndpoint & RpcGateway>\n            SupervisorActor.ActorRegistration registerAkkaRpcActor(C rpcEndpoint) {\n        final Class<? extends AbstractActor> akkaRpcActorType;\n\n        if (rpcEndpoint instanceof FencedRpcEndpoint) {\n            akkaRpcActorType = FencedAkkaRpcActor.class;\n        } else {\n            akkaRpcActorType = AkkaRpcActor.class;\n        }\n\n        synchronized (lock) {\n            checkState(!stopped, \"RpcService is stopped\");\n\n            final SupervisorActor.StartAkkaRpcActorResponse startAkkaRpcActorResponse =\n                    SupervisorActor.startAkkaRpcActor(\n                            supervisor.getActor(),\n                            actorTerminationFuture ->\n                                    Props.create(\n                                            akkaRpcActorType,\n                                            rpcEndpoint,\n                                            actorTerminationFuture,\n                                            getVersion(),\n                                            configuration.getMaximumFramesize(),\n                                            configuration.isForceRpcInvocationSerialization(),\n                                            flinkClassLoader),\n                            rpcEndpoint.getEndpointId());\n\n            final SupervisorActor.ActorRegistration actorRegistration =\n                    startAkkaRpcActorResponse.orElseThrow(\n                            cause ->\n                                    new AkkaRpcRuntimeException(\n                                            String.format(\n                                                    \"Could not create the %s for %s.\",\n                                                    AkkaRpcActor.class.getSimpleName(),\n                                                    rpcEndpoint.getEndpointId()),\n                                            cause));\n\n            actors.put(actorRegistration.getActorRef(), rpcEndpoint);\n\n            return actorRegistration;\n        }\n    }",
          "conflictNames": [
              "rpcEndpoint",
              "akkaRpcActorType",
              "actorRegistration"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaRpcService.java",
      "locators": [
          {
              "line": 446,
              "column": 51
          },
          {
              "line": 450,
              "column": 13
          },
          {
              "line": 457,
              "column": 39
          }
      ],
      "old_name": "akkaRpcActorTerminationFutures",
      "new_name": "rpcActorTerminationFutures",
      "ctx": {
          "symbolName": "akkaRpcActorTerminationFutures",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Collection<CompletableFuture<Void>>",
          "scopeHint": "in terminateAkkaRpcActors(...)",
          "filePath": "AkkaRpcService.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@GuardedBy(\"lock\")\n    @Nonnull\n    private CompletableFuture<Void> terminateAkkaRpcActors() {\n        final Collection<CompletableFuture<Void>> akkaRpcActorTerminationFutures =\n                new ArrayList<>(actors.size());\n\n        for (Map.Entry<ActorRef, RpcEndpoint> actorRefRpcEndpointEntry : actors.entrySet()) {\n            akkaRpcActorTerminationFutures.add(\n                    terminateAkkaRpcActor(\n                            actorRefRpcEndpointEntry.getKey(),\n                            actorRefRpcEndpointEntry.getValue()));\n        }\n        actors.clear();\n\n        return FutureUtils.waitForAll(akkaRpcActorTerminationFutures);\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaRpcServiceUtils.java",
      "locators": [
          {
              "line": 79,
              "column": 37
          },
          {
              "line": 84,
              "column": 13
          },
          {
              "line": 87,
              "column": 28
          },
          {
              "line": 89,
              "column": 16
          }
      ],
      "old_name": "akkaRpcServiceBuilder",
      "new_name": "rpcServiceBuilder",
      "ctx": {
          "symbolName": "akkaRpcServiceBuilder",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "AkkaRpcServiceBuilder",
          "scopeHint": "in createRemoteRpcService(...)",
          "filePath": "AkkaRpcServiceUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "static AkkaRpcService createRemoteRpcService(\n            Configuration configuration,\n            @Nullable String externalAddress,\n            String externalPortRange,\n            @Nullable String bindAddress,\n            @SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\") Optional<Integer> bindPort)\n            throws Exception {\n        final AkkaRpcServiceBuilder akkaRpcServiceBuilder =\n                AkkaRpcServiceUtils.remoteServiceBuilder(\n                        configuration, externalAddress, externalPortRange);\n\n        if (bindAddress != null) {\n            akkaRpcServiceBuilder.withBindAddress(bindAddress);\n        }\n\n        bindPort.ifPresent(akkaRpcServiceBuilder::withBindPort);\n\n        return akkaRpcServiceBuilder.createAndStart();\n    }",
          "conflictNames": [
              "configuration",
              "externalAddress",
              "externalPortRange",
              "bindAddress",
              "bindPort"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaRpcServiceUtils.java",
      "locators": [
          {
              "line": 237,
              "column": 16
          },
          {
              "line": 238,
              "column": 55
          }
      ],
      "old_name": "akkaConfigStr",
      "new_name": "configStr",
      "ctx": {
          "symbolName": "akkaConfigStr",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in extractMaximumFramesize(...)",
          "filePath": "AkkaRpcServiceUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static long extractMaximumFramesize(Configuration configuration) {\n        String maxFrameSizeStr = configuration.getString(AkkaOptions.FRAMESIZE);\n        String akkaConfigStr = String.format(SIMPLE_AKKA_CONFIG_TEMPLATE, maxFrameSizeStr);\n        Config akkaConfig = ConfigFactory.parseString(akkaConfigStr);\n        return akkaConfig.getBytes(MAXIMUM_FRAME_SIZE_PATH);\n    }",
          "conflictNames": [
              "configuration",
              "maxFrameSizeStr",
              "akkaConfig"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaRpcServiceUtils.java",
      "locators": [
          {
              "line": 237,
              "column": 16
          },
          {
              "line": 238,
              "column": 16
          },
          {
              "line": 238,
              "column": 55
          },
          {
              "line": 239,
              "column": 16
          }
      ],
      "old_name": "akkaConfig",
      "new_name": "config",
      "ctx": {
          "symbolName": "akkaConfig",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Config",
          "scopeHint": "in extractMaximumFramesize(...)",
          "filePath": "AkkaRpcServiceUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static long extractMaximumFramesize(Configuration configuration) {\n        String maxFrameSizeStr = configuration.getString(AkkaOptions.FRAMESIZE);\n        String akkaConfigStr = String.format(SIMPLE_AKKA_CONFIG_TEMPLATE, maxFrameSizeStr);\n        Config akkaConfig = ConfigFactory.parseString(akkaConfigStr);\n        return akkaConfig.getBytes(MAXIMUM_FRAME_SIZE_PATH);\n    }",
          "conflictNames": [
              "configuration",
              "maxFrameSizeStr",
              "akkaConfigStr"
          ]
      },
      "suggestions": [
          {
              "name": "config",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/test/java/org/apache/flink/runtime/rpc/akka/AkkaRpcActorHandshakeTest.java",
      "locators": [
          {
              "line": 52,
              "column": 37
          },
          {
              "line": 54,
              "column": 60
          },
          {
              "line": 55,
              "column": 60
          }
      ],
      "old_name": "akkaRpcServiceConfig",
      "new_name": "rpcServiceConfig",
      "ctx": {
          "symbolName": "akkaRpcServiceConfig",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "AkkaRpcServiceConfiguration",
          "scopeHint": "in setupClass(...)",
          "filePath": "AkkaRpcActorHandshakeTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@BeforeAll\n    static void setupClass() {\n        final ActorSystem actorSystem1 = AkkaUtils.createDefaultActorSystem();\n        final ActorSystem actorSystem2 = AkkaUtils.createDefaultActorSystem();\n        final ActorSystem wrongVersionActorSystem = AkkaUtils.createDefaultActorSystem();\n\n        AkkaRpcServiceConfiguration akkaRpcServiceConfig =\n                AkkaRpcServiceConfiguration.defaultConfiguration();\n        akkaRpcService1 = new AkkaRpcService(actorSystem1, akkaRpcServiceConfig);\n        akkaRpcService2 = new AkkaRpcService(actorSystem2, akkaRpcServiceConfig);\n        wrongVersionAkkaRpcService =\n                new WrongVersionAkkaRpcService(\n                        wrongVersionActorSystem,\n                        AkkaRpcServiceConfiguration.defaultConfiguration());\n    }",
          "conflictNames": [
              "actorSystem1",
              "actorSystem2",
              "wrongVersionActorSystem"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/test/java/org/apache/flink/runtime/rpc/akka/AkkaRpcActorTest.java",
      "locators": [
          {
              "line": 221,
              "column": 30
          },
          {
              "line": 239,
              "column": 55
          },
          {
              "line": 255,
              "column": 42
          }
      ],
      "old_name": "serverAkkaRpcService",
      "new_name": "serverPekkoRpcService",
      "ctx": {
          "symbolName": "serverAkkaRpcService",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "AkkaRpcService",
          "scopeHint": "in testResultFutureFailsOnDeserializationError(...)",
          "filePath": "AkkaRpcActorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Tests that the AkkaInvocationHandler properly fails the returned future if the response\n     * cannot be deserialized.\n     */\n    @Test\n    void testResultFutureFailsOnDeserializationError() throws Exception {\n        // setup 2 actor systems and rpc services that support remote connections (for which RPCs go\n        // through serialization)\n        final AkkaRpcService serverAkkaRpcService =\n                new AkkaRpcService(\n                        AkkaUtils.createActorSystem(\n                                \"serverActorSystem\",\n                                AkkaUtils.getAkkaConfig(\n                                        new Configuration(), new HostAndPort(\"localhost\", 0))),\n                        AkkaRpcServiceConfiguration.defaultConfiguration());\n\n        final AkkaRpcService clientAkkaRpcService =\n                new AkkaRpcService(\n                        AkkaUtils.createActorSystem(\n                                \"clientActorSystem\",\n                                AkkaUtils.getAkkaConfig(\n                                        new Configuration(), new HostAndPort(\"localhost\", 0))),\n                        AkkaRpcServiceConfiguration.defaultConfiguration());\n\n        try {\n            final DeserializatonFailingEndpoint rpcEndpoint =\n                    new DeserializatonFailingEndpoint(serverAkkaRpcService);\n            rpcEndpoint.start();\n\n            final DeserializatonFailingGateway rpcGateway =\n                    rpcEndpoint.getSelfGateway(DeserializatonFailingGateway.class);\n\n            final DeserializatonFailingGateway connect =\n                    clientAkkaRpcService\n                            .connect(rpcGateway.getAddress(), DeserializatonFailingGateway.class)\n                            .get();\n\n            assertThatFuture(connect.doStuff())\n                    .eventuallyFailsWith(ExecutionException.class)\n                    .withCauseInstanceOf(RpcException.class);\n        } finally {\n            RpcUtils.terminateRpcService(clientAkkaRpcService);\n            RpcUtils.terminateRpcService(serverAkkaRpcService);\n        }\n    }",
          "conflictNames": [
              "clientAkkaRpcService",
              "rpcEndpoint",
              "rpcGateway",
              "connect"
          ]
      },
      "suggestions": [
          {
              "name": "serverPekkoRpcService",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/test/java/org/apache/flink/runtime/rpc/akka/AkkaRpcActorTest.java",
      "locators": [
          {
              "line": 229,
              "column": 30
          },
          {
              "line": 246,
              "column": 21
          },
          {
              "line": 254,
              "column": 42
          }
      ],
      "old_name": "clientAkkaRpcService",
      "new_name": "clientPekkoRpcService",
      "ctx": {
          "symbolName": "clientAkkaRpcService",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "AkkaRpcService",
          "scopeHint": "in testResultFutureFailsOnDeserializationError(...)",
          "filePath": "AkkaRpcActorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Tests that the AkkaInvocationHandler properly fails the returned future if the response\n     * cannot be deserialized.\n     */\n    @Test\n    void testResultFutureFailsOnDeserializationError() throws Exception {\n        // setup 2 actor systems and rpc services that support remote connections (for which RPCs go\n        // through serialization)\n        final AkkaRpcService serverAkkaRpcService =\n                new AkkaRpcService(\n                        AkkaUtils.createActorSystem(\n                                \"serverActorSystem\",\n                                AkkaUtils.getAkkaConfig(\n                                        new Configuration(), new HostAndPort(\"localhost\", 0))),\n                        AkkaRpcServiceConfiguration.defaultConfiguration());\n\n        final AkkaRpcService clientAkkaRpcService =\n                new AkkaRpcService(\n                        AkkaUtils.createActorSystem(\n                                \"clientActorSystem\",\n                                AkkaUtils.getAkkaConfig(\n                                        new Configuration(), new HostAndPort(\"localhost\", 0))),\n                        AkkaRpcServiceConfiguration.defaultConfiguration());\n\n        try {\n            final DeserializatonFailingEndpoint rpcEndpoint =\n                    new DeserializatonFailingEndpoint(serverAkkaRpcService);\n            rpcEndpoint.start();\n\n            final DeserializatonFailingGateway rpcGateway =\n                    rpcEndpoint.getSelfGateway(DeserializatonFailingGateway.class);\n\n            final DeserializatonFailingGateway connect =\n                    clientAkkaRpcService\n                            .connect(rpcGateway.getAddress(), DeserializatonFailingGateway.class)\n                            .get();\n\n            assertThatFuture(connect.doStuff())\n                    .eventuallyFailsWith(ExecutionException.class)\n                    .withCauseInstanceOf(RpcException.class);\n        } finally {\n            RpcUtils.terminateRpcService(clientAkkaRpcService);\n            RpcUtils.terminateRpcService(serverAkkaRpcService);\n        }\n    }",
          "conflictNames": [
              "serverAkkaRpcService",
              "rpcEndpoint",
              "rpcGateway",
              "connect"
          ]
      },
      "suggestions": [
          {
              "name": "clientPekkoRpcService",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/test/java/org/apache/flink/runtime/rpc/akka/AkkaRpcServiceTest.java",
      "locators": [
          {
              "line": 64,
              "column": 35
          },
          {
              "line": 69,
              "column": 9
          },
          {
              "line": 75,
              "column": 62
          },
          {
              "line": 83,
              "column": 9
          },
          {
              "line": 96,
              "column": 17
          },
          {
              "line": 115,
              "column": 9
          },
          {
              "line": 122,
              "column": 20
          },
          {
              "line": 128,
              "column": 20
          },
          {
              "line": 138,
              "column": 47
          },
          {
              "line": 157,
              "column": 47
          },
          {
              "line": 190,
              "column": 47
          },
          {
              "line": 222,
              "column": 47
          },
          {
              "line": 264,
              "column": 30
          },
          {
              "line": 270,
              "column": 67
          },
          {
              "line": 278,
              "column": 24
          },
          {
              "line": 280,
              "column": 42
          },
          {
              "line": 290,
              "column": 30
          },
          {
              "line": 295,
              "column": 63
          },
          {
              "line": 309,
              "column": 20
          },
          {
              "line": 315,
              "column": 72
          },
          {
              "line": 319,
              "column": 21
          },
          {
              "line": 334,
              "column": 28
          },
          {
              "line": 343,
              "column": 29
          },
          {
              "line": 348,
              "column": 53
          },
          {
              "line": 353,
              "column": 20
          }
      ],
      "old_name": "akkaRpcService",
      "new_name": "pekkoRpcService",
      "ctx": {
          "symbolName": "akkaRpcService",
          "symbolKind": "field",
          "language": "JAVA",
          "type": "AkkaRpcService",
          "scopeHint": "in AkkaRpcServiceTest",
          "filePath": "AkkaRpcServiceTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "\n\n    // ------------------------------------------------------------------------\n    //  shared test members\n    // ------------------------------------------------------------------------\n\n    private static ActorSystem actorSystem;\n\n    private static AkkaRpcService akkaRpcService;\n\n    @BeforeAll\n    static void setup() {\n        actorSystem = AkkaUtils.createDefaultActorSystem();\n        akkaRpcService =\n                new AkkaRpcService(actorSystem, AkkaRpcServiceConfiguration.defaultConfiguration());\n    }\n\n    ",
          "conflictNames": [
              "actorSystem"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka-loader/src/test/java/org/apache/flink/runtime/rpc/akka/FallbackAkkaRpcSystemLoader.java",
      "locators": [
          {
              "line": 68,
              "column": 24
          },
          {
              "line": 73,
              "column": 21
          },
          {
              "line": 77,
              "column": 21
          },
          {
              "line": 82,
              "column": 33
          }
      ],
      "old_name": "akkaRpcModuleDirectory",
      "new_name": "pekkoRpcModuleDirectory",
      "ctx": {
          "symbolName": "akkaRpcModuleDirectory",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Path",
          "scopeHint": "in loadRpcSystem(...)",
          "filePath": "FallbackAkkaRpcSystemLoader.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public RpcSystem loadRpcSystem(Configuration config) {\n        try {\n            LOG.debug(\n                    \"Using Fallback AkkaRpcSystemLoader; this loader will invoke maven to retrieve the dependencies of flink-rpc-akka.\");\n\n            final ClassLoader flinkClassLoader = RpcSystem.class.getClassLoader();\n\n            // flink-rpc/flink-rpc-akka\n            final Path akkaRpcModuleDirectory =\n                    findAkkaRpcModuleDirectory(getCurrentWorkingDirectory());\n\n            // flink-rpc/flink-rpc-akka/target/classes\n            final Path akkaRpcModuleClassesDirectory =\n                    akkaRpcModuleDirectory.resolve(Paths.get(\"target\", \"classes\"));\n\n            // flink-rpc/flink-rpc-akka/target/dependencies\n            final Path akkaRpcModuleDependenciesDirectory =\n                    akkaRpcModuleDirectory.resolve(Paths.get(\"target\", \"dependencies\"));\n\n            if (!Files.exists(akkaRpcModuleDependenciesDirectory)) {\n                int exitCode =\n                        downloadDependencies(\n                                akkaRpcModuleDirectory, akkaRpcModuleDependenciesDirectory);\n                if (exitCode != 0) {\n                    throw new RpcLoaderException(\n                            \"Could not download dependencies of flink-rpc-akka, please see the log output for details.\");\n                }\n            } else {\n                LOG.debug(\n                        \"Re-using previously downloaded flink-rpc-akka dependencies. If you are experiencing strange issues, try clearing '{}'.\",\n                        akkaRpcModuleDependenciesDirectory);\n            }\n\n            // assemble URL collection containing target/classes and each jar\n            final List<URL> urls = new ArrayList<>();\n            urls.add(akkaRpcModuleClassesDirectory.toUri().toURL());\n            try (final Stream<Path> files = Files.list(akkaRpcModuleDependenciesDirectory)) {\n                final List<Path> collect =\n                        files.filter(path -> path.getFileName().toString().endsWith(\".jar\"))\n                                .collect(Collectors.toList());\n\n                for (Path path : collect) {\n                    urls.add(path.toUri().toURL());\n                }\n            }\n\n            final SubmoduleClassLoader submoduleClassLoader =\n                    new SubmoduleClassLoader(urls.toArray(new URL[0]), flinkClassLoader);\n\n            return new CleanupOnCloseRpcSystem(\n                    ServiceLoader.load(RpcSystem.class, submoduleClassLoader).iterator().next(),\n                    submoduleClassLoader,\n                    null);\n        } catch (Exception e) {\n            throw new RpcLoaderException(\n                    String.format(\n                            \"Could not initialize RPC system. Run '%s' on the command-line instead.\",\n                            AkkaRpcSystemLoader.HINT_USAGE),\n                    e);\n        }\n    }",
          "conflictNames": [
              "config",
              "flinkClassLoader",
              "akkaRpcModuleClassesDirectory",
              "akkaRpcModuleDependenciesDirectory",
              "exitCode",
              "urls",
              "files",
              "collect",
              "submoduleClassLoader"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka-loader/src/test/java/org/apache/flink/runtime/rpc/akka/FallbackAkkaRpcSystemLoader.java",
      "locators": [
          {
              "line": 72,
              "column": 24
          },
          {
              "line": 95,
              "column": 22
          }
      ],
      "old_name": "akkaRpcModuleClassesDirectory",
      "new_name": "pekkoRpcModuleClassesDirectory",
      "ctx": {
          "symbolName": "akkaRpcModuleClassesDirectory",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Path",
          "scopeHint": "in loadRpcSystem(...)",
          "filePath": "FallbackAkkaRpcSystemLoader.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public RpcSystem loadRpcSystem(Configuration config) {\n        try {\n            LOG.debug(\n                    \"Using Fallback AkkaRpcSystemLoader; this loader will invoke maven to retrieve the dependencies of flink-rpc-akka.\");\n\n            final ClassLoader flinkClassLoader = RpcSystem.class.getClassLoader();\n\n            // flink-rpc/flink-rpc-akka\n            final Path akkaRpcModuleDirectory =\n                    findAkkaRpcModuleDirectory(getCurrentWorkingDirectory());\n\n            // flink-rpc/flink-rpc-akka/target/classes\n            final Path akkaRpcModuleClassesDirectory =\n                    akkaRpcModuleDirectory.resolve(Paths.get(\"target\", \"classes\"));\n\n            // flink-rpc/flink-rpc-akka/target/dependencies\n            final Path akkaRpcModuleDependenciesDirectory =\n                    akkaRpcModuleDirectory.resolve(Paths.get(\"target\", \"dependencies\"));\n\n            if (!Files.exists(akkaRpcModuleDependenciesDirectory)) {\n                int exitCode =\n                        downloadDependencies(\n                                akkaRpcModuleDirectory, akkaRpcModuleDependenciesDirectory);\n                if (exitCode != 0) {\n                    throw new RpcLoaderException(\n                            \"Could not download dependencies of flink-rpc-akka, please see the log output for details.\");\n                }\n            } else {\n                LOG.debug(\n                        \"Re-using previously downloaded flink-rpc-akka dependencies. If you are experiencing strange issues, try clearing '{}'.\",\n                        akkaRpcModuleDependenciesDirectory);\n            }\n\n            // assemble URL collection containing target/classes and each jar\n            final List<URL> urls = new ArrayList<>();\n            urls.add(akkaRpcModuleClassesDirectory.toUri().toURL());\n            try (final Stream<Path> files = Files.list(akkaRpcModuleDependenciesDirectory)) {\n                final List<Path> collect =\n                        files.filter(path -> path.getFileName().toString().endsWith(\".jar\"))\n                                .collect(Collectors.toList());\n\n                for (Path path : collect) {\n                    urls.add(path.toUri().toURL());\n                }\n            }\n\n            final SubmoduleClassLoader submoduleClassLoader =\n                    new SubmoduleClassLoader(urls.toArray(new URL[0]), flinkClassLoader);\n\n            return new CleanupOnCloseRpcSystem(\n                    ServiceLoader.load(RpcSystem.class, submoduleClassLoader).iterator().next(),\n                    submoduleClassLoader,\n                    null);\n        } catch (Exception e) {\n            throw new RpcLoaderException(\n                    String.format(\n                            \"Could not initialize RPC system. Run '%s' on the command-line instead.\",\n                            AkkaRpcSystemLoader.HINT_USAGE),\n                    e);\n        }\n    }",
          "conflictNames": [
              "config",
              "flinkClassLoader",
              "akkaRpcModuleDirectory",
              "akkaRpcModuleDependenciesDirectory",
              "exitCode",
              "urls",
              "files",
              "collect",
              "submoduleClassLoader"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka-loader/src/test/java/org/apache/flink/runtime/rpc/akka/FallbackAkkaRpcSystemLoader.java",
      "locators": [
          {
              "line": 76,
              "column": 24
          },
          {
              "line": 79,
              "column": 31
          },
          {
              "line": 82,
              "column": 57
          },
          {
              "line": 90,
              "column": 25
          },
          {
              "line": 96,
              "column": 56
          }
      ],
      "old_name": "akkaRpcModuleDependenciesDirectory",
      "new_name": "pekkoRpcModuleDependenciesDirectory",
      "ctx": {
          "symbolName": "akkaRpcModuleDependenciesDirectory",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Path",
          "scopeHint": "in loadRpcSystem(...)",
          "filePath": "FallbackAkkaRpcSystemLoader.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public RpcSystem loadRpcSystem(Configuration config) {\n        try {\n            LOG.debug(\n                    \"Using Fallback AkkaRpcSystemLoader; this loader will invoke maven to retrieve the dependencies of flink-rpc-akka.\");\n\n            final ClassLoader flinkClassLoader = RpcSystem.class.getClassLoader();\n\n            // flink-rpc/flink-rpc-akka\n            final Path akkaRpcModuleDirectory =\n                    findAkkaRpcModuleDirectory(getCurrentWorkingDirectory());\n\n            // flink-rpc/flink-rpc-akka/target/classes\n            final Path akkaRpcModuleClassesDirectory =\n                    akkaRpcModuleDirectory.resolve(Paths.get(\"target\", \"classes\"));\n\n            // flink-rpc/flink-rpc-akka/target/dependencies\n            final Path akkaRpcModuleDependenciesDirectory =\n                    akkaRpcModuleDirectory.resolve(Paths.get(\"target\", \"dependencies\"));\n\n            if (!Files.exists(akkaRpcModuleDependenciesDirectory)) {\n                int exitCode =\n                        downloadDependencies(\n                                akkaRpcModuleDirectory, akkaRpcModuleDependenciesDirectory);\n                if (exitCode != 0) {\n                    throw new RpcLoaderException(\n                            \"Could not download dependencies of flink-rpc-akka, please see the log output for details.\");\n                }\n            } else {\n                LOG.debug(\n                        \"Re-using previously downloaded flink-rpc-akka dependencies. If you are experiencing strange issues, try clearing '{}'.\",\n                        akkaRpcModuleDependenciesDirectory);\n            }\n\n            // assemble URL collection containing target/classes and each jar\n            final List<URL> urls = new ArrayList<>();\n            urls.add(akkaRpcModuleClassesDirectory.toUri().toURL());\n            try (final Stream<Path> files = Files.list(akkaRpcModuleDependenciesDirectory)) {\n                final List<Path> collect =\n                        files.filter(path -> path.getFileName().toString().endsWith(\".jar\"))\n                                .collect(Collectors.toList());\n\n                for (Path path : collect) {\n                    urls.add(path.toUri().toURL());\n                }\n            }\n\n            final SubmoduleClassLoader submoduleClassLoader =\n                    new SubmoduleClassLoader(urls.toArray(new URL[0]), flinkClassLoader);\n\n            return new CleanupOnCloseRpcSystem(\n                    ServiceLoader.load(RpcSystem.class, submoduleClassLoader).iterator().next(),\n                    submoduleClassLoader,\n                    null);\n        } catch (Exception e) {\n            throw new RpcLoaderException(\n                    String.format(\n                            \"Could not initialize RPC system. Run '%s' on the command-line instead.\",\n                            AkkaRpcSystemLoader.HINT_USAGE),\n                    e);\n        }\n    }",
          "conflictNames": [
              "config",
              "flinkClassLoader",
              "akkaRpcModuleDirectory",
              "akkaRpcModuleClassesDirectory",
              "exitCode",
              "urls",
              "files",
              "collect",
              "submoduleClassLoader"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaUtils.java",
      "locators": [
          {
              "line": 73,
              "column": 19
          },
          {
              "line": 98,
              "column": 46
          }
      ],
      "old_name": "akkaThroughput",
      "new_name": "throughput",
      "ctx": {
          "symbolName": "akkaThroughput",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in getBasicAkkaConfig(...)",
          "filePath": "AkkaUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Gets the basic Akka config which is shared by remote and local actor systems.\n     *\n     * @param configuration instance which contains the user specified values for the configuration\n     * @return Flink's basic Akka config\n     */\n    private static Config getBasicAkkaConfig(Configuration configuration) {\n        final int akkaThroughput = configuration.getInteger(AkkaOptions.DISPATCHER_THROUGHPUT);\n        final String jvmExitOnFatalError =\n                booleanToOnOrOff(configuration.getBoolean(AkkaOptions.JVM_EXIT_ON_FATAL_ERROR));\n        final String logLifecycleEvents =\n                booleanToOnOrOff(configuration.getBoolean(AkkaOptions.LOG_LIFECYCLE_EVENTS));\n        final String supervisorStrategy = EscalatingSupervisorStrategy.class.getCanonicalName();\n\n        return new AkkaConfigBuilder()\n                .add(\"akka {\")\n                .add(\"  daemonic = off\")\n                .add(\"  loggers = [\\\"akka.event.slf4j.Slf4jLogger\\\"]\")\n                .add(\"  logging-filter = \\\"akka.event.slf4j.Slf4jLoggingFilter\\\"\")\n                .add(\"  log-config-on-start = off\")\n                .add(\"  logger-startup-timeout = 50s\")\n                .add(\"  loglevel = \" + getLogLevel())\n                .add(\"  stdout-loglevel = OFF\")\n                .add(\"  log-dead-letters = \" + logLifecycleEvents)\n                .add(\"  log-dead-letters-during-shutdown = \" + logLifecycleEvents)\n                .add(\"  jvm-exit-on-fatal-error = \" + jvmExitOnFatalError)\n                .add(\"  serialize-messages = off\")\n                .add(\"  actor {\")\n                .add(\"    guardian-supervisor-strategy = \" + supervisorStrategy)\n                .add(\"    warn-about-java-serializer-usage = off\")\n                .add(\"    allow-java-serialization = on\")\n                .add(\"    default-dispatcher {\")\n                .add(\"      throughput = \" + akkaThroughput)\n                .add(\"    }\")\n                .add(\"    supervisor-dispatcher {\")\n                .add(\"      type = Dispatcher\")\n                .add(\"      executor = \\\"thread-pool-executor\\\"\")\n                .add(\"      thread-pool-executor {\")\n                .add(\"        core-pool-size-min = 1\")\n                .add(\"        core-pool-size-max = 1\")\n                .add(\"      }\")\n                .add(\"    }\")\n                .add(\"  }\")\n                .add(\"}\")\n                .build();\n    }",
          "conflictNames": [
              "configuration",
              "jvmExitOnFatalError",
              "logLifecycleEvents",
              "supervisorStrategy"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaUtils.java",
      "locators": [
          {
              "line": 209,
              "column": 24
          },
          {
              "line": 217,
              "column": 49
          }
      ],
      "old_name": "akkaAskTimeout",
      "new_name": "askTimeout",
      "ctx": {
          "symbolName": "akkaAskTimeout",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Duration",
          "scopeHint": "in addBaseRemoteAkkaConfig(...)",
          "filePath": "AkkaUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void addBaseRemoteAkkaConfig(\n            AkkaConfigBuilder akkaConfigBuilder,\n            Configuration configuration,\n            int port,\n            int externalPort) {\n        final Duration akkaAskTimeout = configuration.get(AkkaOptions.ASK_TIMEOUT_DURATION);\n\n        final String startupTimeout =\n                TimeUtils.getStringInMillis(\n                        TimeUtils.parseDuration(\n                                configuration.getString(\n                                        AkkaOptions.STARTUP_TIMEOUT,\n                                        TimeUtils.getStringInMillis(\n                                                akkaAskTimeout.multipliedBy(10L)))));\n\n        final String akkaTCPTimeout =\n                TimeUtils.getStringInMillis(\n                        TimeUtils.parseDuration(configuration.getString(AkkaOptions.TCP_TIMEOUT)));\n\n        final String akkaFramesize = configuration.getString(AkkaOptions.FRAMESIZE);\n\n        final int clientSocketWorkerPoolPoolSizeMin =\n                configuration.get(AkkaOptions.CLIENT_SOCKET_WORKER_POOL_SIZE_MIN);\n        final int clientSocketWorkerPoolPoolSizeMax =\n                configuration.get(AkkaOptions.CLIENT_SOCKET_WORKER_POOL_SIZE_MAX);\n        final double clientSocketWorkerPoolPoolSizeFactor =\n                configuration.get(AkkaOptions.CLIENT_SOCKET_WORKER_POOL_SIZE_FACTOR);\n        final int serverSocketWorkerPoolPoolSizeMin =\n                configuration.get(AkkaOptions.SERVER_SOCKET_WORKER_POOL_SIZE_MIN);\n        final int serverSocketWorkerPoolPoolSizeMax =\n                configuration.get(AkkaOptions.SERVER_SOCKET_WORKER_POOL_SIZE_MAX);\n        final double serverSocketWorkerPoolPoolSizeFactor =\n                configuration.get(AkkaOptions.SERVER_SOCKET_WORKER_POOL_SIZE_FACTOR);\n\n        final String logLifecycleEvents =\n                booleanToOnOrOff(configuration.getBoolean(AkkaOptions.LOG_LIFECYCLE_EVENTS));\n\n        final long retryGateClosedFor = configuration.getLong(AkkaOptions.RETRY_GATE_CLOSED_FOR);\n\n        akkaConfigBuilder\n                .add(\"akka {\")\n                .add(\"  actor {\")\n                .add(\"    provider = \\\"akka.remote.RemoteActorRefProvider\\\"\")\n                .add(\"  }\")\n                .add(\"  remote.artery.enabled = false\")\n                .add(\"  remote.startup-timeout = \" + startupTimeout)\n                .add(\"  remote.warn-about-direct-use = off\")\n                .add(\"  remote.use-unsafe-remote-features-outside-cluster = on\")\n                .add(\"  remote.classic {\")\n                .add(\"    # disable the transport failure detector by setting very high values\")\n                .add(\"    transport-failure-detector{\")\n                .add(\"      acceptable-heartbeat-pause = 6000 s\")\n                .add(\"      heartbeat-interval = 1000 s\")\n                .add(\"      threshold = 300\")\n                .add(\"    }\")\n                .add(\"    enabled-transports = [\\\"akka.remote.classic.netty.tcp\\\"]\")\n                .add(\"    netty {\")\n                .add(\"      tcp {\")\n                .add(\"        transport-class = \\\"akka.remote.transport.netty.NettyTransport\\\"\")\n                .add(\"        port = \" + externalPort)\n                .add(\"        bind-port = \" + port)\n                .add(\"        connection-timeout = \" + akkaTCPTimeout)\n                .add(\"        maximum-frame-size = \" + akkaFramesize)\n                .add(\"        tcp-nodelay = on\")\n                .add(\"        client-socket-worker-pool {\")\n                .add(\"          pool-size-min = \" + clientSocketWorkerPoolPoolSizeMin)\n                .add(\"          pool-size-max = \" + clientSocketWorkerPoolPoolSizeMax)\n                .add(\"          pool-size-factor = \" + clientSocketWorkerPoolPoolSizeFactor)\n                .add(\"        }\")\n                .add(\"        server-socket-worker-pool {\")\n                .add(\"          pool-size-min = \" + serverSocketWorkerPoolPoolSizeMin)\n                .add(\"          pool-size-max = \" + serverSocketWorkerPoolPoolSizeMax)\n                .add(\"          pool-size-factor = \" + serverSocketWorkerPoolPoolSizeFactor)\n                .add(\"        }\")\n                .add(\"      }\")\n                .add(\"    }\")\n                .add(\"    log-remote-lifecycle-events = \" + logLifecycleEvents)\n                .add(\"    retry-gate-closed-for = \" + retryGateClosedFor + \" ms\")\n                .add(\"  }\")\n                .add(\"}\");\n    }",
          "conflictNames": [
              "akkaConfigBuilder",
              "configuration",
              "port",
              "externalPort",
              "startupTimeout",
              "akkaTCPTimeout",
              "akkaFramesize",
              "clientSocketWorkerPoolPoolSizeMin",
              "clientSocketWorkerPoolPoolSizeMax",
              "clientSocketWorkerPoolPoolSizeFactor",
              "serverSocketWorkerPoolPoolSizeMin",
              "serverSocketWorkerPoolPoolSizeMax",
              "serverSocketWorkerPoolPoolSizeFactor",
              "logLifecycleEvents",
              "retryGateClosedFor"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaUtils.java",
      "locators": [
          {
              "line": 219,
              "column": 22
          },
          {
              "line": 265,
              "column": 56
          }
      ],
      "old_name": "akkaTCPTimeout",
      "new_name": "tcpTimeout",
      "ctx": {
          "symbolName": "akkaTCPTimeout",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in addBaseRemoteAkkaConfig(...)",
          "filePath": "AkkaUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void addBaseRemoteAkkaConfig(\n            AkkaConfigBuilder akkaConfigBuilder,\n            Configuration configuration,\n            int port,\n            int externalPort) {\n        final Duration akkaAskTimeout = configuration.get(AkkaOptions.ASK_TIMEOUT_DURATION);\n\n        final String startupTimeout =\n                TimeUtils.getStringInMillis(\n                        TimeUtils.parseDuration(\n                                configuration.getString(\n                                        AkkaOptions.STARTUP_TIMEOUT,\n                                        TimeUtils.getStringInMillis(\n                                                akkaAskTimeout.multipliedBy(10L)))));\n\n        final String akkaTCPTimeout =\n                TimeUtils.getStringInMillis(\n                        TimeUtils.parseDuration(configuration.getString(AkkaOptions.TCP_TIMEOUT)));\n\n        final String akkaFramesize = configuration.getString(AkkaOptions.FRAMESIZE);\n\n        final int clientSocketWorkerPoolPoolSizeMin =\n                configuration.get(AkkaOptions.CLIENT_SOCKET_WORKER_POOL_SIZE_MIN);\n        final int clientSocketWorkerPoolPoolSizeMax =\n                configuration.get(AkkaOptions.CLIENT_SOCKET_WORKER_POOL_SIZE_MAX);\n        final double clientSocketWorkerPoolPoolSizeFactor =\n                configuration.get(AkkaOptions.CLIENT_SOCKET_WORKER_POOL_SIZE_FACTOR);\n        final int serverSocketWorkerPoolPoolSizeMin =\n                configuration.get(AkkaOptions.SERVER_SOCKET_WORKER_POOL_SIZE_MIN);\n        final int serverSocketWorkerPoolPoolSizeMax =\n                configuration.get(AkkaOptions.SERVER_SOCKET_WORKER_POOL_SIZE_MAX);\n        final double serverSocketWorkerPoolPoolSizeFactor =\n                configuration.get(AkkaOptions.SERVER_SOCKET_WORKER_POOL_SIZE_FACTOR);\n\n        final String logLifecycleEvents =\n                booleanToOnOrOff(configuration.getBoolean(AkkaOptions.LOG_LIFECYCLE_EVENTS));\n\n        final long retryGateClosedFor = configuration.getLong(AkkaOptions.RETRY_GATE_CLOSED_FOR);\n\n        akkaConfigBuilder\n                .add(\"akka {\")\n                .add(\"  actor {\")\n                .add(\"    provider = \\\"akka.remote.RemoteActorRefProvider\\\"\")\n                .add(\"  }\")\n                .add(\"  remote.artery.enabled = false\")\n                .add(\"  remote.startup-timeout = \" + startupTimeout)\n                .add(\"  remote.warn-about-direct-use = off\")\n                .add(\"  remote.use-unsafe-remote-features-outside-cluster = on\")\n                .add(\"  remote.classic {\")\n                .add(\"    # disable the transport failure detector by setting very high values\")\n                .add(\"    transport-failure-detector{\")\n                .add(\"      acceptable-heartbeat-pause = 6000 s\")\n                .add(\"      heartbeat-interval = 1000 s\")\n                .add(\"      threshold = 300\")\n                .add(\"    }\")\n                .add(\"    enabled-transports = [\\\"akka.remote.classic.netty.tcp\\\"]\")\n                .add(\"    netty {\")\n                .add(\"      tcp {\")\n                .add(\"        transport-class = \\\"akka.remote.transport.netty.NettyTransport\\\"\")\n                .add(\"        port = \" + externalPort)\n                .add(\"        bind-port = \" + port)\n                .add(\"        connection-timeout = \" + akkaTCPTimeout)\n                .add(\"        maximum-frame-size = \" + akkaFramesize)\n                .add(\"        tcp-nodelay = on\")\n                .add(\"        client-socket-worker-pool {\")\n                .add(\"          pool-size-min = \" + clientSocketWorkerPoolPoolSizeMin)\n                .add(\"          pool-size-max = \" + clientSocketWorkerPoolPoolSizeMax)\n                .add(\"          pool-size-factor = \" + clientSocketWorkerPoolPoolSizeFactor)\n                .add(\"        }\")\n                .add(\"        server-socket-worker-pool {\")\n                .add(\"          pool-size-min = \" + serverSocketWorkerPoolPoolSizeMin)\n                .add(\"          pool-size-max = \" + serverSocketWorkerPoolPoolSizeMax)\n                .add(\"          pool-size-factor = \" + serverSocketWorkerPoolPoolSizeFactor)\n                .add(\"        }\")\n                .add(\"      }\")\n                .add(\"    }\")\n                .add(\"    log-remote-lifecycle-events = \" + logLifecycleEvents)\n                .add(\"    retry-gate-closed-for = \" + retryGateClosedFor + \" ms\")\n                .add(\"  }\")\n                .add(\"}\");\n    }",
          "conflictNames": [
              "akkaConfigBuilder",
              "configuration",
              "port",
              "externalPort",
              "akkaAskTimeout",
              "startupTimeout",
              "akkaFramesize",
              "clientSocketWorkerPoolPoolSizeMin",
              "clientSocketWorkerPoolPoolSizeMax",
              "clientSocketWorkerPoolPoolSizeFactor",
              "serverSocketWorkerPoolPoolSizeMin",
              "serverSocketWorkerPoolPoolSizeMax",
              "serverSocketWorkerPoolPoolSizeFactor",
              "logLifecycleEvents",
              "retryGateClosedFor"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaUtils.java",
      "locators": [
          {
              "line": 223,
              "column": 22
          },
          {
              "line": 266,
              "column": 56
          }
      ],
      "old_name": "akkaFramesize",
      "new_name": "framesize",
      "ctx": {
          "symbolName": "akkaFramesize",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in addBaseRemoteAkkaConfig(...)",
          "filePath": "AkkaUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void addBaseRemoteAkkaConfig(\n            AkkaConfigBuilder akkaConfigBuilder,\n            Configuration configuration,\n            int port,\n            int externalPort) {\n        final Duration akkaAskTimeout = configuration.get(AkkaOptions.ASK_TIMEOUT_DURATION);\n\n        final String startupTimeout =\n                TimeUtils.getStringInMillis(\n                        TimeUtils.parseDuration(\n                                configuration.getString(\n                                        AkkaOptions.STARTUP_TIMEOUT,\n                                        TimeUtils.getStringInMillis(\n                                                akkaAskTimeout.multipliedBy(10L)))));\n\n        final String akkaTCPTimeout =\n                TimeUtils.getStringInMillis(\n                        TimeUtils.parseDuration(configuration.getString(AkkaOptions.TCP_TIMEOUT)));\n\n        final String akkaFramesize = configuration.getString(AkkaOptions.FRAMESIZE);\n\n        final int clientSocketWorkerPoolPoolSizeMin =\n                configuration.get(AkkaOptions.CLIENT_SOCKET_WORKER_POOL_SIZE_MIN);\n        final int clientSocketWorkerPoolPoolSizeMax =\n                configuration.get(AkkaOptions.CLIENT_SOCKET_WORKER_POOL_SIZE_MAX);\n        final double clientSocketWorkerPoolPoolSizeFactor =\n                configuration.get(AkkaOptions.CLIENT_SOCKET_WORKER_POOL_SIZE_FACTOR);\n        final int serverSocketWorkerPoolPoolSizeMin =\n                configuration.get(AkkaOptions.SERVER_SOCKET_WORKER_POOL_SIZE_MIN);\n        final int serverSocketWorkerPoolPoolSizeMax =\n                configuration.get(AkkaOptions.SERVER_SOCKET_WORKER_POOL_SIZE_MAX);\n        final double serverSocketWorkerPoolPoolSizeFactor =\n                configuration.get(AkkaOptions.SERVER_SOCKET_WORKER_POOL_SIZE_FACTOR);\n\n        final String logLifecycleEvents =\n                booleanToOnOrOff(configuration.getBoolean(AkkaOptions.LOG_LIFECYCLE_EVENTS));\n\n        final long retryGateClosedFor = configuration.getLong(AkkaOptions.RETRY_GATE_CLOSED_FOR);\n\n        akkaConfigBuilder\n                .add(\"akka {\")\n                .add(\"  actor {\")\n                .add(\"    provider = \\\"akka.remote.RemoteActorRefProvider\\\"\")\n                .add(\"  }\")\n                .add(\"  remote.artery.enabled = false\")\n                .add(\"  remote.startup-timeout = \" + startupTimeout)\n                .add(\"  remote.warn-about-direct-use = off\")\n                .add(\"  remote.use-unsafe-remote-features-outside-cluster = on\")\n                .add(\"  remote.classic {\")\n                .add(\"    # disable the transport failure detector by setting very high values\")\n                .add(\"    transport-failure-detector{\")\n                .add(\"      acceptable-heartbeat-pause = 6000 s\")\n                .add(\"      heartbeat-interval = 1000 s\")\n                .add(\"      threshold = 300\")\n                .add(\"    }\")\n                .add(\"    enabled-transports = [\\\"akka.remote.classic.netty.tcp\\\"]\")\n                .add(\"    netty {\")\n                .add(\"      tcp {\")\n                .add(\"        transport-class = \\\"akka.remote.transport.netty.NettyTransport\\\"\")\n                .add(\"        port = \" + externalPort)\n                .add(\"        bind-port = \" + port)\n                .add(\"        connection-timeout = \" + akkaTCPTimeout)\n                .add(\"        maximum-frame-size = \" + akkaFramesize)\n                .add(\"        tcp-nodelay = on\")\n                .add(\"        client-socket-worker-pool {\")\n                .add(\"          pool-size-min = \" + clientSocketWorkerPoolPoolSizeMin)\n                .add(\"          pool-size-max = \" + clientSocketWorkerPoolPoolSizeMax)\n                .add(\"          pool-size-factor = \" + clientSocketWorkerPoolPoolSizeFactor)\n                .add(\"        }\")\n                .add(\"        server-socket-worker-pool {\")\n                .add(\"          pool-size-min = \" + serverSocketWorkerPoolPoolSizeMin)\n                .add(\"          pool-size-max = \" + serverSocketWorkerPoolPoolSizeMax)\n                .add(\"          pool-size-factor = \" + serverSocketWorkerPoolPoolSizeFactor)\n                .add(\"        }\")\n                .add(\"      }\")\n                .add(\"    }\")\n                .add(\"    log-remote-lifecycle-events = \" + logLifecycleEvents)\n                .add(\"    retry-gate-closed-for = \" + retryGateClosedFor + \" ms\")\n                .add(\"  }\")\n                .add(\"}\");\n    }",
          "conflictNames": [
              "akkaConfigBuilder",
              "configuration",
              "port",
              "externalPort",
              "akkaAskTimeout",
              "startupTimeout",
              "akkaTCPTimeout",
              "clientSocketWorkerPoolPoolSizeMin",
              "clientSocketWorkerPoolPoolSizeMax",
              "clientSocketWorkerPoolPoolSizeFactor",
              "serverSocketWorkerPoolPoolSizeMin",
              "serverSocketWorkerPoolPoolSizeMax",
              "serverSocketWorkerPoolPoolSizeFactor",
              "logLifecycleEvents",
              "retryGateClosedFor"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaUtils.java",
      "locators": [
          {
              "line": 313,
              "column": 23
          },
          {
              "line": 317,
              "column": 55
          }
      ],
      "old_name": "akkaEnableSSLConfig",
      "new_name": "enableSSLConfig",
      "ctx": {
          "symbolName": "akkaEnableSSLConfig",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "boolean",
          "scopeHint": "in addSslRemoteAkkaConfig(...)",
          "filePath": "AkkaUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void addSslRemoteAkkaConfig(\n            AkkaConfigBuilder akkaConfigBuilder, Configuration configuration) {\n\n        final boolean akkaEnableSSLConfig =\n                configuration.getBoolean(AkkaOptions.SSL_ENABLED)\n                        && SecurityOptions.isInternalSSLEnabled(configuration);\n\n        final String akkaEnableSSL = booleanToOnOrOff(akkaEnableSSLConfig);\n\n        final String akkaSSLKeyStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE));\n\n        final String akkaSSLKeyStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE_PASSWORD));\n\n        final String akkaSSLKeyPassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEY_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEY_PASSWORD));\n\n        final String akkaSSLTrustStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE));\n\n        final String akkaSSLTrustStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE_PASSWORD));\n\n        final String akkaSSLCertFingerprintString =\n                configuration.getString(SecurityOptions.SSL_INTERNAL_CERT_FINGERPRINT);\n\n        final String akkaSSLCertFingerprints =\n                akkaSSLCertFingerprintString != null\n                        ? Arrays.stream(akkaSSLCertFingerprintString.split(\",\"))\n                                .collect(Collectors.joining(\"\\\",\\\"\", \"[\\\"\", \"\\\"]\"))\n                        : \"[]\";\n\n        final String akkaSSLProtocol = configuration.getString(SecurityOptions.SSL_PROTOCOL);\n\n        final String akkaSSLAlgorithmsString =\n                configuration.getString(SecurityOptions.SSL_ALGORITHMS);\n        final String akkaSSLAlgorithms =\n                Arrays.stream(akkaSSLAlgorithmsString.split(\",\"))\n                        .collect(Collectors.joining(\",\", \"[\", \"]\"));\n\n        final String sslEngineProviderName = CustomSSLEngineProvider.class.getCanonicalName();\n\n        akkaConfigBuilder\n                .add(\"akka {\")\n                .add(\"  remote.classic {\")\n                .add(\"    enabled-transports = [\\\"akka.remote.classic.netty.ssl\\\"]\")\n                .add(\"    netty {\")\n                .add(\"      ssl = ${akka.remote.classic.netty.tcp}\")\n                .add(\"      ssl {\")\n                .add(\"        enable-ssl = \" + akkaEnableSSL)\n                .add(\"        ssl-engine-provider = \" + sslEngineProviderName)\n                .add(\"        security {\")\n                .add(\"          key-store = \\\"\" + akkaSSLKeyStore + \"\\\"\")\n                .add(\"          key-store-password = \\\"\" + akkaSSLKeyStorePassword + \"\\\"\")\n                .add(\"          key-password = \\\"\" + akkaSSLKeyPassword + \"\\\"\")\n                .add(\"          trust-store = \\\"\" + akkaSSLTrustStore + \"\\\"\")\n                .add(\"          trust-store-password = \\\"\" + akkaSSLTrustStorePassword + \"\\\"\")\n                .add(\"          protocol = \" + akkaSSLProtocol + \"\")\n                .add(\"          enabled-algorithms = \" + akkaSSLAlgorithms + \"\")\n                .add(\"          random-number-generator = \\\"\\\"\")\n                .add(\"          require-mutual-authentication = on\")\n                .add(\"          cert-fingerprints = \" + akkaSSLCertFingerprints + \"\")\n                .add(\"        }\")\n                .add(\"      }\")\n                .add(\"    }\")\n                .add(\"  }\")\n                .add(\"}\");\n    }",
          "conflictNames": [
              "akkaConfigBuilder",
              "configuration",
              "akkaEnableSSL",
              "akkaSSLKeyStore",
              "akkaSSLKeyStorePassword",
              "akkaSSLKeyPassword",
              "akkaSSLTrustStore",
              "akkaSSLTrustStorePassword",
              "akkaSSLCertFingerprintString",
              "akkaSSLCertFingerprints",
              "akkaSSLProtocol",
              "akkaSSLAlgorithmsString",
              "akkaSSLAlgorithms",
              "sslEngineProviderName"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaUtils.java",
      "locators": [
          {
              "line": 313,
              "column": 23
          },
          {
              "line": 317,
              "column": 22
          },
          {
              "line": 317,
              "column": 55
          },
          {
              "line": 370,
              "column": 48
          }
      ],
      "old_name": "akkaEnableSSL",
      "new_name": "enableSSL",
      "ctx": {
          "symbolName": "akkaEnableSSL",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in addSslRemoteAkkaConfig(...)",
          "filePath": "AkkaUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void addSslRemoteAkkaConfig(\n            AkkaConfigBuilder akkaConfigBuilder, Configuration configuration) {\n\n        final boolean akkaEnableSSLConfig =\n                configuration.getBoolean(AkkaOptions.SSL_ENABLED)\n                        && SecurityOptions.isInternalSSLEnabled(configuration);\n\n        final String akkaEnableSSL = booleanToOnOrOff(akkaEnableSSLConfig);\n\n        final String akkaSSLKeyStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE));\n\n        final String akkaSSLKeyStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE_PASSWORD));\n\n        final String akkaSSLKeyPassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEY_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEY_PASSWORD));\n\n        final String akkaSSLTrustStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE));\n\n        final String akkaSSLTrustStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE_PASSWORD));\n\n        final String akkaSSLCertFingerprintString =\n                configuration.getString(SecurityOptions.SSL_INTERNAL_CERT_FINGERPRINT);\n\n        final String akkaSSLCertFingerprints =\n                akkaSSLCertFingerprintString != null\n                        ? Arrays.stream(akkaSSLCertFingerprintString.split(\",\"))\n                                .collect(Collectors.joining(\"\\\",\\\"\", \"[\\\"\", \"\\\"]\"))\n                        : \"[]\";\n\n        final String akkaSSLProtocol = configuration.getString(SecurityOptions.SSL_PROTOCOL);\n\n        final String akkaSSLAlgorithmsString =\n                configuration.getString(SecurityOptions.SSL_ALGORITHMS);\n        final String akkaSSLAlgorithms =\n                Arrays.stream(akkaSSLAlgorithmsString.split(\",\"))\n                        .collect(Collectors.joining(\",\", \"[\", \"]\"));\n\n        final String sslEngineProviderName = CustomSSLEngineProvider.class.getCanonicalName();\n\n        akkaConfigBuilder\n                .add(\"akka {\")\n                .add(\"  remote.classic {\")\n                .add(\"    enabled-transports = [\\\"akka.remote.classic.netty.ssl\\\"]\")\n                .add(\"    netty {\")\n                .add(\"      ssl = ${akka.remote.classic.netty.tcp}\")\n                .add(\"      ssl {\")\n                .add(\"        enable-ssl = \" + akkaEnableSSL)\n                .add(\"        ssl-engine-provider = \" + sslEngineProviderName)\n                .add(\"        security {\")\n                .add(\"          key-store = \\\"\" + akkaSSLKeyStore + \"\\\"\")\n                .add(\"          key-store-password = \\\"\" + akkaSSLKeyStorePassword + \"\\\"\")\n                .add(\"          key-password = \\\"\" + akkaSSLKeyPassword + \"\\\"\")\n                .add(\"          trust-store = \\\"\" + akkaSSLTrustStore + \"\\\"\")\n                .add(\"          trust-store-password = \\\"\" + akkaSSLTrustStorePassword + \"\\\"\")\n                .add(\"          protocol = \" + akkaSSLProtocol + \"\")\n                .add(\"          enabled-algorithms = \" + akkaSSLAlgorithms + \"\")\n                .add(\"          random-number-generator = \\\"\\\"\")\n                .add(\"          require-mutual-authentication = on\")\n                .add(\"          cert-fingerprints = \" + akkaSSLCertFingerprints + \"\")\n                .add(\"        }\")\n                .add(\"      }\")\n                .add(\"    }\")\n                .add(\"  }\")\n                .add(\"}\");\n    }",
          "conflictNames": [
              "akkaConfigBuilder",
              "configuration",
              "akkaEnableSSLConfig",
              "akkaSSLKeyStore",
              "akkaSSLKeyStorePassword",
              "akkaSSLKeyPassword",
              "akkaSSLTrustStore",
              "akkaSSLTrustStorePassword",
              "akkaSSLCertFingerprintString",
              "akkaSSLCertFingerprints",
              "akkaSSLProtocol",
              "akkaSSLAlgorithmsString",
              "akkaSSLAlgorithms",
              "sslEngineProviderName"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaUtils.java",
      "locators": [
          {
              "line": 319,
              "column": 22
          },
          {
              "line": 324,
              "column": 22
          },
          {
              "line": 373,
              "column": 51
          },
          {
              "line": 374,
              "column": 60
          }
      ],
      "old_name": "akkaSSLKeyStore",
      "new_name": "sslKeyStore",
      "ctx": {
          "symbolName": "akkaSSLKeyStore",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in addSslRemoteAkkaConfig(...)",
          "filePath": "AkkaUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void addSslRemoteAkkaConfig(\n            AkkaConfigBuilder akkaConfigBuilder, Configuration configuration) {\n\n        final boolean akkaEnableSSLConfig =\n                configuration.getBoolean(AkkaOptions.SSL_ENABLED)\n                        && SecurityOptions.isInternalSSLEnabled(configuration);\n\n        final String akkaEnableSSL = booleanToOnOrOff(akkaEnableSSLConfig);\n\n        final String akkaSSLKeyStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE));\n\n        final String akkaSSLKeyStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE_PASSWORD));\n\n        final String akkaSSLKeyPassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEY_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEY_PASSWORD));\n\n        final String akkaSSLTrustStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE));\n\n        final String akkaSSLTrustStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE_PASSWORD));\n\n        final String akkaSSLCertFingerprintString =\n                configuration.getString(SecurityOptions.SSL_INTERNAL_CERT_FINGERPRINT);\n\n        final String akkaSSLCertFingerprints =\n                akkaSSLCertFingerprintString != null\n                        ? Arrays.stream(akkaSSLCertFingerprintString.split(\",\"))\n                                .collect(Collectors.joining(\"\\\",\\\"\", \"[\\\"\", \"\\\"]\"))\n                        : \"[]\";\n\n        final String akkaSSLProtocol = configuration.getString(SecurityOptions.SSL_PROTOCOL);\n\n        final String akkaSSLAlgorithmsString =\n                configuration.getString(SecurityOptions.SSL_ALGORITHMS);\n        final String akkaSSLAlgorithms =\n                Arrays.stream(akkaSSLAlgorithmsString.split(\",\"))\n                        .collect(Collectors.joining(\",\", \"[\", \"]\"));\n\n        final String sslEngineProviderName = CustomSSLEngineProvider.class.getCanonicalName();\n\n        akkaConfigBuilder\n                .add(\"akka {\")\n                .add(\"  remote.classic {\")\n                .add(\"    enabled-transports = [\\\"akka.remote.classic.netty.ssl\\\"]\")\n                .add(\"    netty {\")\n                .add(\"      ssl = ${akka.remote.classic.netty.tcp}\")\n                .add(\"      ssl {\")\n                .add(\"        enable-ssl = \" + akkaEnableSSL)\n                .add(\"        ssl-engine-provider = \" + sslEngineProviderName)\n                .add(\"        security {\")\n                .add(\"          key-store = \\\"\" + akkaSSLKeyStore + \"\\\"\")\n                .add(\"          key-store-password = \\\"\" + akkaSSLKeyStorePassword + \"\\\"\")\n                .add(\"          key-password = \\\"\" + akkaSSLKeyPassword + \"\\\"\")\n                .add(\"          trust-store = \\\"\" + akkaSSLTrustStore + \"\\\"\")\n                .add(\"          trust-store-password = \\\"\" + akkaSSLTrustStorePassword + \"\\\"\")\n                .add(\"          protocol = \" + akkaSSLProtocol + \"\")\n                .add(\"          enabled-algorithms = \" + akkaSSLAlgorithms + \"\")\n                .add(\"          random-number-generator = \\\"\\\"\")\n                .add(\"          require-mutual-authentication = on\")\n                .add(\"          cert-fingerprints = \" + akkaSSLCertFingerprints + \"\")\n                .add(\"        }\")\n                .add(\"      }\")\n                .add(\"    }\")\n                .add(\"  }\")\n                .add(\"}\");\n    }",
          "conflictNames": [
              "akkaConfigBuilder",
              "configuration",
              "akkaEnableSSLConfig",
              "akkaEnableSSL",
              "akkaSSLKeyStorePassword",
              "akkaSSLKeyPassword",
              "akkaSSLTrustStore",
              "akkaSSLTrustStorePassword",
              "akkaSSLCertFingerprintString",
              "akkaSSLCertFingerprints",
              "akkaSSLProtocol",
              "akkaSSLAlgorithmsString",
              "akkaSSLAlgorithms",
              "sslEngineProviderName"
          ]
      },
      "suggestions": [
          {
              "name": "sslKeyStore",
              "confidence": 0.77
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaUtils.java",
      "locators": [
          {
              "line": 324,
              "column": 22
          },
          {
              "line": 374,
              "column": 60
          }
      ],
      "old_name": "akkaSSLKeyStorePassword",
      "new_name": "sslKeyStorePassword",
      "ctx": {
          "symbolName": "akkaSSLKeyStorePassword",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in addSslRemoteAkkaConfig(...)",
          "filePath": "AkkaUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void addSslRemoteAkkaConfig(\n            AkkaConfigBuilder akkaConfigBuilder, Configuration configuration) {\n\n        final boolean akkaEnableSSLConfig =\n                configuration.getBoolean(AkkaOptions.SSL_ENABLED)\n                        && SecurityOptions.isInternalSSLEnabled(configuration);\n\n        final String akkaEnableSSL = booleanToOnOrOff(akkaEnableSSLConfig);\n\n        final String akkaSSLKeyStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE));\n\n        final String akkaSSLKeyStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE_PASSWORD));\n\n        final String akkaSSLKeyPassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEY_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEY_PASSWORD));\n\n        final String akkaSSLTrustStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE));\n\n        final String akkaSSLTrustStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE_PASSWORD));\n\n        final String akkaSSLCertFingerprintString =\n                configuration.getString(SecurityOptions.SSL_INTERNAL_CERT_FINGERPRINT);\n\n        final String akkaSSLCertFingerprints =\n                akkaSSLCertFingerprintString != null\n                        ? Arrays.stream(akkaSSLCertFingerprintString.split(\",\"))\n                                .collect(Collectors.joining(\"\\\",\\\"\", \"[\\\"\", \"\\\"]\"))\n                        : \"[]\";\n\n        final String akkaSSLProtocol = configuration.getString(SecurityOptions.SSL_PROTOCOL);\n\n        final String akkaSSLAlgorithmsString =\n                configuration.getString(SecurityOptions.SSL_ALGORITHMS);\n        final String akkaSSLAlgorithms =\n                Arrays.stream(akkaSSLAlgorithmsString.split(\",\"))\n                        .collect(Collectors.joining(\",\", \"[\", \"]\"));\n\n        final String sslEngineProviderName = CustomSSLEngineProvider.class.getCanonicalName();\n\n        akkaConfigBuilder\n                .add(\"akka {\")\n                .add(\"  remote.classic {\")\n                .add(\"    enabled-transports = [\\\"akka.remote.classic.netty.ssl\\\"]\")\n                .add(\"    netty {\")\n                .add(\"      ssl = ${akka.remote.classic.netty.tcp}\")\n                .add(\"      ssl {\")\n                .add(\"        enable-ssl = \" + akkaEnableSSL)\n                .add(\"        ssl-engine-provider = \" + sslEngineProviderName)\n                .add(\"        security {\")\n                .add(\"          key-store = \\\"\" + akkaSSLKeyStore + \"\\\"\")\n                .add(\"          key-store-password = \\\"\" + akkaSSLKeyStorePassword + \"\\\"\")\n                .add(\"          key-password = \\\"\" + akkaSSLKeyPassword + \"\\\"\")\n                .add(\"          trust-store = \\\"\" + akkaSSLTrustStore + \"\\\"\")\n                .add(\"          trust-store-password = \\\"\" + akkaSSLTrustStorePassword + \"\\\"\")\n                .add(\"          protocol = \" + akkaSSLProtocol + \"\")\n                .add(\"          enabled-algorithms = \" + akkaSSLAlgorithms + \"\")\n                .add(\"          random-number-generator = \\\"\\\"\")\n                .add(\"          require-mutual-authentication = on\")\n                .add(\"          cert-fingerprints = \" + akkaSSLCertFingerprints + \"\")\n                .add(\"        }\")\n                .add(\"      }\")\n                .add(\"    }\")\n                .add(\"  }\")\n                .add(\"}\");\n    }",
          "conflictNames": [
              "akkaConfigBuilder",
              "configuration",
              "akkaEnableSSLConfig",
              "akkaEnableSSL",
              "akkaSSLKeyStore",
              "akkaSSLKeyPassword",
              "akkaSSLTrustStore",
              "akkaSSLTrustStorePassword",
              "akkaSSLCertFingerprintString",
              "akkaSSLCertFingerprints",
              "akkaSSLProtocol",
              "akkaSSLAlgorithmsString",
              "akkaSSLAlgorithms",
              "sslEngineProviderName"
          ]
      },
      "suggestions": [
          {
              "name": "sslKeyStorePassword",
              "confidence": 0.75
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaUtils.java",
      "locators": [
          {
              "line": 329,
              "column": 22
          },
          {
              "line": 375,
              "column": 54
          }
      ],
      "old_name": "akkaSSLKeyPassword",
      "new_name": "sslKeyPassword",
      "ctx": {
          "symbolName": "akkaSSLKeyPassword",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in addSslRemoteAkkaConfig(...)",
          "filePath": "AkkaUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void addSslRemoteAkkaConfig(\n            AkkaConfigBuilder akkaConfigBuilder, Configuration configuration) {\n\n        final boolean akkaEnableSSLConfig =\n                configuration.getBoolean(AkkaOptions.SSL_ENABLED)\n                        && SecurityOptions.isInternalSSLEnabled(configuration);\n\n        final String akkaEnableSSL = booleanToOnOrOff(akkaEnableSSLConfig);\n\n        final String akkaSSLKeyStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE));\n\n        final String akkaSSLKeyStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE_PASSWORD));\n\n        final String akkaSSLKeyPassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEY_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEY_PASSWORD));\n\n        final String akkaSSLTrustStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE));\n\n        final String akkaSSLTrustStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE_PASSWORD));\n\n        final String akkaSSLCertFingerprintString =\n                configuration.getString(SecurityOptions.SSL_INTERNAL_CERT_FINGERPRINT);\n\n        final String akkaSSLCertFingerprints =\n                akkaSSLCertFingerprintString != null\n                        ? Arrays.stream(akkaSSLCertFingerprintString.split(\",\"))\n                                .collect(Collectors.joining(\"\\\",\\\"\", \"[\\\"\", \"\\\"]\"))\n                        : \"[]\";\n\n        final String akkaSSLProtocol = configuration.getString(SecurityOptions.SSL_PROTOCOL);\n\n        final String akkaSSLAlgorithmsString =\n                configuration.getString(SecurityOptions.SSL_ALGORITHMS);\n        final String akkaSSLAlgorithms =\n                Arrays.stream(akkaSSLAlgorithmsString.split(\",\"))\n                        .collect(Collectors.joining(\",\", \"[\", \"]\"));\n\n        final String sslEngineProviderName = CustomSSLEngineProvider.class.getCanonicalName();\n\n        akkaConfigBuilder\n                .add(\"akka {\")\n                .add(\"  remote.classic {\")\n                .add(\"    enabled-transports = [\\\"akka.remote.classic.netty.ssl\\\"]\")\n                .add(\"    netty {\")\n                .add(\"      ssl = ${akka.remote.classic.netty.tcp}\")\n                .add(\"      ssl {\")\n                .add(\"        enable-ssl = \" + akkaEnableSSL)\n                .add(\"        ssl-engine-provider = \" + sslEngineProviderName)\n                .add(\"        security {\")\n                .add(\"          key-store = \\\"\" + akkaSSLKeyStore + \"\\\"\")\n                .add(\"          key-store-password = \\\"\" + akkaSSLKeyStorePassword + \"\\\"\")\n                .add(\"          key-password = \\\"\" + akkaSSLKeyPassword + \"\\\"\")\n                .add(\"          trust-store = \\\"\" + akkaSSLTrustStore + \"\\\"\")\n                .add(\"          trust-store-password = \\\"\" + akkaSSLTrustStorePassword + \"\\\"\")\n                .add(\"          protocol = \" + akkaSSLProtocol + \"\")\n                .add(\"          enabled-algorithms = \" + akkaSSLAlgorithms + \"\")\n                .add(\"          random-number-generator = \\\"\\\"\")\n                .add(\"          require-mutual-authentication = on\")\n                .add(\"          cert-fingerprints = \" + akkaSSLCertFingerprints + \"\")\n                .add(\"        }\")\n                .add(\"      }\")\n                .add(\"    }\")\n                .add(\"  }\")\n                .add(\"}\");\n    }",
          "conflictNames": [
              "akkaConfigBuilder",
              "configuration",
              "akkaEnableSSLConfig",
              "akkaEnableSSL",
              "akkaSSLKeyStore",
              "akkaSSLKeyStorePassword",
              "akkaSSLTrustStore",
              "akkaSSLTrustStorePassword",
              "akkaSSLCertFingerprintString",
              "akkaSSLCertFingerprints",
              "akkaSSLProtocol",
              "akkaSSLAlgorithmsString",
              "akkaSSLAlgorithms",
              "sslEngineProviderName"
          ]
      },
      "suggestions": [
          {
              "name": "sslKeyPassword",
              "confidence": 0.77
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaUtils.java",
      "locators": [
          {
              "line": 334,
              "column": 22
          },
          {
              "line": 339,
              "column": 22
          },
          {
              "line": 376,
              "column": 53
          },
          {
              "line": 377,
              "column": 62
          }
      ],
      "old_name": "akkaSSLTrustStore",
      "new_name": "sslTrustStore",
      "ctx": {
          "symbolName": "akkaSSLTrustStore",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in addSslRemoteAkkaConfig(...)",
          "filePath": "AkkaUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void addSslRemoteAkkaConfig(\n            AkkaConfigBuilder akkaConfigBuilder, Configuration configuration) {\n\n        final boolean akkaEnableSSLConfig =\n                configuration.getBoolean(AkkaOptions.SSL_ENABLED)\n                        && SecurityOptions.isInternalSSLEnabled(configuration);\n\n        final String akkaEnableSSL = booleanToOnOrOff(akkaEnableSSLConfig);\n\n        final String akkaSSLKeyStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE));\n\n        final String akkaSSLKeyStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE_PASSWORD));\n\n        final String akkaSSLKeyPassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEY_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEY_PASSWORD));\n\n        final String akkaSSLTrustStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE));\n\n        final String akkaSSLTrustStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE_PASSWORD));\n\n        final String akkaSSLCertFingerprintString =\n                configuration.getString(SecurityOptions.SSL_INTERNAL_CERT_FINGERPRINT);\n\n        final String akkaSSLCertFingerprints =\n                akkaSSLCertFingerprintString != null\n                        ? Arrays.stream(akkaSSLCertFingerprintString.split(\",\"))\n                                .collect(Collectors.joining(\"\\\",\\\"\", \"[\\\"\", \"\\\"]\"))\n                        : \"[]\";\n\n        final String akkaSSLProtocol = configuration.getString(SecurityOptions.SSL_PROTOCOL);\n\n        final String akkaSSLAlgorithmsString =\n                configuration.getString(SecurityOptions.SSL_ALGORITHMS);\n        final String akkaSSLAlgorithms =\n                Arrays.stream(akkaSSLAlgorithmsString.split(\",\"))\n                        .collect(Collectors.joining(\",\", \"[\", \"]\"));\n\n        final String sslEngineProviderName = CustomSSLEngineProvider.class.getCanonicalName();\n\n        akkaConfigBuilder\n                .add(\"akka {\")\n                .add(\"  remote.classic {\")\n                .add(\"    enabled-transports = [\\\"akka.remote.classic.netty.ssl\\\"]\")\n                .add(\"    netty {\")\n                .add(\"      ssl = ${akka.remote.classic.netty.tcp}\")\n                .add(\"      ssl {\")\n                .add(\"        enable-ssl = \" + akkaEnableSSL)\n                .add(\"        ssl-engine-provider = \" + sslEngineProviderName)\n                .add(\"        security {\")\n                .add(\"          key-store = \\\"\" + akkaSSLKeyStore + \"\\\"\")\n                .add(\"          key-store-password = \\\"\" + akkaSSLKeyStorePassword + \"\\\"\")\n                .add(\"          key-password = \\\"\" + akkaSSLKeyPassword + \"\\\"\")\n                .add(\"          trust-store = \\\"\" + akkaSSLTrustStore + \"\\\"\")\n                .add(\"          trust-store-password = \\\"\" + akkaSSLTrustStorePassword + \"\\\"\")\n                .add(\"          protocol = \" + akkaSSLProtocol + \"\")\n                .add(\"          enabled-algorithms = \" + akkaSSLAlgorithms + \"\")\n                .add(\"          random-number-generator = \\\"\\\"\")\n                .add(\"          require-mutual-authentication = on\")\n                .add(\"          cert-fingerprints = \" + akkaSSLCertFingerprints + \"\")\n                .add(\"        }\")\n                .add(\"      }\")\n                .add(\"    }\")\n                .add(\"  }\")\n                .add(\"}\");\n    }",
          "conflictNames": [
              "akkaConfigBuilder",
              "configuration",
              "akkaEnableSSLConfig",
              "akkaEnableSSL",
              "akkaSSLKeyStore",
              "akkaSSLKeyStorePassword",
              "akkaSSLKeyPassword",
              "akkaSSLTrustStorePassword",
              "akkaSSLCertFingerprintString",
              "akkaSSLCertFingerprints",
              "akkaSSLProtocol",
              "akkaSSLAlgorithmsString",
              "akkaSSLAlgorithms",
              "sslEngineProviderName"
          ]
      },
      "suggestions": [
          {
              "name": "sslTrustStore",
              "confidence": 0.77
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaUtils.java",
      "locators": [
          {
              "line": 339,
              "column": 22
          },
          {
              "line": 377,
              "column": 62
          }
      ],
      "old_name": "akkaSSLTrustStorePassword",
      "new_name": "sslTrustStorePassword",
      "ctx": {
          "symbolName": "akkaSSLTrustStorePassword",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in addSslRemoteAkkaConfig(...)",
          "filePath": "AkkaUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void addSslRemoteAkkaConfig(\n            AkkaConfigBuilder akkaConfigBuilder, Configuration configuration) {\n\n        final boolean akkaEnableSSLConfig =\n                configuration.getBoolean(AkkaOptions.SSL_ENABLED)\n                        && SecurityOptions.isInternalSSLEnabled(configuration);\n\n        final String akkaEnableSSL = booleanToOnOrOff(akkaEnableSSLConfig);\n\n        final String akkaSSLKeyStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE));\n\n        final String akkaSSLKeyStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE_PASSWORD));\n\n        final String akkaSSLKeyPassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEY_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEY_PASSWORD));\n\n        final String akkaSSLTrustStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE));\n\n        final String akkaSSLTrustStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE_PASSWORD));\n\n        final String akkaSSLCertFingerprintString =\n                configuration.getString(SecurityOptions.SSL_INTERNAL_CERT_FINGERPRINT);\n\n        final String akkaSSLCertFingerprints =\n                akkaSSLCertFingerprintString != null\n                        ? Arrays.stream(akkaSSLCertFingerprintString.split(\",\"))\n                                .collect(Collectors.joining(\"\\\",\\\"\", \"[\\\"\", \"\\\"]\"))\n                        : \"[]\";\n\n        final String akkaSSLProtocol = configuration.getString(SecurityOptions.SSL_PROTOCOL);\n\n        final String akkaSSLAlgorithmsString =\n                configuration.getString(SecurityOptions.SSL_ALGORITHMS);\n        final String akkaSSLAlgorithms =\n                Arrays.stream(akkaSSLAlgorithmsString.split(\",\"))\n                        .collect(Collectors.joining(\",\", \"[\", \"]\"));\n\n        final String sslEngineProviderName = CustomSSLEngineProvider.class.getCanonicalName();\n\n        akkaConfigBuilder\n                .add(\"akka {\")\n                .add(\"  remote.classic {\")\n                .add(\"    enabled-transports = [\\\"akka.remote.classic.netty.ssl\\\"]\")\n                .add(\"    netty {\")\n                .add(\"      ssl = ${akka.remote.classic.netty.tcp}\")\n                .add(\"      ssl {\")\n                .add(\"        enable-ssl = \" + akkaEnableSSL)\n                .add(\"        ssl-engine-provider = \" + sslEngineProviderName)\n                .add(\"        security {\")\n                .add(\"          key-store = \\\"\" + akkaSSLKeyStore + \"\\\"\")\n                .add(\"          key-store-password = \\\"\" + akkaSSLKeyStorePassword + \"\\\"\")\n                .add(\"          key-password = \\\"\" + akkaSSLKeyPassword + \"\\\"\")\n                .add(\"          trust-store = \\\"\" + akkaSSLTrustStore + \"\\\"\")\n                .add(\"          trust-store-password = \\\"\" + akkaSSLTrustStorePassword + \"\\\"\")\n                .add(\"          protocol = \" + akkaSSLProtocol + \"\")\n                .add(\"          enabled-algorithms = \" + akkaSSLAlgorithms + \"\")\n                .add(\"          random-number-generator = \\\"\\\"\")\n                .add(\"          require-mutual-authentication = on\")\n                .add(\"          cert-fingerprints = \" + akkaSSLCertFingerprints + \"\")\n                .add(\"        }\")\n                .add(\"      }\")\n                .add(\"    }\")\n                .add(\"  }\")\n                .add(\"}\");\n    }",
          "conflictNames": [
              "akkaConfigBuilder",
              "configuration",
              "akkaEnableSSLConfig",
              "akkaEnableSSL",
              "akkaSSLKeyStore",
              "akkaSSLKeyStorePassword",
              "akkaSSLKeyPassword",
              "akkaSSLTrustStore",
              "akkaSSLCertFingerprintString",
              "akkaSSLCertFingerprints",
              "akkaSSLProtocol",
              "akkaSSLAlgorithmsString",
              "akkaSSLAlgorithms",
              "sslEngineProviderName"
          ]
      },
      "suggestions": [
          {
              "name": "sslTrustStorePassword",
              "confidence": 0.77
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaUtils.java",
      "locators": [
          {
              "line": 347,
              "column": 22
          },
          {
              "line": 382,
              "column": 57
          }
      ],
      "old_name": "akkaSSLCertFingerprints",
      "new_name": "sslCertFingerprints",
      "ctx": {
          "symbolName": "akkaSSLCertFingerprints",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in addSslRemoteAkkaConfig(...)",
          "filePath": "AkkaUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void addSslRemoteAkkaConfig(\n            AkkaConfigBuilder akkaConfigBuilder, Configuration configuration) {\n\n        final boolean akkaEnableSSLConfig =\n                configuration.getBoolean(AkkaOptions.SSL_ENABLED)\n                        && SecurityOptions.isInternalSSLEnabled(configuration);\n\n        final String akkaEnableSSL = booleanToOnOrOff(akkaEnableSSLConfig);\n\n        final String akkaSSLKeyStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE));\n\n        final String akkaSSLKeyStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE_PASSWORD));\n\n        final String akkaSSLKeyPassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEY_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEY_PASSWORD));\n\n        final String akkaSSLTrustStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE));\n\n        final String akkaSSLTrustStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE_PASSWORD));\n\n        final String akkaSSLCertFingerprintString =\n                configuration.getString(SecurityOptions.SSL_INTERNAL_CERT_FINGERPRINT);\n\n        final String akkaSSLCertFingerprints =\n                akkaSSLCertFingerprintString != null\n                        ? Arrays.stream(akkaSSLCertFingerprintString.split(\",\"))\n                                .collect(Collectors.joining(\"\\\",\\\"\", \"[\\\"\", \"\\\"]\"))\n                        : \"[]\";\n\n        final String akkaSSLProtocol = configuration.getString(SecurityOptions.SSL_PROTOCOL);\n\n        final String akkaSSLAlgorithmsString =\n                configuration.getString(SecurityOptions.SSL_ALGORITHMS);\n        final String akkaSSLAlgorithms =\n                Arrays.stream(akkaSSLAlgorithmsString.split(\",\"))\n                        .collect(Collectors.joining(\",\", \"[\", \"]\"));\n\n        final String sslEngineProviderName = CustomSSLEngineProvider.class.getCanonicalName();\n\n        akkaConfigBuilder\n                .add(\"akka {\")\n                .add(\"  remote.classic {\")\n                .add(\"    enabled-transports = [\\\"akka.remote.classic.netty.ssl\\\"]\")\n                .add(\"    netty {\")\n                .add(\"      ssl = ${akka.remote.classic.netty.tcp}\")\n                .add(\"      ssl {\")\n                .add(\"        enable-ssl = \" + akkaEnableSSL)\n                .add(\"        ssl-engine-provider = \" + sslEngineProviderName)\n                .add(\"        security {\")\n                .add(\"          key-store = \\\"\" + akkaSSLKeyStore + \"\\\"\")\n                .add(\"          key-store-password = \\\"\" + akkaSSLKeyStorePassword + \"\\\"\")\n                .add(\"          key-password = \\\"\" + akkaSSLKeyPassword + \"\\\"\")\n                .add(\"          trust-store = \\\"\" + akkaSSLTrustStore + \"\\\"\")\n                .add(\"          trust-store-password = \\\"\" + akkaSSLTrustStorePassword + \"\\\"\")\n                .add(\"          protocol = \" + akkaSSLProtocol + \"\")\n                .add(\"          enabled-algorithms = \" + akkaSSLAlgorithms + \"\")\n                .add(\"          random-number-generator = \\\"\\\"\")\n                .add(\"          require-mutual-authentication = on\")\n                .add(\"          cert-fingerprints = \" + akkaSSLCertFingerprints + \"\")\n                .add(\"        }\")\n                .add(\"      }\")\n                .add(\"    }\")\n                .add(\"  }\")\n                .add(\"}\");\n    }",
          "conflictNames": [
              "akkaConfigBuilder",
              "configuration",
              "akkaEnableSSLConfig",
              "akkaEnableSSL",
              "akkaSSLKeyStore",
              "akkaSSLKeyStorePassword",
              "akkaSSLKeyPassword",
              "akkaSSLTrustStore",
              "akkaSSLTrustStorePassword",
              "akkaSSLCertFingerprintString",
              "akkaSSLProtocol",
              "akkaSSLAlgorithmsString",
              "akkaSSLAlgorithms",
              "sslEngineProviderName"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaUtils.java",
      "locators": [
          {
              "line": 344,
              "column": 22
          },
          {
              "line": 348,
              "column": 17
          },
          {
              "line": 349,
              "column": 41
          }
      ],
      "old_name": "akkaSSLCertFingerprintString",
      "new_name": "sslCertFingerprintString",
      "ctx": {
          "symbolName": "akkaSSLCertFingerprintString",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in addSslRemoteAkkaConfig(...)",
          "filePath": "AkkaUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void addSslRemoteAkkaConfig(\n            AkkaConfigBuilder akkaConfigBuilder, Configuration configuration) {\n\n        final boolean akkaEnableSSLConfig =\n                configuration.getBoolean(AkkaOptions.SSL_ENABLED)\n                        && SecurityOptions.isInternalSSLEnabled(configuration);\n\n        final String akkaEnableSSL = booleanToOnOrOff(akkaEnableSSLConfig);\n\n        final String akkaSSLKeyStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE));\n\n        final String akkaSSLKeyStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE_PASSWORD));\n\n        final String akkaSSLKeyPassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEY_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEY_PASSWORD));\n\n        final String akkaSSLTrustStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE));\n\n        final String akkaSSLTrustStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE_PASSWORD));\n\n        final String akkaSSLCertFingerprintString =\n                configuration.getString(SecurityOptions.SSL_INTERNAL_CERT_FINGERPRINT);\n\n        final String akkaSSLCertFingerprints =\n                akkaSSLCertFingerprintString != null\n                        ? Arrays.stream(akkaSSLCertFingerprintString.split(\",\"))\n                                .collect(Collectors.joining(\"\\\",\\\"\", \"[\\\"\", \"\\\"]\"))\n                        : \"[]\";\n\n        final String akkaSSLProtocol = configuration.getString(SecurityOptions.SSL_PROTOCOL);\n\n        final String akkaSSLAlgorithmsString =\n                configuration.getString(SecurityOptions.SSL_ALGORITHMS);\n        final String akkaSSLAlgorithms =\n                Arrays.stream(akkaSSLAlgorithmsString.split(\",\"))\n                        .collect(Collectors.joining(\",\", \"[\", \"]\"));\n\n        final String sslEngineProviderName = CustomSSLEngineProvider.class.getCanonicalName();\n\n        akkaConfigBuilder\n                .add(\"akka {\")\n                .add(\"  remote.classic {\")\n                .add(\"    enabled-transports = [\\\"akka.remote.classic.netty.ssl\\\"]\")\n                .add(\"    netty {\")\n                .add(\"      ssl = ${akka.remote.classic.netty.tcp}\")\n                .add(\"      ssl {\")\n                .add(\"        enable-ssl = \" + akkaEnableSSL)\n                .add(\"        ssl-engine-provider = \" + sslEngineProviderName)\n                .add(\"        security {\")\n                .add(\"          key-store = \\\"\" + akkaSSLKeyStore + \"\\\"\")\n                .add(\"          key-store-password = \\\"\" + akkaSSLKeyStorePassword + \"\\\"\")\n                .add(\"          key-password = \\\"\" + akkaSSLKeyPassword + \"\\\"\")\n                .add(\"          trust-store = \\\"\" + akkaSSLTrustStore + \"\\\"\")\n                .add(\"          trust-store-password = \\\"\" + akkaSSLTrustStorePassword + \"\\\"\")\n                .add(\"          protocol = \" + akkaSSLProtocol + \"\")\n                .add(\"          enabled-algorithms = \" + akkaSSLAlgorithms + \"\")\n                .add(\"          random-number-generator = \\\"\\\"\")\n                .add(\"          require-mutual-authentication = on\")\n                .add(\"          cert-fingerprints = \" + akkaSSLCertFingerprints + \"\")\n                .add(\"        }\")\n                .add(\"      }\")\n                .add(\"    }\")\n                .add(\"  }\")\n                .add(\"}\");\n    }",
          "conflictNames": [
              "akkaConfigBuilder",
              "configuration",
              "akkaEnableSSLConfig",
              "akkaEnableSSL",
              "akkaSSLKeyStore",
              "akkaSSLKeyStorePassword",
              "akkaSSLKeyPassword",
              "akkaSSLTrustStore",
              "akkaSSLTrustStorePassword",
              "akkaSSLCertFingerprints",
              "akkaSSLProtocol",
              "akkaSSLAlgorithmsString",
              "akkaSSLAlgorithms",
              "sslEngineProviderName"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaUtils.java",
      "locators": [
          {
              "line": 355,
              "column": 22
          },
          {
              "line": 357,
              "column": 22
          },
          {
              "line": 358,
              "column": 31
          },
          {
              "line": 379,
              "column": 58
          }
      ],
      "old_name": "akkaSSLAlgorithms",
      "new_name": "sslAlgorithms",
      "ctx": {
          "symbolName": "akkaSSLAlgorithms",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in addSslRemoteAkkaConfig(...)",
          "filePath": "AkkaUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void addSslRemoteAkkaConfig(\n            AkkaConfigBuilder akkaConfigBuilder, Configuration configuration) {\n\n        final boolean akkaEnableSSLConfig =\n                configuration.getBoolean(AkkaOptions.SSL_ENABLED)\n                        && SecurityOptions.isInternalSSLEnabled(configuration);\n\n        final String akkaEnableSSL = booleanToOnOrOff(akkaEnableSSLConfig);\n\n        final String akkaSSLKeyStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE));\n\n        final String akkaSSLKeyStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE_PASSWORD));\n\n        final String akkaSSLKeyPassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEY_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEY_PASSWORD));\n\n        final String akkaSSLTrustStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE));\n\n        final String akkaSSLTrustStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE_PASSWORD));\n\n        final String akkaSSLCertFingerprintString =\n                configuration.getString(SecurityOptions.SSL_INTERNAL_CERT_FINGERPRINT);\n\n        final String akkaSSLCertFingerprints =\n                akkaSSLCertFingerprintString != null\n                        ? Arrays.stream(akkaSSLCertFingerprintString.split(\",\"))\n                                .collect(Collectors.joining(\"\\\",\\\"\", \"[\\\"\", \"\\\"]\"))\n                        : \"[]\";\n\n        final String akkaSSLProtocol = configuration.getString(SecurityOptions.SSL_PROTOCOL);\n\n        final String akkaSSLAlgorithmsString =\n                configuration.getString(SecurityOptions.SSL_ALGORITHMS);\n        final String akkaSSLAlgorithms =\n                Arrays.stream(akkaSSLAlgorithmsString.split(\",\"))\n                        .collect(Collectors.joining(\",\", \"[\", \"]\"));\n\n        final String sslEngineProviderName = CustomSSLEngineProvider.class.getCanonicalName();\n\n        akkaConfigBuilder\n                .add(\"akka {\")\n                .add(\"  remote.classic {\")\n                .add(\"    enabled-transports = [\\\"akka.remote.classic.netty.ssl\\\"]\")\n                .add(\"    netty {\")\n                .add(\"      ssl = ${akka.remote.classic.netty.tcp}\")\n                .add(\"      ssl {\")\n                .add(\"        enable-ssl = \" + akkaEnableSSL)\n                .add(\"        ssl-engine-provider = \" + sslEngineProviderName)\n                .add(\"        security {\")\n                .add(\"          key-store = \\\"\" + akkaSSLKeyStore + \"\\\"\")\n                .add(\"          key-store-password = \\\"\" + akkaSSLKeyStorePassword + \"\\\"\")\n                .add(\"          key-password = \\\"\" + akkaSSLKeyPassword + \"\\\"\")\n                .add(\"          trust-store = \\\"\" + akkaSSLTrustStore + \"\\\"\")\n                .add(\"          trust-store-password = \\\"\" + akkaSSLTrustStorePassword + \"\\\"\")\n                .add(\"          protocol = \" + akkaSSLProtocol + \"\")\n                .add(\"          enabled-algorithms = \" + akkaSSLAlgorithms + \"\")\n                .add(\"          random-number-generator = \\\"\\\"\")\n                .add(\"          require-mutual-authentication = on\")\n                .add(\"          cert-fingerprints = \" + akkaSSLCertFingerprints + \"\")\n                .add(\"        }\")\n                .add(\"      }\")\n                .add(\"    }\")\n                .add(\"  }\")\n                .add(\"}\");\n    }",
          "conflictNames": [
              "akkaConfigBuilder",
              "configuration",
              "akkaEnableSSLConfig",
              "akkaEnableSSL",
              "akkaSSLKeyStore",
              "akkaSSLKeyStorePassword",
              "akkaSSLKeyPassword",
              "akkaSSLTrustStore",
              "akkaSSLTrustStorePassword",
              "akkaSSLCertFingerprintString",
              "akkaSSLCertFingerprints",
              "akkaSSLProtocol",
              "akkaSSLAlgorithmsString",
              "sslEngineProviderName"
          ]
      },
      "suggestions": [
          {
              "name": "sslAlgorithms",
              "confidence": 0.7625
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaUtils.java",
      "locators": [
          {
              "line": 355,
              "column": 22
          },
          {
              "line": 358,
              "column": 31
          }
      ],
      "old_name": "akkaSSLAlgorithmsString",
      "new_name": "sslAlgorithmsString",
      "ctx": {
          "symbolName": "akkaSSLAlgorithmsString",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in addSslRemoteAkkaConfig(...)",
          "filePath": "AkkaUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void addSslRemoteAkkaConfig(\n            AkkaConfigBuilder akkaConfigBuilder, Configuration configuration) {\n\n        final boolean akkaEnableSSLConfig =\n                configuration.getBoolean(AkkaOptions.SSL_ENABLED)\n                        && SecurityOptions.isInternalSSLEnabled(configuration);\n\n        final String akkaEnableSSL = booleanToOnOrOff(akkaEnableSSLConfig);\n\n        final String akkaSSLKeyStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE));\n\n        final String akkaSSLKeyStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE_PASSWORD));\n\n        final String akkaSSLKeyPassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEY_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEY_PASSWORD));\n\n        final String akkaSSLTrustStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE));\n\n        final String akkaSSLTrustStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE_PASSWORD));\n\n        final String akkaSSLCertFingerprintString =\n                configuration.getString(SecurityOptions.SSL_INTERNAL_CERT_FINGERPRINT);\n\n        final String akkaSSLCertFingerprints =\n                akkaSSLCertFingerprintString != null\n                        ? Arrays.stream(akkaSSLCertFingerprintString.split(\",\"))\n                                .collect(Collectors.joining(\"\\\",\\\"\", \"[\\\"\", \"\\\"]\"))\n                        : \"[]\";\n\n        final String akkaSSLProtocol = configuration.getString(SecurityOptions.SSL_PROTOCOL);\n\n        final String akkaSSLAlgorithmsString =\n                configuration.getString(SecurityOptions.SSL_ALGORITHMS);\n        final String akkaSSLAlgorithms =\n                Arrays.stream(akkaSSLAlgorithmsString.split(\",\"))\n                        .collect(Collectors.joining(\",\", \"[\", \"]\"));\n\n        final String sslEngineProviderName = CustomSSLEngineProvider.class.getCanonicalName();\n\n        akkaConfigBuilder\n                .add(\"akka {\")\n                .add(\"  remote.classic {\")\n                .add(\"    enabled-transports = [\\\"akka.remote.classic.netty.ssl\\\"]\")\n                .add(\"    netty {\")\n                .add(\"      ssl = ${akka.remote.classic.netty.tcp}\")\n                .add(\"      ssl {\")\n                .add(\"        enable-ssl = \" + akkaEnableSSL)\n                .add(\"        ssl-engine-provider = \" + sslEngineProviderName)\n                .add(\"        security {\")\n                .add(\"          key-store = \\\"\" + akkaSSLKeyStore + \"\\\"\")\n                .add(\"          key-store-password = \\\"\" + akkaSSLKeyStorePassword + \"\\\"\")\n                .add(\"          key-password = \\\"\" + akkaSSLKeyPassword + \"\\\"\")\n                .add(\"          trust-store = \\\"\" + akkaSSLTrustStore + \"\\\"\")\n                .add(\"          trust-store-password = \\\"\" + akkaSSLTrustStorePassword + \"\\\"\")\n                .add(\"          protocol = \" + akkaSSLProtocol + \"\")\n                .add(\"          enabled-algorithms = \" + akkaSSLAlgorithms + \"\")\n                .add(\"          random-number-generator = \\\"\\\"\")\n                .add(\"          require-mutual-authentication = on\")\n                .add(\"          cert-fingerprints = \" + akkaSSLCertFingerprints + \"\")\n                .add(\"        }\")\n                .add(\"      }\")\n                .add(\"    }\")\n                .add(\"  }\")\n                .add(\"}\");\n    }",
          "conflictNames": [
              "akkaConfigBuilder",
              "configuration",
              "akkaEnableSSLConfig",
              "akkaEnableSSL",
              "akkaSSLKeyStore",
              "akkaSSLKeyStorePassword",
              "akkaSSLKeyPassword",
              "akkaSSLTrustStore",
              "akkaSSLTrustStorePassword",
              "akkaSSLCertFingerprintString",
              "akkaSSLCertFingerprints",
              "akkaSSLProtocol",
              "akkaSSLAlgorithms",
              "sslEngineProviderName"
          ]
      },
      "suggestions": [
          {
              "name": "sslAlgorithmsString",
              "confidence": 0.7625
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaUtils.java",
      "locators": [
          {
              "line": 353,
              "column": 22
          },
          {
              "line": 378,
              "column": 48
          }
      ],
      "old_name": "akkaSSLProtocol",
      "new_name": "sslProtocol",
      "ctx": {
          "symbolName": "akkaSSLProtocol",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in addSslRemoteAkkaConfig(...)",
          "filePath": "AkkaUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void addSslRemoteAkkaConfig(\n            AkkaConfigBuilder akkaConfigBuilder, Configuration configuration) {\n\n        final boolean akkaEnableSSLConfig =\n                configuration.getBoolean(AkkaOptions.SSL_ENABLED)\n                        && SecurityOptions.isInternalSSLEnabled(configuration);\n\n        final String akkaEnableSSL = booleanToOnOrOff(akkaEnableSSLConfig);\n\n        final String akkaSSLKeyStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE));\n\n        final String akkaSSLKeyStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEYSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEYSTORE_PASSWORD));\n\n        final String akkaSSLKeyPassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_KEY_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_KEY_PASSWORD));\n\n        final String akkaSSLTrustStore =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE));\n\n        final String akkaSSLTrustStorePassword =\n                configuration.getString(\n                        SecurityOptions.SSL_INTERNAL_TRUSTSTORE_PASSWORD,\n                        configuration.getString(SecurityOptions.SSL_TRUSTSTORE_PASSWORD));\n\n        final String akkaSSLCertFingerprintString =\n                configuration.getString(SecurityOptions.SSL_INTERNAL_CERT_FINGERPRINT);\n\n        final String akkaSSLCertFingerprints =\n                akkaSSLCertFingerprintString != null\n                        ? Arrays.stream(akkaSSLCertFingerprintString.split(\",\"))\n                                .collect(Collectors.joining(\"\\\",\\\"\", \"[\\\"\", \"\\\"]\"))\n                        : \"[]\";\n\n        final String akkaSSLProtocol = configuration.getString(SecurityOptions.SSL_PROTOCOL);\n\n        final String akkaSSLAlgorithmsString =\n                configuration.getString(SecurityOptions.SSL_ALGORITHMS);\n        final String akkaSSLAlgorithms =\n                Arrays.stream(akkaSSLAlgorithmsString.split(\",\"))\n                        .collect(Collectors.joining(\",\", \"[\", \"]\"));\n\n        final String sslEngineProviderName = CustomSSLEngineProvider.class.getCanonicalName();\n\n        akkaConfigBuilder\n                .add(\"akka {\")\n                .add(\"  remote.classic {\")\n                .add(\"    enabled-transports = [\\\"akka.remote.classic.netty.ssl\\\"]\")\n                .add(\"    netty {\")\n                .add(\"      ssl = ${akka.remote.classic.netty.tcp}\")\n                .add(\"      ssl {\")\n                .add(\"        enable-ssl = \" + akkaEnableSSL)\n                .add(\"        ssl-engine-provider = \" + sslEngineProviderName)\n                .add(\"        security {\")\n                .add(\"          key-store = \\\"\" + akkaSSLKeyStore + \"\\\"\")\n                .add(\"          key-store-password = \\\"\" + akkaSSLKeyStorePassword + \"\\\"\")\n                .add(\"          key-password = \\\"\" + akkaSSLKeyPassword + \"\\\"\")\n                .add(\"          trust-store = \\\"\" + akkaSSLTrustStore + \"\\\"\")\n                .add(\"          trust-store-password = \\\"\" + akkaSSLTrustStorePassword + \"\\\"\")\n                .add(\"          protocol = \" + akkaSSLProtocol + \"\")\n                .add(\"          enabled-algorithms = \" + akkaSSLAlgorithms + \"\")\n                .add(\"          random-number-generator = \\\"\\\"\")\n                .add(\"          require-mutual-authentication = on\")\n                .add(\"          cert-fingerprints = \" + akkaSSLCertFingerprints + \"\")\n                .add(\"        }\")\n                .add(\"      }\")\n                .add(\"    }\")\n                .add(\"  }\")\n                .add(\"}\");\n    }",
          "conflictNames": [
              "akkaConfigBuilder",
              "configuration",
              "akkaEnableSSLConfig",
              "akkaEnableSSL",
              "akkaSSLKeyStore",
              "akkaSSLKeyStorePassword",
              "akkaSSLKeyPassword",
              "akkaSSLTrustStore",
              "akkaSSLTrustStorePassword",
              "akkaSSLCertFingerprintString",
              "akkaSSLCertFingerprints",
              "akkaSSLAlgorithmsString",
              "akkaSSLAlgorithms",
              "sslEngineProviderName"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/test/java/org/apache/flink/runtime/rpc/akka/AkkaUtilsTest.java",
      "locators": [
          {
              "line": 48,
              "column": 22
          },
          {
              "line": 56,
              "column": 84
          }
      ],
      "old_name": "remoteAkkaUrl",
      "new_name": "remoteRpcURL",
      "ctx": {
          "symbolName": "remoteAkkaUrl",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in getHostFromAkkaURLForRemoteAkkaURL(...)",
          "filePath": "AkkaUtilsTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void getHostFromAkkaURLForRemoteAkkaURL() throws Exception {\n        final String host = \"127.0.0.1\";\n        final int port = 1234;\n\n        final InetSocketAddress address = new InetSocketAddress(host, port);\n\n        final String remoteAkkaUrl =\n                AkkaRpcServiceUtils.getRpcUrl(\n                        host,\n                        port,\n                        \"actor\",\n                        AddressResolution.NO_ADDRESS_RESOLUTION,\n                        AkkaRpcServiceUtils.AkkaProtocol.TCP);\n\n        final InetSocketAddress result = AkkaUtils.getInetSocketAddressFromAkkaURL(remoteAkkaUrl);\n\n        assertThat(result).isEqualTo(address);\n    }",
          "conflictNames": [
              "host",
              "port",
              "address",
              "result"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/test/java/org/apache/flink/runtime/rpc/akka/AkkaUtilsTest.java",
      "locators": [
          {
              "line": 63,
              "column": 22
          },
          {
              "line": 65,
              "column": 76
          }
      ],
      "old_name": "localAkkaURL",
      "new_name": "localRpcURL",
      "ctx": {
          "symbolName": "localAkkaURL",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in getHostFromAkkaURLThrowsExceptionIfAddressCannotBeRetrieved(...)",
          "filePath": "AkkaUtilsTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void getHostFromAkkaURLThrowsExceptionIfAddressCannotBeRetrieved() throws Exception {\n        final String localAkkaURL = \"akka://flink/user/actor\";\n\n        assertThatThrownBy(() -> AkkaUtils.getInetSocketAddressFromAkkaURL(localAkkaURL))\n                .isInstanceOf(Exception.class);\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c8ae39d4ac73f81873e1d8ac37e17c29ae330b23^1/flink-rpc/flink-rpc-akka/src/test/java/org/apache/flink/runtime/rpc/akka/AkkaUtilsTest.java",
      "locators": [
          {
              "line": 154,
              "column": 22
          },
          {
              "line": 157,
              "column": 20
          },
          {
              "line": 163,
              "column": 22
          },
          {
              "line": 166,
              "column": 33
          },
          {
              "line": 173,
              "column": 22
          },
          {
              "line": 175,
              "column": 20
          },
          {
              "line": 185,
              "column": 22
          },
          {
              "line": 194,
              "column": 20
          },
          {
              "line": 196,
              "column": 20
          },
          {
              "line": 199,
              "column": 25
          },
          {
              "line": 203,
              "column": 25
          },
          {
              "line": 211,
              "column": 22
          },
          {
              "line": 215,
              "column": 20
          },
          {
              "line": 224,
              "column": 22
          },
          {
              "line": 227,
              "column": 20
          },
          {
              "line": 235,
              "column": 22
          },
          {
              "line": 237,
              "column": 34
          },
          {
              "line": 252,
              "column": 22
          },
          {
              "line": 254,
              "column": 34
          }
      ],
      "old_name": "akkaConfig",
      "new_name": "config",
      "ctx": {
          "symbolName": "akkaConfig",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Config",
          "scopeHint": "in getAkkaConfigNormalizesHostName(...)",
          "filePath": "AkkaUtilsTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void getAkkaConfigNormalizesHostName() {\n        final Configuration configuration = new Configuration();\n        final String hostname = \"AbC123foOBaR\";\n        final int port = 1234;\n\n        final Config akkaConfig =\n                AkkaUtils.getAkkaConfig(configuration, new HostAndPort(hostname, port));\n\n        assertThat(akkaConfig.getString(\"akka.remote.classic.netty.tcp.hostname\"))\n                .isEqualTo(NetUtils.unresolvedHostToNormalizedString(hostname));\n    }",
          "conflictNames": [
              "configuration",
              "hostname",
              "port"
          ]
      },
      "suggestions": [
          {
              "name": "config",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/c91500423151bae2c6cb75f9652dd9abf918982c^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/operations/SqlNodeToOperationConversion.java",
      "locators": [
          {
              "line": 1116,
              "column": 27
          },
          {
              "line": 1130,
              "column": 25
          }
      ],
      "old_name": "fieldList",
      "new_name": "viewFields",
      "ctx": {
          "symbolName": "fieldList",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SqlNodeList",
          "scopeHint": "in convertCreateView(...)",
          "filePath": "SqlNodeToOperationConversion.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Convert CREATE VIEW statement. */\n    private Operation convertCreateView(SqlCreateView sqlCreateView) {\n        final SqlNode query = sqlCreateView.getQuery();\n        final SqlNodeList fieldList = sqlCreateView.getFieldList();\n\n        UnresolvedIdentifier unresolvedIdentifier =\n                UnresolvedIdentifier.of(sqlCreateView.fullViewName());\n        ObjectIdentifier identifier = catalogManager.qualifyIdentifier(unresolvedIdentifier);\n\n        String comment =\n                sqlCreateView\n                        .getComment()\n                        .map(c -> c.getValueAs(NlsString.class).getValue())\n                        .orElse(null);\n        CatalogView catalogView =\n                convertViewQuery(\n                        query,\n                        fieldList.getList(),\n                        OperationConverterUtils.extractProperties(\n                                sqlCreateView.getProperties().orElse(null)),\n                        comment);\n        return new CreateViewOperation(\n                identifier,\n                catalogView,\n                sqlCreateView.isIfNotExists(),\n                sqlCreateView.isTemporary());\n    }",
          "conflictNames": [
              "sqlCreateView",
              "query",
              "unresolvedIdentifier",
              "identifier",
              "comment",
              "catalogView"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c942d0f61a044a327f5393f3752e04ee489d7d4a^1/flink-table/flink-table-planner/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java",
      "locators": [
          {
              "line": 2324,
              "column": 31
          },
          {
              "line": 2336,
              "column": 34
          },
          {
              "line": 2349,
              "column": 21
          }
      ],
      "old_name": "needAlias",
      "new_name": "needAliasNamespace",
      "ctx": {
          "symbolName": "needAlias",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "boolean",
          "scopeHint": "in registerFrom(...)",
          "filePath": "SqlValidatorImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Registers scopes and namespaces implied a relational expression in the FROM clause.\n     *\n     * <p>{@code parentScope} and {@code usingScope} are often the same. They differ when the\n     * namespace are not visible within the parent. (Example needed.)\n     *\n     * <p>Likewise, {@code enclosingNode} and {@code node} are often the same. {@code enclosingNode}\n     * is the topmost node within the FROM clause, from which any decorations like an alias (<code>\n     * AS alias</code>) or a table sample clause are stripped away to get {@code node}. Both are\n     * recorded in the namespace.\n     *\n     * @param parentScope Parent scope which this scope turns to in order to resolve objects\n     * @param usingScope Scope whose child list this scope should add itself to\n     * @param register Whether to register this scope as a child of {@code usingScope}\n     * @param node Node which namespace is based on\n     * @param enclosingNode Outermost node for namespace, including decorations such as alias and\n     *     sample clause\n     * @param alias Alias\n     * @param extendList Definitions of extended columns\n     * @param forceNullable Whether to force the type of namespace to be nullable because it is in\n     *     an outer join\n     * @param lateral Whether LATERAL is specified, so that items to the left of this in the JOIN\n     *     tree are visible in the scope\n     * @return registered node, usually the same as {@code node}\n     */\n    private SqlNode registerFrom(\n            SqlValidatorScope parentScope,\n            SqlValidatorScope usingScope,\n            boolean register,\n            final SqlNode node,\n            SqlNode enclosingNode,\n            @Nullable String alias,\n            @Nullable SqlNodeList extendList,\n            boolean forceNullable,\n            final boolean lateral) {\n        final SqlKind kind = node.getKind();\n\n        SqlNode expr;\n        SqlNode newExpr;\n\n        // Add an alias if necessary.\n        SqlNode newNode = node;\n        if (alias == null) {\n            switch (kind) {\n                case IDENTIFIER:\n                case OVER:\n                    alias = deriveAlias(node, -1);\n                    if (alias == null) {\n                        alias = deriveAliasNonNull(node, nextGeneratedId++);\n                    }\n                    if (config.identifierExpansion()) {\n                        newNode = SqlValidatorUtil.addAlias(node, alias);\n                    }\n                    break;\n\n                case SELECT:\n                case UNION:\n                case INTERSECT:\n                case EXCEPT:\n                case VALUES:\n                case UNNEST:\n                case OTHER_FUNCTION:\n                case COLLECTION_TABLE:\n                case PIVOT:\n                case UNPIVOT:\n                case MATCH_RECOGNIZE:\n\n                    // give this anonymous construct a name since later\n                    // query processing stages rely on it\n                    alias = deriveAliasNonNull(node, nextGeneratedId++);\n                    if (config.identifierExpansion()) {\n                        // Since we're expanding identifiers, we should make the\n                        // aliases explicit too, otherwise the expanded query\n                        // will not be consistent if we convert back to SQL, e.g.\n                        // \"select EXPR$1.EXPR$2 from values (1)\".\n                        newNode = SqlValidatorUtil.addAlias(node, alias);\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        if (lateral) {\n            SqlValidatorScope s = usingScope;\n            while (s instanceof JoinScope) {\n                s = ((JoinScope) s).getUsingScope();\n            }\n            final SqlNode node2 = s != null ? s.getNode() : node;\n            final TableScope tableScope = new TableScope(parentScope, node2);\n            if (usingScope instanceof ListScope) {\n                for (ScopeChild child : ((ListScope) usingScope).children) {\n                    tableScope.addChild(child.namespace, child.name, child.nullable);\n                }\n            }\n            parentScope = tableScope;\n        }\n\n        SqlCall call;\n        SqlNode operand;\n        SqlNode newOperand;\n\n        switch (kind) {\n            case AS:\n                call = (SqlCall) node;\n                if (alias == null) {\n                    alias = String.valueOf(call.operand(1));\n                }\n                expr = call.operand(0);\n                final boolean needAlias =\n                        call.operandCount() > 2\n                                || expr.getKind() == SqlKind.VALUES\n                                || expr.getKind() == SqlKind.UNNEST\n                                        && (((SqlCall) expr).operand(0).getKind()\n                                                        == SqlKind.ARRAY_VALUE_CONSTRUCTOR\n                                                || ((SqlCall) expr).operand(0).getKind()\n                                                        == SqlKind.MULTISET_VALUE_CONSTRUCTOR);\n                newExpr =\n                        registerFrom(\n                                parentScope,\n                                usingScope,\n                                !needAlias,\n                                expr,\n                                enclosingNode,\n                                alias,\n                                extendList,\n                                forceNullable,\n                                lateral);\n                if (newExpr != expr) {\n                    call.setOperand(0, newExpr);\n                }\n\n                // If alias has a column list, introduce a namespace to translate\n                // column names. We skipped registering it just now.\n                if (needAlias) {\n                    registerNamespace(\n                            usingScope,\n                            alias,\n                            new AliasNamespace(this, call, enclosingNode),\n                            forceNullable);\n                }\n                return node;\n\n            case MATCH_RECOGNIZE:\n                registerMatchRecognize(\n                        parentScope,\n                        usingScope,\n                        (SqlMatchRecognize) node,\n                        enclosingNode,\n                        alias,\n                        forceNullable);\n                return node;\n\n            case PIVOT:\n                registerPivot(\n                        parentScope,\n                        usingScope,\n                        (SqlPivot) node,\n                        enclosingNode,\n                        alias,\n                        forceNullable);\n                return node;\n\n            case UNPIVOT:\n                registerUnpivot(\n                        parentScope,\n                        usingScope,\n                        (SqlUnpivot) node,\n                        enclosingNode,\n                        alias,\n                        forceNullable);\n                return node;\n\n            case TABLESAMPLE:\n                call = (SqlCall) node;\n                expr = call.operand(0);\n                newExpr =\n                        registerFrom(\n                                parentScope,\n                                usingScope,\n                                true,\n                                expr,\n                                enclosingNode,\n                                alias,\n                                extendList,\n                                forceNullable,\n                                lateral);\n                if (newExpr != expr) {\n                    call.setOperand(0, newExpr);\n                }\n                return node;\n\n            case JOIN:\n                final SqlJoin join = (SqlJoin) node;\n                final JoinScope joinScope = new JoinScope(parentScope, usingScope, join);\n                scopes.put(join, joinScope);\n                final SqlNode left = join.getLeft();\n                final SqlNode right = join.getRight();\n                boolean forceLeftNullable = forceNullable;\n                boolean forceRightNullable = forceNullable;\n                switch (join.getJoinType()) {\n                    case LEFT:\n                        forceRightNullable = true;\n                        break;\n                    case RIGHT:\n                        forceLeftNullable = true;\n                        break;\n                    case FULL:\n                        forceLeftNullable = true;\n                        forceRightNullable = true;\n                        break;\n                    default:\n                        break;\n                }\n                final SqlNode newLeft =\n                        registerFrom(\n                                parentScope,\n                                joinScope,\n                                true,\n                                left,\n                                left,\n                                null,\n                                null,\n                                forceLeftNullable,\n                                lateral);\n                if (newLeft != left) {\n                    join.setLeft(newLeft);\n                }\n                final SqlNode newRight =\n                        registerFrom(\n                                parentScope,\n                                joinScope,\n                                true,\n                                right,\n                                right,\n                                null,\n                                null,\n                                forceRightNullable,\n                                lateral);\n                if (newRight != right) {\n                    join.setRight(newRight);\n                }\n                registerSubQueries(joinScope, join.getCondition());\n                final JoinNamespace joinNamespace = new JoinNamespace(this, join);\n                registerNamespace(null, null, joinNamespace, forceNullable);\n                return join;\n\n            case IDENTIFIER:\n                final SqlIdentifier id = (SqlIdentifier) node;\n                final IdentifierNamespace newNs =\n                        new IdentifierNamespace(this, id, extendList, enclosingNode, parentScope);\n                registerNamespace(register ? usingScope : null, alias, newNs, forceNullable);\n                if (tableScope == null) {\n                    tableScope = new TableScope(parentScope, node);\n                }\n                tableScope.addChild(newNs, requireNonNull(alias, \"alias\"), forceNullable);\n                if (extendList != null && extendList.size() != 0) {\n                    return enclosingNode;\n                }\n                return newNode;\n\n            case LATERAL:\n                return registerFrom(\n                        parentScope,\n                        usingScope,\n                        register,\n                        ((SqlCall) node).operand(0),\n                        enclosingNode,\n                        alias,\n                        extendList,\n                        forceNullable,\n                        true);\n\n            case COLLECTION_TABLE:\n                call = (SqlCall) node;\n                operand = call.operand(0);\n                newOperand =\n                        registerFrom(\n                                parentScope,\n                                usingScope,\n                                register,\n                                operand,\n                                enclosingNode,\n                                alias,\n                                extendList,\n                                forceNullable,\n                                lateral);\n                if (newOperand != operand) {\n                    call.setOperand(0, newOperand);\n                }\n                // If the operator is SqlWindowTableFunction, restricts the scope as\n                // its first operand's (the table) scope.\n                if (operand instanceof SqlBasicCall) {\n                    final SqlBasicCall call1 = (SqlBasicCall) operand;\n                    final SqlOperator op = call1.getOperator();\n                    if (op instanceof SqlWindowTableFunction\n                            && call1.operand(0).getKind() == SqlKind.SELECT) {\n                        scopes.put(node, getSelectScope(call1.operand(0)));\n                        return newNode;\n                    }\n                }\n                // Put the usingScope which can be a JoinScope\n                // or a SelectScope, in order to see the left items\n                // of the JOIN tree.\n                scopes.put(node, usingScope);\n                return newNode;\n\n            case UNNEST:\n                if (!lateral) {\n                    return registerFrom(\n                            parentScope,\n                            usingScope,\n                            register,\n                            node,\n                            enclosingNode,\n                            alias,\n                            extendList,\n                            forceNullable,\n                            true);\n                }\n                // fall through\n            case SELECT:\n            case UNION:\n            case INTERSECT:\n            case EXCEPT:\n            case VALUES:\n            case WITH:\n            case OTHER_FUNCTION:\n                if (alias == null) {\n                    alias = deriveAliasNonNull(node, nextGeneratedId++);\n                }\n                registerQuery(\n                        parentScope,\n                        register ? usingScope : null,\n                        node,\n                        enclosingNode,\n                        alias,\n                        forceNullable);\n                return newNode;\n\n            case OVER:\n                if (!shouldAllowOverRelation()) {\n                    throw Util.unexpected(kind);\n                }\n                call = (SqlCall) node;\n                final OverScope overScope = new OverScope(usingScope, call);\n                scopes.put(call, overScope);\n                operand = call.operand(0);\n                newOperand =\n                        registerFrom(\n                                parentScope,\n                                overScope,\n                                true,\n                                operand,\n                                enclosingNode,\n                                alias,\n                                extendList,\n                                forceNullable,\n                                lateral);\n                if (newOperand != operand) {\n                    call.setOperand(0, newOperand);\n                }\n\n                for (ScopeChild child : overScope.children) {\n                    registerNamespace(\n                            register ? usingScope : null,\n                            child.name,\n                            child.namespace,\n                            forceNullable);\n                }\n\n                return newNode;\n\n            case TABLE_REF:\n                call = (SqlCall) node;\n                registerFrom(\n                        parentScope,\n                        usingScope,\n                        register,\n                        call.operand(0),\n                        enclosingNode,\n                        alias,\n                        extendList,\n                        forceNullable,\n                        lateral);\n                if (extendList != null && extendList.size() != 0) {\n                    return enclosingNode;\n                }\n                return newNode;\n\n            case EXTEND:\n                final SqlCall extend = (SqlCall) node;\n                return registerFrom(\n                        parentScope,\n                        usingScope,\n                        true,\n                        extend.getOperandList().get(0),\n                        extend,\n                        alias,\n                        (SqlNodeList) extend.getOperandList().get(1),\n                        forceNullable,\n                        lateral);\n\n            case SNAPSHOT:\n                call = (SqlCall) node;\n                operand = call.operand(0);\n                newOperand =\n                        registerFrom(\n                                parentScope,\n                                usingScope,\n                                register,\n                                operand,\n                                enclosingNode,\n                                alias,\n                                extendList,\n                                forceNullable,\n                                lateral);\n                if (newOperand != operand) {\n                    call.setOperand(0, newOperand);\n                }\n                // Put the usingScope which can be a JoinScope\n                // or a SelectScope, in order to see the left items\n                // of the JOIN tree.\n                scopes.put(node, usingScope);\n                return newNode;\n\n            default:\n                throw Util.unexpected(kind);\n        }\n    }",
          "conflictNames": [
              "parentScope",
              "usingScope",
              "register",
              "node",
              "enclosingNode",
              "alias",
              "extendList",
              "forceNullable",
              "lateral",
              "kind",
              "expr",
              "newExpr",
              "newNode",
              "s",
              "node2",
              "tableScope",
              "call",
              "operand",
              "newOperand",
              "join",
              "joinScope",
              "left",
              "right",
              "forceLeftNullable",
              "forceRightNullable",
              "newLeft",
              "newRight",
              "joinNamespace",
              "id",
              "newNs",
              "call1",
              "op",
              "overScope",
              "extend"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c9e87fe410c42f7e7c19c81456d4212a58564f5e^1/flink-table/flink-sql-gateway/src/main/java/org/apache/flink/table/gateway/service/session/SessionManager.java",
      "locators": [
          {
              "line": 86,
              "column": 51
          },
          {
              "line": 89,
              "column": 90
          },
          {
              "line": 144,
              "column": 23
          },
          {
              "line": 146,
              "column": 13
          },
          {
              "line": 147,
              "column": 39
          },
          {
              "line": 151,
              "column": 41
          },
          {
              "line": 154,
              "column": 22
          },
          {
              "line": 164,
              "column": 44
          },
          {
              "line": 165,
              "column": 38
          },
          {
              "line": 196,
              "column": 23
          },
          {
              "line": 197,
              "column": 25
          },
          {
              "line": 199,
              "column": 44
          },
          {
              "line": 203,
              "column": 49
          },
          {
              "line": 204,
              "column": 37
          }
      ],
      "old_name": "sessionId",
      "new_name": "sessionHandle",
      "ctx": {
          "symbolName": "sessionId",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SessionHandle",
          "scopeHint": "in start(...)",
          "filePath": "SessionManager.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public void start() {\n        if (checkInterval > 0 && idleTimeout > 0) {\n            scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();\n            timeoutCheckerFuture =\n                    scheduledExecutorService.scheduleAtFixedRate(\n                            () -> {\n                                LOG.debug(\n                                        \"Start to cleanup expired sessions, current session count: {}\",\n                                        sessions.size());\n                                for (Map.Entry<SessionHandle, Session> entry :\n                                        sessions.entrySet()) {\n                                    SessionHandle sessionId = entry.getKey();\n                                    Session session = entry.getValue();\n                                    if (isSessionExpired(session)) {\n                                        LOG.info(\"Session {} is expired, closing it...\", sessionId);\n                                        closeSession(session);\n                                    }\n                                }\n                                LOG.debug(\n                                        \"Removing expired session finished, current session count: {}\",\n                                        sessions.size());\n                            },\n                            checkInterval,\n                            checkInterval,\n                            TimeUnit.MILLISECONDS);\n        }\n\n        ReadableConfig conf = defaultContext.getFlinkConfig();\n        operationExecutorService =\n                ThreadUtils.newThreadPool(\n                        conf.get(SQL_GATEWAY_WORKER_THREADS_MIN),\n                        conf.get(SQL_GATEWAY_WORKER_THREADS_MAX),\n                        conf.get(SQL_GATEWAY_WORKER_KEEPALIVE_TIME).toMillis(),\n                        OPERATION_POOL_NAME);\n    }",
          "conflictNames": [
              "session",
              "conf"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/c9f1e89b48569aec092048b9db01cc2335c929d5^1/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/PendingCheckpointTest.java",
      "locators": [
          {
              "line": 118,
              "column": 20
          },
          {
              "line": 132,
              "column": 27
          },
          {
              "line": 133,
              "column": 21
          },
          {
              "line": 136,
              "column": 19
          },
          {
              "line": 153,
              "column": 9
          },
          {
              "line": 154,
              "column": 21
          },
          {
              "line": 162,
              "column": 27
          },
          {
              "line": 163,
              "column": 21
          },
          {
              "line": 166,
              "column": 19
          },
          {
              "line": 191,
              "column": 27
          },
          {
              "line": 192,
              "column": 57
          },
          {
              "line": 195,
              "column": 15
          },
          {
              "line": 199,
              "column": 9
          },
          {
              "line": 200,
              "column": 18
          },
          {
              "line": 203,
              "column": 15
          },
          {
              "line": 207,
              "column": 9
          },
          {
              "line": 208,
              "column": 18
          },
          {
              "line": 211,
              "column": 15
          },
          {
              "line": 215,
              "column": 9
          },
          {
              "line": 216,
              "column": 18
          },
          {
              "line": 219,
              "column": 9
          },
          {
              "line": 220,
              "column": 20
          },
          {
              "line": 221,
              "column": 9
          },
          {
              "line": 225,
              "column": 9
          },
          {
              "line": 226,
              "column": 18
          },
          {
              "line": 230,
              "column": 13
          },
          {
              "line": 250,
              "column": 27
          },
          {
              "line": 251,
              "column": 22
          },
          {
              "line": 253,
              "column": 15
          },
          {
              "line": 261,
              "column": 9
          },
          {
              "line": 262,
              "column": 22
          },
          {
              "line": 264,
              "column": 15
          },
          {
              "line": 272,
              "column": 9
          },
          {
              "line": 273,
              "column": 22
          },
          {
              "line": 275,
              "column": 15
          },
          {
              "line": 283,
              "column": 9
          },
          {
              "line": 284,
              "column": 22
          },
          {
              "line": 286,
              "column": 15
          },
          {
              "line": 300,
              "column": 27
          },
          {
              "line": 304,
              "column": 9
          },
          {
              "line": 308,
              "column": 71
          },
          {
              "line": 320,
              "column": 27
          },
          {
              "line": 324,
              "column": 9
          },
          {
              "line": 326,
              "column": 28
          },
          {
              "line": 340,
              "column": 27
          },
          {
              "line": 343,
              "column": 20
          },
          {
              "line": 344,
              "column": 15
          },
          {
              "line": 354,
              "column": 33
          },
          {
              "line": 368,
              "column": 9
          },
          {
              "line": 369,
              "column": 20
          },
          {
              "line": 370,
              "column": 21
          },
          {
              "line": 372,
              "column": 9
          },
          {
              "line": 373,
              "column": 20
          },
          {
              "line": 375,
              "column": 54
          },
          {
              "line": 397,
              "column": 33
          },
          {
              "line": 411,
              "column": 9
          },
          {
              "line": 412,
              "column": 21
          },
          {
              "line": 421,
              "column": 9
          },
          {
              "line": 422,
              "column": 20
          },
          {
              "line": 423,
              "column": 21
          },
          {
              "line": 425,
              "column": 9
          },
          {
              "line": 426,
              "column": 20
          },
          {
              "line": 428,
              "column": 54
          },
          {
              "line": 638,
              "column": 27
          },
          {
              "line": 650,
              "column": 9
          },
          {
              "line": 651,
              "column": 16
          },
          {
              "line": 655,
              "column": 48
          },
          {
              "line": 660,
              "column": 60
          }
      ],
      "old_name": "pending",
      "new_name": "pendingCheckpoint",
      "ctx": {
          "symbolName": "pending",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "PendingCheckpoint",
          "scopeHint": "in testCanBeSubsumed(...)",
          "filePath": "PendingCheckpointTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Tests that pending checkpoints can be subsumed iff they are forced. */\n    @Test\n    public void testCanBeSubsumed() throws Exception {\n        // Forced checkpoints cannot be subsumed\n        CheckpointProperties forced =\n                new CheckpointProperties(\n                        true,\n                        SavepointType.savepoint(SavepointFormatType.CANONICAL),\n                        false,\n                        false,\n                        false,\n                        false,\n                        false,\n                        false);\n        PendingCheckpoint pending = createPendingCheckpoint(forced);\n        assertFalse(pending.canBeSubsumed());\n\n        try {\n            abort(pending, CheckpointFailureReason.CHECKPOINT_SUBSUMED);\n            fail(\"Did not throw expected Exception\");\n        } catch (IllegalStateException ignored) {\n            // Expected\n        }\n\n        // Non-forced checkpoints can be subsumed\n        CheckpointProperties subsumed =\n                new CheckpointProperties(\n                        false,\n                        SavepointType.savepoint(SavepointFormatType.CANONICAL),\n                        false,\n                        false,\n                        false,\n                        false,\n                        false,\n                        false);\n        pending = createPendingCheckpoint(subsumed);\n        assertFalse(pending.canBeSubsumed());\n    }",
          "conflictNames": [
              "forced",
              "subsumed"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ca8f5cf93c6bf755d1cd253b89ce7fb4051811b1^1/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionVertex.java",
      "locators": [
          {
              "line": 483,
              "column": 43
          },
          {
              "line": 490,
              "column": 21
          },
          {
              "line": 491,
              "column": 21
          },
          {
              "line": 494,
              "column": 17
          },
          {
              "line": 498,
              "column": 13
          },
          {
              "line": 501,
              "column": 20
          }
      ],
      "old_name": "finishedBlockingPartitions",
      "new_name": "finishedPartitions",
      "ctx": {
          "symbolName": "finishedBlockingPartitions",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<IntermediateResultPartition>",
          "scopeHint": "in finishAllBlockingPartitions(...)",
          "filePath": "ExecutionVertex.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Returns all blocking result partitions whose receivers can be scheduled/updated. */\n    @VisibleForTesting\n    public List<IntermediateResultPartition> finishAllBlockingPartitions() {\n        List<IntermediateResultPartition> finishedBlockingPartitions = null;\n\n        for (IntermediateResultPartition partition : resultPartitions.values()) {\n            if (!partition.getResultType().canBePipelinedConsumed()) {\n\n                partition.markFinished();\n\n                if (finishedBlockingPartitions == null) {\n                    finishedBlockingPartitions = new LinkedList<>();\n                }\n\n                finishedBlockingPartitions.add(partition);\n            }\n        }\n\n        if (finishedBlockingPartitions == null) {\n            return Collections.emptyList();\n        } else {\n            return finishedBlockingPartitions;\n        }\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/caa032236979bdd53cdbf78ff05cceb6ec2f4d93^1/flink-runtime/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java",
      "locators": [
          {
              "line": 684,
              "column": 30
          },
          {
              "line": 699,
              "column": 21
          },
          {
              "line": 724,
              "column": 44
          },
          {
              "line": 767,
              "column": 68
          },
          {
              "line": 774,
              "column": 59
          },
          {
              "line": 1197,
              "column": 30
          },
          {
              "line": 1200,
              "column": 32
          },
          {
              "line": 1212,
              "column": 53
          },
          {
              "line": 1237,
              "column": 28
          },
          {
              "line": 1244,
              "column": 29
          },
          {
              "line": 1378,
              "column": 65
          },
          {
              "line": 1392,
              "column": 32
          }
      ],
      "old_name": "nonChainableOutputs",
      "new_name": "operatorInfo",
      "ctx": {
          "symbolName": "nonChainableOutputs",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<StreamEdge>",
          "scopeHint": "in createChain(...)",
          "filePath": "StreamingJobGraphGenerator.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private List<StreamEdge> createChain(\n            final Integer currentNodeId,\n            final int chainIndex,\n            final OperatorChainInfo chainInfo,\n            final Map<Integer, OperatorChainInfo> chainEntryPoints) {\n\n        Integer startNodeId = chainInfo.getStartNodeId();\n        if (!builtVertices.contains(startNodeId)) {\n\n            List<StreamEdge> transitiveOutEdges = new ArrayList<StreamEdge>();\n\n            List<StreamEdge> chainableOutputs = new ArrayList<StreamEdge>();\n            List<StreamEdge> nonChainableOutputs = new ArrayList<StreamEdge>();\n\n            StreamNode currentNode = streamGraph.getStreamNode(currentNodeId);\n            Attribute currentNodeAttribute = currentNode.getAttribute();\n            boolean isNoOutputUntilEndOfInput =\n                    currentNode.isOutputOnlyAfterEndOfStream()\n                            || currentNodeAttribute.isNoOutputUntilEndOfInput();\n            if (isNoOutputUntilEndOfInput) {\n                currentNodeAttribute.setNoOutputUntilEndOfInput(true);\n            }\n\n            for (StreamEdge outEdge : currentNode.getOutEdges()) {\n                if (isChainable(outEdge, streamGraph)) {\n                    chainableOutputs.add(outEdge);\n                } else {\n                    nonChainableOutputs.add(outEdge);\n                }\n            }\n\n            for (StreamEdge chainable : chainableOutputs) {\n                StreamNode targetNode = streamGraph.getStreamNode(chainable.getTargetId());\n                Attribute targetNodeAttribute = targetNode.getAttribute();\n                if (isNoOutputUntilEndOfInput) {\n                    if (targetNodeAttribute != null) {\n                        targetNodeAttribute.setNoOutputUntilEndOfInput(true);\n                    }\n                }\n                transitiveOutEdges.addAll(\n                        createChain(\n                                chainable.getTargetId(),\n                                chainIndex + 1,\n                                chainInfo,\n                                chainEntryPoints));\n                // Mark upstream nodes in the same chain as outputBlocking\n                if (targetNodeAttribute != null\n                        && targetNodeAttribute.isNoOutputUntilEndOfInput()) {\n                    currentNodeAttribute.setNoOutputUntilEndOfInput(true);\n                }\n            }\n\n            for (StreamEdge nonChainable : nonChainableOutputs) {\n                transitiveOutEdges.add(nonChainable);\n                createChain(\n                        nonChainable.getTargetId(),\n                        1, // operators start at position 1 because 0 is for chained source inputs\n                        chainEntryPoints.computeIfAbsent(\n                                nonChainable.getTargetId(),\n                                (k) -> chainInfo.newChain(nonChainable.getTargetId())),\n                        chainEntryPoints);\n            }\n\n            chainedNames.put(\n                    currentNodeId,\n                    createChainedName(\n                            currentNodeId,\n                            chainableOutputs,\n                            Optional.ofNullable(chainEntryPoints.get(currentNodeId))));\n            chainedMinResources.put(\n                    currentNodeId, createChainedMinResources(currentNodeId, chainableOutputs));\n            chainedPreferredResources.put(\n                    currentNodeId,\n                    createChainedPreferredResources(currentNodeId, chainableOutputs));\n\n            OperatorID currentOperatorId =\n                    chainInfo.addNodeToChain(\n                            currentNodeId,\n                            streamGraph.getStreamNode(currentNodeId).getOperatorName());\n\n            if (currentNode.getInputFormat() != null) {\n                getOrCreateFormatContainer(startNodeId)\n                        .addInputFormat(currentOperatorId, currentNode.getInputFormat());\n            }\n\n            if (currentNode.getOutputFormat() != null) {\n                getOrCreateFormatContainer(startNodeId)\n                        .addOutputFormat(currentOperatorId, currentNode.getOutputFormat());\n            }\n\n            StreamConfig config =\n                    currentNodeId.equals(startNodeId)\n                            ? createJobVertex(startNodeId, chainInfo)\n                            : new StreamConfig(new Configuration());\n\n            tryConvertPartitionerForDynamicGraph(chainableOutputs, nonChainableOutputs);\n            config.setAttribute(currentNodeAttribute);\n            setOperatorConfig(currentNodeId, config, chainInfo.getChainedSources());\n\n            setOperatorChainedOutputsConfig(config, chainableOutputs);\n\n            // we cache the non-chainable outputs here, and set the non-chained config later\n            opNonChainableOutputsCache.put(currentNodeId, nonChainableOutputs);\n\n            if (currentNodeId.equals(startNodeId)) {\n                chainInfo.setTransitiveOutEdges(transitiveOutEdges);\n                chainInfos.put(startNodeId, chainInfo);\n\n                config.setChainStart();\n                config.setChainIndex(chainIndex);\n                config.setOperatorName(streamGraph.getStreamNode(currentNodeId).getOperatorName());\n                config.setTransitiveChainedTaskConfigs(chainedConfigs.get(startNodeId));\n\n            } else {\n                chainedConfigs.computeIfAbsent(\n                        startNodeId, k -> new HashMap<Integer, StreamConfig>());\n\n                config.setChainIndex(chainIndex);\n                StreamNode node = streamGraph.getStreamNode(currentNodeId);\n                config.setOperatorName(node.getOperatorName());\n                chainedConfigs.get(startNodeId).put(currentNodeId, config);\n            }\n\n            config.setOperatorID(currentOperatorId);\n\n            if (chainableOutputs.isEmpty()) {\n                config.setChainEnd();\n            }\n            return transitiveOutEdges;\n\n        } else {\n            return new ArrayList<>();\n        }\n    }",
          "conflictNames": [
              "currentNodeId",
              "chainIndex",
              "chainInfo",
              "chainEntryPoints",
              "startNodeId",
              "transitiveOutEdges",
              "chainableOutputs",
              "currentNode",
              "currentNodeAttribute",
              "isNoOutputUntilEndOfInput",
              "targetNode",
              "targetNodeAttribute",
              "currentOperatorId",
              "config",
              "node"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/cae5fb4d3b6d9e0c10c3539ea4994fc1ad463b70^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamPhysicalMultiJoin.java",
      "locators": [
          {
              "line": 170,
              "column": 33
          },
          {
              "line": 180,
              "column": 17
          }
      ],
      "old_name": "inputUpsertKeys",
      "new_name": "inputUniqueKeys",
      "ctx": {
          "symbolName": "inputUpsertKeys",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<List<int[]>>",
          "scopeHint": "in translateToExecNode(...)",
          "filePath": "StreamPhysicalMultiJoin.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public ExecNode<?> translateToExecNode() {\n        final RexNode multiJoinCondition = createMultiJoinCondition();\n        final List<List<int[]>> inputUpsertKeys = getUpsertKeysForInputs();\n        final List<FlinkJoinType> execJoinTypes = getExecJoinTypes();\n        final List<InputProperty> inputProperties = createInputProperties();\n\n        return new StreamExecMultiJoin(\n                unwrapTableConfig(this),\n                execJoinTypes,\n                joinConditions,\n                multiJoinCondition,\n                joinAttributeMap,\n                inputUpsertKeys,\n                Collections.emptyMap(), // TODO Enable hint-based state ttl. See ticket\n                // TODO https://issues.apache.org/jira/browse/FLINK-37936\n                inputProperties,\n                FlinkTypeFactory.toLogicalRowType(getRowType()),\n                getRelDetailedDescription());\n    }",
          "conflictNames": [
              "multiJoinCondition",
              "execJoinTypes",
              "inputProperties"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/cae5fb4d3b6d9e0c10c3539ea4994fc1ad463b70^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamPhysicalMultiJoin.java",
      "locators": [
          {
              "line": 201,
              "column": 56
          },
          {
              "line": 203,
              "column": 33
          },
          {
              "line": 206,
              "column": 36
          }
      ],
      "old_name": "upsertKeys",
      "new_name": "uniqueKeys",
      "ctx": {
          "symbolName": "upsertKeys",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Set<ImmutableBitSet>",
          "scopeHint": "in getUpsertKeysForInputs(...)",
          "filePath": "StreamPhysicalMultiJoin.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private List<List<int[]>> getUpsertKeysForInputs() {\n        return inputs.stream()\n                .map(\n                        input -> {\n                            final Set<ImmutableBitSet> upsertKeys = getUpsertKeys(input);\n\n                            if (upsertKeys == null) {\n                                return Collections.<int[]>emptyList();\n                            }\n                            return upsertKeys.stream()\n                                    .map(ImmutableBitSet::toArray)\n                                    .collect(Collectors.toList());\n                        })\n                .collect(Collectors.toList());\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/cc9540cacc2d775cc190ee6534794ec33fd07828^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/operations/AlterSchemaConverter.java",
      "locators": [
          {
              "line": 129,
              "column": 22
          },
          {
              "line": 138,
              "column": 17
          },
          {
              "line": 149,
              "column": 77
          },
          {
              "line": 614,
              "column": 26
          },
          {
              "line": 618,
              "column": 14
          },
          {
              "line": 626,
              "column": 13
          },
          {
              "line": 641,
              "column": 77
          }
      ],
      "old_name": "tableColumns",
      "new_name": "rowtimeAttributes",
      "ctx": {
          "symbolName": "tableColumns",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<String>",
          "scopeHint": "in applySchemaChange(...)",
          "filePath": "AlterSchemaConverter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public Schema applySchemaChange(\n            SqlAlterTableRenameColumn renameColumn, ContextResolvedTable originalTable) {\n        String oldColumnName = getColumnName(renameColumn.getOriginColumnIdentifier());\n        String newColumnName = getColumnName(renameColumn.getNewColumnIdentifier());\n        List<String> tableColumns =\n                originalTable.getResolvedSchema().getColumns().stream()\n                        .map(Column::getName)\n                        .collect(Collectors.toList());\n        // validate old column is exists or new column isn't duplicated or old column isn't\n        // referenced by computed column\n        validateColumnName(\n                oldColumnName,\n                newColumnName,\n                tableColumns,\n                originalTable.getResolvedSchema(),\n                ((CatalogTable) originalTable.getResolvedTable()).getPartitionKeys());\n\n        // validate old column isn't referenced by watermark\n        List<WatermarkSpec> watermarkSpecs = originalTable.getResolvedSchema().getWatermarkSpecs();\n        watermarkSpecs.forEach(\n                watermarkSpec -> {\n                    String rowtimeAttribute = watermarkSpec.getRowtimeAttribute();\n                    Set<String> referencedColumns =\n                            ColumnReferenceFinder.findReferencedColumn(\n                                    watermarkSpec.getWatermarkExpression(), tableColumns);\n                    if (oldColumnName.equals(rowtimeAttribute)\n                            || referencedColumns.contains(oldColumnName)) {\n                        throw new ValidationException(\n                                String.format(\n                                        \"Old column %s is referred by watermark expression %s, \"\n                                                + \"currently doesn't allow to rename column which is \"\n                                                + \"referred by watermark expression.\",\n                                        oldColumnName, watermarkSpec.asSummaryString()));\n                    }\n                });\n\n        Schema.Builder builder = Schema.newBuilder();\n        // build column\n        Schema originSchema = originalTable.getTable().getUnresolvedSchema();\n        originSchema\n                .getColumns()\n                .forEach(\n                        column -> {\n                            if (oldColumnName.equals(column.getName())) {\n                                buildNewColumnFromOriginColumn(builder, column, newColumnName);\n                            } else {\n                                builder.fromColumns(Collections.singletonList(column));\n                            }\n                        });\n        // build primary key\n        Optional<Schema.UnresolvedPrimaryKey> originPrimaryKey = originSchema.getPrimaryKey();\n        if (originPrimaryKey.isPresent()) {\n            List<String> originPrimaryKeyNames = originPrimaryKey.get().getColumnNames();\n            String constrainName = originPrimaryKey.get().getConstraintName();\n            List<String> newPrimaryKeyNames =\n                    originPrimaryKeyNames.stream()\n                            .map(pkName -> pkName.equals(oldColumnName) ? newColumnName : pkName)\n                            .collect(Collectors.toList());\n            builder.primaryKeyNamed(constrainName, newPrimaryKeyNames);\n        }\n\n        // build watermark\n        originSchema\n                .getWatermarkSpecs()\n                .forEach(\n                        watermarkSpec ->\n                                builder.watermark(\n                                        watermarkSpec.getColumnName(),\n                                        watermarkSpec.getWatermarkExpression()));\n\n        // generate new schema\n        return builder.build();\n    }",
          "conflictNames": [
              "renameColumn",
              "originalTable",
              "oldColumnName",
              "newColumnName",
              "watermarkSpecs",
              "rowtimeAttribute",
              "referencedColumns",
              "builder",
              "originSchema",
              "originPrimaryKey",
              "originPrimaryKeyNames",
              "constrainName",
              "newPrimaryKeyNames"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/cc9540cacc2d775cc190ee6534794ec33fd07828^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/operations/AlterSchemaConverter.java",
      "locators": [
          {
              "line": 127,
              "column": 16
          },
          {
              "line": 136,
              "column": 17
          },
          {
              "line": 150,
              "column": 25
          },
          {
              "line": 151,
              "column": 59
          },
          {
              "line": 157,
              "column": 41
          },
          {
              "line": 168,
              "column": 33
          },
          {
              "line": 181,
              "column": 58
          }
      ],
      "old_name": "oldColumnName",
      "new_name": "originColumnName",
      "ctx": {
          "symbolName": "oldColumnName",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in applySchemaChange(...)",
          "filePath": "AlterSchemaConverter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public Schema applySchemaChange(\n            SqlAlterTableRenameColumn renameColumn, ContextResolvedTable originalTable) {\n        String oldColumnName = getColumnName(renameColumn.getOriginColumnIdentifier());\n        String newColumnName = getColumnName(renameColumn.getNewColumnIdentifier());\n        List<String> tableColumns =\n                originalTable.getResolvedSchema().getColumns().stream()\n                        .map(Column::getName)\n                        .collect(Collectors.toList());\n        // validate old column is exists or new column isn't duplicated or old column isn't\n        // referenced by computed column\n        validateColumnName(\n                oldColumnName,\n                newColumnName,\n                tableColumns,\n                originalTable.getResolvedSchema(),\n                ((CatalogTable) originalTable.getResolvedTable()).getPartitionKeys());\n\n        // validate old column isn't referenced by watermark\n        List<WatermarkSpec> watermarkSpecs = originalTable.getResolvedSchema().getWatermarkSpecs();\n        watermarkSpecs.forEach(\n                watermarkSpec -> {\n                    String rowtimeAttribute = watermarkSpec.getRowtimeAttribute();\n                    Set<String> referencedColumns =\n                            ColumnReferenceFinder.findReferencedColumn(\n                                    watermarkSpec.getWatermarkExpression(), tableColumns);\n                    if (oldColumnName.equals(rowtimeAttribute)\n                            || referencedColumns.contains(oldColumnName)) {\n                        throw new ValidationException(\n                                String.format(\n                                        \"Old column %s is referred by watermark expression %s, \"\n                                                + \"currently doesn't allow to rename column which is \"\n                                                + \"referred by watermark expression.\",\n                                        oldColumnName, watermarkSpec.asSummaryString()));\n                    }\n                });\n\n        Schema.Builder builder = Schema.newBuilder();\n        // build column\n        Schema originSchema = originalTable.getTable().getUnresolvedSchema();\n        originSchema\n                .getColumns()\n                .forEach(\n                        column -> {\n                            if (oldColumnName.equals(column.getName())) {\n                                buildNewColumnFromOriginColumn(builder, column, newColumnName);\n                            } else {\n                                builder.fromColumns(Collections.singletonList(column));\n                            }\n                        });\n        // build primary key\n        Optional<Schema.UnresolvedPrimaryKey> originPrimaryKey = originSchema.getPrimaryKey();\n        if (originPrimaryKey.isPresent()) {\n            List<String> originPrimaryKeyNames = originPrimaryKey.get().getColumnNames();\n            String constrainName = originPrimaryKey.get().getConstraintName();\n            List<String> newPrimaryKeyNames =\n                    originPrimaryKeyNames.stream()\n                            .map(pkName -> pkName.equals(oldColumnName) ? newColumnName : pkName)\n                            .collect(Collectors.toList());\n            builder.primaryKeyNamed(constrainName, newPrimaryKeyNames);\n        }\n\n        // build watermark\n        originSchema\n                .getWatermarkSpecs()\n                .forEach(\n                        watermarkSpec ->\n                                builder.watermark(\n                                        watermarkSpec.getColumnName(),\n                                        watermarkSpec.getWatermarkExpression()));\n\n        // generate new schema\n        return builder.build();\n    }",
          "conflictNames": [
              "renameColumn",
              "originalTable",
              "newColumnName",
              "tableColumns",
              "watermarkSpecs",
              "rowtimeAttribute",
              "referencedColumns",
              "builder",
              "originSchema",
              "originPrimaryKey",
              "originPrimaryKeyNames",
              "constrainName",
              "newPrimaryKeyNames"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/cc9540cacc2d775cc190ee6534794ec33fd07828^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/operations/AlterSchemaConverter.java",
      "locators": [
          {
              "line": 306,
              "column": 37
          },
          {
              "line": 312,
              "column": 33
          }
      ],
      "old_name": "originalType",
      "new_name": "originType",
      "ctx": {
          "symbolName": "originalType",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "AbstractDataType<?>",
          "scopeHint": "in updatePrimaryKeyNullability(...)",
          "filePath": "AlterSchemaConverter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void updatePrimaryKeyNullability(String columnName) {\n            Schema.UnresolvedColumn column = columns.get(columnName);\n            if (column instanceof Schema.UnresolvedPhysicalColumn) {\n                AbstractDataType<?> originalType =\n                        ((Schema.UnresolvedPhysicalColumn) column).getDataType();\n                columns.put(\n                        columnName,\n                        new Schema.UnresolvedPhysicalColumn(\n                                columnName,\n                                originalType.notNull(),\n                                column.getComment().orElse(null)));\n            }\n        }",
          "conflictNames": [
              "columnName",
              "column"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/cc9540cacc2d775cc190ee6534794ec33fd07828^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/operations/SqlToOperationConverter.java",
      "locators": [
          {
              "line": 541,
              "column": 26
          },
          {
              "line": 546,
              "column": 29
          },
          {
              "line": 547,
              "column": 29
          },
          {
              "line": 548,
              "column": 29
          }
      ],
      "old_name": "baseCatalogTable",
      "new_name": "resolvedCatalogTable",
      "ctx": {
          "symbolName": "baseCatalogTable",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CatalogTable",
          "scopeHint": "in convertAlterTable(...)",
          "filePath": "SqlToOperationConverter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** convert ALTER TABLE statement. */\n    private Operation convertAlterTable(SqlAlterTable sqlAlterTable) {\n        UnresolvedIdentifier unresolvedIdentifier =\n                UnresolvedIdentifier.of(sqlAlterTable.fullTableName());\n        ObjectIdentifier tableIdentifier = catalogManager.qualifyIdentifier(unresolvedIdentifier);\n        Optional<ContextResolvedTable> optionalCatalogTable =\n                catalogManager.getTable(tableIdentifier);\n        if (!optionalCatalogTable.isPresent() || optionalCatalogTable.get().isTemporary()) {\n            throw new ValidationException(\n                    String.format(\n                            \"Table %s doesn't exist or is a temporary table.\", tableIdentifier));\n        }\n        CatalogBaseTable baseTable = optionalCatalogTable.get().getResolvedTable();\n        if (baseTable instanceof CatalogView) {\n            throw new ValidationException(\"ALTER TABLE for a view is not allowed\");\n        }\n        if (sqlAlterTable instanceof SqlAlterTableRename) {\n            UnresolvedIdentifier newUnresolvedIdentifier =\n                    UnresolvedIdentifier.of(\n                            ((SqlAlterTableRename) sqlAlterTable).fullNewTableName());\n            ObjectIdentifier newTableIdentifier =\n                    catalogManager.qualifyIdentifier(newUnresolvedIdentifier);\n            return new AlterTableRenameOperation(tableIdentifier, newTableIdentifier);\n        } else if (sqlAlterTable instanceof SqlAlterTableOptions) {\n            return convertAlterTableOptions(\n                    tableIdentifier,\n                    (CatalogTable) baseTable,\n                    (SqlAlterTableOptions) sqlAlterTable);\n        } else if (sqlAlterTable instanceof SqlAlterTableReset) {\n            return convertAlterTableReset(\n                    tableIdentifier, (CatalogTable) baseTable, (SqlAlterTableReset) sqlAlterTable);\n        } else if (sqlAlterTable instanceof SqlAlterTableDropConstraint) {\n            SqlAlterTableDropConstraint dropConstraint =\n                    ((SqlAlterTableDropConstraint) sqlAlterTable);\n            String constraintName = dropConstraint.getConstraintName().getSimple();\n            TableSchema oriSchema =\n                    TableSchema.fromResolvedSchema(\n                            baseTable\n                                    .getUnresolvedSchema()\n                                    .resolve(catalogManager.getSchemaResolver()));\n            if (!oriSchema\n                    .getPrimaryKey()\n                    .filter(pk -> pk.getName().equals(constraintName))\n                    .isPresent()) {\n                throw new ValidationException(\n                        String.format(\"CONSTRAINT [%s] does not exist\", constraintName));\n            }\n            return new AlterTableDropConstraintOperation(tableIdentifier, constraintName);\n        } else if (sqlAlterTable instanceof SqlAddReplaceColumns) {\n            return OperationConverterUtils.convertAddReplaceColumns(\n                    tableIdentifier,\n                    (SqlAddReplaceColumns) sqlAlterTable,\n                    (CatalogTable) baseTable,\n                    flinkPlanner.getOrCreateSqlValidator());\n        } else if (sqlAlterTable instanceof SqlChangeColumn) {\n            return OperationConverterUtils.convertChangeColumn(\n                    tableIdentifier,\n                    (SqlChangeColumn) sqlAlterTable,\n                    (CatalogTable) baseTable,\n                    flinkPlanner.getOrCreateSqlValidator());\n        } else if (sqlAlterTable instanceof SqlAlterTableRenameColumn) {\n            SqlAlterTableRenameColumn sqlAlterTableRenameColumn =\n                    (SqlAlterTableRenameColumn) sqlAlterTable;\n            Schema newSchema =\n                    alterSchemaConverter.applySchemaChange(\n                            sqlAlterTableRenameColumn, optionalCatalogTable.get());\n            CatalogTable baseCatalogTable = (CatalogTable) baseTable;\n            return new AlterTableSchemaOperation(\n                    tableIdentifier,\n                    CatalogTable.of(\n                            newSchema,\n                            baseCatalogTable.getComment(),\n                            baseCatalogTable.getPartitionKeys(),\n                            baseCatalogTable.getOptions()));\n        } else if (sqlAlterTable instanceof SqlAddPartitions) {\n            List<CatalogPartitionSpec> specs = new ArrayList<>();\n            List<CatalogPartition> partitions = new ArrayList<>();\n            SqlAddPartitions addPartitions = (SqlAddPartitions) sqlAlterTable;\n            for (int i = 0; i < addPartitions.getPartSpecs().size(); i++) {\n                specs.add(new CatalogPartitionSpec(addPartitions.getPartitionKVs(i)));\n                Map<String, String> props =\n                        OperationConverterUtils.extractProperties(\n                                addPartitions.getPartProps().get(i));\n                partitions.add(new CatalogPartitionImpl(props, null));\n            }\n            return new AddPartitionsOperation(\n                    tableIdentifier, addPartitions.ifNotExists(), specs, partitions);\n        } else if (sqlAlterTable instanceof SqlDropPartitions) {\n            SqlDropPartitions dropPartitions = (SqlDropPartitions) sqlAlterTable;\n            List<CatalogPartitionSpec> specs = new ArrayList<>();\n            for (int i = 0; i < dropPartitions.getPartSpecs().size(); i++) {\n                specs.add(new CatalogPartitionSpec(dropPartitions.getPartitionKVs(i)));\n            }\n            return new DropPartitionsOperation(tableIdentifier, dropPartitions.ifExists(), specs);\n        } else if (sqlAlterTable instanceof SqlAlterTableCompact) {\n            return convertAlterTableCompact(\n                    tableIdentifier,\n                    optionalCatalogTable.get(),\n                    (SqlAlterTableCompact) sqlAlterTable);\n        } else if (sqlAlterTable instanceof SqlAlterTableSchema) {\n            return convertAlterTableSchema(\n                    tableIdentifier,\n                    optionalCatalogTable.get().getResolvedTable(),\n                    (SqlAlterTableSchema) sqlAlterTable);\n        } else {\n            throw new ValidationException(\n                    String.format(\n                            \"[%s] needs to implement\",\n                            sqlAlterTable.toSqlString(CalciteSqlDialect.DEFAULT)));\n        }\n    }",
          "conflictNames": [
              "sqlAlterTable",
              "unresolvedIdentifier",
              "tableIdentifier",
              "optionalCatalogTable",
              "baseTable",
              "newUnresolvedIdentifier",
              "newTableIdentifier",
              "dropConstraint",
              "constraintName",
              "oriSchema",
              "sqlAlterTableRenameColumn",
              "newSchema",
              "specs",
              "partitions",
              "addPartitions",
              "i",
              "props",
              "dropPartitions"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/cc9712bfe92de4a68e87baef8f6937dcdc8a8634^1/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/api/internal/TableEnvironmentImpl.java",
      "locators": [
          {
              "line": 896,
              "column": 39
          },
          {
              "line": 897,
              "column": 43
          }
      ],
      "old_name": "ctasJobStatusHook",
      "new_name": "stagingSinkJobStatusHook",
      "ctx": {
          "symbolName": "ctasJobStatusHook",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CtasJobStatusHook",
          "scopeHint": "in getModifyOperation(...)",
          "filePath": "TableEnvironmentImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private ModifyOperation getModifyOperation(\n            CreateTableASOperation ctasOperation, List<JobStatusHook> jobStatusHookList) {\n        CreateTableOperation createTableOperation = ctasOperation.getCreateTableOperation();\n        if (tableConfig.get(TableConfigOptions.TABLE_CTAS_ATOMICITY_ENABLED)) {\n            ObjectIdentifier tableIdentifier = createTableOperation.getTableIdentifier();\n            Catalog catalog =\n                    catalogManager.getCatalog(tableIdentifier.getCatalogName()).orElse(null);\n            ResolvedCatalogTable catalogTable =\n                    catalogManager.resolveCatalogTable(createTableOperation.getCatalogTable());\n            if (!TableFactoryUtil.isLegacyConnectorOptions(\n                    catalog,\n                    tableConfig,\n                    isStreamingMode,\n                    tableIdentifier,\n                    catalogTable,\n                    createTableOperation.isTemporary())) {\n                DynamicTableSink dynamicTableSink =\n                        ExecutableOperationUtils.createDynamicTableSink(\n                                catalog,\n                                () -> moduleManager.getFactory((Module::getTableSinkFactory)),\n                                tableIdentifier,\n                                catalogTable,\n                                Collections.emptyMap(),\n                                tableConfig,\n                                resourceManager.getUserClassLoader(),\n                                createTableOperation.isTemporary());\n                if (dynamicTableSink instanceof SupportsStaging) {\n                    // use atomic ctas\n                    SupportsStaging.StagingPurpose stagingPurpose =\n                            createTableOperation.isIgnoreIfExists()\n                                    ? SupportsStaging.StagingPurpose.CREATE_TABLE_AS_IF_NOT_EXISTS\n                                    : SupportsStaging.StagingPurpose.CREATE_TABLE_AS;\n                    StagedTable stagedTable =\n                            ((SupportsStaging) dynamicTableSink)\n                                    .applyStaging(new SinkStagingContext(stagingPurpose));\n                    CtasJobStatusHook ctasJobStatusHook = new CtasJobStatusHook(stagedTable);\n                    jobStatusHookList.add(ctasJobStatusHook);\n                    return ctasOperation.toStagedSinkModifyOperation(\n                            createTableOperation.getTableIdentifier(),\n                            catalogTable,\n                            catalog,\n                            dynamicTableSink);\n                }\n            }\n        }\n        // use non-atomic ctas, create table first\n        executeInternal(createTableOperation);\n        return ctasOperation.toSinkModifyOperation(catalogManager);\n    }",
          "conflictNames": [
              "ctasOperation",
              "jobStatusHookList",
              "createTableOperation",
              "tableIdentifier",
              "catalog",
              "catalogTable",
              "dynamicTableSink",
              "stagingPurpose",
              "stagedTable"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ccfd8be19ba1d38e5cd6fb5c7e18dc07019375b5^1/flink-table/flink-table-planner/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java",
      "locators": [
          {
              "line": 3602,
              "column": 21
          },
          {
              "line": 3607,
              "column": 16
          },
          {
              "line": 6521,
              "column": 29
          },
          {
              "line": 6522,
              "column": 21
          },
          {
              "line": 6523,
              "column": 28
          }
      ],
      "old_name": "colType",
      "new_name": "field",
      "ctx": {
          "symbolName": "colType",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RelDataType",
          "scopeHint": "in checkAndDeriveDataType(...)",
          "filePath": "SqlValidatorImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private RelDataType checkAndDeriveDataType(SqlIdentifier id, SqlNode node) {\n        Preconditions.checkArgument(id.names.size() == 1);\n        String name = id.names.get(0);\n        SqlNameMatcher nameMatcher = getCatalogReader().nameMatcher();\n        RelDataType rowType = getNamespaceOrThrow(node).getRowType();\n        RelDataType colType =\n                requireNonNull(\n                                nameMatcher.field(rowType, name),\n                                () -> \"unable to find left field \" + name + \" in \" + rowType)\n                        .getType();\n        return colType;\n    }",
          "conflictNames": [
              "id",
              "node",
              "name",
              "nameMatcher",
              "rowType"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ccfd8be19ba1d38e5cd6fb5c7e18dc07019375b5^1/flink-table/flink-table-planner/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java",
      "locators": [
          {
              "line": 4986,
              "column": 27
          },
          {
              "line": 4988,
              "column": 84
          },
          {
              "line": 4990,
              "column": 84
          }
      ],
      "old_name": "targetColumnCnt",
      "new_name": "targetColumnCount",
      "ctx": {
          "symbolName": "targetColumnCnt",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in checkTypeAssignment(...)",
          "filePath": "SqlValidatorImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Checks the type assignment of an INSERT or UPDATE query.\n     *\n     * <p>Skip the virtual columns(can not insert into) type assignment check if the source fields\n     * count equals with the real target table fields count, see how #checkFieldCount was used.\n     *\n     * @param sourceScope Scope of query source which is used to infer node type\n     * @param table Target table\n     * @param sourceRowType Source row type\n     * @param targetRowType Target row type, it should either contain all the virtual columns (can\n     *     not insert into) or exclude all the virtual columns\n     * @param query The query\n     */\n    protected void checkTypeAssignment(\n            @Nullable SqlValidatorScope sourceScope,\n            SqlValidatorTable table,\n            RelDataType sourceRowType,\n            RelDataType targetRowType,\n            final SqlNode query) {\n        // NOTE jvs 23-Feb-2006: subclasses may allow for extra targets\n        // representing system-maintained columns, so stop after all sources\n        // matched\n        boolean isUpdateModifiableViewTable = false;\n        if (query instanceof SqlUpdate) {\n            final SqlNodeList targetColumnList = ((SqlUpdate) query).getTargetColumnList();\n            if (targetColumnList != null) {\n                final int targetColumnCnt = targetColumnList.size();\n                targetRowType =\n                        SqlTypeUtil.extractLastNFields(typeFactory, targetRowType, targetColumnCnt);\n                sourceRowType =\n                        SqlTypeUtil.extractLastNFields(typeFactory, sourceRowType, targetColumnCnt);\n            }\n            isUpdateModifiableViewTable = table.unwrap(ModifiableViewTable.class) != null;\n        }\n        if (SqlTypeUtil.equalAsStructSansNullability(\n                typeFactory, sourceRowType, targetRowType, null)) {\n            // Returns early if source and target row type equals sans nullability.\n            return;\n        }\n        if (config.typeCoercionEnabled() && !isUpdateModifiableViewTable) {\n            // Try type coercion first if implicit type coercion is allowed.\n            boolean coerced =\n                    typeCoercion.querySourceCoercion(\n                            sourceScope, sourceRowType, targetRowType, query);\n            if (coerced) {\n                return;\n            }\n        }\n\n        // Fall back to default behavior: compare the type families.\n        List<RelDataTypeField> sourceFields = sourceRowType.getFieldList();\n        List<RelDataTypeField> targetFields = targetRowType.getFieldList();\n        final int sourceCount = sourceFields.size();\n        for (int i = 0; i < sourceCount; ++i) {\n            RelDataType sourceType = sourceFields.get(i).getType();\n            RelDataType targetType = targetFields.get(i).getType();\n            if (!SqlTypeUtil.canAssignFrom(targetType, sourceType)) {\n                SqlNode node = getNthExpr(query, i, sourceCount);\n                if (node instanceof SqlDynamicParam) {\n                    continue;\n                }\n                String targetTypeString;\n                String sourceTypeString;\n                if (SqlTypeUtil.areCharacterSetsMismatched(sourceType, targetType)) {\n                    sourceTypeString = sourceType.getFullTypeString();\n                    targetTypeString = targetType.getFullTypeString();\n                } else {\n                    sourceTypeString = sourceType.toString();\n                    targetTypeString = targetType.toString();\n                }\n                throw newValidationError(\n                        node,\n                        RESOURCE.typeNotAssignable(\n                                targetFields.get(i).getName(), targetTypeString,\n                                sourceFields.get(i).getName(), sourceTypeString));\n            }\n        }\n    }",
          "conflictNames": [
              "sourceScope",
              "table",
              "sourceRowType",
              "targetRowType",
              "query",
              "isUpdateModifiableViewTable",
              "targetColumnList",
              "coerced",
              "sourceFields",
              "targetFields",
              "sourceCount",
              "i",
              "sourceType",
              "targetType",
              "node",
              "targetTypeString",
              "sourceTypeString"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ccfd8be19ba1d38e5cd6fb5c7e18dc07019375b5^1/flink-table/flink-table-planner/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java",
      "locators": [
          {
              "line": 1976,
              "column": 27
          },
          {
              "line": 1986,
              "column": 66
          },
          {
              "line": 1987,
              "column": 54
          }
      ],
      "old_name": "rexCall",
      "new_name": "call2",
      "ctx": {
          "symbolName": "rexCall",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RexCall",
          "scopeHint": "in convertCall(...)",
          "filePath": "StandardConvertletTable.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "\n        @Override\n        public RexNode convertCall(SqlRexContext cx, SqlCall call) {\n            // TIMESTAMPDIFF(unit, t1, t2)\n            //    => (t2 - t1) UNIT\n            // TIMESTAMP_DIFF(t1, t2, unit)\n            //    => (t1 - t2) UNIT\n            SqlIntervalQualifier qualifier;\n            final RexNode op1;\n            final RexNode op2;\n            if (call.operand(0).getKind() == SqlKind.INTERVAL_QUALIFIER) {\n                qualifier = call.operand(0);\n                op1 = cx.convertExpression(call.operand(1));\n                op2 = cx.convertExpression(call.operand(2));\n            } else {\n                qualifier = call.operand(2);\n                op1 = cx.convertExpression(call.operand(1));\n                op2 = cx.convertExpression(call.operand(0));\n            }\n            final RexBuilder rexBuilder = cx.getRexBuilder();\n            final TimeFrame timeFrame = cx.getValidator().validateTimeFrame(qualifier);\n            final TimeUnit unit = first(timeFrame.unit(), TimeUnit.EPOCH);\n\n            if (unit == TimeUnit.EPOCH && qualifier.timeFrameName != null) {\n                // Custom time frames have a different path. They are kept as names, and\n                // then handled by Java functions.\n                final RexLiteral timeFrameName = rexBuilder.makeLiteral(qualifier.timeFrameName);\n                return rexBuilder.makeCall(\n                        cx.getValidator().getValidatedNodeType(call),\n                        SqlStdOperatorTable.TIMESTAMP_DIFF,\n                        ImmutableList.of(timeFrameName, op1, op2));\n            }\n\n            BigDecimal multiplier = BigDecimal.ONE;\n            BigDecimal divider = BigDecimal.ONE;\n            SqlTypeName sqlTypeName =\n                    unit == TimeUnit.NANOSECOND ? SqlTypeName.BIGINT : SqlTypeName.INTEGER;\n            switch (unit) {\n                case MICROSECOND:\n                case MILLISECOND:\n                case NANOSECOND:\n                case WEEK:\n                    multiplier = BigDecimal.valueOf(DateTimeUtils.MILLIS_PER_SECOND);\n                    divider = unit.multiplier;\n                    qualifier =\n                            new SqlIntervalQualifier(\n                                    TimeUnit.SECOND, null, qualifier.getParserPosition());\n                    break;\n                case QUARTER:\n                case CENTURY:\n                case MILLENNIUM:\n                    divider = unit.multiplier;\n                    qualifier =\n                            new SqlIntervalQualifier(\n                                    TimeUnit.MONTH, null, qualifier.getParserPosition());\n                    break;\n                default:\n                    qualifier = new SqlIntervalQualifier(unit, null, qualifier.getParserPosition());\n                    break;\n            }\n            final RelDataType intervalType =\n                    cx.getTypeFactory()\n                            .createTypeWithNullability(\n                                    cx.getTypeFactory().createSqlIntervalType(qualifier),\n                                    op1.getType().isNullable() || op2.getType().isNullable());\n            final RexCall rexCall =\n                    (RexCall)\n                            rexBuilder.makeCall(\n                                    intervalType,\n                                    SqlStdOperatorTable.MINUS_DATE,\n                                    ImmutableList.of(op2, op1));\n            final RelDataType intType =\n                    cx.getTypeFactory()\n                            .createTypeWithNullability(\n                                    cx.getTypeFactory().createSqlType(sqlTypeName),\n                                    SqlTypeUtil.containsNullable(rexCall.getType()));\n            RexNode e = rexBuilder.makeCast(intType, rexCall);\n            return rexBuilder.multiplyDivide(e, multiplier, divider);\n        }",
          "conflictNames": [
              "cx",
              "call",
              "qualifier",
              "op1",
              "op2",
              "rexBuilder",
              "timeFrame",
              "unit",
              "timeFrameName",
              "multiplier",
              "divider",
              "sqlTypeName",
              "intervalType",
              "intType",
              "e"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/cd95b560d0c11a64b42bf6b98107314d32a4de86^1/flink-runtime/src/test/java/org/apache/flink/runtime/entrypoint/ClusterEntrypointTest.java",
      "locators": [
          {
              "line": 137,
              "column": 39
          },
          {
              "line": 141,
              "column": 58
          },
          {
              "line": 157,
              "column": 20
          },
          {
              "line": 187,
              "column": 39
          },
          {
              "line": 193,
              "column": 58
          },
          {
              "line": 224,
              "column": 20
          }
      ],
      "old_name": "closeAndCleanupAllDataFuture",
      "new_name": "cleanupAllDataFuture",
      "ctx": {
          "symbolName": "closeAndCleanupAllDataFuture",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CompletableFuture<Void>",
          "scopeHint": "in testCloseAsyncShouldNotCleanUpHAData(...)",
          "filePath": "ClusterEntrypointTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testCloseAsyncShouldNotCleanUpHAData() throws Exception {\n        final CompletableFuture<Void> closeFuture = new CompletableFuture<>();\n        final CompletableFuture<Void> closeAndCleanupAllDataFuture = new CompletableFuture<>();\n        final HighAvailabilityServices testingHaService =\n                new TestingHighAvailabilityServicesBuilder()\n                        .setCloseFuture(closeFuture)\n                        .setCloseAndCleanupAllDataFuture(closeAndCleanupAllDataFuture)\n                        .build();\n        final TestingEntryPoint testingEntryPoint =\n                new TestingEntryPoint.Builder()\n                        .setConfiguration(flinkConfig)\n                        .setHighAvailabilityServices(testingHaService)\n                        .build();\n\n        final CompletableFuture<ApplicationStatus> appStatusFuture =\n                startClusterEntrypoint(testingEntryPoint);\n\n        testingEntryPoint.closeAsync();\n        assertThat(\n                appStatusFuture.get(TIMEOUT_MS, TimeUnit.MILLISECONDS),\n                is(ApplicationStatus.UNKNOWN));\n        assertThat(closeFuture.isDone(), is(true));\n        assertThat(closeAndCleanupAllDataFuture.isDone(), is(false));\n    }",
          "conflictNames": [
              "closeFuture",
              "testingHaService",
              "testingEntryPoint",
              "appStatusFuture"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/cf358d7d55ca48b9d25e5217006898e3070a85ad^1/flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/connectors/hive/HiveTableSink.java",
      "locators": [
          {
              "line": 296,
              "column": 23
          },
          {
              "line": 331,
              "column": 25
          },
          {
              "line": 343,
              "column": 25
          },
          {
              "line": 362,
              "column": 23
          },
          {
              "line": 394,
              "column": 33
          },
          {
              "line": 396,
              "column": 33
          },
          {
              "line": 406,
              "column": 23
          },
          {
              "line": 492,
              "column": 29
          },
          {
              "line": 500,
              "column": 29
          }
      ],
      "old_name": "parallelism",
      "new_name": "sinkParallelism",
      "ctx": {
          "symbolName": "parallelism",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in consume(...)",
          "filePath": "HiveTableSink.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private DataStreamSink<?> consume(\n            ProviderContext providerContext,\n            DataStream<RowData> dataStream,\n            boolean isBounded,\n            DataStructureConverter converter) {\n        checkAcidTable(catalogTable.getOptions(), identifier.toObjectPath());\n\n        StorageDescriptor sd;\n        Properties tableProps = new Properties();\n        Map<String, String> options = catalogTable.getOptions();\n        boolean isInsertDirectory =\n                Boolean.parseBoolean(\n                        options.getOrDefault(\n                                CatalogPropertiesUtil.FLINK_PROPERTY_PREFIX + IS_INSERT_DIRECTORY,\n                                \"false\"));\n        boolean isToLocal = false;\n        if (isInsertDirectory) {\n            isToLocal =\n                    Boolean.parseBoolean(\n                            options.getOrDefault(\n                                    CatalogPropertiesUtil.FLINK_PROPERTY_PREFIX\n                                            + IS_TO_LOCAL_DIRECTORY,\n                                    \"false\"));\n            sd =\n                    org.apache.hadoop.hive.ql.metadata.Table.getEmptyTable(\n                                    identifier.getDatabaseName(), identifier.getObjectName())\n                            .getSd();\n            HiveConf hiveConf = HiveConfUtils.create(jobConf);\n            HiveTableUtil.setDefaultStorageFormatForDirectory(sd, HiveConfUtils.create(jobConf));\n            HiveTableUtil.extractRowFormat(sd, catalogTable.getOptions());\n            HiveTableUtil.extractStoredAs(sd, catalogTable.getOptions(), hiveConf);\n            HiveTableUtil.extractLocation(sd, catalogTable.getOptions());\n            tableProps.putAll(sd.getSerdeInfo().getParameters());\n            tableProps.putAll(catalogTable.getOptions());\n        } else {\n            try (HiveMetastoreClientWrapper client =\n                    HiveMetastoreClientFactory.create(HiveConfUtils.create(jobConf), hiveVersion)) {\n                Table table =\n                        client.getTable(identifier.getDatabaseName(), identifier.getObjectName());\n                sd = table.getSd();\n                tableProps = HiveReflectionUtils.getTableMetadata(hiveShim, table);\n            } catch (TException e) {\n                throw new CatalogException(\"Failed to query Hive metaStore\", e);\n            }\n        }\n\n        try {\n            Class hiveOutputFormatClz =\n                    hiveShim.getHiveOutputFormatClass(Class.forName(sd.getOutputFormat()));\n            boolean isCompressed =\n                    jobConf.getBoolean(HiveConf.ConfVars.COMPRESSRESULT.varname, false);\n            HiveWriterFactory writerFactory =\n                    new HiveWriterFactory(\n                            jobConf,\n                            hiveOutputFormatClz,\n                            sd.getSerdeInfo(),\n                            tableSchema,\n                            getPartitionKeyArray(),\n                            tableProps,\n                            hiveShim,\n                            isCompressed);\n            String extension =\n                    Utilities.getFileExtension(\n                            jobConf,\n                            isCompressed,\n                            (HiveOutputFormat<?, ?>) hiveOutputFormatClz.newInstance());\n\n            OutputFileConfig.OutputFileConfigBuilder fileNamingBuilder =\n                    OutputFileConfig.builder()\n                            .withPartPrefix(\"part-\" + UUID.randomUUID())\n                            .withPartSuffix(extension == null ? \"\" : extension);\n\n            final int parallelism =\n                    Optional.ofNullable(configuredParallelism).orElse(dataStream.getParallelism());\n            if (isBounded) {\n                OutputFileConfig fileNaming = fileNamingBuilder.build();\n                TableMetaStoreFactory msFactory =\n                        isInsertDirectory\n                                ? new EmptyMetaStoreFactory(\n                                        new org.apache.flink.core.fs.Path(sd.getLocation()))\n                                : msFactory(autoGatherStatistic);\n                // default to use the dest location as the parent directory of staging directory\n                String stagingParentDir = sd.getLocation();\n                if (isToLocal) {\n                    // it's for writing to local file system, dest location is a path in local file\n                    // system. we need to know the scratch path for\n                    // non-local file system, so that it'll first write to the scratch path and then\n                    // move to the local path\n                    Path rootScratchDirPath =\n                            new Path(\n                                    HiveConf.getVar(\n                                            HiveConfUtils.create(jobConf),\n                                            HiveConf.ConfVars.SCRATCHDIR));\n                    // TODO: may append something more meaningful than a timestamp, like query ID\n                    Path scratchDir =\n                            new Path(\n                                    rootScratchDirPath, String.valueOf(System.currentTimeMillis()));\n                    stagingParentDir = scratchDir.toUri().toString();\n                }\n                return createBatchSink(\n                        dataStream,\n                        converter,\n                        writerFactory,\n                        msFactory,\n                        fileNaming,\n                        stagingParentDir,\n                        isToLocal,\n                        parallelism);\n            } else {\n                if (overwrite) {\n                    throw new IllegalStateException(\"Streaming mode not support overwrite.\");\n                }\n                return createStreamSink(\n                        providerContext,\n                        dataStream,\n                        sd,\n                        tableProps,\n                        writerFactory,\n                        fileNamingBuilder,\n                        parallelism);\n            }\n        } catch (IOException e) {\n            throw new FlinkRuntimeException(\"Failed to create staging dir\", e);\n        } catch (ClassNotFoundException e) {\n            throw new FlinkHiveException(\"Failed to get output format class\", e);\n        } catch (IllegalAccessException | InstantiationException e) {\n            throw new FlinkHiveException(\"Failed to instantiate output format instance\", e);\n        }\n    }",
          "conflictNames": [
              "providerContext",
              "dataStream",
              "isBounded",
              "converter",
              "sd",
              "tableProps",
              "options",
              "isInsertDirectory",
              "isToLocal",
              "hiveConf",
              "client",
              "table",
              "hiveOutputFormatClz",
              "isCompressed",
              "writerFactory",
              "extension",
              "fileNamingBuilder",
              "fileNaming",
              "msFactory",
              "stagingParentDir",
              "rootScratchDirPath",
              "scratchDir"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/cf358d7d55ca48b9d25e5217006898e3070a85ad^1/flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/connectors/hive/HiveDynamicTableFactory.java",
      "locators": [
          {
              "line": 91,
              "column": 23
          },
          {
              "line": 100,
              "column": 17
          }
      ],
      "old_name": "configuredParallelism",
      "new_name": "configuredSinkParallelism",
      "ctx": {
          "symbolName": "configuredParallelism",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Integer",
          "scopeHint": "in createDynamicTableSink(...)",
          "filePath": "HiveDynamicTableFactory.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public DynamicTableSink createDynamicTableSink(Context context) {\n        final boolean isHiveTable = HiveCatalog.isHiveTable(context.getCatalogTable().getOptions());\n\n        // we don't support temporary hive tables yet\n        if (!isHiveTable || context.isTemporary()) {\n            DynamicTableSink sink =\n                    FactoryUtil.createDynamicTableSink(\n                            null,\n                            context.getObjectIdentifier(),\n                            context.getCatalogTable(),\n                            context.getConfiguration(),\n                            context.getClassLoader(),\n                            context.isTemporary());\n            if (sink instanceof RequireCatalogLock) {\n                ((RequireCatalogLock) sink).setLockFactory(HiveCatalogLock.createFactory(hiveConf));\n            }\n            return sink;\n        }\n\n        final Integer configuredParallelism =\n                Configuration.fromMap(context.getCatalogTable().getOptions())\n                        .get(FileSystemConnectorOptions.SINK_PARALLELISM);\n        final JobConf jobConf = JobConfUtils.createJobConfWithCredentials(hiveConf);\n        return new HiveTableSink(\n                context.getConfiguration(),\n                jobConf,\n                context.getObjectIdentifier(),\n                context.getCatalogTable(),\n                configuredParallelism);\n    }",
          "conflictNames": [
              "context",
              "isHiveTable",
              "sink",
              "jobConf"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/cf4ccb73d945122ec2bb2392bde6fced039975c6^1/flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/connectors/hive/HiveTableSink.java",
      "locators": [
          {
              "line": 304,
              "column": 21
          },
          {
              "line": 341,
              "column": 25
          },
          {
              "line": 354,
              "column": 25
          }
      ],
      "old_name": "sinkParallelismConfigued",
      "new_name": "sinkParallelismConfigured",
      "ctx": {
          "symbolName": "sinkParallelismConfigued",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "boolean",
          "scopeHint": "in consume(...)",
          "filePath": "HiveTableSink.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private DataStreamSink<?> consume(\n            ProviderContext providerContext,\n            DataStream<RowData> dataStream,\n            boolean isBounded,\n            DataStructureConverter converter) {\n        checkAcidTable(catalogTable.getOptions(), identifier.toObjectPath());\n\n        StorageDescriptor sd;\n        Properties tableProps = new Properties();\n        Map<String, String> options = catalogTable.getOptions();\n        boolean isInsertDirectory =\n                Boolean.parseBoolean(\n                        options.getOrDefault(\n                                CatalogPropertiesUtil.FLINK_PROPERTY_PREFIX + IS_INSERT_DIRECTORY,\n                                \"false\"));\n        boolean isToLocal = false;\n        if (isInsertDirectory) {\n            isToLocal =\n                    Boolean.parseBoolean(\n                            options.getOrDefault(\n                                    CatalogPropertiesUtil.FLINK_PROPERTY_PREFIX\n                                            + IS_TO_LOCAL_DIRECTORY,\n                                    \"false\"));\n            sd =\n                    org.apache.hadoop.hive.ql.metadata.Table.getEmptyTable(\n                                    identifier.getDatabaseName(), identifier.getObjectName())\n                            .getSd();\n            HiveConf hiveConf = HiveConfUtils.create(jobConf);\n            HiveTableUtil.setDefaultStorageFormatForDirectory(sd, HiveConfUtils.create(jobConf));\n            HiveTableUtil.extractRowFormat(sd, catalogTable.getOptions());\n            HiveTableUtil.extractStoredAs(sd, catalogTable.getOptions(), hiveConf);\n            HiveTableUtil.extractLocation(sd, catalogTable.getOptions());\n            tableProps.putAll(sd.getSerdeInfo().getParameters());\n            tableProps.putAll(catalogTable.getOptions());\n        } else {\n            try (HiveMetastoreClientWrapper client =\n                    HiveMetastoreClientFactory.create(HiveConfUtils.create(jobConf), hiveVersion)) {\n                Table table =\n                        client.getTable(identifier.getDatabaseName(), identifier.getObjectName());\n                sd = table.getSd();\n                tableProps = HiveReflectionUtils.getTableMetadata(hiveShim, table);\n            } catch (TException e) {\n                throw new CatalogException(\"Failed to query Hive metaStore\", e);\n            }\n        }\n\n        try {\n            Class hiveOutputFormatClz =\n                    hiveShim.getHiveOutputFormatClass(Class.forName(sd.getOutputFormat()));\n            boolean isCompressed =\n                    jobConf.getBoolean(HiveConf.ConfVars.COMPRESSRESULT.varname, false);\n            HiveWriterFactory writerFactory =\n                    new HiveWriterFactory(\n                            jobConf,\n                            hiveOutputFormatClz,\n                            sd.getSerdeInfo(),\n                            tableSchema,\n                            getPartitionKeyArray(),\n                            tableProps,\n                            hiveShim,\n                            isCompressed);\n            String extension =\n                    Utilities.getFileExtension(\n                            jobConf,\n                            isCompressed,\n                            (HiveOutputFormat<?, ?>) hiveOutputFormatClz.newInstance());\n\n            OutputFileConfig.OutputFileConfigBuilder fileNamingBuilder =\n                    OutputFileConfig.builder()\n                            .withPartPrefix(\"part-\" + UUID.randomUUID())\n                            .withPartSuffix(extension == null ? \"\" : extension);\n\n            final int sinkParallelism =\n                    Optional.ofNullable(configuredSinkParallelism)\n                            .orElse(dataStream.getParallelism());\n            boolean sinkParallelismConfigued = configuredSinkParallelism != null;\n            if (isBounded) {\n                TableMetaStoreFactory msFactory =\n                        isInsertDirectory\n                                ? new EmptyMetaStoreFactory(\n                                        new org.apache.flink.core.fs.Path(sd.getLocation()))\n                                : msFactory(autoGatherStatistic);\n                // default to use the dest location as the parent directory of staging directory\n                String stagingParentDir = sd.getLocation();\n                if (isToLocal) {\n                    // it's for writing to local file system, dest location is a path in local file\n                    // system. we need to know the scratch path for\n                    // non-local file system, so that it'll first write to the scratch path and then\n                    // move to the local path\n                    Path rootScratchDirPath =\n                            new Path(\n                                    HiveConf.getVar(\n                                            HiveConfUtils.create(jobConf),\n                                            HiveConf.ConfVars.SCRATCHDIR));\n                    // TODO: may append something more meaningful than a timestamp, like query ID\n                    Path scratchDir =\n                            new Path(\n                                    rootScratchDirPath, String.valueOf(System.currentTimeMillis()));\n                    stagingParentDir = scratchDir.toUri().toString();\n                }\n                return createBatchSink(\n                        dataStream,\n                        converter,\n                        writerFactory,\n                        msFactory,\n                        fileNamingBuilder,\n                        stagingParentDir,\n                        sd,\n                        tableProps,\n                        isToLocal,\n                        overwrite,\n                        sinkParallelism,\n                        sinkParallelismConfigued);\n            } else {\n                if (overwrite) {\n                    throw new IllegalStateException(\"Streaming mode not support overwrite.\");\n                }\n                return createStreamSink(\n                        providerContext,\n                        dataStream,\n                        sd,\n                        tableProps,\n                        writerFactory,\n                        fileNamingBuilder,\n                        sinkParallelism,\n                        sinkParallelismConfigued);\n            }\n        } catch (IOException e) {\n            throw new FlinkRuntimeException(\"Failed to create staging dir\", e);\n        } catch (ClassNotFoundException e) {\n            throw new FlinkHiveException(\"Failed to get output format class\", e);\n        } catch (IllegalAccessException | InstantiationException e) {\n            throw new FlinkHiveException(\"Failed to instantiate output format instance\", e);\n        }\n    }",
          "conflictNames": [
              "providerContext",
              "dataStream",
              "isBounded",
              "converter",
              "sd",
              "tableProps",
              "options",
              "isInsertDirectory",
              "isToLocal",
              "hiveConf",
              "client",
              "table",
              "hiveOutputFormatClz",
              "isCompressed",
              "writerFactory",
              "extension",
              "fileNamingBuilder",
              "sinkParallelism",
              "msFactory",
              "stagingParentDir",
              "rootScratchDirPath",
              "scratchDir"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d033f64b41f1d11edd22b2d70699dac7822abfe5^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolServiceTest.java",
      "locators": [
          {
              "line": 212,
              "column": 33
          },
          {
              "line": 214,
              "column": 78
          },
          {
              "line": 229,
              "column": 61
          },
          {
              "line": 231,
              "column": 56
          }
      ],
      "old_name": "simpleSlotContext2",
      "new_name": "testingPhysicalSlot2",
      "ctx": {
          "symbolName": "simpleSlotContext2",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SimpleSlotContext",
          "scopeHint": "in testCreateAllocatedSlotReport(...)",
          "filePath": "DeclarativeSlotPoolServiceTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testCreateAllocatedSlotReport() throws Exception {\n        final LocalTaskManagerLocation taskManagerLocation1 = new LocalTaskManagerLocation();\n        final LocalTaskManagerLocation taskManagerLocation2 = new LocalTaskManagerLocation();\n        final SimpleSlotContext simpleSlotContext2 = createSimpleSlotContext(taskManagerLocation2);\n        final Collection<SlotInfo> slotInfos =\n                Arrays.asList(createSimpleSlotContext(taskManagerLocation1), simpleSlotContext2);\n        try (DeclarativeSlotPoolService declarativeSlotPoolService =\n                createDeclarativeSlotPoolService(\n                        new TestingDeclarativeSlotPoolFactory(\n                                new TestingDeclarativeSlotPoolBuilder()\n                                        .setGetAllSlotsInformationSupplier(() -> slotInfos)))) {\n\n            final AllocatedSlotReport allocatedSlotReport =\n                    declarativeSlotPoolService.createAllocatedSlotReport(\n                            taskManagerLocation2.getResourceID());\n\n            assertThat(allocatedSlotReport.getAllocatedSlotInfos())\n                    .allMatch(\n                            context ->\n                                    context.getAllocationId()\n                                                    .equals(simpleSlotContext2.getAllocationId())\n                                            && context.getSlotIndex()\n                                                    == simpleSlotContext2.getPhysicalSlotNumber());\n        }\n    }",
          "conflictNames": [
              "taskManagerLocation1",
              "taskManagerLocation2",
              "slotInfos",
              "declarativeSlotPoolService",
              "allocatedSlotReport"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d033f64b41f1d11edd22b2d70699dac7822abfe5^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultAllocatedSlotPoolTest.java",
      "locators": [
          {
              "line": 226,
              "column": 29
          },
          {
              "line": 228,
              "column": 20
          },
          {
              "line": 232,
              "column": 49
          },
          {
              "line": 233,
              "column": 57
          },
          {
              "line": 240,
              "column": 13
          },
          {
              "line": 244,
              "column": 24
          },
          {
              "line": 248,
              "column": 53
          },
          {
              "line": 249,
              "column": 61
          }
      ],
      "old_name": "freeSlotInfoTracker",
      "new_name": "freeSlotTracker",
      "ctx": {
          "symbolName": "freeSlotInfoTracker",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "FreeSlotInfoTracker",
          "scopeHint": "in testSlotUtilizationCalculation(...)",
          "filePath": "DefaultAllocatedSlotPoolTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testSlotUtilizationCalculation() {\n        final DefaultAllocatedSlotPool slotPool = new DefaultAllocatedSlotPool();\n        final ResourceID owner = ResourceID.generate();\n        final Collection<AllocatedSlot> slots = createAllocatedSlotsWithOwner(owner);\n\n        slotPool.addSlots(slots, 0);\n\n        FreeSlotInfoTracker freeSlotInfoTracker = slotPool.getFreeSlotInfoTracker();\n\n        assertThat(freeSlotInfoTracker.getAvailableSlots())\n                .allSatisfy(\n                        allocationId ->\n                                assertThat(\n                                                freeSlotInfoTracker.getTaskExecutorUtilization(\n                                                        freeSlotInfoTracker.getSlotInfo(\n                                                                allocationId)))\n                                        .isCloseTo(0, offset(0.1)));\n\n        int numAllocatedSlots = 0;\n        for (AllocatedSlot slot : slots) {\n            assertThat(slotPool.reserveFreeSlot(slot.getAllocationId())).isEqualTo(slot);\n            freeSlotInfoTracker.reserveSlot(slot.getAllocationId());\n            numAllocatedSlots++;\n            final double utilization = (double) numAllocatedSlots / slots.size();\n\n            assertThat(freeSlotInfoTracker.getAvailableSlots())\n                    .allSatisfy(\n                            allocationId ->\n                                    assertThat(\n                                                    freeSlotInfoTracker.getTaskExecutorUtilization(\n                                                            freeSlotInfoTracker.getSlotInfo(\n                                                                    allocationId)))\n                                            .isCloseTo(utilization, offset(0.1)));\n        }\n    }",
          "conflictNames": [
              "slotPool",
              "owner",
              "slots",
              "numAllocatedSlots",
              "utilization"
          ]
      },
      "suggestions": [
          {
              "name": "freeSlotTracker",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/d033f64b41f1d11edd22b2d70699dac7822abfe5^1/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotProviderImpl.java",
      "locators": [
          {
              "line": 113,
              "column": 29
          },
          {
              "line": 119,
              "column": 29
          },
          {
              "line": 124,
              "column": 33
          }
      ],
      "old_name": "freeSlotInfoTracker",
      "new_name": "freeSlotTracker",
      "ctx": {
          "symbolName": "freeSlotInfoTracker",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "FreeSlotInfoTracker",
          "scopeHint": "in tryAllocateFromAvailable(...)",
          "filePath": "PhysicalSlotProviderImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private Map<SlotRequestId, Optional<PhysicalSlot>> tryAllocateFromAvailable(\n            Collection<PhysicalSlotRequest> slotRequests) {\n        FreeSlotInfoTracker freeSlotInfoTracker = slotPool.getFreeSlotInfoTracker();\n\n        Map<SlotRequestId, Optional<PhysicalSlot>> allocateResult = new HashMap<>();\n        for (PhysicalSlotRequest request : slotRequests) {\n            Optional<SlotSelectionStrategy.SlotInfoAndLocality> slot =\n                    slotSelectionStrategy.selectBestSlotForProfile(\n                            freeSlotInfoTracker, request.getSlotProfile());\n            allocateResult.put(\n                    request.getSlotRequestId(),\n                    slot.flatMap(\n                            slotInfoAndLocality -> {\n                                freeSlotInfoTracker.reserveSlot(\n                                        slotInfoAndLocality.getSlotInfo().getAllocationId());\n                                return slotPool.allocateAvailableSlot(\n                                        request.getSlotRequestId(),\n                                        slotInfoAndLocality.getSlotInfo().getAllocationId(),\n                                        request.getSlotProfile().getPhysicalSlotResourceProfile());\n                            }));\n        }\n        return allocateResult;\n    }",
          "conflictNames": [
              "slotRequests",
              "allocateResult",
              "slot"
          ]
      },
      "suggestions": [
          {
              "name": "freeSlotTracker",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/d033f64b41f1d11edd22b2d70699dac7822abfe5^1/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultFreeSlotInfoTracker.java",
      "locators": [
          {
              "line": 89,
              "column": 27
          },
          {
              "line": 95,
              "column": 17
          }
      ],
      "old_name": "freeSlotInfoTrackerWithoutBlockedSlots",
      "new_name": "freeSlotTrackerWithoutBlockedSlots",
      "ctx": {
          "symbolName": "freeSlotInfoTrackerWithoutBlockedSlots",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Set<AllocationID>",
          "scopeHint": "in createNewFreeSlotInfoTrackerWithoutBlockedSlots(...)",
          "filePath": "DefaultFreeSlotInfoTracker.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public DefaultFreeSlotInfoTracker createNewFreeSlotInfoTrackerWithoutBlockedSlots(\n            Set<AllocationID> blockedSlots) {\n\n        Set<AllocationID> freeSlotInfoTrackerWithoutBlockedSlots =\n                freeSlots.stream()\n                        .filter(slot -> !blockedSlots.contains(slot))\n                        .collect(Collectors.toSet());\n\n        return new DefaultFreeSlotInfoTracker(\n                freeSlotInfoTrackerWithoutBlockedSlots,\n                slotInfoLookup,\n                freeSlotInfoLookup,\n                taskExecutorUtilizationLookup);\n    }",
          "conflictNames": [
              "blockedSlots"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d033f64b41f1d11edd22b2d70699dac7822abfe5^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultFreeSlotInfoTrackerTest.java",
      "locators": [
          {
              "line": 46,
              "column": 24
          },
          {
              "line": 50,
              "column": 19
          },
          {
              "line": 50,
              "column": 48
          },
          {
              "line": 64,
              "column": 32
          },
          {
              "line": 70,
              "column": 24
          },
          {
              "line": 74,
              "column": 19
          },
          {
              "line": 74,
              "column": 48
          },
          {
              "line": 85,
              "column": 41
          }
      ],
      "old_name": "slotInfo1",
      "new_name": "slot1",
      "ctx": {
          "symbolName": "slotInfo1",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SlotInfo",
          "scopeHint": "in testReserveSlot(...)",
          "filePath": "DefaultFreeSlotInfoTrackerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testReserveSlot() {\n        final ResourceID resourceId = ResourceID.generate();\n        final SlotInfo slotInfo1 = createAllocatedSlot(resourceId);\n        final SlotInfo slotInfo2 = createAllocatedSlot(resourceId);\n        final Map<AllocationID, SlotInfo> slots = new HashMap<>();\n\n        slots.put(slotInfo1.getAllocationId(), slotInfo1);\n        slots.put(slotInfo2.getAllocationId(), slotInfo2);\n\n        final FreeSlotInfoTracker freeSlotInfoTracker =\n                FreeSlotInfoTrackerTestUtils.createDefaultFreeSlotInfoTracker(slots);\n        for (AllocationID candidate : freeSlotInfoTracker.getAvailableSlots()) {\n            SlotInfo selectSlot = freeSlotInfoTracker.getSlotInfo(candidate);\n            assertThat(slots.get(selectSlot.getAllocationId())).isEqualTo(selectSlot);\n            freeSlotInfoTracker.reserveSlot(selectSlot.getAllocationId());\n            break;\n        }\n\n        assertThat(freeSlotInfoTracker.getAvailableSlots())\n                .hasSize(1)\n                .containsAnyOf(slotInfo1.getAllocationId(), slotInfo2.getAllocationId());\n    }",
          "conflictNames": [
              "resourceId",
              "slotInfo2",
              "slots",
              "freeSlotInfoTracker",
              "selectSlot"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d033f64b41f1d11edd22b2d70699dac7822abfe5^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultFreeSlotInfoTrackerTest.java",
      "locators": [
          {
              "line": 47,
              "column": 24
          },
          {
              "line": 51,
              "column": 19
          },
          {
              "line": 51,
              "column": 48
          },
          {
              "line": 64,
              "column": 61
          },
          {
              "line": 71,
              "column": 24
          },
          {
              "line": 75,
              "column": 19
          },
          {
              "line": 75,
              "column": 48
          },
          {
              "line": 85,
              "column": 70
          }
      ],
      "old_name": "slotInfo2",
      "new_name": "slot2",
      "ctx": {
          "symbolName": "slotInfo2",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SlotInfo",
          "scopeHint": "in testReserveSlot(...)",
          "filePath": "DefaultFreeSlotInfoTrackerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testReserveSlot() {\n        final ResourceID resourceId = ResourceID.generate();\n        final SlotInfo slotInfo1 = createAllocatedSlot(resourceId);\n        final SlotInfo slotInfo2 = createAllocatedSlot(resourceId);\n        final Map<AllocationID, SlotInfo> slots = new HashMap<>();\n\n        slots.put(slotInfo1.getAllocationId(), slotInfo1);\n        slots.put(slotInfo2.getAllocationId(), slotInfo2);\n\n        final FreeSlotInfoTracker freeSlotInfoTracker =\n                FreeSlotInfoTrackerTestUtils.createDefaultFreeSlotInfoTracker(slots);\n        for (AllocationID candidate : freeSlotInfoTracker.getAvailableSlots()) {\n            SlotInfo selectSlot = freeSlotInfoTracker.getSlotInfo(candidate);\n            assertThat(slots.get(selectSlot.getAllocationId())).isEqualTo(selectSlot);\n            freeSlotInfoTracker.reserveSlot(selectSlot.getAllocationId());\n            break;\n        }\n\n        assertThat(freeSlotInfoTracker.getAvailableSlots())\n                .hasSize(1)\n                .containsAnyOf(slotInfo1.getAllocationId(), slotInfo2.getAllocationId());\n    }",
          "conflictNames": [
              "resourceId",
              "slotInfo1",
              "slots",
              "freeSlotInfoTracker",
              "selectSlot"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d033f64b41f1d11edd22b2d70699dac7822abfe5^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultFreeSlotInfoTrackerTest.java",
      "locators": [
          {
              "line": 53,
              "column": 35
          },
          {
              "line": 55,
              "column": 39
          },
          {
              "line": 56,
              "column": 35
          },
          {
              "line": 58,
              "column": 13
          },
          {
              "line": 62,
              "column": 20
          },
          {
              "line": 77,
              "column": 35
          },
          {
              "line": 79,
              "column": 20
          },
          {
              "line": 81,
              "column": 35
          },
          {
              "line": 82,
              "column": 17
          },
          {
              "line": 86,
              "column": 20
          }
      ],
      "old_name": "freeSlotInfoTracker",
      "new_name": "freeSlotTracker",
      "ctx": {
          "symbolName": "freeSlotInfoTracker",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "FreeSlotInfoTracker",
          "scopeHint": "in testReserveSlot(...)",
          "filePath": "DefaultFreeSlotInfoTrackerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testReserveSlot() {\n        final ResourceID resourceId = ResourceID.generate();\n        final SlotInfo slotInfo1 = createAllocatedSlot(resourceId);\n        final SlotInfo slotInfo2 = createAllocatedSlot(resourceId);\n        final Map<AllocationID, SlotInfo> slots = new HashMap<>();\n\n        slots.put(slotInfo1.getAllocationId(), slotInfo1);\n        slots.put(slotInfo2.getAllocationId(), slotInfo2);\n\n        final FreeSlotInfoTracker freeSlotInfoTracker =\n                FreeSlotInfoTrackerTestUtils.createDefaultFreeSlotInfoTracker(slots);\n        for (AllocationID candidate : freeSlotInfoTracker.getAvailableSlots()) {\n            SlotInfo selectSlot = freeSlotInfoTracker.getSlotInfo(candidate);\n            assertThat(slots.get(selectSlot.getAllocationId())).isEqualTo(selectSlot);\n            freeSlotInfoTracker.reserveSlot(selectSlot.getAllocationId());\n            break;\n        }\n\n        assertThat(freeSlotInfoTracker.getAvailableSlots())\n                .hasSize(1)\n                .containsAnyOf(slotInfo1.getAllocationId(), slotInfo2.getAllocationId());\n    }",
          "conflictNames": [
              "resourceId",
              "slotInfo1",
              "slotInfo2",
              "slots",
              "selectSlot"
          ]
      },
      "suggestions": [
          {
              "name": "freeSlotTracker",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/d033f64b41f1d11edd22b2d70699dac7822abfe5^1/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultFreeSlotInfoTrackerTest.java",
      "locators": [
          {
              "line": 81,
              "column": 35
          },
          {
              "line": 86,
              "column": 20
          }
      ],
      "old_name": "freeSlotInfoTrackerWithoutBlockedSlots",
      "new_name": "freeSlotTrackerWithoutBlockedSlots",
      "ctx": {
          "symbolName": "freeSlotInfoTrackerWithoutBlockedSlots",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "FreeSlotInfoTracker",
          "scopeHint": "in testCreatedFreeSlotInfoTrackerWithoutBlockedSlots(...)",
          "filePath": "DefaultFreeSlotInfoTrackerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testCreatedFreeSlotInfoTrackerWithoutBlockedSlots() {\n        final ResourceID resourceId = ResourceID.generate();\n        final SlotInfo slotInfo1 = createAllocatedSlot(resourceId);\n        final SlotInfo slotInfo2 = createAllocatedSlot(resourceId);\n        final Map<AllocationID, SlotInfo> slots = new HashMap<>();\n\n        slots.put(slotInfo1.getAllocationId(), slotInfo1);\n        slots.put(slotInfo2.getAllocationId(), slotInfo2);\n\n        final FreeSlotInfoTracker freeSlotInfoTracker =\n                FreeSlotInfoTrackerTestUtils.createDefaultFreeSlotInfoTracker(slots);\n        assertThat(freeSlotInfoTracker.getAvailableSlots()).hasSize(2);\n\n        final FreeSlotInfoTracker freeSlotInfoTrackerWithoutBlockedSlots =\n                freeSlotInfoTracker.createNewFreeSlotInfoTrackerWithoutBlockedSlots(\n                        new HashSet<>(\n                                Arrays.asList(\n                                        slotInfo1.getAllocationId(), slotInfo2.getAllocationId())));\n        assertThat(freeSlotInfoTrackerWithoutBlockedSlots.getAvailableSlots()).isEmpty();\n    }",
          "conflictNames": [
              "resourceId",
              "slotInfo1",
              "slotInfo2",
              "slots",
              "freeSlotInfoTracker"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d04405c0f6ef0c661909935a1a3fb0b1c79d2540^1/flink-table/flink-table-api-java-bridge/src/main/java/org/apache/flink/connector/datagen/table/RandomGeneratorVisitor.java",
      "locators": [
          {
              "line": 345,
              "column": 30
          },
          {
              "line": 346,
              "column": 9
          },
          {
              "line": 356,
              "column": 17
          },
          {
              "line": 371,
              "column": 27
          },
          {
              "line": 382,
              "column": 76
          }
      ],
      "old_name": "options",
      "new_name": "fieldOptions",
      "ctx": {
          "symbolName": "options",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Set<ConfigOption<?>>",
          "scopeHint": "in visit(...)",
          "filePath": "RandomGeneratorVisitor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public DataGeneratorContainer visit(MapType mapType) {\n        ConfigOption<Integer> lenOption =\n                key(DataGenConnectorOptionsUtil.FIELDS\n                                + \".\"\n                                + name\n                                + \".\"\n                                + DataGenConnectorOptionsUtil.LENGTH)\n                        .intType()\n                        .defaultValue(RANDOM_COLLECTION_LENGTH_DEFAULT);\n\n        String keyName = name + \".\" + \"key\";\n        String valName = name + \".\" + \"value\";\n\n        DataGeneratorContainer keyContainer =\n                mapType.getKeyType().accept(new RandomGeneratorVisitor(keyName, config));\n\n        DataGeneratorContainer valContainer =\n                mapType.getValueType().accept(new RandomGeneratorVisitor(valName, config));\n\n        Set<ConfigOption<?>> options = keyContainer.getOptions();\n        options.addAll(valContainer.getOptions());\n\n        DataGenerator<Map<Object, Object>> mapGenerator =\n                RandomGenerator.mapGenerator(\n                        keyContainer.getGenerator(),\n                        valContainer.getGenerator(),\n                        config.get(lenOption));\n\n        return DataGeneratorContainer.of(\n                new DataGeneratorMapper<>(mapGenerator, GenericMapData::new),\n                options.toArray(new ConfigOption<?>[0]));\n    }",
          "conflictNames": [
              "mapType",
              "lenOption",
              "keyName",
              "valName",
              "keyContainer",
              "valContainer",
              "mapGenerator"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d11cc32948b7165a8dc49d8e1828dc9b9044bf25^1/flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBStateDownloaderTest.java",
      "locators": [
          {
              "line": 60,
              "column": 28
          },
          {
              "line": 62,
              "column": 65
          },
          {
              "line": 85,
              "column": 26
          },
          {
              "line": 171,
              "column": 35
          },
          {
              "line": 173,
              "column": 49
          },
          {
              "line": 174,
              "column": 18
          },
          {
              "line": 174,
              "column": 38
          },
          {
              "line": 179,
              "column": 19
          }
      ],
      "old_name": "expectedException",
      "new_name": "expectedCause",
      "ctx": {
          "symbolName": "expectedException",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SpecifiedException",
          "scopeHint": "in testMultiThreadRestoreThreadPoolExceptionRethrow(...)",
          "filePath": "RocksDBStateDownloaderTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Test that the exception arose in the thread pool will rethrow to the main thread. */\n    @Test\n    public void testMultiThreadRestoreThreadPoolExceptionRethrow() {\n        SpecifiedException expectedException =\n                new SpecifiedException(\"throw exception while multi thread restore.\");\n        StreamStateHandle stateHandle = new ThrowingStateHandle(expectedException);\n\n        Map<StateHandleID, StreamStateHandle> stateHandles = new HashMap<>(1);\n        stateHandles.put(new StateHandleID(\"state1\"), stateHandle);\n\n        IncrementalRemoteKeyedStateHandle incrementalKeyedStateHandle =\n                new IncrementalRemoteKeyedStateHandle(\n                        UUID.randomUUID(),\n                        KeyGroupRange.EMPTY_KEY_GROUP_RANGE,\n                        1,\n                        stateHandles,\n                        stateHandles,\n                        stateHandle);\n\n        try (RocksDBStateDownloader rocksDBStateDownloader = new RocksDBStateDownloader(5)) {\n            rocksDBStateDownloader.transferAllStateDataToDirectory(\n                    Collections.singletonList(\n                            new StateHandleDownloadSpec(\n                                    incrementalKeyedStateHandle,\n                                    temporaryFolder.newFolder().toPath())),\n                    new CloseableRegistry());\n            fail();\n        } catch (Exception e) {\n            assertEquals(expectedException, e);\n        }\n    }",
          "conflictNames": [
              "stateHandle",
              "stateHandles",
              "incrementalKeyedStateHandle",
              "rocksDBStateDownloader"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d18a4bfe596fc580f8280750fa3bfa22007671d9^1/flink-runtime/src/test/java/org/apache/flink/runtime/deployment/CachedShuffleDescriptorsTest.java",
      "locators": [
          {
              "line": 160,
              "column": 46
          },
          {
              "line": 163,
              "column": 17
          }
      ],
      "old_name": "nonOffloaded",
      "new_name": "nonOffloadedRaw",
      "ctx": {
          "symbolName": "nonOffloaded",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "NonOffloaded<ShuffleDescriptorGroup>",
          "scopeHint": "in assertNonOffloadedShuffleDescriptorAndIndexEquals(...)",
          "filePath": "CachedShuffleDescriptorsTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void assertNonOffloadedShuffleDescriptorAndIndexEquals(\n            MaybeOffloaded<ShuffleDescriptorGroup> maybeOffloaded,\n            List<ShuffleDescriptor> expectedDescriptors,\n            List<Integer> expectedIndices)\n            throws Exception {\n        assertThat(expectedDescriptors).hasSameSizeAs(expectedIndices);\n        assertThat(maybeOffloaded).isInstanceOf(NonOffloaded.class);\n        NonOffloaded<ShuffleDescriptorGroup> nonOffloaded =\n                (NonOffloaded<ShuffleDescriptorGroup>) maybeOffloaded;\n        ShuffleDescriptorAndIndex[] shuffleDescriptorAndIndices =\n                nonOffloaded\n                        .serializedValue\n                        .deserializeValue(getClass().getClassLoader())\n                        .getShuffleDescriptors();\n        assertThat(shuffleDescriptorAndIndices).hasSameSizeAs(expectedDescriptors);\n        for (int i = 0; i < shuffleDescriptorAndIndices.length; i++) {\n            assertThat(shuffleDescriptorAndIndices[i].getIndex()).isEqualTo(expectedIndices.get(i));\n            assertThat(shuffleDescriptorAndIndices[i].getShuffleDescriptor().getResultPartitionID())\n                    .isEqualTo(expectedDescriptors.get(i).getResultPartitionID());\n        }\n    }",
          "conflictNames": [
              "maybeOffloaded",
              "expectedDescriptors",
              "expectedIndices",
              "shuffleDescriptorAndIndices",
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d18a4bfe596fc580f8280750fa3bfa22007671d9^1/flink-runtime/src/main/java/org/apache/flink/runtime/deployment/InputGateDeploymentDescriptor.java",
      "locators": [
          {
              "line": 151,
              "column": 61
          },
          {
              "line": 154,
              "column": 29
          },
          {
              "line": 157,
              "column": 68
          },
          {
              "line": 179,
              "column": 57
          },
          {
              "line": 182,
              "column": 45
          },
          {
              "line": 192,
              "column": 52
          },
          {
              "line": 195,
              "column": 13
          },
          {
              "line": 197,
              "column": 58
          },
          {
              "line": 217,
              "column": 60
          }
      ],
      "old_name": "serializedShuffleDescriptors",
      "new_name": "rawShuffleDescriptors",
      "ctx": {
          "symbolName": "serializedShuffleDescriptors",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "MaybeOffloaded<ShuffleDescriptorGroup>",
          "scopeHint": "in getShuffleDescriptors(...)",
          "filePath": "InputGateDeploymentDescriptor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "ion environment we always call\n            // tryLoadAndDeserializeShuffleDescriptors to deserialize ShuffleDescriptors first.\n            inputChannels = new ShuffleDescriptor[numberOfInputChannels];\n            try {\n                for (MaybeOffloaded<ShuffleDescriptorGroup> serializedShuffleDescriptors :\n                        serializedInputChannels) {\n                    checkState(\n                            serializedShuffleDescriptors instanceof NonOffloaded,\n                            \"Trying to work with offloaded serialized sh",
          "conflictNames": [
              "nonOffloadedSerializedValue"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d18a4bfe596fc580f8280750fa3bfa22007671d9^1/flink-runtime/src/main/java/org/apache/flink/runtime/deployment/InputGateDeploymentDescriptor.java",
      "locators": [
          {
              "line": 156,
              "column": 58
          },
          {
              "line": 158,
              "column": 58
          },
          {
              "line": 216,
              "column": 50
          },
          {
              "line": 218,
              "column": 50
          }
      ],
      "old_name": "nonOffloadedSerializedValue",
      "new_name": "nonOffloadedRawValue",
      "ctx": {
          "symbolName": "nonOffloadedSerializedValue",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "NonOffloaded<ShuffleDescriptorGroup>",
          "scopeHint": "in getShuffleDescriptors(...)",
          "filePath": "InputGateDeploymentDescriptor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public ShuffleDescriptor[] getShuffleDescriptors() {\n        if (inputChannels == null) {\n            // This is only for testing scenarios, in a production environment we always call\n            // tryLoadAndDeserializeShuffleDescriptors to deserialize ShuffleDescriptors first.\n            inputChannels = new ShuffleDescriptor[numberOfInputChannels];\n            try {\n                for (MaybeOffloaded<ShuffleDescriptorGroup> serializedShuffleDescriptors :\n                        serializedInputChannels) {\n                    checkState(\n                            serializedShuffleDescriptors instanceof NonOffloaded,\n                            \"Trying to work with offloaded serialized shuffle descriptors.\");\n                    NonOffloaded<ShuffleDescriptorGroup> nonOffloadedSerializedValue =\n                            (NonOffloaded<ShuffleDescriptorGroup>) serializedShuffleDescriptors;\n                    tryDeserializeShuffleDescriptorGroup(nonOffloadedSerializedValue);\n                }\n            } catch (ClassNotFoundException | IOException e) {\n                throw new RuntimeException(\"Could not deserialize shuffle descriptors.\", e);\n            }\n        }\n        return inputChannels;\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d18a4bfe596fc580f8280750fa3bfa22007671d9^1/flink-runtime/src/main/java/org/apache/flink/runtime/deployment/TaskDeploymentDescriptorFactory.java",
      "locators": [
          {
              "line": 497,
              "column": 21
          },
          {
              "line": 505,
              "column": 17
          },
          {
              "line": 506,
              "column": 68
          },
          {
              "line": 508,
              "column": 65
          }
      ],
      "old_name": "serializedValueOrBlobKey",
      "new_name": "rawValueOrBlobKey",
      "ctx": {
          "symbolName": "serializedValueOrBlobKey",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Either<SerializedValue<ShuffleDescriptorGroup>, PermanentBlobKey>",
          "scopeHint": "in serializeAndTryOffloadShuffleDescriptor(...)",
          "filePath": "TaskDeploymentDescriptorFactory.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public MaybeOffloaded<ShuffleDescriptorGroup> serializeAndTryOffloadShuffleDescriptor(\n                ShuffleDescriptorGroup shuffleDescriptorGroup, int numConsumer) throws IOException {\n\n            final CompressedSerializedValue<ShuffleDescriptorGroup> compressedSerializedValue =\n                    CompressedSerializedValue.fromObject(shuffleDescriptorGroup);\n\n            final Either<SerializedValue<ShuffleDescriptorGroup>, PermanentBlobKey>\n                    serializedValueOrBlobKey =\n                            shouldOffload(\n                                            shuffleDescriptorGroup.getShuffleDescriptors(),\n                                            numConsumer)\n                                    ? BlobWriter.offloadWithException(\n                                            compressedSerializedValue, jobID, blobWriter)\n                                    : Either.Left(compressedSerializedValue);\n\n            if (serializedValueOrBlobKey.isLeft()) {\n                return new TaskDeploymentDescriptor.NonOffloaded<>(serializedValueOrBlobKey.left());\n            } else {\n                return new TaskDeploymentDescriptor.Offloaded<>(serializedValueOrBlobKey.right());\n            }\n        }",
          "conflictNames": [
              "shuffleDescriptorGroup",
              "numConsumer",
              "compressedSerializedValue"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d1b8db8443c8c7201f45fc1b53c3287fc5521a8f^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/JoinToMultiJoinRule.java",
      "locators": [
          {
              "line": 310,
              "column": 29
          },
          {
              "line": 311,
              "column": 33
          },
          {
              "line": 312,
              "column": 31
          },
          {
              "line": 313,
              "column": 36
          },
          {
              "line": 315,
              "column": 25
          }
      ],
      "old_name": "leftMultiJoin",
      "new_name": "multiJoin",
      "ctx": {
          "symbolName": "leftMultiJoin",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "MultiJoin",
          "scopeHint": "in combineInputs(...)",
          "filePath": "JoinToMultiJoinRule.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Combines the inputs into a LogicalJoin into an array of inputs.\n     *\n     * @param join original join\n     * @param left left input into join\n     * @param right right input into join\n     * @param projFieldsList returns a list of the new combined projection fields\n     * @param joinFieldRefCountsList returns a list of the new combined join field reference counts\n     * @return combined left and right inputs in an array\n     */\n    private List<RelNode> combineInputs(\n            Join join,\n            RelNode left,\n            RelNode right,\n            List<ImmutableBitSet> projFieldsList,\n            List<int[]> joinFieldRefCountsList,\n            List<Boolean> inputNullGenFieldList) {\n        final List<RelNode> newInputs = new ArrayList<>();\n        // Leave the null generating sides of an outer join intact; don't pull up those children\n        // inputs into the array we're constructing.\n        JoinInfo joinInfo = join.analyzeCondition();\n        ImmutableIntList leftKeys = joinInfo.leftKeys;\n        ImmutableIntList rightKeys = joinInfo.rightKeys;\n\n        if (canCombine(left, join)) {\n            final MultiJoin leftMultiJoin = (MultiJoin) left;\n            for (int i = 0; i < leftMultiJoin.getInputs().size(); i++) {\n                newInputs.add(leftMultiJoin.getInput(i));\n                projFieldsList.add(leftMultiJoin.getProjFields().get(i));\n                joinFieldRefCountsList.add(\n                        leftMultiJoin.getJoinFieldRefCountsMap().get(i).toIntArray());\n            }\n\n        } else {\n            newInputs.add(left);\n            projFieldsList.add(null);\n            joinFieldRefCountsList.add(new int[left.getRowType().getFieldCount()]);\n        }\n\n        if (canCombine(right, join)) {\n            final MultiJoin rightMultiJoin = (MultiJoin) right;\n            for (int i = 0; i < rightMultiJoin.getInputs().size(); i++) {\n                newInputs.add(rightMultiJoin.getInput(i));\n                projFieldsList.add(rightMultiJoin.getProjFields().get(i));\n                joinFieldRefCountsList.add(\n                        rightMultiJoin.getJoinFieldRefCountsMap().get(i).toIntArray());\n            }\n        } else {\n            newInputs.add(right);\n            projFieldsList.add(null);\n            joinFieldRefCountsList.add(new int[right.getRowType().getFieldCount()]);\n        }\n\n        return newInputs;\n    }",
          "conflictNames": [
              "join",
              "left",
              "right",
              "projFieldsList",
              "joinFieldRefCountsList",
              "inputNullGenFieldList",
              "newInputs",
              "joinInfo",
              "leftKeys",
              "rightKeys",
              "i",
              "rightMultiJoin"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d1b8db8443c8c7201f45fc1b53c3287fc5521a8f^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/JoinToMultiJoinRule.java",
      "locators": [
          {
              "line": 325,
              "column": 29
          },
          {
              "line": 326,
              "column": 33
          },
          {
              "line": 327,
              "column": 31
          },
          {
              "line": 328,
              "column": 36
          },
          {
              "line": 330,
              "column": 25
          }
      ],
      "old_name": "rightMultiJoin",
      "new_name": "multiJoin",
      "ctx": {
          "symbolName": "rightMultiJoin",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "MultiJoin",
          "scopeHint": "in combineInputs(...)",
          "filePath": "JoinToMultiJoinRule.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Combines the inputs into a LogicalJoin into an array of inputs.\n     *\n     * @param join original join\n     * @param left left input into join\n     * @param right right input into join\n     * @param projFieldsList returns a list of the new combined projection fields\n     * @param joinFieldRefCountsList returns a list of the new combined join field reference counts\n     * @return combined left and right inputs in an array\n     */\n    private List<RelNode> combineInputs(\n            Join join,\n            RelNode left,\n            RelNode right,\n            List<ImmutableBitSet> projFieldsList,\n            List<int[]> joinFieldRefCountsList,\n            List<Boolean> inputNullGenFieldList) {\n        final List<RelNode> newInputs = new ArrayList<>();\n        // Leave the null generating sides of an outer join intact; don't pull up those children\n        // inputs into the array we're constructing.\n        JoinInfo joinInfo = join.analyzeCondition();\n        ImmutableIntList leftKeys = joinInfo.leftKeys;\n        ImmutableIntList rightKeys = joinInfo.rightKeys;\n\n        if (canCombine(left, join)) {\n            final MultiJoin leftMultiJoin = (MultiJoin) left;\n            for (int i = 0; i < leftMultiJoin.getInputs().size(); i++) {\n                newInputs.add(leftMultiJoin.getInput(i));\n                projFieldsList.add(leftMultiJoin.getProjFields().get(i));\n                joinFieldRefCountsList.add(\n                        leftMultiJoin.getJoinFieldRefCountsMap().get(i).toIntArray());\n            }\n\n        } else {\n            newInputs.add(left);\n            projFieldsList.add(null);\n            joinFieldRefCountsList.add(new int[left.getRowType().getFieldCount()]);\n        }\n\n        if (canCombine(right, join)) {\n            final MultiJoin rightMultiJoin = (MultiJoin) right;\n            for (int i = 0; i < rightMultiJoin.getInputs().size(); i++) {\n                newInputs.add(rightMultiJoin.getInput(i));\n                projFieldsList.add(rightMultiJoin.getProjFields().get(i));\n                joinFieldRefCountsList.add(\n                        rightMultiJoin.getJoinFieldRefCountsMap().get(i).toIntArray());\n            }\n        } else {\n            newInputs.add(right);\n            projFieldsList.add(null);\n            joinFieldRefCountsList.add(new int[right.getRowType().getFieldCount()]);\n        }\n\n        return newInputs;\n    }",
          "conflictNames": [
              "join",
              "left",
              "right",
              "projFieldsList",
              "joinFieldRefCountsList",
              "inputNullGenFieldList",
              "newInputs",
              "joinInfo",
              "leftKeys",
              "rightKeys",
              "leftMultiJoin",
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d343a0bc79b0c85c845d0011d29404567f28dd0a^1/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/collect/CollectSinkOperatorCoordinatorTest.java",
      "locators": [
          {
              "line": 62,
              "column": 22
          },
          {
              "line": 65,
              "column": 65
          },
          {
              "line": 66,
              "column": 58
          },
          {
              "line": 96,
              "column": 22
          },
          {
              "line": 99,
              "column": 65
          },
          {
              "line": 110,
              "column": 64
          },
          {
              "line": 137,
              "column": 76
          },
          {
              "line": 139,
              "column": 40
          },
          {
              "line": 154,
              "column": 20
          },
          {
              "line": 161,
              "column": 53
          }
      ],
      "old_name": "expectedVersion",
      "new_name": "requestVersion",
      "ctx": {
          "symbolName": "expectedVersion",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in testNoAddress(...)",
          "filePath": "CollectSinkOperatorCoordinatorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testNoAddress() throws Exception {\n        CollectSinkOperatorCoordinator coordinator =\n                new CollectSinkOperatorCoordinator(SOCKET_TIMEOUT_MILLIS);\n        coordinator.start();\n\n        final String expectedVersion = \"version\";\n        final CompletableFuture<CoordinationResponse> response =\n                coordinator.handleCoordinationRequest(\n                        createRequestForClientGeneratedResponse(expectedVersion));\n        assertEmptyResponseGeneratedFromClient(response, expectedVersion);\n\n        coordinator.close();\n    }",
          "conflictNames": [
              "coordinator",
              "response"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d536b5a7d73bb0696291d6ea7c47544f4edd3e77^1/flink-runtime/src/main/java/org/apache/flink/runtime/state/OperatorStateRestoreOperation.java",
      "locators": [
          {
              "line": 174,
              "column": 76
          },
          {
              "line": 180,
              "column": 21
          },
          {
              "line": 181,
              "column": 29
          },
          {
              "line": 199,
              "column": 91
          }
      ],
      "old_name": "entries",
      "new_name": "toRestore",
      "ctx": {
          "symbolName": "entries",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<Entry<String, StateMetaInfo>>",
          "scopeHint": "in restore(...)",
          "filePath": "OperatorStateRestoreOperation.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public Void restore() throws Exception {\n        if (stateHandles.isEmpty()) {\n            return null;\n        }\n\n        for (OperatorStateHandle stateHandle : stateHandles) {\n\n            if (stateHandle == null) {\n                continue;\n            }\n\n            FSDataInputStream in = stateHandle.openInputStream();\n            closeStreamOnCancelRegistry.registerCloseable(in);\n\n            ClassLoader restoreClassLoader = Thread.currentThread().getContextClassLoader();\n\n            try {\n                Thread.currentThread().setContextClassLoader(userClassloader);\n                OperatorBackendSerializationProxy backendSerializationProxy =\n                        new OperatorBackendSerializationProxy(userClassloader);\n\n                backendSerializationProxy.read(new DataInputViewStreamWrapper(in));\n\n                List<StateMetaInfoSnapshot> restoredOperatorMetaInfoSnapshots =\n                        backendSerializationProxy.getOperatorStateMetaInfoSnapshots();\n\n                // Recreate all PartitionableListStates from the meta info\n                for (StateMetaInfoSnapshot restoredSnapshot : restoredOperatorMetaInfoSnapshots) {\n\n                    final RegisteredOperatorStateBackendMetaInfo<?> restoredMetaInfo =\n                            new RegisteredOperatorStateBackendMetaInfo<>(restoredSnapshot);\n\n                    if (restoredMetaInfo.getPartitionStateSerializer()\n                            instanceof UnloadableDummyTypeSerializer) {\n\n                        // must fail now if the previous typeSerializer cannot be restored because\n                        // there is no typeSerializer\n                        // capable of reading previous state\n                        // TODO when eager state registration is in place, we can try to get a\n                        // convert deserializer\n                        // TODO from the newly registered typeSerializer instead of simply failing\n                        // here\n\n                        throw new IOException(\n                                \"Unable to restore operator state [\"\n                                        + restoredSnapshot.getName()\n                                        + \"].\"\n                                        + \" The previous typeSerializer of the operator state must be present; the typeSerializer could\"\n                                        + \" have been removed from the classpath, or its implementation have changed and could\"\n                                        + \" not be loaded. This is a temporary restriction that will be fixed in future versions.\");\n                    }\n\n                    PartitionableListState<?> listState =\n                            registeredOperatorStates.get(restoredSnapshot.getName());\n\n                    if (null == listState) {\n                        listState = new PartitionableListState<>(restoredMetaInfo);\n\n                        registeredOperatorStates.put(\n                                listState.getStateMetaInfo().getName(), listState);\n                    } else {\n                        // TODO with eager state registration in place, check here for\n                        // typeSerializer migration strategies\n                    }\n                }\n\n                // ... and then get back the broadcast state.\n                List<StateMetaInfoSnapshot> restoredBroadcastMetaInfoSnapshots =\n                        backendSerializationProxy.getBroadcastStateMetaInfoSnapshots();\n\n                for (StateMetaInfoSnapshot restoredSnapshot : restoredBroadcastMetaInfoSnapshots) {\n\n                    final RegisteredBroadcastStateBackendMetaInfo<?, ?> restoredMetaInfo =\n                            new RegisteredBroadcastStateBackendMetaInfo<>(restoredSnapshot);\n\n                    if (restoredMetaInfo.getKeySerializer() instanceof UnloadableDummyTypeSerializer\n                            || restoredMetaInfo.getValueSerializer()\n                                    instanceof UnloadableDummyTypeSerializer) {\n\n                        // must fail now if the previous typeSerializer cannot be restored because\n                        // there is no typeSerializer\n                        // capable of reading previous state\n                        // TODO when eager state registration is in place, we can try to get a\n                        // convert deserializer\n                        // TODO from the newly registered typeSerializer instead of simply failing\n                        // here\n\n                        throw new IOException(\n                                \"Unable to restore broadcast state [\"\n                                        + restoredSnapshot.getName()\n                                        + \"].\"\n                                        + \" The previous key and value serializers of the state must be present; the serializers could\"\n                                        + \" have been removed from the classpath, or their implementations have changed and could\"\n                                        + \" not be loaded. This is a temporary restriction that will be fixed in future versions.\");\n                    }\n\n                    BackendWritableBroadcastState<?, ?> broadcastState =\n                            registeredBroadcastStates.get(restoredSnapshot.getName());\n\n                    if (broadcastState == null) {\n                        broadcastState = new HeapBroadcastState<>(restoredMetaInfo);\n\n                        registeredBroadcastStates.put(\n                                broadcastState.getStateMetaInfo().getName(), broadcastState);\n                    } else {\n                        // TODO with eager state registration in place, check here for\n                        // typeSerializer migration strategies\n                    }\n                }\n\n                List<Map.Entry<String, OperatorStateHandle.StateMetaInfo>> entries =\n                        new ArrayList<>(stateHandle.getStateNameToPartitionOffsets().entrySet());\n\n                if (backendSerializationProxy.isUsingStateCompression()) {\n                    // sort state handles by offsets to avoid building SnappyFramedInputStream with\n                    // EOF stream.\n                    entries =\n                            entries.stream()\n                                    .sorted(\n                                            Comparator.comparingLong(\n                                                    entry -> {\n                                                        OperatorStateHandle.StateMetaInfo\n                                                                stateMetaInfo = entry.getValue();\n                                                        long[] offsets = stateMetaInfo.getOffsets();\n                                                        if (offsets == null\n                                                                || offsets.length == 0) {\n                                                            return Long.MIN_VALUE;\n                                                        } else {\n                                                            return offsets[0];\n                                                        }\n                                                    }))\n                                    .collect(Collectors.toList());\n                }\n\n                // Restore all the states\n                for (Map.Entry<String, OperatorStateHandle.StateMetaInfo> nameToOffsets : entries) {\n\n                    final String stateName = nameToOffsets.getKey();\n\n                    PartitionableListState<?> listStateForName =\n                            registeredOperatorStates.get(stateName);\n                    final StreamCompressionDecorator compressionDecorator =\n                            backendSerializationProxy.isUsingStateCompression()\n                                    ? SnappyStreamCompressionDecorator.INSTANCE\n                                    : UncompressedStreamCompressionDecorator.INSTANCE;\n                    // create the compressed stream for each state to have the compression header\n                    // for each\n                    try (final CompressibleFSDataInputStream compressedIn =\n                            new CompressibleFSDataInputStream(\n                                    in,\n                                    compressionDecorator)) { // closes only the outer compression\n                        // stream\n                        if (listStateForName == null) {\n                            BackendWritableBroadcastState<?, ?> broadcastStateForName =\n                                    registeredBroadcastStates.get(stateName);\n                            Preconditions.checkState(\n                                    broadcastStateForName != null,\n                                    \"Found state without \"\n                                            + \"corresponding meta info: \"\n                                            + stateName);\n                            deserializeBroadcastStateValues(\n                                    broadcastStateForName, compressedIn, nameToOffsets.getValue());\n                        } else {\n                            deserializeOperatorStateValues(\n                                    listStateForName, compressedIn, nameToOffsets.getValue());\n                        }\n                    }\n                }\n\n            } finally {\n                Thread.currentThread().setContextClassLoader(restoreClassLoader);\n                if (closeStreamOnCancelRegistry.unregisterCloseable(in)) {\n                    IOUtils.closeQuietly(in);\n                }\n            }\n        }\n        return null;\n    }",
          "conflictNames": [
              "in",
              "restoreClassLoader",
              "backendSerializationProxy",
              "restoredOperatorMetaInfoSnapshots",
              "restoredMetaInfo",
              "listState",
              "restoredBroadcastMetaInfoSnapshots",
              "broadcastState",
              "stateMetaInfo",
              "offsets",
              "stateName",
              "listStateForName",
              "compressionDecorator",
              "compressedIn",
              "broadcastStateForName"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d5b8ad7672cd981cdbc757549ed2ab1fcf007500^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/operations/AlterSchemaConverter.java",
      "locators": [
          {
              "line": 814,
              "column": 42
          },
          {
              "line": 817,
              "column": 37
          }
      ],
      "old_name": "originPrimaryKeyNames",
      "new_name": "oldPrimaryKeyNames",
      "ctx": {
          "symbolName": "originPrimaryKeyNames",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<String>",
          "scopeHint": "in buildUpdatedPrimaryKey(...)",
          "filePath": "AlterSchemaConverter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void buildUpdatedPrimaryKey(\n            Schema.Builder builder,\n            ResolvedCatalogTable originTable,\n            Function<String, String> columnRenamer) {\n        originTable\n                .getUnresolvedSchema()\n                .getPrimaryKey()\n                .ifPresent(\n                        pk -> {\n                            List<String> originPrimaryKeyNames = pk.getColumnNames();\n                            String constrainName = pk.getConstraintName();\n                            List<String> newPrimaryKeyNames =\n                                    originPrimaryKeyNames.stream()\n                                            .map(columnRenamer)\n                                            .collect(Collectors.toList());\n                            builder.primaryKeyNamed(constrainName, newPrimaryKeyNames);\n                        });\n    }",
          "conflictNames": [
              "builder",
              "originTable",
              "columnRenamer",
              "constrainName",
              "newPrimaryKeyNames"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d5b8ad7672cd981cdbc757549ed2ab1fcf007500^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/operations/AlterSchemaConverter.java",
      "locators": [
          {
              "line": 137,
              "column": 16
          },
          {
              "line": 142,
              "column": 17
          },
          {
              "line": 146,
              "column": 40
          },
          {
              "line": 154,
              "column": 49
          },
          {
              "line": 163,
              "column": 35
          },
          {
              "line": 688,
              "column": 20
          },
          {
              "line": 693,
              "column": 17
          },
          {
              "line": 697,
              "column": 81
          }
      ],
      "old_name": "originColumnName",
      "new_name": "oldColumnName",
      "ctx": {
          "symbolName": "originColumnName",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in applySchemaChange(...)",
          "filePath": "AlterSchemaConverter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Convert ALTER TABLE RENAME col_name to new_col_name to generate an updated Schema. */\n    public Schema applySchemaChange(\n            SqlAlterTableRenameColumn renameColumn, ResolvedCatalogTable originTable) {\n        String originColumnName = getColumnName(renameColumn.getOriginColumnIdentifier());\n        String newColumnName = getColumnName(renameColumn.getNewColumnIdentifier());\n        // validate origin column is exists, new column name does not collide with existed column\n        // names, and origin column isn't referenced by computed column\n        validateColumnName(\n                originColumnName,\n                newColumnName,\n                originTable.getResolvedSchema(),\n                originTable.getPartitionKeys());\n        validateWatermark(originTable, originColumnName);\n\n        // generate new schema\n        Schema.Builder schemaBuilder = Schema.newBuilder();\n        buildUpdatedColumn(\n                schemaBuilder,\n                originTable,\n                (builder, column) -> {\n                    if (column.getName().equals(originColumnName)) {\n                        buildNewColumnFromOriginColumn(builder, column, newColumnName);\n                    } else {\n                        builder.fromColumns(Collections.singletonList(column));\n                    }\n                });\n        buildUpdatedPrimaryKey(\n                schemaBuilder,\n                originTable,\n                (pk) -> pk.equals(originColumnName) ? newColumnName : pk);\n        buildUpdatedWatermark(schemaBuilder, originTable);\n        return schemaBuilder.build();\n    }",
          "conflictNames": [
              "renameColumn",
              "originTable",
              "newColumnName",
              "schemaBuilder"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d5b8ad7672cd981cdbc757549ed2ab1fcf007500^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/operations/AlterSchemaConverter.java",
      "locators": [
          {
              "line": 382,
              "column": 37
          },
          {
              "line": 388,
              "column": 33
          }
      ],
      "old_name": "originType",
      "new_name": "oldType",
      "ctx": {
          "symbolName": "originType",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "AbstractDataType<?>",
          "scopeHint": "in updatePrimaryKeyNullability(...)",
          "filePath": "AlterSchemaConverter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void updatePrimaryKeyNullability(String columnName) {\n            Schema.UnresolvedColumn column = columns.get(columnName);\n            if (column instanceof Schema.UnresolvedPhysicalColumn) {\n                AbstractDataType<?> originType =\n                        ((Schema.UnresolvedPhysicalColumn) column).getDataType();\n                columns.put(\n                        columnName,\n                        new Schema.UnresolvedPhysicalColumn(\n                                columnName,\n                                originType.notNull(),\n                                column.getComment().orElse(null)));\n            }\n        }",
          "conflictNames": [
              "columnName",
              "column"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d5ecb07dab460f0dfff7eaf0e0edddff8b85aac9^1/flink-core/src/main/java/org/apache/flink/configuration/GlobalConfiguration.java",
      "locators": [
          {
              "line": 2,
              "column": 7
          },
          {
              "line": 2,
              "column": 10
          },
          {
              "line": 2,
              "column": 18
          },
          {
              "line": 2,
              "column": 25
          },
          {
              "line": 2,
              "column": 34
          },
          {
              "line": 2,
              "column": 56
          },
          {
              "line": 2,
              "column": 61
          },
          {
              "line": 3,
              "column": 10
          },
          {
              "line": 3,
              "column": 27
          },
          {
              "line": 3,
              "column": 30
          },
          {
              "line": 3,
              "column": 35
          },
          {
              "line": 3,
              "column": 36
          },
          {
              "line": 3,
              "column": 38
          },
          {
              "line": 3,
              "column": 46
          },
          {
              "line": 3,
              "column": 47
          },
          {
              "line": 3,
              "column": 51
          },
          {
              "line": 3,
              "column": 63
          },
          {
              "line": 4,
              "column": 13
          },
          {
              "line": 5,
              "column": 5
          },
          {
              "line": 5,
              "column": 27
          },
          {
              "line": 5,
              "column": 38
          },
          {
              "line": 5,
              "column": 47
          },
          {
              "line": 5,
              "column": 50
          },
          {
              "line": 5,
              "column": 61
          },
          {
              "line": 6,
              "column": 14
          },
          {
              "line": 6,
              "column": 19
          },
          {
              "line": 6,
              "column": 26
          },
          {
              "line": 6,
              "column": 31
          },
          {
              "line": 6,
              "column": 34
          },
          {
              "line": 6,
              "column": 38
          },
          {
              "line": 6,
              "column": 52
          },
          {
              "line": 7,
              "column": 8
          },
          {
              "line": 7,
              "column": 11
          },
          {
              "line": 7,
              "column": 30
          },
          {
              "line": 7,
              "column": 40
          },
          {
              "line": 7,
              "column": 42
          },
          {
              "line": 7,
              "column": 45
          },
          {
              "line": 7,
              "column": 61
          },
          {
              "line": 8,
              "column": 11
          },
          {
              "line": 8,
              "column": 16
          },
          {
              "line": 8,
              "column": 19
          },
          {
              "line": 8,
              "column": 50
          },
          {
              "line": 8,
              "column": 55
          },
          {
              "line": 8,
              "column": 58
          },
          {
              "line": 10,
              "column": 24
          },
          {
              "line": 10,
              "column": 33
          },
          {
              "line": 10,
              "column": 36
          },
          {
              "line": 12,
              "column": 7
          },
          {
              "line": 12,
              "column": 12
          },
          {
              "line": 12,
              "column": 17
          },
          {
              "line": 12,
              "column": 32
          },
          {
              "line": 12,
              "column": 44
          },
          {
              "line": 12,
              "column": 45
          },
          {
              "line": 12,
              "column": 70
          },
          {
              "line": 13,
              "column": 13
          },
          {
              "line": 13,
              "column": 19
          },
          {
              "line": 13,
              "column": 24
          },
          {
              "line": 13,
              "column": 29
          },
          {
              "line": 13,
              "column": 32
          },
          {
              "line": 13,
              "column": 46
          },
          {
              "line": 14,
              "column": 50
          },
          {
              "line": 14,
              "column": 54
          },
          {
              "line": 14,
              "column": 57
          },
          {
              "line": 14,
              "column": 61
          },
          {
              "line": 14,
              "column": 73
          },
          {
              "line": 15,
              "column": 5
          },
          {
              "line": 15,
              "column": 6
          },
          {
              "line": 15,
              "column": 10
          },
          {
              "line": 15,
              "column": 15
          },
          {
              "line": 15,
              "column": 18
          },
          {
              "line": 15,
              "column": 26
          },
          {
              "line": 15,
              "column": 30
          },
          {
              "line": 15,
              "column": 44
          },
          {
              "line": 15,
              "column": 49
          },
          {
              "line": 15,
              "column": 57
          },
          {
              "line": 16,
              "column": 19
          },
          {
              "line": 16,
              "column": 24
          },
          {
              "line": 16,
              "column": 29
          },
          {
              "line": 16,
              "column": 32
          },
          {
              "line": 19,
              "column": 7
          },
          {
              "line": 19,
              "column": 18
          },
          {
              "line": 21,
              "column": 17
          },
          {
              "line": 21,
              "column": 39
          },
          {
              "line": 22,
              "column": 17
          },
          {
              "line": 22,
              "column": 32
          },
          {
              "line": 24,
              "column": 22
          },
          {
              "line": 25,
              "column": 22
          },
          {
              "line": 27,
              "column": 32
          },
          {
              "line": 29,
              "column": 19
          },
          {
              "line": 35,
              "column": 28
          },
          {
              "line": 35,
              "column": 63
          },
          {
              "line": 35,
              "column": 67
          },
          {
              "line": 35,
              "column": 87
          },
          {
              "line": 36,
              "column": 10
          },
          {
              "line": 36,
              "column": 14
          },
          {
              "line": 36,
              "column": 21
          },
          {
              "line": 36,
              "column": 36
          },
          {
              "line": 36,
              "column": 39
          },
          {
              "line": 36,
              "column": 41
          },
          {
              "line": 36,
              "column": 47
          },
          {
              "line": 36,
              "column": 53
          },
          {
              "line": 38,
              "column": 5
          },
          {
              "line": 41,
              "column": 11
          },
          {
              "line": 41,
              "column": 30
          },
          {
              "line": 41,
              "column": 43
          },
          {
              "line": 41,
              "column": 54
          },
          {
              "line": 41,
              "column": 60
          },
          {
              "line": 45,
              "column": 9
          },
          {
              "line": 45,
              "column": 13
          },
          {
              "line": 45,
              "column": 29
          },
          {
              "line": 46,
              "column": 11
          },
          {
              "line": 48,
              "column": 10
          },
          {
              "line": 48,
              "column": 13
          },
          {
              "line": 48,
              "column": 21
          },
          {
              "line": 48,
              "column": 27
          },
          {
              "line": 48,
              "column": 38
          },
          {
              "line": 48,
              "column": 44
          },
          {
              "line": 49,
              "column": 11
          },
          {
              "line": 50,
              "column": 14
          },
          {
              "line": 52,
              "column": 19
          },
          {
              "line": 52,
              "column": 22
          },
          {
              "line": 53,
              "column": 25
          },
          {
              "line": 53,
              "column": 36
          },
          {
              "line": 54,
              "column": 22
          },
          {
              "line": 56,
              "column": 19
          },
          {
              "line": 56,
              "column": 24
          },
          {
              "line": 56,
              "column": 27
          },
          {
              "line": 57,
              "column": 21
          },
          {
              "line": 60,
              "column": 24
          },
          {
              "line": 60,
              "column": 27
          },
          {
              "line": 63,
              "column": 10
          },
          {
              "line": 63,
              "column": 16
          },
          {
              "line": 63,
              "column": 23
          },
          {
              "line": 63,
              "column": 31
          },
          {
              "line": 63,
              "column": 40
          },
          {
              "line": 68,
              "column": 11
          },
          {
              "line": 73,
              "column": 16
          },
          {
              "line": 73,
              "column": 46
          },
          {
              "line": 73,
              "column": 48
          },
          {
              "line": 73,
              "column": 56
          },
          {
              "line": 73,
              "column": 73
          },
          {
              "line": 74,
              "column": 9
          },
          {
              "line": 74,
              "column": 19
          },
          {
              "line": 74,
              "column": 42
          },
          {
              "line": 74,
              "column": 51
          },
          {
              "line": 74,
              "column": 53
          },
          {
              "line": 74,
              "column": 61
          },
          {
              "line": 74,
              "column": 72
          },
          {
              "line": 74,
              "column": 82
          },
          {
              "line": 75,
              "column": 20
          },
          {
              "line": 75,
              "column": 26
          },
          {
              "line": 75,
              "column": 34
          },
          {
              "line": 75,
              "column": 49
          },
          {
              "line": 75,
              "column": 51
          },
          {
              "line": 75,
              "column": 60
          },
          {
              "line": 75,
              "column": 78
          },
          {
              "line": 75,
              "column": 85
          },
          {
              "line": 75,
              "column": 93
          },
          {
              "line": 76,
              "column": 15
          },
          {
              "line": 76,
              "column": 18
          },
          {
              "line": 76,
              "column": 34
          },
          {
              "line": 76,
              "column": 62
          },
          {
              "line": 78,
              "column": 10
          },
          {
              "line": 78,
              "column": 17
          },
          {
              "line": 78,
              "column": 26
          },
          {
              "line": 81,
              "column": 10
          },
          {
              "line": 81,
              "column": 35
          },
          {
              "line": 85,
              "column": 16
          },
          {
              "line": 85,
              "column": 50
          },
          {
              "line": 85,
              "column": 55
          },
          {
              "line": 85,
              "column": 70
          },
          {
              "line": 85,
              "column": 74
          },
          {
              "line": 87,
              "column": 26
          },
          {
              "line": 87,
              "column": 30
          },
          {
              "line": 87,
              "column": 35
          },
          {
              "line": 87,
              "column": 40
          },
          {
              "line": 87,
              "column": 55
          },
          {
              "line": 87,
              "column": 59
          },
          {
              "line": 88,
              "column": 10
          },
          {
              "line": 88,
              "column": 17
          },
          {
              "line": 88,
              "column": 26
          },
          {
              "line": 88,
              "column": 32
          },
          {
              "line": 88,
              "column": 73
          },
          {
              "line": 88,
              "column": 77
          },
          {
              "line": 90,
              "column": 76
          },
          {
              "line": 90,
              "column": 80
          },
          {
              "line": 91,
              "column": 38
          },
          {
              "line": 91,
              "column": 42
          },
          {
              "line": 91,
              "column": 44
          },
          {
              "line": 93,
              "column": 14
          },
          {
              "line": 93,
              "column": 21
          },
          {
              "line": 93,
              "column": 49
          },
          {
              "line": 93,
              "column": 53
          },
          {
              "line": 96,
              "column": 10
          },
          {
              "line": 96,
              "column": 56
          },
          {
              "line": 96,
              "column": 60
          },
          {
              "line": 100,
              "column": 16
          },
          {
              "line": 100,
              "column": 35
          },
          {
              "line": 100,
              "column": 45
          },
          {
              "line": 100,
              "column": 49
          },
          {
              "line": 100,
              "column": 54
          },
          {
              "line": 100,
              "column": 60
          },
          {
              "line": 102,
              "column": 19
          },
          {
              "line": 102,
              "column": 24
          },
          {
              "line": 102,
              "column": 33
          },
          {
              "line": 102,
              "column": 56
          },
          {
              "line": 104,
              "column": 27
          },
          {
              "line": 104,
              "column": 32
          },
          {
              "line": 104,
              "column": 56
          },
          {
              "line": 104,
              "column": 75
          },
          {
              "line": 107,
              "column": 10
          },
          {
              "line": 111,
              "column": 16
          },
          {
              "line": 111,
              "column": 35
          },
          {
              "line": 111,
              "column": 45
          },
          {
              "line": 111,
              "column": 49
          },
          {
              "line": 111,
              "column": 54
          },
          {
              "line": 111,
              "column": 60
          },
          {
              "line": 111,
              "column": 73
          },
          {
              "line": 111,
              "column": 87
          },
          {
              "line": 111,
              "column": 91
          },
          {
              "line": 112,
              "column": 37
          },
          {
              "line": 112,
              "column": 49
          },
          {
              "line": 112,
              "column": 57
          },
          {
              "line": 112,
              "column": 63
          },
          {
              "line": 114,
              "column": 28
          },
          {
              "line": 114,
              "column": 45
          },
          {
              "line": 115,
              "column": 26
          },
          {
              "line": 115,
              "column": 30
          },
          {
              "line": 115,
              "column": 50
          },
          {
              "line": 115,
              "column": 65
          },
          {
              "line": 115,
              "column": 79
          },
          {
              "line": 115,
              "column": 83
          },
          {
              "line": 115,
              "column": 98
          },
          {
              "line": 116,
              "column": 10
          },
          {
              "line": 116,
              "column": 18
          },
          {
              "line": 116,
              "column": 38
          },
          {
              "line": 116,
              "column": 48
          },
          {
              "line": 116,
              "column": 53
          },
          {
              "line": 116,
              "column": 73
          },
          {
              "line": 119,
              "column": 45
          },
          {
              "line": 119,
              "column": 78
          },
          {
              "line": 119,
              "column": 82
          },
          {
              "line": 122,
              "column": 20
          },
          {
              "line": 122,
              "column": 26
          },
          {
              "line": 122,
              "column": 35
          },
          {
              "line": 122,
              "column": 41
          },
          {
              "line": 123,
              "column": 25
          },
          {
              "line": 123,
              "column": 45
          },
          {
              "line": 126,
              "column": 18
          },
          {
              "line": 126,
              "column": 30
          },
          {
              "line": 126,
              "column": 35
          },
          {
              "line": 126,
              "column": 41
          },
          {
              "line": 127,
              "column": 25
          },
          {
              "line": 127,
              "column": 27
          },
          {
              "line": 128,
              "column": 20
          },
          {
              "line": 128,
              "column": 26
          },
          {
              "line": 128,
              "column": 46
          },
          {
              "line": 129,
              "column": 24
          },
          {
              "line": 129,
              "column": 29
          },
          {
              "line": 129,
              "column": 49
          },
          {
              "line": 129,
              "column": 59
          },
          {
              "line": 132,
              "column": 41
          },
          {
              "line": 132,
              "column": 44
          },
          {
              "line": 132,
              "column": 53
          },
          {
              "line": 133,
              "column": 36
          },
          {
              "line": 133,
              "column": 44
          },
          {
              "line": 133,
              "column": 50
          },
          {
              "line": 133,
              "column": 55
          },
          {
              "line": 133,
              "column": 67
          },
          {
              "line": 136,
              "column": 13
          },
          {
              "line": 136,
              "column": 44
          },
          {
              "line": 138,
              "column": 12
          },
          {
              "line": 138,
              "column": 27
          },
          {
              "line": 138,
              "column": 32
          },
          {
              "line": 138,
              "column": 38
          },
          {
              "line": 138,
              "column": 50
          },
          {
              "line": 139,
              "column": 27
          },
          {
              "line": 139,
              "column": 29
          },
          {
              "line": 140,
              "column": 20
          },
          {
              "line": 140,
              "column": 26
          },
          {
              "line": 140,
              "column": 46
          },
          {
              "line": 141,
              "column": 24
          },
          {
              "line": 141,
              "column": 42
          },
          {
              "line": 142,
              "column": 44
          },
          {
              "line": 144,
              "column": 44
          },
          {
              "line": 144,
              "column": 47
          },
          {
              "line": 144,
              "column": 56
          },
          {
              "line": 145,
              "column": 36
          },
          {
              "line": 145,
              "column": 43
          },
          {
              "line": 146,
              "column": 11
          },
          {
              "line": 146,
              "column": 14
          },
          {
              "line": 148,
              "column": 46
          },
          {
              "line": 148,
              "column": 80
          },
          {
              "line": 149,
              "column": 34
          },
          {
              "line": 149,
              "column": 37
          },
          {
              "line": 149,
              "column": 46
          },
          {
              "line": 150,
              "column": 38
          },
          {
              "line": 150,
              "column": 44
          },
          {
              "line": 150,
              "column": 59
          },
          {
              "line": 155,
              "column": 24
          },
          {
              "line": 155,
              "column": 28
          },
          {
              "line": 156,
              "column": 60
          },
          {
              "line": 156,
              "column": 64
          },
          {
              "line": 157,
              "column": 45
          },
          {
              "line": 157,
              "column": 49
          },
          {
              "line": 160,
              "column": 10
          },
          {
              "line": 163,
              "column": 11
          },
          {
              "line": 163,
              "column": 51
          },
          {
              "line": 165,
              "column": 19
          },
          {
              "line": 165,
              "column": 27
          },
          {
              "line": 167,
              "column": 55
          },
          {
              "line": 168,
              "column": 35
          },
          {
              "line": 169,
              "column": 34
          },
          {
              "line": 170,
              "column": 36
          },
          {
              "line": 170,
              "column": 43
          },
          {
              "line": 170,
              "column": 46
          },
          {
              "line": 170,
              "column": 73
          },
          {
              "line": 174,
              "column": 13
          },
          {
              "line": 174,
              "column": 20
          },
          {
              "line": 174,
              "column": 23
          },
          {
              "line": 174,
              "column": 48
          },
          {
              "line": 174,
              "column": 57
          },
          {
              "line": 174,
              "column": 60
          },
          {
              "line": 174,
              "column": 62
          },
          {
              "line": 174,
              "column": 66
          },
          {
              "line": 174,
              "column": 67
          },
          {
              "line": 176,
              "column": 12
          },
          {
              "line": 176,
              "column": 15
          },
          {
              "line": 176,
              "column": 19
          },
          {
              "line": 176,
              "column": 25
          },
          {
              "line": 176,
              "column": 37
          },
          {
              "line": 176,
              "column": 48
          },
          {
              "line": 176,
              "column": 55
          },
          {
              "line": 176,
              "column": 79
          },
          {
              "line": 178,
              "column": 11
          },
          {
              "line": 179,
              "column": 9
          },
          {
              "line": 180,
              "column": 11
          },
          {
              "line": 181,
              "column": 13
          },
          {
              "line": 181,
              "column": 20
          },
          {
              "line": 182,
              "column": 13
          },
          {
              "line": 183,
              "column": 12
          },
          {
              "line": 185,
              "column": 12
          },
          {
              "line": 185,
              "column": 16
          },
          {
              "line": 187,
              "column": 11
          },
          {
              "line": 188,
              "column": 9
          },
          {
              "line": 188,
              "column": 14
          },
          {
              "line": 188,
              "column": 19
          },
          {
              "line": 188,
              "column": 26
          },
          {
              "line": 189,
              "column": 9
          },
          {
              "line": 189,
              "column": 14
          },
          {
              "line": 189,
              "column": 19
          },
          {
              "line": 190,
              "column": 12
          },
          {
              "line": 192,
              "column": 38
          },
          {
              "line": 192,
              "column": 41
          },
          {
              "line": 193,
              "column": 16
          },
          {
              "line": 193,
              "column": 20
          },
          {
              "line": 193,
              "column": 27
          },
          {
              "line": 193,
              "column": 41
          },
          {
              "line": 193,
              "column": 48
          },
          {
              "line": 193,
              "column": 51
          },
          {
              "line": 193,
              "column": 60
          },
          {
              "line": 193,
              "column": 66
          },
          {
              "line": 193,
              "column": 78
          },
          {
              "line": 193,
              "column": 80
          },
          {
              "line": 194,
              "column": 10
          },
          {
              "line": 194,
              "column": 23
          },
          {
              "line": 194,
              "column": 25
          },
          {
              "line": 194,
              "column": 32
          },
          {
              "line": 194,
              "column": 34
          },
          {
              "line": 194,
              "column": 38
          },
          {
              "line": 194,
              "column": 39
          },
          {
              "line": 196,
              "column": 11
          },
          {
              "line": 196,
              "column": 28
          },
          {
              "line": 196,
              "column": 31
          },
          {
              "line": 197,
              "column": 11
          },
          {
              "line": 197,
              "column": 35
          },
          {
              "line": 197,
              "column": 45
          },
          {
              "line": 197,
              "column": 63
          },
          {
              "line": 197,
              "column": 84
          },
          {
              "line": 197,
              "column": 88
          },
          {
              "line": 198,
              "column": 30
          },
          {
              "line": 198,
              "column": 40
          },
          {
              "line": 198,
              "column": 42
          },
          {
              "line": 198,
              "column": 51
          },
          {
              "line": 201,
              "column": 19
          },
          {
              "line": 201,
              "column": 27
          },
          {
              "line": 202,
              "column": 33
          },
          {
              "line": 202,
              "column": 35
          },
          {
              "line": 202,
              "column": 38
          },
          {
              "line": 202,
              "column": 44
          },
          {
              "line": 202,
              "column": 48
          },
          {
              "line": 202,
              "column": 56
          },
          {
              "line": 203,
              "column": 29
          },
          {
              "line": 203,
              "column": 38
          },
          {
              "line": 204,
              "column": 40
          },
          {
              "line": 204,
              "column": 45
          },
          {
              "line": 204,
              "column": 65
          },
          {
              "line": 204,
              "column": 75
          },
          {
              "line": 205,
              "column": 30
          },
          {
              "line": 205,
              "column": 32
          },
          {
              "line": 205,
              "column": 50
          },
          {
              "line": 205,
              "column": 53
          },
          {
              "line": 205,
              "column": 61
          },
          {
              "line": 205,
              "column": 63
          },
          {
              "line": 205,
              "column": 66
          },
          {
              "line": 206,
              "column": 23
          },
          {
              "line": 206,
              "column": 26
          },
          {
              "line": 207,
              "column": 33
          },
          {
              "line": 207,
              "column": 42
          },
          {
              "line": 208,
              "column": 34
          },
          {
              "line": 208,
              "column": 36
          },
          {
              "line": 208,
              "column": 51
          },
          {
              "line": 208,
              "column": 53
          },
          {
              "line": 208,
              "column": 56
          },
          {
              "line": 208,
              "column": 68
          },
          {
              "line": 208,
              "column": 93
          },
          {
              "line": 209,
              "column": 27
          },
          {
              "line": 209,
              "column": 30
          },
          {
              "line": 210,
              "column": 34
          },
          {
              "line": 210,
              "column": 36
          },
          {
              "line": 210,
              "column": 51
          },
          {
              "line": 210,
              "column": 53
          },
          {
              "line": 210,
              "column": 56
          },
          {
              "line": 210,
              "column": 64
          },
          {
              "line": 215,
              "column": 10
          },
          {
              "line": 215,
              "column": 21
          },
          {
              "line": 215,
              "column": 23
          },
          {
              "line": 218,
              "column": 11
          },
          {
              "line": 218,
              "column": 35
          },
          {
              "line": 218,
              "column": 45
          },
          {
              "line": 218,
              "column": 63
          },
          {
              "line": 219,
              "column": 16
          },
          {
              "line": 219,
              "column": 19
          },
          {
              "line": 219,
              "column": 32
          },
          {
              "line": 219,
              "column": 45
          },
          {
              "line": 219,
              "column": 54
          },
          {
              "line": 219,
              "column": 70
          },
          {
              "line": 219,
              "column": 74
          },
          {
              "line": 219,
              "column": 78
          },
          {
              "line": 220,
              "column": 10
          },
          {
              "line": 220,
              "column": 21
          },
          {
              "line": 224,
              "column": 24
          },
          {
              "line": 224,
              "column": 30
          },
          {
              "line": 224,
              "column": 37
          },
          {
              "line": 226,
              "column": 12
          },
          {
              "line": 226,
              "column": 21
          },
          {
              "line": 226,
              "column": 23
          },
          {
              "line": 226,
              "column": 27
          },
          {
              "line": 226,
              "column": 30
          },
          {
              "line": 226,
              "column": 33
          },
          {
              "line": 226,
              "column": 37
          },
          {
              "line": 226,
              "column": 44
          },
          {
              "line": 226,
              "column": 47
          },
          {
              "line": 226,
              "column": 51
          },
          {
              "line": 226,
              "column": 66
          },
          {
              "line": 226,
              "column": 87
          },
          {
              "line": 226,
              "column": 89
          },
          {
              "line": 226,
              "column": 93
          },
          {
              "line": 226,
              "column": 97
          },
          {
              "line": 227,
              "column": 12
          },
          {
              "line": 227,
              "column": 18
          },
          {
              "line": 227,
              "column": 23
          },
          {
              "line": 227,
              "column": 52
          },
          {
              "line": 227,
              "column": 54
          },
          {
              "line": 227,
              "column": 61
          },
          {
              "line": 229,
              "column": 11
          },
          {
              "line": 230,
              "column": 16
          },
          {
              "line": 230,
              "column": 27
          },
          {
              "line": 230,
              "column": 45
          },
          {
              "line": 230,
              "column": 56
          },
          {
              "line": 230,
              "column": 85
          },
          {
              "line": 230,
              "column": 96
          },
          {
              "line": 231,
              "column": 16
          },
          {
              "line": 231,
              "column": 45
          },
          {
              "line": 231,
              "column": 64
          },
          {
              "line": 231,
              "column": 96
          },
          {
              "line": 231,
              "column": 107
          },
          {
              "line": 232,
              "column": 17
          },
          {
              "line": 232,
              "column": 45
          },
          {
              "line": 232,
              "column": 59
          },
          {
              "line": 232,
              "column": 71
          },
          {
              "line": 232,
              "column": 74
          },
          {
              "line": 232,
              "column": 77
          },
          {
              "line": 232,
              "column": 99
          },
          {
              "line": 233,
              "column": 12
          },
          {
              "line": 235,
              "column": 11
          },
          {
              "line": 236,
              "column": 16
          },
          {
              "line": 238,
              "column": 20
          },
          {
              "line": 238,
              "column": 38
          },
          {
              "line": 238,
              "column": 49
          },
          {
              "line": 238,
              "column": 78
          },
          {
              "line": 238,
              "column": 89
          },
          {
              "line": 239,
              "column": 38
          },
          {
              "line": 239,
              "column": 57
          },
          {
              "line": 239,
              "column": 89
          },
          {
              "line": 239,
              "column": 100
          },
          {
              "line": 240,
              "column": 17
          },
          {
              "line": 242,
              "column": 38
          },
          {
              "line": 242,
              "column": 52
          },
          {
              "line": 242,
              "column": 64
          },
          {
              "line": 242,
              "column": 67
          },
          {
              "line": 242,
              "column": 70
          },
          {
              "line": 242,
              "column": 92
          },
          {
              "line": 243,
              "column": 12
          },
          {
              "line": 245,
              "column": 18
          },
          {
              "line": 245,
              "column": 22
          },
          {
              "line": 245,
              "column": 32
          },
          {
              "line": 245,
              "column": 38
          },
          {
              "line": 246,
              "column": 10
          },
          {
              "line": 246,
              "column": 11
          },
          {
              "line": 246,
              "column": 18
          },
          {
              "line": 246,
              "column": 44
          },
          {
              "line": 246,
              "column": 53
          },
          {
              "line": 246,
              "column": 73
          },
          {
              "line": 248,
              "column": 11
          },
          {
              "line": 248,
              "column": 43
          },
          {
              "line": 248,
              "column": 49
          },
          {
              "line": 248,
              "column": 54
          },
          {
              "line": 248,
              "column": 59
          },
          {
              "line": 249,
              "column": 39
          },
          {
              "line": 252,
              "column": 28
          },
          {
              "line": 252,
              "column": 44
          },
          {
              "line": 252,
              "column": 55
          },
          {
              "line": 252,
              "column": 66
          },
          {
              "line": 252,
              "column": 85
          },
          {
              "line": 252,
              "column": 90
          },
          {
              "line": 253,
              "column": 24
          },
          {
              "line": 253,
              "column": 54
          },
          {
              "line": 253,
              "column": 60
          },
          {
              "line": 253,
              "column": 64
          },
          {
              "line": 253,
              "column": 80
          },
          {
              "line": 255,
              "column": 14
          },
          {
              "line": 256,
              "column": 21
          },
          {
              "line": 256,
              "column": 28
          },
          {
              "line": 257,
              "column": 20
          },
          {
              "line": 257,
              "column": 29
          },
          {
              "line": 257,
              "column": 33
          },
          {
              "line": 257,
              "column": 77
          },
          {
              "line": 262,
              "column": 10
          },
          {
              "line": 262,
              "column": 16
          },
          {
              "line": 262,
              "column": 19
          },
          {
              "line": 262,
              "column": 24
          },
          {
              "line": 262,
              "column": 27
          },
          {
              "line": 262,
              "column": 39
          },
          {
              "line": 262,
              "column": 43
          },
          {
              "line": 264,
              "column": 16
          },
          {
              "line": 264,
              "column": 21
          },
          {
              "line": 264,
              "column": 31
          },
          {
              "line": 266,
              "column": 23
          },
          {
              "line": 266,
              "column": 30
          },
          {
              "line": 266,
              "column": 37
          },
          {
              "line": 266,
              "column": 47
          },
          {
              "line": 267,
              "column": 11
          },
          {
              "line": 267,
              "column": 25
          },
          {
              "line": 267,
              "column": 37
          },
          {
              "line": 267,
              "column": 43
          },
          {
              "line": 268,
              "column": 23
          },
          {
              "line": 268,
              "column": 30
          },
          {
              "line": 268,
              "column": 36
          },
          {
              "line": 268,
              "column": 44
          },
          {
              "line": 268,
              "column": 49
          },
          {
              "line": 269,
              "column": 24
          },
          {
              "line": 269,
              "column": 26
          },
          {
              "line": 270,
              "column": 18
          },
          {
              "line": 270,
              "column": 25
          },
          {
              "line": 270,
              "column": 29
          },
          {
              "line": 270,
              "column": 43
          },
          {
              "line": 270,
              "column": 45
          },
          {
              "line": 270,
              "column": 49
          },
          {
              "line": 270,
              "column": 61
          },
          {
              "line": 270,
              "column": 68
          },
          {
              "line": 270,
              "column": 83
          },
          {
              "line": 270,
              "column": 85
          },
          {
              "line": 271,
              "column": 18
          },
          {
              "line": 271,
              "column": 27
          },
          {
              "line": 274,
              "column": 10
          },
          {
              "line": 274,
              "column": 20
          },
          {
              "line": 277,
              "column": 27
          },
          {
              "line": 277,
              "column": 41
          },
          {
              "line": 277,
              "column": 45
          },
          {
              "line": 278,
              "column": 10
          }
      ],
      "old_name": "e",
      "new_name": "nestedMap",
      "ctx": {
          "symbolName": "e",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Map<String, Object>",
          "scopeHint": "in flatten(...)",
          "filePath": "GlobalConfiguration.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Flattens a nested configuration map to be only one level deep.\n     *\n     * <p>Nested keys are concatinated using the {@code KEY_SEPARATOR} character. So that:\n     *\n     * <pre>\n     * keyA:\n     *   keyB:\n     *     keyC: \"hello\"\n     *     keyD: \"world\"\n     * </pre>\n     *\n     * <p>becomes:\n     *\n     * <pre>\n     * keyA.keyB.keyC: \"hello\"\n     * keyA.keyB.keyD: \"world\"\n     * </pre>\n     *\n     * @param config an arbitrarily nested config map\n     * @param keyPrefix The string to prefix the keys in the current config level\n     * @return A flattened, 1 level deep map\n     */\n    @SuppressWarnings(\"unchecked\")\n    private static Map<String, Object> flatten(Map<String, Object> config, String keyPrefix) {\n        final Map<String, Object> flattenedMap = new HashMap<>();\n\n        config.forEach(\n                (key, value) -> {\n                    String flattenedKey = keyPrefix + key;\n                    if (value instanceof Map) {\n                        Map<String, Object> e = (Map<String, Object>) value;\n                        flattenedMap.putAll(flatten(e, flattenedKey + KEY_SEPARATOR));\n                    } else {\n                        if (value instanceof List) {\n                            flattenedMap.put(flattenedKey, YamlParserUtils.toYAMLString(value));\n                        } else {\n                            flattenedMap.put(flattenedKey, value);\n                        }\n                    }\n                });\n\n        return flattenedMap;\n    }",
          "conflictNames": [
              "config",
              "keyPrefix",
              "flattenedMap",
              "flattenedKey"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d65722f29a92440b63a98543b7ca62bd5ccd145e^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/HsResultPartition.java",
      "locators": [
          {
              "line": 189,
              "column": 32
          },
          {
              "line": 193,
              "column": 63
          },
          {
              "line": 199,
              "column": 71
          },
          {
              "line": 201,
              "column": 9
          },
          {
              "line": 202,
              "column": 9
          },
          {
              "line": 203,
              "column": 16
          }
      ],
      "old_name": "subpartitionView",
      "new_name": "subpartitionConsumer",
      "ctx": {
          "symbolName": "subpartitionView",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "HsSubpartitionConsumer",
          "scopeHint": "in createSubpartitionView(...)",
          "filePath": "HsResultPartition.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public ResultSubpartitionView createSubpartitionView(\n            int subpartitionId, BufferAvailabilityListener availabilityListener)\n            throws IOException {\n        checkState(!isReleased(), \"ResultPartition already released.\");\n\n        // If data file is not readable, throw PartitionNotFoundException to mark this result\n        // partition failed. Otherwise, the partition data is not regenerated, so failover can not\n        // recover the job.\n        if (!Files.isReadable(dataFilePath)) {\n            throw new PartitionNotFoundException(getPartitionId());\n        }\n\n        HsSubpartitionConsumer subpartitionView = new HsSubpartitionConsumer(availabilityListener);\n        HsDataView diskDataView =\n                // TODO pass real consumerId in the next commit.\n                fileDataManager.registerNewConsumer(\n                        subpartitionId, HsConsumerId.DEFAULT, subpartitionView);\n\n        HsDataView memoryDataView =\n                checkNotNull(memoryDataManager)\n                        // TODO pass real consumerId in the next commit.\n                        .registerNewConsumer(\n                                subpartitionId, HsConsumerId.DEFAULT, subpartitionView);\n\n        subpartitionView.setDiskDataView(diskDataView);\n        subpartitionView.setMemoryDataView(memoryDataView);\n        return subpartitionView;\n    }",
          "conflictNames": [
              "subpartitionId",
              "availabilityListener",
              "diskDataView",
              "memoryDataView"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d65f7c1c2f3bf3076fee6940e538c3725eee0a05^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptivebatch/AdaptiveBatchSchedulerFactory.java",
      "locators": [
          {
              "line": 121,
              "column": 23
          },
          {
              "line": 163,
              "column": 59
          },
          {
              "line": 194,
              "column": 21
          },
          {
              "line": 223,
              "column": 21
          },
          {
              "line": 228,
              "column": 21
          },
          {
              "line": 229,
              "column": 27
          },
          {
              "line": 234,
              "column": 16
          },
          {
              "line": 241,
              "column": 23
          },
          {
              "line": 247,
              "column": 21
          },
          {
              "line": 250,
              "column": 16
          }
      ],
      "old_name": "hybridOnlyConsumeFinishedPartition",
      "new_name": "hybridPartitionDataConsumeConstraint",
      "ctx": {
          "symbolName": "hybridOnlyConsumeFinishedPartition",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "boolean",
          "scopeHint": "in createInstance(...)",
          "filePath": "AdaptiveBatchSchedulerFactory.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public SchedulerNG createInstance(\n            Logger log,\n            JobGraph jobGraph,\n            Executor ioExecutor,\n            Configuration jobMasterConfiguration,\n            SlotPoolService slotPoolService,\n            ScheduledExecutorService futureExecutor,\n            ClassLoader userCodeLoader,\n            CheckpointRecoveryFactory checkpointRecoveryFactory,\n            Time rpcTimeout,\n            BlobWriter blobWriter,\n            JobManagerJobMetricGroup jobManagerJobMetricGroup,\n            Time slotRequestTimeout,\n            ShuffleMaster<?> shuffleMaster,\n            JobMasterPartitionTracker partitionTracker,\n            ExecutionDeploymentTracker executionDeploymentTracker,\n            long initializationTimestamp,\n            ComponentMainThreadExecutor mainThreadExecutor,\n            FatalErrorHandler fatalErrorHandler,\n            JobStatusListener jobStatusListener,\n            BlocklistOperations blocklistOperations)\n            throws Exception {\n\n        checkState(\n                jobGraph.getJobType() == JobType.BATCH,\n                \"Adaptive batch scheduler only supports batch jobs\");\n        checkAllExchangesAreSupported(jobGraph);\n        final SlotPool slotPool =\n                slotPoolService\n                        .castInto(SlotPool.class)\n                        .orElseThrow(\n                                () ->\n                                        new IllegalStateException(\n                                                \"The AdaptiveBatchScheduler requires a SlotPool.\"));\n\n        final boolean enableSpeculativeExecution =\n                jobMasterConfiguration.getBoolean(JobManagerOptions.SPECULATIVE_ENABLED);\n\n        final boolean hybridOnlyConsumeFinishedPartition =\n                getHybridOnlyConsumeFinishedPartition(\n                        jobMasterConfiguration, enableSpeculativeExecution);\n\n        final List<Consumer<ComponentMainThreadExecutor>> startUpActions = new ArrayList<>();\n        final Consumer<ComponentMainThreadExecutor> combinedStartUpActions =\n                m -> startUpActions.forEach(a -> a.accept(m));\n\n        final ExecutionSlotAllocatorFactory allocatorFactory =\n                createExecutionSlotAllocatorFactory(jobMasterConfiguration, slotPool);\n\n        final RestartBackoffTimeStrategy restartBackoffTimeStrategy =\n                RestartBackoffTimeStrategyFactoryLoader.createRestartBackoffTimeStrategyFactory(\n                                jobGraph.getSerializedExecutionConfig()\n                                        .deserializeValue(userCodeLoader)\n                                        .getRestartStrategy(),\n                                jobMasterConfiguration,\n                                jobGraph.isCheckpointingEnabled())\n                        .create();\n        log.info(\n                \"Using restart back off time strategy {} for {} ({}).\",\n                restartBackoffTimeStrategy,\n                jobGraph.getName(),\n                jobGraph.getJobID());\n\n        final ExecutionGraphFactory executionGraphFactory =\n                new DefaultExecutionGraphFactory(\n                        jobMasterConfiguration,\n                        userCodeLoader,\n                        executionDeploymentTracker,\n                        futureExecutor,\n                        ioExecutor,\n                        rpcTimeout,\n                        jobManagerJobMetricGroup,\n                        blobWriter,\n                        shuffleMaster,\n                        partitionTracker,\n                        true,\n                        createExecutionJobVertexFactory(enableSpeculativeExecution));\n\n        final SchedulingStrategyFactory schedulingStrategyFactory =\n                new VertexwiseSchedulingStrategy.Factory(\n                        loadInputConsumableDeciderFactory(hybridOnlyConsumeFinishedPartition));\n\n        if (enableSpeculativeExecution) {\n            return new SpeculativeScheduler(\n                    log,\n                    jobGraph,\n                    ioExecutor,\n                    jobMasterConfiguration,\n                    combinedStartUpActions,\n                    new ScheduledExecutorServiceAdapter(futureExecutor),\n                    userCodeLoader,\n                    new CheckpointsCleaner(),\n                    checkpointRecoveryFactory,\n                    jobManagerJobMetricGroup,\n                    schedulingStrategyFactory,\n                    FailoverStrategyFactoryLoader.loadFailoverStrategyFactory(\n                            jobMasterConfiguration),\n                    restartBackoffTimeStrategy,\n                    new DefaultExecutionOperations(),\n                    new ExecutionVertexVersioner(),\n                    allocatorFactory,\n                    initializationTimestamp,\n                    mainThreadExecutor,\n                    jobStatusListener,\n                    executionGraphFactory,\n                    shuffleMaster,\n                    rpcTimeout,\n                    DefaultVertexParallelismDecider.from(jobMasterConfiguration),\n                    DefaultVertexParallelismDecider.getNormalizedMaxParallelism(\n                            jobMasterConfiguration),\n                    blocklistOperations,\n                    hybridOnlyConsumeFinishedPartition);\n        } else {\n            return new AdaptiveBatchScheduler(\n                    log,\n                    jobGraph,\n                    ioExecutor,\n                    jobMasterConfiguration,\n                    combinedStartUpActions,\n                    new ScheduledExecutorServiceAdapter(futureExecutor),\n                    userCodeLoader,\n                    new CheckpointsCleaner(),\n                    checkpointRecoveryFactory,\n                    jobManagerJobMetricGroup,\n                    schedulingStrategyFactory,\n                    FailoverStrategyFactoryLoader.loadFailoverStrategyFactory(\n                            jobMasterConfiguration),\n                    restartBackoffTimeStrategy,\n                    new DefaultExecutionOperations(),\n                    new ExecutionVertexVersioner(),\n                    allocatorFactory,\n                    initializationTimestamp,\n                    mainThreadExecutor,\n                    jobStatusListener,\n                    executionGraphFactory,\n                    shuffleMaster,\n                    rpcTimeout,\n                    DefaultVertexParallelismDecider.from(jobMasterConfiguration),\n                    DefaultVertexParallelismDecider.getNormalizedMaxParallelism(\n                            jobMasterConfiguration),\n                    hybridOnlyConsumeFinishedPartition);\n        }\n    }",
          "conflictNames": [
              "log",
              "jobGraph",
              "ioExecutor",
              "jobMasterConfiguration",
              "slotPoolService",
              "futureExecutor",
              "userCodeLoader",
              "checkpointRecoveryFactory",
              "rpcTimeout",
              "blobWriter",
              "jobManagerJobMetricGroup",
              "slotRequestTimeout",
              "shuffleMaster",
              "partitionTracker",
              "executionDeploymentTracker",
              "initializationTimestamp",
              "mainThreadExecutor",
              "fatalErrorHandler",
              "jobStatusListener",
              "blocklistOperations",
              "slotPool",
              "enableSpeculativeExecution",
              "startUpActions",
              "combinedStartUpActions",
              "allocatorFactory",
              "restartBackoffTimeStrategy",
              "executionGraphFactory",
              "schedulingStrategyFactory"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d65f7c1c2f3bf3076fee6940e538c3725eee0a05^1/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java",
      "locators": [
          {
              "line": 655,
              "column": 48
          },
          {
              "line": 700,
              "column": 48
          },
          {
              "line": 719,
              "column": 41
          },
          {
              "line": 720,
              "column": 13
          },
          {
              "line": 724,
              "column": 34
          },
          {
              "line": 724,
              "column": 56
          },
          {
              "line": 725,
              "column": 36
          },
          {
              "line": 725,
              "column": 55
          },
          {
              "line": 726,
              "column": 46
          },
          {
              "line": 730,
              "column": 39
          },
          {
              "line": 732,
              "column": 60
          },
          {
              "line": 733,
              "column": 33
          },
          {
              "line": 733,
              "column": 44
          },
          {
              "line": 734,
              "column": 38
          },
          {
              "line": 734,
              "column": 54
          },
          {
              "line": 741,
              "column": 21
          },
          {
              "line": 742,
              "column": 28
          },
          {
              "line": 743,
              "column": 28
          },
          {
              "line": 745,
              "column": 41
          },
          {
              "line": 747,
              "column": 25
          },
          {
              "line": 748,
              "column": 25
          },
          {
              "line": 750,
              "column": 25
          }
      ],
      "old_name": "consumer",
      "new_name": "consumers",
      "ctx": {
          "symbolName": "consumer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Execution",
          "scopeHint": "in updatePartitionConsumers(...)",
          "filePath": "Execution.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void updatePartitionConsumers(final IntermediateResultPartition partition) {\n        final List<ConsumerVertexGroup> consumerVertexGroups = partition.getConsumerVertexGroups();\n        if (consumerVertexGroups.isEmpty()) {\n            return;\n        }\n        final Set<ExecutionVertexID> updatedVertices = new HashSet<>();\n        for (ConsumerVertexGroup consumerVertexGroup : consumerVertexGroups) {\n            for (ExecutionVertexID consumerVertexId : consumerVertexGroup) {\n                if (updatedVertices.contains(consumerVertexId)) {\n                    continue;\n                }\n\n                final ExecutionVertex consumerVertex =\n                        vertex.getExecutionGraphAccessor()\n                                .getExecutionVertexOrThrow(consumerVertexId);\n                final Execution consumer = consumerVertex.getCurrentExecutionAttempt();\n                final ExecutionState consumerState = consumer.getState();\n\n                // ----------------------------------------------------------------\n                // Consumer is recovering or running => send update message now\n                // Consumer is deploying => cache the partition info which would be\n                // sent after switching to running\n                // ----------------------------------------------------------------\n                if (consumerState == DEPLOYING\n                        || consumerState == RUNNING\n                        || consumerState == INITIALIZING) {\n                    final PartitionInfo partitionInfo = createPartitionInfo(partition);\n                    updatedVertices.add(consumerVertexId);\n\n                    if (consumerState == DEPLOYING) {\n                        consumerVertex.cachePartitionInfo(partitionInfo);\n                    } else {\n                        consumer.sendUpdatePartitionInfoRpcCall(\n                                Collections.singleton(partitionInfo));\n                    }\n                }\n            }\n        }\n    }",
          "conflictNames": [
              "partition",
              "consumerVertexGroups",
              "updatedVertices",
              "consumerVertex",
              "consumerState",
              "partitionInfo"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d853b7104c145f0c22b54511ee92e0d368a764f4^1/flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBNativeMetricMonitorTest.java",
      "locators": [
          {
              "line": 54,
              "column": 25
          },
          {
              "line": 55,
              "column": 9
          },
          {
              "line": 75,
              "column": 25
          },
          {
              "line": 76,
              "column": 25
          },
          {
              "line": 78,
              "column": 37
          },
          {
              "line": 85,
              "column": 9
          },
          {
              "line": 106,
              "column": 9
          },
          {
              "line": 124,
              "column": 25
          },
          {
              "line": 125,
              "column": 9
          },
          {
              "line": 141,
              "column": 25
          },
          {
              "line": 142,
              "column": 25
          },
          {
              "line": 152,
              "column": 9
          }
      ],
      "old_name": "localRocksDBResource",
      "new_name": "localRocksDBExtension",
      "ctx": {
          "symbolName": "localRocksDBResource",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RocksDBResource",
          "scopeHint": "in testMetricMonitorLifecycle(...)",
          "filePath": "RocksDBNativeMetricMonitorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testMetricMonitorLifecycle() throws Throwable {\n        // We use a local variable here to manually control the life-cycle.\n        // This allows us to verify that metrics do not try to access\n        // RocksDB after the monitor was closed.\n        RocksDBResource localRocksDBResource = new RocksDBResource(true);\n        localRocksDBResource.before();\n\n        SimpleMetricRegistry registry = new SimpleMetricRegistry();\n        GenericMetricGroup group =\n                new GenericMetricGroup(\n                        registry,\n                        UnregisteredMetricGroups.createUnregisteredTaskMetricGroup(),\n                        OPERATOR_NAME);\n\n        RocksDBNativeMetricOptions options = new RocksDBNativeMetricOptions();\n        // always returns a non-zero\n        // value since empty memtables\n        // have overhead.\n        options.enableSizeAllMemTables();\n        options.enableNativeStatistics(RocksDBNativeMetricOptions.MONITOR_BYTES_WRITTEN);\n\n        RocksDBNativeMetricMonitor monitor =\n                new RocksDBNativeMetricMonitor(\n                        options,\n                        group,\n                        localRocksDBResource.getRocksDB(),\n                        localRocksDBResource.getDbOptions().statistics());\n\n        ColumnFamilyHandle handle = localRocksDBResource.createNewColumnFamily(COLUMN_FAMILY_NAME);\n        monitor.registerColumnFamily(COLUMN_FAMILY_NAME, handle);\n\n        Assert.assertEquals(\n                \"Failed to register metrics for column family\", 1, registry.propertyMetrics.size());\n\n        // write something to ensure the bytes-written is not zero.\n        localRocksDBResource.getRocksDB().put(new byte[4], new byte[10]);\n\n        for (RocksDBNativeMetricMonitor.RocksDBNativePropertyMetricView view :\n                registry.propertyMetrics) {\n            view.update();\n            Assert.assertNotEquals(\n                    \"Failed to pull metric from RocksDB\", BigInteger.ZERO, view.getValue());\n            view.setValue(0L);\n        }\n\n        for (RocksDBNativeMetricMonitor.RocksDBNativeStatisticsMetricView view :\n                registry.statisticsMetrics) {\n            view.update();\n            Assert.assertNotEquals(0L, (long) view.getValue());\n            view.setValue(0L);\n        }\n\n        // After the monitor is closed no metric should be accessing RocksDB anymore.\n        // If they do, then this test will likely fail with a segmentation fault.\n        monitor.close();\n\n        localRocksDBResource.after();\n\n        for (RocksDBNativeMetricMonitor.RocksDBNativePropertyMetricView view :\n                registry.propertyMetrics) {\n            view.update();\n            Assert.assertEquals(\n                    \"Failed to release RocksDB reference\", BigInteger.ZERO, view.getValue());\n        }\n\n        for (RocksDBNativeMetricMonitor.RocksDBNativeStatisticsMetricView view :\n                registry.statisticsMetrics) {\n            view.update();\n            Assert.assertEquals(0L, (long) view.getValue());\n        }\n    }",
          "conflictNames": [
              "registry",
              "group",
              "options",
              "monitor",
              "handle"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/d9fc5ee03afe86e3d4c2fcee50616df2a7c095f2^1/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/failover/RestartBackoffTimeStrategyFactoryLoaderTest.java",
      "locators": [
          {
              "line": 191,
              "column": 46
          },
          {
              "line": 194,
              "column": 28
          },
          {
              "line": 196,
              "column": 28
          }
      ],
      "old_name": "fixedDelayStrategy",
      "new_name": "exponentialDelayStrategy",
      "ctx": {
          "symbolName": "fixedDelayStrategy",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "FixedDelayRestartBackoffTimeStrategy",
          "scopeHint": "in testNoStrategySpecifiedWhenCheckpointingEnabled(...)",
          "filePath": "RestartBackoffTimeStrategyFactoryLoaderTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testNoStrategySpecifiedWhenCheckpointingEnabled() {\n        final RestartBackoffTimeStrategy.Factory factory =\n                RestartBackoffTimeStrategyFactoryLoader.createRestartBackoffTimeStrategyFactory(\n                        DEFAULT_JOB_LEVEL_RESTART_CONFIGURATION, new Configuration(), true);\n\n        RestartBackoffTimeStrategy strategy = factory.create();\n        assertThat(strategy).isInstanceOf(FixedDelayRestartBackoffTimeStrategy.class);\n\n        FixedDelayRestartBackoffTimeStrategy fixedDelayStrategy =\n                (FixedDelayRestartBackoffTimeStrategy) strategy;\n        assertThat(RestartBackoffTimeStrategyFactoryLoader.DEFAULT_RESTART_DELAY)\n                .isEqualTo(fixedDelayStrategy.getBackoffTime());\n        assertThat(RestartBackoffTimeStrategyFactoryLoader.DEFAULT_RESTART_ATTEMPTS)\n                .isEqualTo(fixedDelayStrategy.getMaxNumberRestartAttempts());\n    }",
          "conflictNames": [
              "factory",
              "strategy"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/daf476f76bd3ff58e34a01848a76ee1c985b2fc3^1/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/storage/TieredStorageProducerClient.java",
      "locators": [
          {
              "line": 2,
              "column": 7
          },
          {
              "line": 2,
              "column": 10
          },
          {
              "line": 2,
              "column": 18
          },
          {
              "line": 2,
              "column": 25
          },
          {
              "line": 2,
              "column": 34
          },
          {
              "line": 2,
              "column": 56
          },
          {
              "line": 2,
              "column": 61
          },
          {
              "line": 3,
              "column": 10
          },
          {
              "line": 3,
              "column": 27
          },
          {
              "line": 3,
              "column": 30
          },
          {
              "line": 3,
              "column": 35
          },
          {
              "line": 3,
              "column": 36
          },
          {
              "line": 3,
              "column": 38
          },
          {
              "line": 3,
              "column": 46
          },
          {
              "line": 3,
              "column": 47
          },
          {
              "line": 3,
              "column": 51
          },
          {
              "line": 3,
              "column": 63
          },
          {
              "line": 4,
              "column": 13
          },
          {
              "line": 5,
              "column": 5
          },
          {
              "line": 5,
              "column": 27
          },
          {
              "line": 5,
              "column": 38
          },
          {
              "line": 5,
              "column": 47
          },
          {
              "line": 5,
              "column": 50
          },
          {
              "line": 5,
              "column": 61
          },
          {
              "line": 6,
              "column": 14
          },
          {
              "line": 6,
              "column": 19
          },
          {
              "line": 6,
              "column": 26
          },
          {
              "line": 6,
              "column": 31
          },
          {
              "line": 6,
              "column": 34
          },
          {
              "line": 6,
              "column": 38
          },
          {
              "line": 6,
              "column": 52
          },
          {
              "line": 7,
              "column": 8
          },
          {
              "line": 7,
              "column": 11
          },
          {
              "line": 7,
              "column": 30
          },
          {
              "line": 7,
              "column": 40
          },
          {
              "line": 7,
              "column": 42
          },
          {
              "line": 7,
              "column": 45
          },
          {
              "line": 7,
              "column": 61
          },
          {
              "line": 8,
              "column": 11
          },
          {
              "line": 8,
              "column": 16
          },
          {
              "line": 8,
              "column": 19
          },
          {
              "line": 8,
              "column": 50
          },
          {
              "line": 8,
              "column": 55
          },
          {
              "line": 8,
              "column": 58
          },
          {
              "line": 10,
              "column": 24
          },
          {
              "line": 10,
              "column": 33
          },
          {
              "line": 10,
              "column": 36
          },
          {
              "line": 12,
              "column": 7
          },
          {
              "line": 12,
              "column": 12
          },
          {
              "line": 12,
              "column": 17
          },
          {
              "line": 12,
              "column": 32
          },
          {
              "line": 12,
              "column": 44
          },
          {
              "line": 12,
              "column": 45
          },
          {
              "line": 12,
              "column": 70
          },
          {
              "line": 13,
              "column": 13
          },
          {
              "line": 13,
              "column": 19
          },
          {
              "line": 13,
              "column": 24
          },
          {
              "line": 13,
              "column": 29
          },
          {
              "line": 13,
              "column": 32
          },
          {
              "line": 13,
              "column": 46
          },
          {
              "line": 14,
              "column": 50
          },
          {
              "line": 14,
              "column": 54
          },
          {
              "line": 14,
              "column": 57
          },
          {
              "line": 14,
              "column": 61
          },
          {
              "line": 14,
              "column": 73
          },
          {
              "line": 15,
              "column": 5
          },
          {
              "line": 15,
              "column": 6
          },
          {
              "line": 15,
              "column": 10
          },
          {
              "line": 15,
              "column": 15
          },
          {
              "line": 15,
              "column": 18
          },
          {
              "line": 15,
              "column": 26
          },
          {
              "line": 15,
              "column": 30
          },
          {
              "line": 15,
              "column": 44
          },
          {
              "line": 15,
              "column": 49
          },
          {
              "line": 15,
              "column": 57
          },
          {
              "line": 16,
              "column": 19
          },
          {
              "line": 16,
              "column": 24
          },
          {
              "line": 16,
              "column": 29
          },
          {
              "line": 16,
              "column": 32
          },
          {
              "line": 19,
              "column": 7
          },
          {
              "line": 19,
              "column": 18
          },
          {
              "line": 19,
              "column": 32
          },
          {
              "line": 19,
              "column": 38
          },
          {
              "line": 19,
              "column": 64
          },
          {
              "line": 19,
              "column": 66
          },
          {
              "line": 19,
              "column": 75
          },
          {
              "line": 21,
              "column": 17
          },
          {
              "line": 21,
              "column": 31
          },
          {
              "line": 21,
              "column": 37
          },
          {
              "line": 21,
              "column": 48
          },
          {
              "line": 21,
              "column": 55
          },
          {
              "line": 22,
              "column": 17
          },
          {
              "line": 22,
              "column": 31
          },
          {
              "line": 22,
              "column": 37
          },
          {
              "line": 22,
              "column": 48
          },
          {
              "line": 22,
              "column": 55
          },
          {
              "line": 22,
              "column": 62
          },
          {
              "line": 23,
              "column": 17
          },
          {
              "line": 23,
              "column": 31
          },
          {
              "line": 23,
              "column": 37
          },
          {
              "line": 23,
              "column": 63
          },
          {
              "line": 23,
              "column": 65
          },
          {
              "line": 23,
              "column": 77
          },
          {
              "line": 23,
              "column": 79
          },
          {
              "line": 23,
              "column": 87
          },
          {
              "line": 24,
              "column": 17
          },
          {
              "line": 24,
              "column": 31
          },
          {
              "line": 24,
              "column": 37
          },
          {
              "line": 24,
              "column": 63
          },
          {
              "line": 24,
              "column": 65
          },
          {
              "line": 24,
              "column": 70
          },
          {
              "line": 24,
              "column": 75
          },
          {
              "line": 24,
              "column": 83
          },
          {
              "line": 24,
              "column": 87
          },
          {
              "line": 25,
              "column": 17
          },
          {
              "line": 25,
              "column": 33
          },
          {
              "line": 27,
              "column": 32
          },
          {
              "line": 29,
              "column": 21
          },
          {
              "line": 30,
              "column": 20
          },
          {
              "line": 30,
              "column": 25
          },
          {
              "line": 33,
              "column": 8
          },
          {
              "line": 33,
              "column": 17
          },
          {
              "line": 33,
              "column": 21
          },
          {
              "line": 33,
              "column": 23
          },
          {
              "line": 33,
              "column": 32
          },
          {
              "line": 33,
              "column": 36
          },
          {
              "line": 33,
              "column": 44
          },
          {
              "line": 33,
              "column": 52
          },
          {
              "line": 34,
              "column": 16
          },
          {
              "line": 34,
              "column": 18
          },
          {
              "line": 34,
              "column": 26
          },
          {
              "line": 34,
              "column": 33
          },
          {
              "line": 34,
              "column": 38
          },
          {
              "line": 35,
              "column": 11
          },
          {
              "line": 35,
              "column": 23
          },
          {
              "line": 37,
              "column": 11
          },
          {
              "line": 39,
              "column": 11
          },
          {
              "line": 39,
              "column": 23
          },
          {
              "line": 39,
              "column": 41
          },
          {
              "line": 41,
              "column": 11
          },
          {
              "line": 41,
              "column": 23
          },
          {
              "line": 41,
              "column": 30
          },
          {
              "line": 41,
              "column": 40
          },
          {
              "line": 41,
              "column": 47
          },
          {
              "line": 43,
              "column": 11
          },
          {
              "line": 43,
              "column": 26
          },
          {
              "line": 43,
              "column": 34
          },
          {
              "line": 43,
              "column": 38
          },
          {
              "line": 43,
              "column": 45
          },
          {
              "line": 43,
              "column": 53
          },
          {
              "line": 43,
              "column": 57
          },
          {
              "line": 45,
              "column": 14
          },
          {
              "line": 45,
              "column": 16
          },
          {
              "line": 45,
              "column": 24
          },
          {
              "line": 45,
              "column": 31
          },
          {
              "line": 45,
              "column": 36
          },
          {
              "line": 47,
              "column": 17
          },
          {
              "line": 48,
              "column": 17
          },
          {
              "line": 48,
              "column": 35
          },
          {
              "line": 49,
              "column": 21
          },
          {
              "line": 49,
              "column": 27
          },
          {
              "line": 49,
              "column": 34
          },
          {
              "line": 49,
              "column": 44
          },
          {
              "line": 49,
              "column": 51
          },
          {
              "line": 50,
              "column": 20
          },
          {
              "line": 50,
              "column": 28
          },
          {
              "line": 50,
              "column": 32
          },
          {
              "line": 50,
              "column": 39
          },
          {
              "line": 50,
              "column": 47
          },
          {
              "line": 50,
              "column": 51
          },
          {
              "line": 53,
              "column": 18
          },
          {
              "line": 53,
              "column": 38
          },
          {
              "line": 54,
              "column": 18
          },
          {
              "line": 54,
              "column": 25
          },
          {
              "line": 54,
              "column": 37
          },
          {
              "line": 54,
              "column": 44
          },
          {
              "line": 55,
              "column": 16
          },
          {
              "line": 55,
              "column": 24
          },
          {
              "line": 55,
              "column": 28
          },
          {
              "line": 55,
              "column": 37
          },
          {
              "line": 55,
              "column": 45
          },
          {
              "line": 55,
              "column": 49
          },
          {
              "line": 57,
              "column": 13
          },
          {
              "line": 57,
              "column": 28
          },
          {
              "line": 57,
              "column": 43
          },
          {
              "line": 57,
              "column": 53
          },
          {
              "line": 57,
              "column": 59
          },
          {
              "line": 61,
              "column": 12
          },
          {
              "line": 61,
              "column": 15
          },
          {
              "line": 61,
              "column": 27
          },
          {
              "line": 61,
              "column": 35
          },
          {
              "line": 61,
              "column": 41
          },
          {
              "line": 61,
              "column": 48
          },
          {
              "line": 61,
              "column": 61
          },
          {
              "line": 61,
              "column": 90
          },
          {
              "line": 61,
              "column": 94
          },
          {
              "line": 62,
              "column": 9
          },
          {
              "line": 62,
              "column": 25
          },
          {
              "line": 64,
              "column": 14
          },
          {
              "line": 64,
              "column": 40
          },
          {
              "line": 64,
              "column": 45
          },
          {
              "line": 64,
              "column": 48
          },
          {
              "line": 64,
              "column": 53
          },
          {
              "line": 64,
              "column": 56
          },
          {
              "line": 64,
              "column": 80
          },
          {
              "line": 65,
              "column": 15
          },
          {
              "line": 65,
              "column": 20
          },
          {
              "line": 65,
              "column": 23
          },
          {
              "line": 65,
              "column": 28
          },
          {
              "line": 65,
              "column": 31
          },
          {
              "line": 65,
              "column": 68
          },
          {
              "line": 65,
              "column": 73
          },
          {
              "line": 65,
              "column": 76
          },
          {
              "line": 66,
              "column": 29
          },
          {
              "line": 66,
              "column": 32
          },
          {
              "line": 66,
              "column": 54
          },
          {
              "line": 66,
              "column": 63
          },
          {
              "line": 66,
              "column": 66
          },
          {
              "line": 66,
              "column": 78
          },
          {
              "line": 66,
              "column": 85
          },
          {
              "line": 66,
              "column": 97
          },
          {
              "line": 69,
              "column": 16
          },
          {
              "line": 69,
              "column": 24
          },
          {
              "line": 69,
              "column": 31
          },
          {
              "line": 69,
              "column": 35
          },
          {
              "line": 70,
              "column": 32
          },
          {
              "line": 70,
              "column": 49
          },
          {
              "line": 70,
              "column": 55
          },
          {
              "line": 71,
              "column": 22
          },
          {
              "line": 71,
              "column": 26
          },
          {
              "line": 71,
              "column": 36
          },
          {
              "line": 71,
              "column": 43
          },
          {
              "line": 71,
              "column": 46
          },
          {
              "line": 72,
              "column": 29
          },
          {
              "line": 72,
              "column": 32
          },
          {
              "line": 72,
              "column": 37
          },
          {
              "line": 72,
              "column": 40
          },
          {
              "line": 72,
              "column": 62
          },
          {
              "line": 74,
              "column": 21
          },
          {
              "line": 75,
              "column": 16
          },
          {
              "line": 75,
              "column": 21
          },
          {
              "line": 75,
              "column": 25
          },
          {
              "line": 76,
              "column": 15
          },
          {
              "line": 76,
              "column": 17
          },
          {
              "line": 76,
              "column": 25
          },
          {
              "line": 77,
              "column": 17
          },
          {
              "line": 77,
              "column": 27
          },
          {
              "line": 77,
              "column": 36
          },
          {
              "line": 78,
              "column": 17
          },
          {
              "line": 79,
              "column": 25
          },
          {
              "line": 83,
              "column": 25
          },
          {
              "line": 83,
              "column": 29
          },
          {
              "line": 83,
              "column": 31
          },
          {
              "line": 83,
              "column": 40
          },
          {
              "line": 83,
              "column": 63
          },
          {
              "line": 83,
              "column": 66
          },
          {
              "line": 83,
              "column": 89
          },
          {
              "line": 84,
              "column": 28
          },
          {
              "line": 84,
              "column": 31
          },
          {
              "line": 84,
              "column": 33
          },
          {
              "line": 84,
              "column": 49
          },
          {
              "line": 84,
              "column": 59
          },
          {
              "line": 84,
              "column": 62
          },
          {
              "line": 84,
              "column": 71
          },
          {
              "line": 84,
              "column": 84
          },
          {
              "line": 84,
              "column": 86
          },
          {
              "line": 84,
              "column": 95
          },
          {
              "line": 85,
              "column": 22
          },
          {
              "line": 85,
              "column": 24
          },
          {
              "line": 85,
              "column": 32
          },
          {
              "line": 85,
              "column": 51
          },
          {
              "line": 85,
              "column": 59
          },
          {
              "line": 85,
              "column": 62
          },
          {
              "line": 85,
              "column": 65
          },
          {
              "line": 85,
              "column": 72
          },
          {
              "line": 85,
              "column": 79
          },
          {
              "line": 85,
              "column": 83
          },
          {
              "line": 85,
              "column": 91
          },
          {
              "line": 86,
              "column": 21
          },
          {
              "line": 86,
              "column": 30
          },
          {
              "line": 86,
              "column": 52
          },
          {
              "line": 86,
              "column": 55
          },
          {
              "line": 86,
              "column": 76
          },
          {
              "line": 86,
              "column": 85
          },
          {
              "line": 87,
              "column": 21
          },
          {
              "line": 87,
              "column": 36
          },
          {
              "line": 87,
              "column": 38
          },
          {
              "line": 87,
              "column": 41
          },
          {
              "line": 88,
              "column": 26
          },
          {
              "line": 88,
              "column": 40
          },
          {
              "line": 88,
              "column": 46
          },
          {
              "line": 88,
              "column": 51
          },
          {
              "line": 88,
              "column": 53
          },
          {
              "line": 88,
              "column": 61
          },
          {
              "line": 88,
              "column": 88
          },
          {
              "line": 90,
              "column": 11
          },
          {
              "line": 90,
              "column": 14
          },
          {
              "line": 91,
              "column": 17
          },
          {
              "line": 91,
              "column": 32
          },
          {
              "line": 91,
              "column": 34
          },
          {
              "line": 91,
              "column": 37
          },
          {
              "line": 91,
              "column": 40
          },
          {
              "line": 91,
              "column": 70
          },
          {
              "line": 95,
              "column": 21
          },
          {
              "line": 96,
              "column": 13
          },
          {
              "line": 96,
              "column": 31
          },
          {
              "line": 97,
              "column": 11
          },
          {
              "line": 97,
              "column": 19
          },
          {
              "line": 97,
              "column": 23
          },
          {
              "line": 97,
              "column": 38
          },
          {
              "line": 97,
              "column": 46
          },
          {
              "line": 97,
              "column": 50
          },
          {
              "line": 97,
              "column": 59
          },
          {
              "line": 101,
              "column": 12
          },
          {
              "line": 101,
              "column": 16
          },
          {
              "line": 101,
              "column": 27
          },
          {
              "line": 101,
              "column": 34
          },
          {
              "line": 101,
              "column": 66
          },
          {
              "line": 101,
              "column": 78
          },
          {
              "line": 101,
              "column": 82
          },
          {
              "line": 103,
              "column": 32
          },
          {
              "line": 103,
              "column": 49
          },
          {
              "line": 103,
              "column": 55
          },
          {
              "line": 104,
              "column": 24
          },
          {
              "line": 104,
              "column": 30
          },
          {
              "line": 104,
              "column": 36
          },
          {
              "line": 104,
              "column": 47
          },
          {
              "line": 104,
              "column": 54
          },
          {
              "line": 106,
              "column": 11
          },
          {
              "line": 106,
              "column": 22
          },
          {
              "line": 106,
              "column": 32
          },
          {
              "line": 106,
              "column": 38
          },
          {
              "line": 107,
              "column": 15
          },
          {
              "line": 107,
              "column": 17
          },
          {
              "line": 107,
              "column": 25
          },
          {
              "line": 107,
              "column": 66
          },
          {
              "line": 107,
              "column": 79
          },
          {
              "line": 107,
              "column": 85
          },
          {
              "line": 109,
              "column": 22
          },
          {
              "line": 109,
              "column": 31
          },
          {
              "line": 109,
              "column": 37
          },
          {
              "line": 109,
              "column": 51
          },
          {
              "line": 109,
              "column": 57
          },
          {
              "line": 110,
              "column": 21
          },
          {
              "line": 110,
              "column": 31
          },
          {
              "line": 110,
              "column": 37
          },
          {
              "line": 110,
              "column": 62
          },
          {
              "line": 110,
              "column": 68
          },
          {
              "line": 112,
              "column": 23
          },
          {
              "line": 112,
              "column": 30
          },
          {
              "line": 113,
              "column": 16
          },
          {
              "line": 113,
              "column": 29
          },
          {
              "line": 113,
              "column": 36
          },
          {
              "line": 118,
              "column": 12
          },
          {
              "line": 118,
              "column": 16
          },
          {
              "line": 118,
              "column": 27
          },
          {
              "line": 118,
              "column": 34
          },
          {
              "line": 118,
              "column": 76
          },
          {
              "line": 118,
              "column": 80
          },
          {
              "line": 118,
              "column": 87
          },
          {
              "line": 118,
              "column": 92
          },
          {
              "line": 118,
              "column": 96
          },
          {
              "line": 119,
              "column": 9
          },
          {
              "line": 119,
              "column": 13
          },
          {
              "line": 119,
              "column": 19
          },
          {
              "line": 119,
              "column": 25
          },
          {
              "line": 119,
              "column": 34
          },
          {
              "line": 119,
              "column": 41
          },
          {
              "line": 119,
              "column": 49
          },
          {
              "line": 119,
              "column": 52
          },
          {
              "line": 119,
              "column": 54
          },
          {
              "line": 119,
              "column": 57
          },
          {
              "line": 119,
              "column": 62
          },
          {
              "line": 121,
              "column": 32
          },
          {
              "line": 121,
              "column": 49
          },
          {
              "line": 121,
              "column": 55
          },
          {
              "line": 122,
              "column": 24
          },
          {
              "line": 122,
              "column": 30
          },
          {
              "line": 122,
              "column": 35
          },
          {
              "line": 122,
              "column": 46
          },
          {
              "line": 122,
              "column": 53
          },
          {
              "line": 124,
              "column": 11
          },
          {
              "line": 124,
              "column": 22
          },
          {
              "line": 124,
              "column": 32
          },
          {
              "line": 124,
              "column": 38
          },
          {
              "line": 125,
              "column": 15
          },
          {
              "line": 125,
              "column": 17
          },
          {
              "line": 125,
              "column": 25
          },
          {
              "line": 125,
              "column": 61
          },
          {
              "line": 125,
              "column": 73
          },
          {
              "line": 125,
              "column": 79
          },
          {
              "line": 126,
              "column": 25
          },
          {
              "line": 127,
              "column": 29
          },
          {
              "line": 127,
              "column": 33
          },
          {
              "line": 127,
              "column": 44
          },
          {
              "line": 127,
              "column": 51
          },
          {
              "line": 127,
              "column": 59
          },
          {
              "line": 127,
              "column": 71
          },
          {
              "line": 127,
              "column": 75
          },
          {
              "line": 127,
              "column": 82
          },
          {
              "line": 127,
              "column": 87
          },
          {
              "line": 127,
              "column": 91
          },
          {
              "line": 128,
              "column": 13
          },
          {
              "line": 128,
              "column": 17
          },
          {
              "line": 128,
              "column": 23
          },
          {
              "line": 128,
              "column": 30
          },
          {
              "line": 128,
              "column": 34
          },
          {
              "line": 128,
              "column": 45
          },
          {
              "line": 128,
              "column": 52
          },
          {
              "line": 128,
              "column": 60
          },
          {
              "line": 128,
              "column": 64
          }
      ],
      "old_name": "e",
      "new_name": "ioe",
      "ctx": {
          "symbolName": "e",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "IOException",
          "scopeHint": "in writeAccumulatedBuffers(...)",
          "filePath": "TieredStorageProducerClient.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "titionId subpartitionId, List<Buffer> accumulatedBuffers) {\n        try {\n            for (Buffer finishedBuffer : accumulatedBuffers) {\n                writeAccumulatedBuffer(subpartitionId, finishedBuffer);\n            }\n        } catch (IOException e) {\n            ExceptionUtils.rethrow(e);\n        }\n    }\n\n    /**\n     * Write the accumulated buffer of this subpartitionId to an appropriate tier. After the tier is\n     * decided, the buffer will be written to the selected tier.\n     *",
          "conflictNames": [
              "subpartitionId",
              "accumulatedBuffers"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/dafed7ed282ba0807cf67e8ad2aa14cf68028ee6^1/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/api/internal/StatementSetImplTest.java",
      "locators": [
          {
              "line": 70,
              "column": 16
          },
          {
              "line": 74,
              "column": 72
          }
      ],
      "old_name": "actual",
      "new_name": "expected",
      "ctx": {
          "symbolName": "actual",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in testGetJsonPlan(...)",
          "filePath": "StatementSetImplTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testGetJsonPlan() throws IOException {\n        String srcTableDdl =\n                \"CREATE TABLE MyTable (\\n\"\n                        + \"  a bigint,\\n\"\n                        + \"  b int,\\n\"\n                        + \"  c varchar\\n\"\n                        + \") with (\\n\"\n                        + \"  'connector' = 'values',\\n\"\n                        + \"  'bounded' = 'false')\";\n        tableEnv.executeSql(srcTableDdl);\n\n        String sinkTableDdl =\n                \"CREATE TABLE MySink (\\n\"\n                        + \"  a bigint,\\n\"\n                        + \"  b int,\\n\"\n                        + \"  c varchar\\n\"\n                        + \") with (\\n\"\n                        + \"  'connector' = 'values',\\n\"\n                        + \"  'table-sink-class' = 'DEFAULT')\";\n        tableEnv.executeSql(sinkTableDdl);\n\n        StatementSet stmtSet = tableEnv.createStatementSet();\n        stmtSet.addInsertSql(\"INSERT INTO MySink SELECT * FROM MyTable\");\n        String jsonPlan = stmtSet.compilePlan().asJsonString();\n        String actual = TableTestUtil.readFromResource(\"/jsonplan/testGetJsonPlan.out\");\n        assertThat(\n                        TableTestUtil.getFormattedJson(\n                                TableTestUtil.replaceExecNodeId(\n                                        TableTestUtil.getFormattedJson(actual))))\n                .isEqualTo(\n                        TableTestUtil.getFormattedJson(\n                                TableTestUtil.replaceExecNodeId(\n                                        TableTestUtil.replaceFlinkVersion(\n                                                TableTestUtil.getFormattedJson(jsonPlan)))));\n    }",
          "conflictNames": [
              "srcTableDdl",
              "sinkTableDdl",
              "stmtSet",
              "jsonPlan"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/db682b9869dcedce1873c6ee5252b0e351373a69^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerTest.java",
      "locators": [
          {
              "line": 2183,
              "column": 24
          },
          {
              "line": 2186,
              "column": 77
          },
          {
              "line": 2190,
              "column": 64
          },
          {
              "line": 2310,
              "column": 24
          },
          {
              "line": 2315,
              "column": 77
          },
          {
              "line": 2336,
              "column": 68
          }
      ],
      "old_name": "scalingIntervalMax",
      "new_name": "scalingStabilizationTimeout",
      "ctx": {
          "symbolName": "scalingIntervalMax",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Duration",
          "scopeHint": "in testScalingIntervalConfigurationIsRespected(...)",
          "filePath": "AdaptiveSchedulerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testScalingIntervalConfigurationIsRespected() throws ConfigurationException {\n        final Duration scalingIntervalMin = Duration.ofMillis(1337);\n        final Duration scalingIntervalMax = Duration.ofMillis(7331);\n        final Configuration configuration = createConfigurationWithNoTimeouts();\n        configuration.set(JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MIN, scalingIntervalMin);\n        configuration.set(JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MAX, scalingIntervalMax);\n\n        final AdaptiveScheduler.Settings settings = AdaptiveScheduler.Settings.of(configuration);\n        assertThat(settings.getScalingIntervalMin()).isEqualTo(scalingIntervalMin);\n        assertThat(settings.getScalingIntervalMax()).isEqualTo(scalingIntervalMax);\n    }",
          "conflictNames": [
              "scalingIntervalMin",
              "configuration",
              "settings"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/db682b9869dcedce1873c6ee5252b0e351373a69^1/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerTest.java",
      "locators": [
          {
              "line": 2183,
              "column": 24
          },
          {
              "line": 2186,
              "column": 77
          },
          {
              "line": 2190,
              "column": 64
          },
          {
              "line": 2310,
              "column": 24
          },
          {
              "line": 2315,
              "column": 77
          },
          {
              "line": 2336,
              "column": 68
          }
      ],
      "old_name": "scalingIntervalMax",
      "new_name": "scalingResourceStabilizationTimeout",
      "ctx": {
          "symbolName": "scalingIntervalMax",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Duration",
          "scopeHint": "in testScalingIntervalConfigurationIsRespected(...)",
          "filePath": "AdaptiveSchedulerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testScalingIntervalConfigurationIsRespected() throws ConfigurationException {\n        final Duration scalingIntervalMin = Duration.ofMillis(1337);\n        final Duration scalingIntervalMax = Duration.ofMillis(7331);\n        final Configuration configuration = createConfigurationWithNoTimeouts();\n        configuration.set(JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MIN, scalingIntervalMin);\n        configuration.set(JobManagerOptions.SCHEDULER_SCALING_INTERVAL_MAX, scalingIntervalMax);\n\n        final AdaptiveScheduler.Settings settings = AdaptiveScheduler.Settings.of(configuration);\n        assertThat(settings.getScalingIntervalMin()).isEqualTo(scalingIntervalMin);\n        assertThat(settings.getScalingIntervalMax()).isEqualTo(scalingIntervalMax);\n    }",
          "conflictNames": [
              "scalingIntervalMin",
              "configuration",
              "settings"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ddba701ec67f16c5f2e43b34428add686fd56eaa^1/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/nodes/exec/testutils/SemanticTestBase.java",
      "locators": [
          {
              "line": 116,
              "column": 43
          },
          {
              "line": 117,
              "column": 25
          },
          {
              "line": 127,
              "column": 43
          },
          {
              "line": 128,
              "column": 25
          },
          {
              "line": 133,
              "column": 50
          },
          {
              "line": 134,
              "column": 25
          }
      ],
      "old_name": "sqlTestStep",
      "new_name": "apiTestStep",
      "ctx": {
          "symbolName": "sqlTestStep",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SqlTestStep",
          "scopeHint": "in runTests(...)",
          "filePath": "SemanticTestBase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@ParameterizedTest\n    @MethodSource(\"supportedPrograms\")\n    void runTests(TableTestProgram program) throws Exception {\n        final TableEnvironment env = TableEnvironment.create(EnvironmentSettings.inStreamingMode());\n\n        for (TestStep testStep : program.setupSteps) {\n            switch (testStep.getKind()) {\n                case CONFIG:\n                    {\n                        final ConfigOptionTestStep<?> configTestStep =\n                                (ConfigOptionTestStep<?>) testStep;\n                        configTestStep.apply(env);\n                    }\n                    break;\n                case SOURCE_WITH_DATA:\n                    {\n                        final SourceTestStep sourceTestStep = (SourceTestStep) testStep;\n                        final String id =\n                                TestValuesTableFactory.registerData(\n                                        sourceTestStep.dataBeforeRestore);\n                        final Map<String, String> options = createSourceOptions(id);\n                        sourceTestStep.apply(env, options);\n                    }\n                    break;\n                case SINK_WITH_DATA:\n                    {\n                        final SinkTestStep sinkTestStep = (SinkTestStep) testStep;\n                        final Map<String, String> options = createSinkOptions();\n                        sinkTestStep.apply(env, options);\n                    }\n                    break;\n                case FUNCTION:\n                    {\n                        final FunctionTestStep functionTestStep = (FunctionTestStep) testStep;\n                        functionTestStep.apply(env);\n                        break;\n                    }\n                case SQL:\n                    {\n                        final SqlTestStep sqlTestStep = (SqlTestStep) testStep;\n                        sqlTestStep.apply(env).await();\n                    }\n                    break;\n            }\n        }\n\n        for (TestStep testStep : program.runSteps) {\n            switch (testStep.getKind()) {\n                case SQL:\n                    {\n                        final SqlTestStep sqlTestStep = (SqlTestStep) testStep;\n                        sqlTestStep.apply(env).await();\n                    }\n                    break;\n                case FAILING_SQL:\n                    {\n                        final FailingSqlTestStep sqlTestStep = (FailingSqlTestStep) testStep;\n                        sqlTestStep.apply(env);\n                    }\n                    break;\n            }\n        }\n\n        for (SinkTestStep sinkTestStep : program.getSetupSinkTestSteps()) {\n            List<String> actualResults = getActualResults(sinkTestStep, sinkTestStep.name);\n            assertThat(actualResults)\n                    .containsExactlyInAnyOrder(\n                            sinkTestStep.getExpectedAsStrings().toArray(new String[0]));\n        }\n    }",
          "conflictNames": [
              "program",
              "env",
              "configTestStep",
              "sourceTestStep",
              "id",
              "options",
              "sinkTestStep",
              "functionTestStep",
              "sqlTestStep",
              "actualResults"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ddba701ec67f16c5f2e43b34428add686fd56eaa^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/QueryOperationConverter.java",
      "locators": [
          {
              "line": 292,
              "column": 43
          },
          {
              "line": 295,
              "column": 59
          },
          {
              "line": 306,
              "column": 69
          }
      ],
      "old_name": "resolvedFunction",
      "new_name": "contextFunction",
      "ctx": {
          "symbolName": "resolvedFunction",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ContextResolvedFunction",
          "scopeHint": "in visit(...)",
          "filePath": "QueryOperationConverter.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public RelNode visit(CalculatedQueryOperation calculatedTable) {\n            final ContextResolvedFunction resolvedFunction = calculatedTable.getResolvedFunction();\n            final List<RexNode> parameters = convertToRexNodes(calculatedTable.getArguments());\n\n            final FunctionDefinition functionDefinition = resolvedFunction.getDefinition();\n            if (functionDefinition instanceof TableFunctionDefinition) {\n                final FlinkTypeFactory typeFactory = relBuilder.getTypeFactory();\n                return convertLegacyTableFunction(\n                        calculatedTable,\n                        (TableFunctionDefinition) functionDefinition,\n                        parameters,\n                        typeFactory);\n            }\n\n            final BridgingSqlFunction sqlFunction =\n                    BridgingSqlFunction.of(relBuilder.getCluster(), resolvedFunction);\n\n            FlinkRelBuilder.pushFunctionScan(\n                    relBuilder,\n                    sqlFunction,\n                    0,\n                    parameters,\n                    calculatedTable.getResolvedSchema().getColumnNames());\n\n            return relBuilder.build();\n        }",
          "conflictNames": [
              "calculatedTable",
              "parameters",
              "functionDefinition",
              "typeFactory",
              "sqlFunction"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ddc7171dd83ade50e6b551d3bc2d31acb5ff6451^1/flink-yarn/src/main/java/org/apache/flink/yarn/YarnClusterDescriptor.java",
      "locators": [
          {
              "line": 1078,
              "column": 20
          },
          {
              "line": 1080,
              "column": 21
          }
      ],
      "old_name": "flinkConfigKey",
      "new_name": "flinkConfigFileName",
      "ctx": {
          "symbolName": "flinkConfigKey",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in startAppMaster(...)",
          "filePath": "YarnClusterDescriptor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private ApplicationReport startAppMaster(\n            Configuration configuration,\n            String applicationName,\n            String yarnClusterEntrypoint,\n            JobGraph jobGraph,\n            YarnClient yarnClient,\n            YarnClientApplication yarnApplication,\n            ClusterSpecification clusterSpecification)\n            throws Exception {\n\n        // ------------------ Initialize the file systems -------------------------\n\n        org.apache.flink.core.fs.FileSystem.initialize(\n                configuration, PluginUtils.createPluginManagerFromRootFolder(configuration));\n\n        final FileSystem fs = FileSystem.get(yarnConfiguration);\n\n        // hard coded check for the GoogleHDFS client because its not overriding the getScheme()\n        // method.\n        if (!fs.getClass().getSimpleName().equals(\"GoogleHadoopFileSystem\")\n                && fs.getScheme().startsWith(\"file\")) {\n            LOG.warn(\n                    \"The file system scheme is '\"\n                            + fs.getScheme()\n                            + \"'. This indicates that the \"\n                            + \"specified Hadoop configuration path is wrong and the system is using the default Hadoop configuration values.\"\n                            + \"The Flink YARN client needs to store its files in a distributed file system\");\n        }\n\n        ApplicationSubmissionContext appContext = yarnApplication.getApplicationSubmissionContext();\n\n        final List<Path> providedLibDirs =\n                Utils.getQualifiedRemoteProvidedLibDirs(configuration, yarnConfiguration);\n\n        final Optional<Path> providedUsrLibDir =\n                Utils.getQualifiedRemoteProvidedUsrLib(configuration, yarnConfiguration);\n\n        Path stagingDirPath = getStagingDir(fs);\n        FileSystem stagingDirFs = stagingDirPath.getFileSystem(yarnConfiguration);\n        final YarnApplicationFileUploader fileUploader =\n                YarnApplicationFileUploader.from(\n                        stagingDirFs,\n                        stagingDirPath,\n                        providedLibDirs,\n                        appContext.getApplicationId(),\n                        getFileReplication());\n\n        // The files need to be shipped and added to classpath.\n        Set<Path> systemShipFiles = new HashSet<>(shipFiles);\n\n        final String logConfigFilePath =\n                configuration.getString(YarnConfigOptionsInternal.APPLICATION_LOG_CONFIG_FILE);\n        if (logConfigFilePath != null) {\n            systemShipFiles.add(getPathFromLocalFilePathStr(logConfigFilePath));\n        }\n\n        // Set-up ApplicationSubmissionContext for the application\n\n        final ApplicationId appId = appContext.getApplicationId();\n\n        // ------------------ Add Zookeeper namespace to local flinkConfiguration ------\n        setHAClusterIdIfNotSet(configuration, appId);\n\n        if (HighAvailabilityMode.isHighAvailabilityModeActivated(configuration)) {\n            // activate re-execution of failed applications\n            appContext.setMaxAppAttempts(\n                    configuration.getInteger(\n                            YarnConfigOptions.APPLICATION_ATTEMPTS.key(),\n                            YarnConfiguration.DEFAULT_RM_AM_MAX_ATTEMPTS));\n\n            activateHighAvailabilitySupport(appContext);\n        } else {\n            // set number of application retries to 1 in the default case\n            appContext.setMaxAppAttempts(\n                    configuration.getInteger(YarnConfigOptions.APPLICATION_ATTEMPTS.key(), 1));\n        }\n\n        final Set<Path> userJarFiles = new HashSet<>();\n        if (jobGraph != null) {\n            userJarFiles.addAll(\n                    jobGraph.getUserJars().stream()\n                            .map(f -> f.toUri())\n                            .map(Path::new)\n                            .collect(Collectors.toSet()));\n        }\n\n        final List<URI> jarUrls =\n                ConfigUtils.decodeListFromConfig(configuration, PipelineOptions.JARS, URI::create);\n        if (jarUrls != null\n                && YarnApplicationClusterEntryPoint.class.getName().equals(yarnClusterEntrypoint)) {\n            userJarFiles.addAll(jarUrls.stream().map(Path::new).collect(Collectors.toSet()));\n        }\n\n        // only for per job mode\n        if (jobGraph != null) {\n            for (Map.Entry<String, DistributedCache.DistributedCacheEntry> entry :\n                    jobGraph.getUserArtifacts().entrySet()) {\n                // only upload local files\n                if (!Utils.isRemotePath(entry.getValue().filePath)) {\n                    Path localPath = new Path(entry.getValue().filePath);\n                    Tuple2<Path, Long> remoteFileInfo =\n                            fileUploader.uploadLocalFileToRemote(localPath, entry.getKey());\n                    jobGraph.setUserArtifactRemotePath(\n                            entry.getKey(), remoteFileInfo.f0.toString());\n                }\n            }\n\n            jobGraph.writeUserArtifactEntriesToConfiguration();\n        }\n\n        if (providedLibDirs == null || providedLibDirs.isEmpty()) {\n            addLibFoldersToShipFiles(systemShipFiles);\n        }\n\n        // Register all files in provided lib dirs as local resources with public visibility\n        // and upload the remaining dependencies as local resources with APPLICATION visibility.\n        final List<String> systemClassPaths = fileUploader.registerProvidedLocalResources();\n        final List<String> uploadedDependencies =\n                fileUploader.registerMultipleLocalResources(\n                        systemShipFiles, Path.CUR_DIR, LocalResourceType.FILE);\n        systemClassPaths.addAll(uploadedDependencies);\n\n        // upload and register ship-only files\n        // Plugin files only need to be shipped and should not be added to classpath.\n        if (providedLibDirs == null || providedLibDirs.isEmpty()) {\n            Set<Path> shipOnlyFiles = new HashSet<>();\n            addPluginsFoldersToShipFiles(shipOnlyFiles);\n            fileUploader.registerMultipleLocalResources(\n                    shipOnlyFiles, Path.CUR_DIR, LocalResourceType.FILE);\n        }\n\n        if (!shipArchives.isEmpty()) {\n            fileUploader.registerMultipleLocalResources(\n                    shipArchives, Path.CUR_DIR, LocalResourceType.ARCHIVE);\n        }\n\n        // only for application mode\n        // Python jar file only needs to be shipped and should not be added to classpath.\n        if (YarnApplicationClusterEntryPoint.class.getName().equals(yarnClusterEntrypoint)\n                && PackagedProgramUtils.isPython(configuration.get(APPLICATION_MAIN_CLASS))) {\n            fileUploader.registerMultipleLocalResources(\n                    Collections.singletonList(\n                            new Path(PackagedProgramUtils.getPythonJar().toURI())),\n                    ConfigConstants.DEFAULT_FLINK_OPT_DIR,\n                    LocalResourceType.FILE);\n        }\n\n        // Upload and register user jars\n        final List<String> userClassPaths =\n                fileUploader.registerMultipleLocalResources(\n                        userJarFiles,\n                        userJarInclusion == YarnConfigOptions.UserJarInclusion.DISABLED\n                                ? ConfigConstants.DEFAULT_FLINK_USR_LIB_DIR\n                                : Path.CUR_DIR,\n                        LocalResourceType.FILE);\n\n        // usrlib in remote will be used first.\n        if (providedUsrLibDir.isPresent()) {\n            final List<String> usrLibClassPaths =\n                    fileUploader.registerMultipleLocalResources(\n                            Collections.singletonList(providedUsrLibDir.get()),\n                            Path.CUR_DIR,\n                            LocalResourceType.FILE);\n            userClassPaths.addAll(usrLibClassPaths);\n        } else if (ClusterEntrypointUtils.tryFindUserLibDirectory().isPresent()) {\n            // local usrlib will be automatically shipped if it exists and there is no remote\n            // usrlib.\n            final Set<File> usrLibShipFiles = new HashSet<>();\n            addUsrLibFolderToShipFiles(usrLibShipFiles);\n            final List<String> usrLibClassPaths =\n                    fileUploader.registerMultipleLocalResources(\n                            usrLibShipFiles.stream()\n                                    .map(e -> new Path(e.toURI()))\n                                    .collect(Collectors.toSet()),\n                            Path.CUR_DIR,\n                            LocalResourceType.FILE);\n            userClassPaths.addAll(usrLibClassPaths);\n        }\n\n        if (userJarInclusion == YarnConfigOptions.UserJarInclusion.ORDER) {\n            systemClassPaths.addAll(userClassPaths);\n        }\n\n        // normalize classpath by sorting\n        Collections.sort(systemClassPaths);\n        Collections.sort(userClassPaths);\n\n        // classpath assembler\n        StringBuilder classPathBuilder = new StringBuilder();\n        if (userJarInclusion == YarnConfigOptions.UserJarInclusion.FIRST) {\n            for (String userClassPath : userClassPaths) {\n                classPathBuilder.append(userClassPath).append(File.pathSeparator);\n            }\n        }\n        for (String classPath : systemClassPaths) {\n            classPathBuilder.append(classPath).append(File.pathSeparator);\n        }\n\n        // Setup jar for ApplicationMaster\n        final YarnLocalResourceDescriptor localResourceDescFlinkJar =\n                fileUploader.uploadFlinkDist(flinkJarPath);\n        classPathBuilder\n                .append(localResourceDescFlinkJar.getResourceKey())\n                .append(File.pathSeparator);\n\n        // write job graph to tmp file and add it to local resource\n        // TODO: server use user main method to generate job graph\n        if (jobGraph != null) {\n            File tmpJobGraphFile = null;\n            try {\n                tmpJobGraphFile = File.createTempFile(appId.toString(), null);\n                try (FileOutputStream output = new FileOutputStream(tmpJobGraphFile);\n                        ObjectOutputStream obOutput = new ObjectOutputStream(output)) {\n                    obOutput.writeObject(jobGraph);\n                }\n\n                final String jobGraphFilename = \"job.graph\";\n                configuration.setString(JOB_GRAPH_FILE_PATH, jobGraphFilename);\n\n                fileUploader.registerSingleLocalResource(\n                        jobGraphFilename,\n                        new Path(tmpJobGraphFile.toURI()),\n                        \"\",\n                        LocalResourceType.FILE,\n                        true,\n                        false);\n                classPathBuilder.append(jobGraphFilename).append(File.pathSeparator);\n            } catch (Exception e) {\n                LOG.warn(\"Add job graph to local resource fail.\");\n                throw e;\n            } finally {\n                if (tmpJobGraphFile != null && !tmpJobGraphFile.delete()) {\n                    LOG.warn(\"Fail to delete temporary file {}.\", tmpJobGraphFile.toPath());\n                }\n            }\n        }\n\n        // Upload the flink configuration\n        // write out configuration file\n        File tmpConfigurationFile = null;\n        try {\n            tmpConfigurationFile = File.createTempFile(appId + \"-flink-conf.yaml\", null);\n\n            // remove localhost bind hosts as they render production clusters unusable\n            removeLocalhostBindHostSetting(configuration, JobManagerOptions.BIND_HOST);\n            removeLocalhostBindHostSetting(configuration, TaskManagerOptions.BIND_HOST);\n            // this setting is unconditionally overridden anyway, so we remove it for clarity\n            configuration.removeConfig(TaskManagerOptions.HOST);\n\n            BootstrapTools.writeConfiguration(configuration, tmpConfigurationFile);\n\n            String flinkConfigKey = \"flink-conf.yaml\";\n            fileUploader.registerSingleLocalResource(\n                    flinkConfigKey,\n                    new Path(tmpConfigurationFile.getAbsolutePath()),\n                    \"\",\n                    LocalResourceType.FILE,\n                    true,\n                    true);\n            classPathBuilder.append(\"flink-conf.yaml\").append(File.pathSeparator);\n        } finally {\n            if (tmpConfigurationFile != null && !tmpConfigurationFile.delete()) {\n                LOG.warn(\"Fail to delete temporary file {}.\", tmpConfigurationFile.toPath());\n            }\n        }\n\n        if (userJarInclusion == YarnConfigOptions.UserJarInclusion.LAST) {\n            for (String userClassPath : userClassPaths) {\n                classPathBuilder.append(userClassPath).append(File.pathSeparator);\n            }\n        }\n\n        // To support Yarn Secure Integration Test Scenario\n        // In Integration test setup, the Yarn containers created by YarnMiniCluster does not have\n        // the Yarn site XML\n        // and KRB5 configuration files. We are adding these files as container local resources for\n        // the container\n        // applications (JM/TMs) to have proper secure cluster setup\n        Path remoteYarnSiteXmlPath = null;\n        if (System.getenv(\"IN_TESTS\") != null) {\n            File f = new File(System.getenv(\"YARN_CONF_DIR\"), Utils.YARN_SITE_FILE_NAME);\n            LOG.info(\n                    \"Adding Yarn configuration {} to the AM container local resource bucket\",\n                    f.getAbsolutePath());\n            Path yarnSitePath = new Path(f.getAbsolutePath());\n            remoteYarnSiteXmlPath =\n                    fileUploader\n                            .registerSingleLocalResource(\n                                    Utils.YARN_SITE_FILE_NAME,\n                                    yarnSitePath,\n                                    \"\",\n                                    LocalResourceType.FILE,\n                                    false,\n                                    false)\n                            .getPath();\n            if (System.getProperty(\"java.security.krb5.conf\") != null) {\n                configuration.set(\n                        SecurityOptions.KERBEROS_KRB5_PATH,\n                        System.getProperty(\"java.security.krb5.conf\"));\n            }\n        }\n\n        Path remoteKrb5Path = null;\n        boolean hasKrb5 = false;\n        String krb5Config = configuration.get(SecurityOptions.KERBEROS_KRB5_PATH);\n        if (!StringUtils.isNullOrWhitespaceOnly(krb5Config)) {\n            final File krb5 = new File(krb5Config);\n            LOG.info(\n                    \"Adding KRB5 configuration {} to the AM container local resource bucket\",\n                    krb5.getAbsolutePath());\n            final Path krb5ConfPath = new Path(krb5.getAbsolutePath());\n            remoteKrb5Path =\n                    fileUploader\n                            .registerSingleLocalResource(\n                                    Utils.KRB5_FILE_NAME,\n                                    krb5ConfPath,\n                                    \"\",\n                                    LocalResourceType.FILE,\n                                    false,\n                                    false)\n                            .getPath();\n            hasKrb5 = true;\n        }\n\n        Path remotePathKeytab = null;\n        String localizedKeytabPath = null;\n        String keytab = configuration.getString(SecurityOptions.KERBEROS_LOGIN_KEYTAB);\n        if (keytab != null) {\n            boolean localizeKeytab =\n                    flinkConfiguration.getBoolean(YarnConfigOptions.SHIP_LOCAL_KEYTAB);\n            localizedKeytabPath =\n                    flinkConfiguration.getString(YarnConfigOptions.LOCALIZED_KEYTAB_PATH);\n            if (localizeKeytab) {\n                // Localize the keytab to YARN containers via local resource.\n                LOG.info(\"Adding keytab {} to the AM container local resource bucket\", keytab);\n                remotePathKeytab =\n                        fileUploader\n                                .registerSingleLocalResource(\n                                        localizedKeytabPath,\n                                        new Path(keytab),\n                                        \"\",\n                                        LocalResourceType.FILE,\n                                        false,\n                                        false)\n                                .getPath();\n            } else {\n                // // Assume Keytab is pre-installed in the container.\n                localizedKeytabPath =\n                        flinkConfiguration.getString(YarnConfigOptions.LOCALIZED_KEYTAB_PATH);\n            }\n        }\n\n        final JobManagerProcessSpec processSpec =\n                JobManagerProcessUtils.processSpecFromConfigWithNewOptionToInterpretLegacyHeap(\n                        flinkConfiguration, JobManagerOptions.TOTAL_PROCESS_MEMORY);\n        final ContainerLaunchContext amContainer =\n                setupApplicationMasterContainer(yarnClusterEntrypoint, hasKrb5, processSpec);\n\n        boolean fetchToken = configuration.getBoolean(SecurityOptions.DELEGATION_TOKENS_ENABLED);\n        KerberosLoginProvider kerberosLoginProvider = new KerberosLoginProvider(configuration);\n        if (kerberosLoginProvider.isLoginPossible(true)) {\n            setTokensFor(amContainer, fetchToken);\n        } else {\n            LOG.info(\n                    \"Cannot use kerberos delegation token manager, no valid kerberos credentials provided.\");\n        }\n\n        amContainer.setLocalResources(fileUploader.getRegisteredLocalResources());\n        fileUploader.close();\n\n        Utils.setAclsFor(amContainer, flinkConfiguration);\n\n        // Setup CLASSPATH and environment variables for ApplicationMaster\n        final Map<String, String> appMasterEnv =\n                generateApplicationMasterEnv(\n                        fileUploader,\n                        classPathBuilder.toString(),\n                        localResourceDescFlinkJar.toString(),\n                        appId.toString());\n\n        if (localizedKeytabPath != null) {\n            appMasterEnv.put(YarnConfigKeys.LOCAL_KEYTAB_PATH, localizedKeytabPath);\n            String principal = configuration.getString(SecurityOptions.KERBEROS_LOGIN_PRINCIPAL);\n            appMasterEnv.put(YarnConfigKeys.KEYTAB_PRINCIPAL, principal);\n            if (remotePathKeytab != null) {\n                appMasterEnv.put(YarnConfigKeys.REMOTE_KEYTAB_PATH, remotePathKeytab.toString());\n            }\n        }\n\n        // To support Yarn Secure Integration Test Scenario\n        if (remoteYarnSiteXmlPath != null) {\n            appMasterEnv.put(\n                    YarnConfigKeys.ENV_YARN_SITE_XML_PATH, remoteYarnSiteXmlPath.toString());\n        }\n        if (remoteKrb5Path != null) {\n            appMasterEnv.put(YarnConfigKeys.ENV_KRB5_PATH, remoteKrb5Path.toString());\n        }\n\n        amContainer.setEnvironment(appMasterEnv);\n\n        // Set up resource type requirements for ApplicationMaster\n        Resource capability = Records.newRecord(Resource.class);\n        capability.setMemorySize(clusterSpecification.getMasterMemoryMB());\n        capability.setVirtualCores(\n                flinkConfiguration.getInteger(YarnConfigOptions.APP_MASTER_VCORES));\n\n        final String customApplicationName = customName != null ? customName : applicationName;\n\n        appContext.setApplicationName(customApplicationName);\n        appContext.setApplicationType(applicationType != null ? applicationType : \"Apache Flink\");\n        appContext.setAMContainerSpec(amContainer);\n        appContext.setResource(capability);\n\n        // Set priority for application\n        int priorityNum = flinkConfiguration.getInteger(YarnConfigOptions.APPLICATION_PRIORITY);\n        if (priorityNum >= 0) {\n            Priority priority = Priority.newInstance(priorityNum);\n            appContext.setPriority(priority);\n        }\n\n        if (yarnQueue != null) {\n            appContext.setQueue(yarnQueue);\n        }\n\n        setApplicationNodeLabel(appContext);\n\n        setApplicationTags(appContext);\n\n        // add a hook to clean up in case deployment fails\n        Thread deploymentFailureHook =\n                new DeploymentFailureHook(yarnApplication, fileUploader.getApplicationDir());\n        Runtime.getRuntime().addShutdownHook(deploymentFailureHook);\n        LOG.info(\"Submitting application master \" + appId);\n        yarnClient.submitApplication(appContext);\n\n        LOG.info(\"Waiting for the cluster to be allocated\");\n        final long startTime = System.currentTimeMillis();\n        long lastLogTime = System.currentTimeMillis();\n        ApplicationReport report;\n        YarnApplicationState lastAppState = YarnApplicationState.NEW;\n        loop:\n        while (true) {\n            try {\n                report = yarnClient.getApplicationReport(appId);\n            } catch (IOException e) {\n                throw new YarnDeploymentException(\"Failed to deploy the cluster.\", e);\n            }\n            YarnApplicationState appState = report.getYarnApplicationState();\n            LOG.debug(\"Application State: {}\", appState);\n            switch (appState) {\n                case FAILED:\n                case KILLED:\n                    throw new YarnDeploymentException(\n                            \"The YARN application unexpectedly switched to state \"\n                                    + appState\n                                    + \" during deployment. \\n\"\n                                    + \"Diagnostics from YARN: \"\n                                    + report.getDiagnostics()\n                                    + \"\\n\"\n                                    + \"If log aggregation is enabled on your cluster, use this command to further investigate the issue:\\n\"\n                                    + \"yarn logs -applicationId \"\n                                    + appId);\n                    // break ..\n                case RUNNING:\n                    LOG.info(\"YARN application has been deployed successfully.\");\n                    break loop;\n                case FINISHED:\n                    LOG.info(\"YARN application has been finished successfully.\");\n                    break loop;\n                default:\n                    if (appState != lastAppState) {\n                        LOG.info(\"Deploying cluster, current state \" + appState);\n                    }\n                    if (System.currentTimeMillis() - lastLogTime > 60000) {\n                        lastLogTime = System.currentTimeMillis();\n                        LOG.info(\n                                \"Deployment took more than {} seconds. Please check if the requested resources are available in the YARN cluster\",\n                                (lastLogTime - startTime) / 1000);\n                    }\n            }\n            lastAppState = appState;\n            Thread.sleep(250);\n        }\n\n        // since deployment was successful, remove the hook\n        ShutdownHookUtil.removeShutdownHook(deploymentFailureHook, getClass().getSimpleName(), LOG);\n        return report;\n    }",
          "conflictNames": [
              "configuration",
              "applicationName",
              "yarnClusterEntrypoint",
              "jobGraph",
              "yarnClient",
              "yarnApplication",
              "clusterSpecification",
              "fs",
              "appContext",
              "providedLibDirs",
              "providedUsrLibDir",
              "stagingDirPath",
              "stagingDirFs",
              "fileUploader",
              "systemShipFiles",
              "logConfigFilePath",
              "appId",
              "userJarFiles",
              "jarUrls",
              "localPath",
              "remoteFileInfo",
              "systemClassPaths",
              "uploadedDependencies",
              "shipOnlyFiles",
              "userClassPaths",
              "usrLibClassPaths",
              "usrLibShipFiles",
              "classPathBuilder",
              "localResourceDescFlinkJar",
              "tmpJobGraphFile",
              "output",
              "obOutput",
              "jobGraphFilename",
              "tmpConfigurationFile",
              "remoteYarnSiteXmlPath",
              "f",
              "yarnSitePath",
              "remoteKrb5Path",
              "hasKrb5",
              "krb5Config",
              "krb5",
              "krb5ConfPath",
              "remotePathKeytab",
              "localizedKeytabPath",
              "keytab",
              "localizeKeytab",
              "processSpec",
              "amContainer",
              "fetchToken",
              "kerberosLoginProvider",
              "appMasterEnv",
              "principal",
              "capability",
              "customApplicationName",
              "priorityNum",
              "priority",
              "deploymentFailureHook",
              "startTime",
              "lastLogTime",
              "report",
              "lastAppState",
              "appState"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ddd65bd03749b740ea978570509f2286cda161db^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/exec/stream/StreamExecProcessTableFunction.java",
      "locators": [
          {
              "line": 181,
              "column": 58
          },
          {
              "line": 183,
              "column": 45
          }
      ],
      "old_name": "tabledArg",
      "new_name": "tableArg",
      "ctx": {
          "symbolName": "tabledArg",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "StaticArgument",
          "scopeHint": "in translateToPlanInternal(...)",
          "filePath": "StreamExecProcessTableFunction.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    @SuppressWarnings(\"unchecked\")\n    protected Transformation<RowData> translateToPlanInternal(\n            PlannerBase planner, ExecNodeConfig config) {\n        final List<Transformation<RowData>> inputTransforms =\n                getInputEdges().stream()\n                        .map(e -> (Transformation<RowData>) e.translateToPlan(planner))\n                        .collect(Collectors.toList());\n        if (inputTransforms.size() != 1) {\n            throw new TableException(\"Process table function only supports exactly one input.\");\n        }\n        final Transformation<RowData> inputTransform = inputTransforms.get(0);\n\n        final List<Ord<StaticArgument>> providedInputArgs =\n                StreamPhysicalProcessTableFunction.getProvidedInputArgs(invocation);\n        final List<RexNode> operands = invocation.getOperands();\n        final Set<String> onTimeFields = deriveOnTimeFields(operands);\n        final List<RuntimeTableSemantics> runtimeTableSemantics =\n                providedInputArgs.stream()\n                        .map(\n                                providedInputArg -> {\n                                    final RexTableArgCall tableArgCall =\n                                            (RexTableArgCall) operands.get(providedInputArg.i);\n                                    final StaticArgument tabledArg = providedInputArg.e;\n                                    return createRuntimeTableSemantics(\n                                            tabledArg, tableArgCall, onTimeFields);\n                                })\n                        .collect(Collectors.toList());\n        final List<Integer> timeColumns =\n                runtimeTableSemantics.stream()\n                        .map(RuntimeTableSemantics::timeColumn)\n                        .collect(Collectors.toList());\n\n        final CodeGeneratorContext ctx =\n                new CodeGeneratorContext(config, planner.getFlinkContext().getClassLoader());\n\n        final GeneratedRunnerResult generated =\n                ProcessTableRunnerGenerator.generate(\n                        ctx, invocation, timeColumns, inputChangelogModes);\n        final GeneratedProcessTableRunner generatedRunner = generated.runner();\n        final LinkedHashMap<String, StateInfo> stateInfos = generated.stateInfos();\n\n        final List<RuntimeStateInfo> runtimeStateInfos =\n                stateInfos.entrySet().stream()\n                        .map(\n                                stateInfo ->\n                                        createRuntimeStateInfo(\n                                                stateInfo.getKey(), stateInfo.getValue(), config))\n                        .collect(Collectors.toList());\n        final GeneratedHashFunction[] stateHashCode =\n                runtimeStateInfos.stream()\n                        .map(RuntimeStateInfo::getDataType)\n                        .map(DataType::getLogicalType)\n                        .map(\n                                t ->\n                                        HashCodeGenerator.generateRowHash(\n                                                ctx,\n                                                t,\n                                                \"StateHashCode\",\n                                                IntStream.range(0, getFieldCount(t)).toArray()))\n                        .toArray(GeneratedHashFunction[]::new);\n        final GeneratedRecordEqualiser[] stateEquals =\n                runtimeStateInfos.stream()\n                        .map(RuntimeStateInfo::getDataType)\n                        .map(DataType::getLogicalType)\n                        .map(t -> EqualiserCodeGenerator.generateRowEquals(ctx, t, \"StateEquals\"))\n                        .toArray(GeneratedRecordEqualiser[]::new);\n\n        final RuntimeTableSemantics singleTableSemantics;\n        if (runtimeTableSemantics.isEmpty()) {\n            // For constant function calls\n            singleTableSemantics = null;\n        } else {\n            singleTableSemantics = runtimeTableSemantics.get(0);\n        }\n\n        final ProcessTableOperatorFactory operatorFactory =\n                new ProcessTableOperatorFactory(\n                        singleTableSemantics,\n                        runtimeStateInfos,\n                        generatedRunner,\n                        stateHashCode,\n                        stateEquals);\n\n        final String effectiveUid =\n                uid != null ? uid : createTransformationUid(PROCESS_TRANSFORMATION, config);\n\n        final TransformationMetadata metadata =\n                new TransformationMetadata(\n                        effectiveUid,\n                        createTransformationName(config),\n                        createTransformationDescription(config));\n\n        final OneInputTransformation<RowData, RowData> transform =\n                ExecNodeUtil.createOneInputTransformation(\n                        inputTransform,\n                        metadata,\n                        operatorFactory,\n                        InternalTypeInfo.of(getOutputType()),\n                        inputTransform.getParallelism(),\n                        false);\n\n        // For one input (but non-constant) functions with set semantics\n        if (singleTableSemantics != null && singleTableSemantics.hasSetSemantics()) {\n            final RowDataKeySelector selector =\n                    KeySelectorUtil.getRowDataSelector(\n                            planner.getFlinkContext().getClassLoader(),\n                            singleTableSemantics.partitionByColumns(),\n                            (InternalTypeInfo<RowData>) inputTransform.getOutputType());\n            transform.setStateKeySelector(selector);\n            transform.setStateKeyType(selector.getProducedType());\n        }\n\n        if (inputsContainSingleton()) {\n            transform.setParallelism(1);\n            transform.setMaxParallelism(1);\n        }\n\n        return transform;\n    }",
          "conflictNames": [
              "planner",
              "config",
              "inputTransforms",
              "inputTransform",
              "providedInputArgs",
              "operands",
              "onTimeFields",
              "runtimeTableSemantics",
              "tableArgCall",
              "timeColumns",
              "ctx",
              "generated",
              "generatedRunner",
              "stateInfos",
              "runtimeStateInfos",
              "stateHashCode",
              "stateEquals",
              "singleTableSemantics",
              "operatorFactory",
              "effectiveUid",
              "metadata",
              "transform",
              "selector"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ddd65bd03749b740ea978570509f2286cda161db^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/exec/stream/StreamExecProcessTableFunction.java",
      "locators": [
          {
              "line": 186,
              "column": 29
          },
          {
              "line": 196,
              "column": 42
          }
      ],
      "old_name": "timeColumns",
      "new_name": "inputTimeColumns",
      "ctx": {
          "symbolName": "timeColumns",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<Integer>",
          "scopeHint": "in translateToPlanInternal(...)",
          "filePath": "StreamExecProcessTableFunction.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    @SuppressWarnings(\"unchecked\")\n    protected Transformation<RowData> translateToPlanInternal(\n            PlannerBase planner, ExecNodeConfig config) {\n        final List<Transformation<RowData>> inputTransforms =\n                getInputEdges().stream()\n                        .map(e -> (Transformation<RowData>) e.translateToPlan(planner))\n                        .collect(Collectors.toList());\n        if (inputTransforms.size() != 1) {\n            throw new TableException(\"Process table function only supports exactly one input.\");\n        }\n        final Transformation<RowData> inputTransform = inputTransforms.get(0);\n\n        final List<Ord<StaticArgument>> providedInputArgs =\n                StreamPhysicalProcessTableFunction.getProvidedInputArgs(invocation);\n        final List<RexNode> operands = invocation.getOperands();\n        final Set<String> onTimeFields = deriveOnTimeFields(operands);\n        final List<RuntimeTableSemantics> runtimeTableSemantics =\n                providedInputArgs.stream()\n                        .map(\n                                providedInputArg -> {\n                                    final RexTableArgCall tableArgCall =\n                                            (RexTableArgCall) operands.get(providedInputArg.i);\n                                    final StaticArgument tabledArg = providedInputArg.e;\n                                    return createRuntimeTableSemantics(\n                                            tabledArg, tableArgCall, onTimeFields);\n                                })\n                        .collect(Collectors.toList());\n        final List<Integer> timeColumns =\n                runtimeTableSemantics.stream()\n                        .map(RuntimeTableSemantics::timeColumn)\n                        .collect(Collectors.toList());\n\n        final CodeGeneratorContext ctx =\n                new CodeGeneratorContext(config, planner.getFlinkContext().getClassLoader());\n\n        final GeneratedRunnerResult generated =\n                ProcessTableRunnerGenerator.generate(\n                        ctx, invocation, timeColumns, inputChangelogModes);\n        final GeneratedProcessTableRunner generatedRunner = generated.runner();\n        final LinkedHashMap<String, StateInfo> stateInfos = generated.stateInfos();\n\n        final List<RuntimeStateInfo> runtimeStateInfos =\n                stateInfos.entrySet().stream()\n                        .map(\n                                stateInfo ->\n                                        createRuntimeStateInfo(\n                                                stateInfo.getKey(), stateInfo.getValue(), config))\n                        .collect(Collectors.toList());\n        final GeneratedHashFunction[] stateHashCode =\n                runtimeStateInfos.stream()\n                        .map(RuntimeStateInfo::getDataType)\n                        .map(DataType::getLogicalType)\n                        .map(\n                                t ->\n                                        HashCodeGenerator.generateRowHash(\n                                                ctx,\n                                                t,\n                                                \"StateHashCode\",\n                                                IntStream.range(0, getFieldCount(t)).toArray()))\n                        .toArray(GeneratedHashFunction[]::new);\n        final GeneratedRecordEqualiser[] stateEquals =\n                runtimeStateInfos.stream()\n                        .map(RuntimeStateInfo::getDataType)\n                        .map(DataType::getLogicalType)\n                        .map(t -> EqualiserCodeGenerator.generateRowEquals(ctx, t, \"StateEquals\"))\n                        .toArray(GeneratedRecordEqualiser[]::new);\n\n        final RuntimeTableSemantics singleTableSemantics;\n        if (runtimeTableSemantics.isEmpty()) {\n            // For constant function calls\n            singleTableSemantics = null;\n        } else {\n            singleTableSemantics = runtimeTableSemantics.get(0);\n        }\n\n        final ProcessTableOperatorFactory operatorFactory =\n                new ProcessTableOperatorFactory(\n                        singleTableSemantics,\n                        runtimeStateInfos,\n                        generatedRunner,\n                        stateHashCode,\n                        stateEquals);\n\n        final String effectiveUid =\n                uid != null ? uid : createTransformationUid(PROCESS_TRANSFORMATION, config);\n\n        final TransformationMetadata metadata =\n                new TransformationMetadata(\n                        effectiveUid,\n                        createTransformationName(config),\n                        createTransformationDescription(config));\n\n        final OneInputTransformation<RowData, RowData> transform =\n                ExecNodeUtil.createOneInputTransformation(\n                        inputTransform,\n                        metadata,\n                        operatorFactory,\n                        InternalTypeInfo.of(getOutputType()),\n                        inputTransform.getParallelism(),\n                        false);\n\n        // For one input (but non-constant) functions with set semantics\n        if (singleTableSemantics != null && singleTableSemantics.hasSetSemantics()) {\n            final RowDataKeySelector selector =\n                    KeySelectorUtil.getRowDataSelector(\n                            planner.getFlinkContext().getClassLoader(),\n                            singleTableSemantics.partitionByColumns(),\n                            (InternalTypeInfo<RowData>) inputTransform.getOutputType());\n            transform.setStateKeySelector(selector);\n            transform.setStateKeyType(selector.getProducedType());\n        }\n\n        if (inputsContainSingleton()) {\n            transform.setParallelism(1);\n            transform.setMaxParallelism(1);\n        }\n\n        return transform;\n    }",
          "conflictNames": [
              "planner",
              "config",
              "inputTransforms",
              "inputTransform",
              "providedInputArgs",
              "operands",
              "onTimeFields",
              "runtimeTableSemantics",
              "tableArgCall",
              "tabledArg",
              "ctx",
              "generated",
              "generatedRunner",
              "stateInfos",
              "runtimeStateInfos",
              "stateHashCode",
              "stateEquals",
              "singleTableSemantics",
              "operatorFactory",
              "effectiveUid",
              "metadata",
              "transform",
              "selector"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ddd65bd03749b740ea978570509f2286cda161db^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/operators/process/RuntimeTableSemantics.java",
      "locators": [
          {
              "line": 43,
              "column": 26
          },
          {
              "line": 55,
              "column": 20
          },
          {
              "line": 63,
              "column": 14
          },
          {
              "line": 63,
              "column": 32
          },
          {
              "line": 88,
              "column": 23
          },
          {
              "line": 88,
              "column": 40
          },
          {
              "line": 89,
              "column": 64
          }
      ],
      "old_name": "expectedChange",
      "new_name": "change",
      "ctx": {
          "symbolName": "expectedChange",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "byte",
          "scopeHint": "in getChangelogMode(...)",
          "filePath": "RuntimeTableSemantics.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "an hasSetSemantics() {\n        return hasSetSemantics;\n    }\n\n    public ChangelogMode getChangelogMode() {\n        if (changelogMode == null) {\n            final ChangelogMode.Builder builder = ChangelogMode.newBuilder();\n            for (byte expectedChange : expectedChanges) {\n                builder.addContainedKind(RowKind.fromByteValue(expectedChange));\n            }\n            changelogMode = builder.build();\n        }\n        return changelogMode;\n    }\n\n    @Override\n    public DataTy",
          "conflictNames": [
              "builder"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/de01f021bdfead67459800abca6bbca9fcf3cecd^1/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/NettyShuffleEnvironmentConfiguration.java",
      "locators": [
          {
              "line": 299,
              "column": 19
          },
          {
              "line": 308,
              "column": 25
          },
          {
              "line": 451,
              "column": 19
          },
          {
              "line": 453,
              "column": 13
          },
          {
              "line": 455,
              "column": 21
          },
          {
              "line": 456,
              "column": 21
          },
          {
              "line": 462,
              "column": 13
          },
          {
              "line": 464,
              "column": 21
          },
          {
              "line": 465,
              "column": 21
          },
          {
              "line": 469,
              "column": 16
          }
      ],
      "old_name": "dataBindPort",
      "new_name": "dataBindPortRange",
      "ctx": {
          "symbolName": "dataBindPort",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in fromConfiguration(...)",
          "filePath": "NettyShuffleEnvironmentConfiguration.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Utility method to extract network related parameters from the configuration and to sanity\n     * check them.\n     *\n     * @param configuration configuration object\n     * @param networkMemorySize the size of memory reserved for shuffle environment\n     * @param localTaskManagerCommunication true, to skip initializing the network stack\n     * @param taskManagerAddress identifying the IP address under which the TaskManager will be\n     *     accessible\n     * @return NettyShuffleEnvironmentConfiguration\n     */\n    public static NettyShuffleEnvironmentConfiguration fromConfiguration(\n            Configuration configuration,\n            MemorySize networkMemorySize,\n            boolean localTaskManagerCommunication,\n            InetAddress taskManagerAddress) {\n\n        final int dataBindPort = getDataBindPort(configuration);\n\n        final int pageSize = ConfigurationParserUtils.getPageSize(configuration);\n\n        final NettyConfig nettyConfig =\n                createNettyConfig(\n                        configuration,\n                        localTaskManagerCommunication,\n                        taskManagerAddress,\n                        dataBindPort);\n\n        final int numberOfNetworkBuffers =\n                calculateNumberOfNetworkBuffers(configuration, networkMemorySize, pageSize);\n\n        int initialRequestBackoff =\n                configuration.getInteger(\n                        NettyShuffleEnvironmentOptions.NETWORK_REQUEST_BACKOFF_INITIAL);\n        int maxRequestBackoff =\n                configuration.getInteger(\n                        NettyShuffleEnvironmentOptions.NETWORK_REQUEST_BACKOFF_MAX);\n\n        int buffersPerChannel =\n                configuration.getInteger(\n                        NettyShuffleEnvironmentOptions.NETWORK_BUFFERS_PER_CHANNEL);\n        int extraBuffersPerGate =\n                configuration.getInteger(\n                        NettyShuffleEnvironmentOptions.NETWORK_EXTRA_BUFFERS_PER_GATE);\n\n        Optional<Integer> maxRequiredBuffersPerGate =\n                configuration.getOptional(\n                        NettyShuffleEnvironmentOptions.NETWORK_READ_MAX_REQUIRED_BUFFERS_PER_GATE);\n\n        int maxBuffersPerChannel =\n                configuration.getInteger(\n                        NettyShuffleEnvironmentOptions.NETWORK_MAX_BUFFERS_PER_CHANNEL);\n\n        int maxOverdraftBuffersPerGate =\n                configuration.getInteger(\n                        NettyShuffleEnvironmentOptions.NETWORK_MAX_OVERDRAFT_BUFFERS_PER_GATE);\n\n        long batchShuffleReadMemoryBytes =\n                configuration.get(TaskManagerOptions.NETWORK_BATCH_SHUFFLE_READ_MEMORY).getBytes();\n\n        int sortShuffleMinBuffers =\n                configuration.getInteger(\n                        NettyShuffleEnvironmentOptions.NETWORK_SORT_SHUFFLE_MIN_BUFFERS);\n        int sortShuffleMinParallelism =\n                configuration.getInteger(\n                        NettyShuffleEnvironmentOptions.NETWORK_SORT_SHUFFLE_MIN_PARALLELISM);\n\n        boolean isNetworkDetailedMetrics =\n                configuration.getBoolean(NettyShuffleEnvironmentOptions.NETWORK_DETAILED_METRICS);\n\n        String[] tempDirs = ConfigurationUtils.parseTempDirectories(configuration);\n        // Shuffle the data directories to make it fairer for directory selection between different\n        // TaskManagers, which is good for load balance especially when there are multiple disks.\n        List<String> shuffleDirs = Arrays.asList(tempDirs);\n        Collections.shuffle(shuffleDirs);\n\n        Duration requestSegmentsTimeout =\n                Duration.ofMillis(\n                        configuration.getLong(\n                                NettyShuffleEnvironmentOptions\n                                        .NETWORK_EXCLUSIVE_BUFFERS_REQUEST_TIMEOUT_MILLISECONDS));\n\n        BoundedBlockingSubpartitionType blockingSubpartitionType =\n                getBlockingSubpartitionType(configuration);\n\n        boolean batchShuffleCompressionEnabled =\n                configuration.get(NettyShuffleEnvironmentOptions.BATCH_SHUFFLE_COMPRESSION_ENABLED);\n        String compressionCodec =\n                configuration.getString(NettyShuffleEnvironmentOptions.SHUFFLE_COMPRESSION_CODEC);\n\n        int maxNumConnections =\n                Math.max(\n                        1,\n                        configuration.getInteger(\n                                NettyShuffleEnvironmentOptions.MAX_NUM_TCP_CONNECTIONS));\n\n        boolean connectionReuseEnabled =\n                configuration.get(\n                        NettyShuffleEnvironmentOptions.TCP_CONNECTION_REUSE_ACROSS_JOBS_ENABLED);\n\n        int hybridShuffleSpilledIndexSegmentSize =\n                configuration.get(\n                        NettyShuffleEnvironmentOptions\n                                .HYBRID_SHUFFLE_SPILLED_INDEX_REGION_GROUP_SIZE);\n\n        long hybridShuffleNumRetainedInMemoryRegionsMax =\n                configuration.get(\n                        NettyShuffleEnvironmentOptions\n                                .HYBRID_SHUFFLE_NUM_RETAINED_IN_MEMORY_REGIONS_MAX);\n\n        checkArgument(buffersPerChannel >= 0, \"Must be non-negative.\");\n        checkArgument(\n                !maxRequiredBuffersPerGate.isPresent() || maxRequiredBuffersPerGate.get() >= 1,\n                String.format(\n                        \"At least one buffer is required for each gate, please increase the value of %s.\",\n                        NettyShuffleEnvironmentOptions.NETWORK_READ_MAX_REQUIRED_BUFFERS_PER_GATE\n                                .key()));\n        checkArgument(\n                extraBuffersPerGate >= 1,\n                String.format(\n                        \"The configured floating buffer should be at least 1, please increase the value of %s.\",\n                        NettyShuffleEnvironmentOptions.NETWORK_EXTRA_BUFFERS_PER_GATE.key()));\n\n        TieredStorageConfiguration tieredStorageConfiguration = null;\n        if ((configuration.get(BATCH_SHUFFLE_MODE) == ALL_EXCHANGES_HYBRID_FULL\n                        || configuration.get(BATCH_SHUFFLE_MODE) == ALL_EXCHANGES_HYBRID_SELECTIVE)\n                && configuration.getBoolean(NETWORK_HYBRID_SHUFFLE_ENABLE_NEW_MODE)) {\n            tieredStorageConfiguration =\n                    TieredStorageConfiguration.builder(\n                                    pageSize,\n                                    configuration.getString(\n                                            NETWORK_HYBRID_SHUFFLE_REMOTE_STORAGE_BASE_PATH))\n                            .build();\n        }\n        return new NettyShuffleEnvironmentConfiguration(\n                numberOfNetworkBuffers,\n                pageSize,\n                initialRequestBackoff,\n                maxRequestBackoff,\n                buffersPerChannel,\n                extraBuffersPerGate,\n                maxRequiredBuffersPerGate,\n                requestSegmentsTimeout,\n                isNetworkDetailedMetrics,\n                nettyConfig,\n                shuffleDirs.toArray(tempDirs),\n                blockingSubpartitionType,\n                batchShuffleCompressionEnabled,\n                compressionCodec,\n                maxBuffersPerChannel,\n                batchShuffleReadMemoryBytes,\n                sortShuffleMinBuffers,\n                sortShuffleMinParallelism,\n                BufferDebloatConfiguration.fromConfiguration(configuration),\n                maxNumConnections,\n                connectionReuseEnabled,\n                maxOverdraftBuffersPerGate,\n                hybridShuffleSpilledIndexSegmentSize,\n                hybridShuffleNumRetainedInMemoryRegionsMax,\n                tieredStorageConfiguration);\n    }",
          "conflictNames": [
              "configuration",
              "networkMemorySize",
              "localTaskManagerCommunication",
              "taskManagerAddress",
              "pageSize",
              "nettyConfig",
              "numberOfNetworkBuffers",
              "initialRequestBackoff",
              "maxRequestBackoff",
              "buffersPerChannel",
              "extraBuffersPerGate",
              "maxRequiredBuffersPerGate",
              "maxBuffersPerChannel",
              "maxOverdraftBuffersPerGate",
              "batchShuffleReadMemoryBytes",
              "sortShuffleMinBuffers",
              "sortShuffleMinParallelism",
              "isNetworkDetailedMetrics",
              "tempDirs",
              "shuffleDirs",
              "requestSegmentsTimeout",
              "blockingSubpartitionType",
              "batchShuffleCompressionEnabled",
              "compressionCodec",
              "maxNumConnections",
              "connectionReuseEnabled",
              "hybridShuffleSpilledIndexSegmentSize",
              "hybridShuffleNumRetainedInMemoryRegionsMax",
              "tieredStorageConfiguration"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/de7322112cbf594ae4b74163b5e58892e6cdf4ca^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/exec/stream/StreamExecWindowAggregate.java",
      "locators": [
          {
              "line": 187,
              "column": 29
          },
          {
              "line": 200,
              "column": 25
          },
          {
              "line": 222,
              "column": 35
          },
          {
              "line": 244,
              "column": 27
          },
          {
              "line": 259,
              "column": 13
          },
          {
              "line": 277,
              "column": 17
          }
      ],
      "old_name": "sliceAssigner",
      "new_name": "windowAssigner",
      "ctx": {
          "symbolName": "sliceAssigner",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SliceAssigner",
          "scopeHint": "in translateToPlanInternal(...)",
          "filePath": "StreamExecWindowAggregate.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@SuppressWarnings(\"unchecked\")\n    @Override\n    protected Transformation<RowData> translateToPlanInternal(\n            PlannerBase planner, ExecNodeConfig config) {\n        // TODO Currently, the operator of WindowAggregate does not support Session Window, and it\n        //  needs to fall back to the legacy GroupWindowAggregate. See more at FLINK-34048.\n        if (windowing.getWindow() instanceof SessionWindowSpec) {\n            return fallbackToLegacyGroupWindowAggregate(planner, config);\n        }\n\n        final ExecEdge inputEdge = getInputEdges().get(0);\n        final Transformation<RowData> inputTransform =\n                (Transformation<RowData>) inputEdge.translateToPlan(planner);\n        final RowType inputRowType = (RowType) inputEdge.getOutputType();\n\n        final ZoneId shiftTimeZone =\n                TimeWindowUtil.getShiftTimeZone(\n                        windowing.getTimeAttributeType(),\n                        TableConfigUtils.getLocalTimeZone(config));\n        final SliceAssigner sliceAssigner = createSliceAssigner(windowing, shiftTimeZone);\n\n        final AggregateInfoList aggInfoList =\n                AggregateUtil.deriveStreamWindowAggregateInfoList(\n                        planner.getTypeFactory(),\n                        inputRowType,\n                        JavaScalaConversionUtil.toScala(Arrays.asList(aggCalls)),\n                        needRetraction,\n                        windowing.getWindow(),\n                        true); // isStateBackendDataViews\n\n        final GeneratedNamespaceAggsHandleFunction<Long> generatedAggsHandler =\n                createAggsHandler(\n                        sliceAssigner,\n                        aggInfoList,\n                        config,\n                        planner.getFlinkContext().getClassLoader(),\n                        planner.createRelBuilder(),\n                        inputRowType.getChildren(),\n                        shiftTimeZone);\n\n        final RowDataKeySelector selector =\n                KeySelectorUtil.getRowDataSelector(\n                        planner.getFlinkContext().getClassLoader(),\n                        grouping,\n                        InternalTypeInfo.of(inputRowType));\n        final LogicalType[] accTypes = convertToLogicalTypes(aggInfoList.getAccTypes());\n\n        final OneInputStreamOperator<RowData, RowData> windowOperator =\n                SlicingWindowAggOperatorBuilder.builder()\n                        .inputSerializer(new RowDataSerializer(inputRowType))\n                        .shiftTimeZone(shiftTimeZone)\n                        .keySerializer(\n                                (PagedTypeSerializer<RowData>)\n                                        selector.getProducedType().toSerializer())\n                        .assigner(sliceAssigner)\n                        .countStarIndex(aggInfoList.getIndexOfCountStar())\n                        .aggregate(generatedAggsHandler, new RowDataSerializer(accTypes))\n                        .build();\n\n        final OneInputTransformation<RowData, RowData> transform =\n                ExecNodeUtil.createOneInputTransformation(\n                        inputTransform,\n                        createTransformationMeta(WINDOW_AGGREGATE_TRANSFORMATION, config),\n                        SimpleOperatorFactory.of(windowOperator),\n                        InternalTypeInfo.of(getOutputType()),\n                        inputTransform.getParallelism(),\n                        WINDOW_AGG_MEMORY_RATIO,\n                        false);\n\n        // set KeyType and Selector for state\n        transform.setStateKeySelector(selector);\n        transform.setStateKeyType(selector.getProducedType());\n        return transform;\n    }",
          "conflictNames": [
              "planner",
              "config",
              "inputEdge",
              "inputTransform",
              "inputRowType",
              "shiftTimeZone",
              "aggInfoList",
              "generatedAggsHandler",
              "selector",
              "accTypes",
              "windowOperator",
              "transform"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/df2747f31f09a1142a4ce5ab67ae4ffbd56d2f0e^1/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/ZooKeeperMultipleComponentLeaderElectionDriverTest.java",
      "locators": [
          {
              "line": 99,
              "column": 42
          },
          {
              "line": 104,
              "column": 53
          },
          {
              "line": 115,
              "column": 37
          },
          {
              "line": 134,
              "column": 42
          },
          {
              "line": 139,
              "column": 53
          },
          {
              "line": 148,
              "column": 37
          },
          {
              "line": 154,
              "column": 37
          },
          {
              "line": 185,
              "column": 42
          },
          {
              "line": 214,
              "column": 42
          },
          {
              "line": 214,
              "column": 57
          },
          {
              "line": 216,
              "column": 86
          },
          {
              "line": 231,
              "column": 48
          },
          {
              "line": 309,
              "column": 42
          },
          {
              "line": 309,
              "column": 57
          },
          {
              "line": 311,
              "column": 86
          },
          {
              "line": 332,
              "column": 48
          },
          {
              "line": 379,
              "column": 46
          },
          {
              "line": 381,
              "column": 59
          },
          {
              "line": 404,
              "column": 24
          }
      ],
      "old_name": "componentId",
      "new_name": "contenderID",
      "ctx": {
          "symbolName": "componentId",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in testPublishLeaderInformation(...)",
          "filePath": "ZooKeeperMultipleComponentLeaderElectionDriverTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testPublishLeaderInformation() throws Exception {\n        new Context() {\n            {\n                runTest(\n                        () -> {\n                            leaderElectionListener.await(LeaderElectionEvent.IsLeaderEvent.class);\n\n                            final String componentId = \"retrieved-component\";\n                            final DefaultLeaderRetrievalService defaultLeaderRetrievalService =\n                                    new DefaultLeaderRetrievalService(\n                                            new ZooKeeperLeaderRetrievalDriverFactory(\n                                                    curatorFramework.asCuratorFramework(),\n                                                    componentId,\n                                                    ZooKeeperLeaderRetrievalDriver\n                                                            .LeaderInformationClearancePolicy\n                                                            .ON_LOST_CONNECTION));\n\n                            final TestingListener leaderRetrievalListener = new TestingListener();\n                            defaultLeaderRetrievalService.start(leaderRetrievalListener);\n\n                            final LeaderInformation leaderInformation =\n                                    LeaderInformation.known(UUID.randomUUID(), \"foobar\");\n                            leaderElectionDriver.publishLeaderInformation(\n                                    componentId, leaderInformation);\n\n                            leaderRetrievalListener.waitForNewLeader();\n\n                            assertThat(leaderRetrievalListener.getLeader())\n                                    .isEqualTo(leaderInformation);\n                        });\n            }\n        };\n    }",
          "conflictNames": [
              "defaultLeaderRetrievalService",
              "leaderRetrievalListener",
              "leaderInformation"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/df29023d8be8d91bed9aa2110ef4be7d66cc9d9f^1/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptivebatch/DefaultVertexParallelismAndInputInfosDecider.java",
      "locators": [
          {
              "line": 222,
              "column": 16
          },
          {
              "line": 223,
              "column": 21
          },
          {
              "line": 228,
              "column": 17
          },
          {
              "line": 235,
              "column": 25
          },
          {
              "line": 241,
              "column": 29
          }
      ],
      "old_name": "nonBroadcastBytesBySubpartition",
      "new_name": "bytesBySubpartition",
      "ctx": {
          "symbolName": "nonBroadcastBytesBySubpartition",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "long[]",
          "scopeHint": "in decideParallelismAndEvenlyDistributeData(...)",
          "filePath": "DefaultVertexParallelismAndInputInfosDecider.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Decide parallelism and input infos, which will make the data be evenly distributed to\n     * downstream subtasks, such that different downstream subtasks consume roughly the same amount\n     * of data.\n     *\n     * @param jobVertexId The job vertex id\n     * @param consumedResults The information of consumed blocking results\n     * @param initialParallelism The initial parallelism of the job vertex\n     * @return the parallelism and vertex input infos\n     */\n    private ParallelismAndInputInfos decideParallelismAndEvenlyDistributeData(\n            JobVertexID jobVertexId,\n            List<BlockingResultInfo> consumedResults,\n            int initialParallelism) {\n        checkArgument(initialParallelism == ExecutionConfig.PARALLELISM_DEFAULT);\n        checkArgument(!consumedResults.isEmpty());\n        consumedResults.forEach(resultInfo -> checkState(!resultInfo.isPointwise()));\n\n        final List<BlockingResultInfo> nonBroadcastResults =\n                getNonBroadcastResultInfos(consumedResults);\n        long broadcastBytes = getReasonableBroadcastBytes(jobVertexId, consumedResults);\n        int subpartitionNum = checkAndGetSubpartitionNum(nonBroadcastResults);\n\n        long nonBroadcastDataVolumeLimit = dataVolumePerTask - broadcastBytes;\n        long[] nonBroadcastBytesBySubpartition = new long[subpartitionNum];\n        Arrays.fill(nonBroadcastBytesBySubpartition, 0L);\n        for (BlockingResultInfo resultInfo : nonBroadcastResults) {\n            List<Long> subpartitionBytes =\n                    ((AllToAllBlockingResultInfo) resultInfo).getAggregatedSubpartitionBytes();\n            for (int i = 0; i < subpartitionNum; ++i) {\n                nonBroadcastBytesBySubpartition[i] += subpartitionBytes.get(i);\n            }\n        }\n\n        // compute subpartition ranges\n        List<IndexRange> subpartitionRanges =\n                computeSubpartitionRanges(\n                        nonBroadcastBytesBySubpartition, nonBroadcastDataVolumeLimit);\n\n        // if the parallelism is not legal, adjust to a legal parallelism\n        if (!isLegalParallelism(subpartitionRanges.size())) {\n            Optional<List<IndexRange>> adjustedSubpartitionRanges =\n                    adjustToClosestLegalParallelism(\n                            nonBroadcastBytesBySubpartition,\n                            nonBroadcastDataVolumeLimit,\n                            subpartitionRanges.size());\n            if (!adjustedSubpartitionRanges.isPresent()) {\n                // can't find any legal parallelism, fall back to evenly distribute subpartitions\n                LOG.info(\n                        \"Cannot find a legal parallelism to evenly distribute data for job vertex {}. \"\n                                + \"Fall back to compute a parallelism that can evenly distribute subpartitions.\",\n                        jobVertexId);\n                return decideParallelismAndEvenlyDistributeSubpartitions(\n                        jobVertexId, consumedResults, initialParallelism);\n            }\n            subpartitionRanges = adjustedSubpartitionRanges.get();\n        }\n\n        checkState(isLegalParallelism(subpartitionRanges.size()));\n        return createParallelismAndInputInfos(consumedResults, subpartitionRanges);\n    }",
          "conflictNames": [
              "jobVertexId",
              "consumedResults",
              "initialParallelism",
              "nonBroadcastResults",
              "broadcastBytes",
              "subpartitionNum",
              "nonBroadcastDataVolumeLimit",
              "subpartitionBytes",
              "i",
              "subpartitionRanges",
              "adjustedSubpartitionRanges"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/df2ecdc77b23e0e40fe151ed8a7350a6db333f91^1/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/nodes/exec/stream/WindowAggregateJsonPlanTest.java",
      "locators": [
          {
              "line": 42,
              "column": 16
          },
          {
              "line": 52,
              "column": 25
          }
      ],
      "old_name": "srcTableDdl",
      "new_name": "insertOnlyTableDdl",
      "ctx": {
          "symbolName": "srcTableDdl",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in setup(...)",
          "filePath": "WindowAggregateJsonPlanTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@BeforeEach\n    void setup() {\n        util = streamTestUtil(TableConfig.getDefault());\n        tEnv = util.getTableEnv();\n\n        String srcTableDdl =\n                \"CREATE TABLE MyTable (\\n\"\n                        + \" a INT,\\n\"\n                        + \" b BIGINT,\\n\"\n                        + \" c VARCHAR,\\n\"\n                        + \" `rowtime` AS TO_TIMESTAMP(c),\\n\"\n                        + \" proctime as PROCTIME(),\\n\"\n                        + \" WATERMARK for `rowtime` AS `rowtime` - INTERVAL '1' SECOND\\n\"\n                        + \") WITH (\\n\"\n                        + \" 'connector' = 'values')\\n\";\n        tEnv.executeSql(srcTableDdl);\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/dfdba3dd18e56c0b4f288c9a350245f982b27d2f^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/operators/join/stream/StreamingJoinOperator.java",
      "locators": [
          {
              "line": 145,
              "column": 17
          },
          {
              "line": 153,
              "column": 26
          }
      ],
      "old_name": "originalRowKind",
      "new_name": "inputRowKind",
      "ctx": {
          "symbolName": "originalRowKind",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RowKind",
          "scopeHint": "in processElement(...)",
          "filePath": "StreamingJoinOperator.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "protected void processElement(\n            RowData input,\n            JoinRecordStateView inputSideStateView,\n            JoinRecordStateView otherSideStateView,\n            boolean inputIsLeft,\n            boolean isSuppress)\n            throws Exception {\n        RowKind originalRowKind = input.getRowKind();\n        // erase RowKind for later state updating\n        input.setRowKind(RowKind.INSERT);\n\n        AssociatedRecords associatedRecords =\n                AssociatedRecords.fromSyncStateView(\n                        input, inputIsLeft, otherSideStateView, joinCondition);\n        // set back RowKind\n        input.setRowKind(originalRowKind);\n        joinHelper.processJoin(\n                input,\n                inputSideStateView,\n                otherSideStateView,\n                inputIsLeft,\n                associatedRecords,\n                isSuppress);\n    }",
          "conflictNames": [
              "input",
              "inputSideStateView",
              "otherSideStateView",
              "inputIsLeft",
              "isSuppress",
              "associatedRecords"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e06fddc95541cb10df1b605087acc4b49252c254^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/exec/stream/StreamExecOverAggregate.java",
      "locators": [
          {
              "line": 187,
              "column": 19
          },
          {
              "line": 189,
              "column": 13
          },
          {
              "line": 191,
              "column": 13
          },
          {
              "line": 224,
              "column": 29
          },
          {
              "line": 248,
              "column": 29
          },
          {
              "line": 290,
              "column": 15
          },
          {
              "line": 299,
              "column": 17
          },
          {
              "line": 336,
              "column": 13
          },
          {
              "line": 348,
              "column": 33
          },
          {
              "line": 357,
              "column": 33
          },
          {
              "line": 367,
              "column": 29
          },
          {
              "line": 391,
              "column": 15
          },
          {
              "line": 400,
              "column": 17
          },
          {
              "line": 442,
              "column": 13
          },
          {
              "line": 451,
              "column": 25
          },
          {
              "line": 454,
              "column": 87
          }
      ],
      "old_name": "rowTimeIdx",
      "new_name": "timeAttribute",
      "ctx": {
          "symbolName": "rowTimeIdx",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in translateToPlanInternal(...)",
          "filePath": "StreamExecOverAggregate.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@SuppressWarnings(\"unchecked\")\n    @Override\n    protected Transformation<RowData> translateToPlanInternal(\n            PlannerBase planner, ExecNodeConfig config) {\n        if (overSpec.getGroups().size() > 1) {\n            throw new TableException(\"All aggregates must be computed on the same window.\");\n        }\n\n        final OverSpec.GroupSpec group = overSpec.getGroups().get(0);\n        final int[] orderKeys = group.getSort().getFieldIndices();\n        final boolean[] isAscendingOrders = group.getSort().getAscendingOrders();\n        if (orderKeys.length != 1 || isAscendingOrders.length != 1) {\n            throw new TableException(\"The window can only be ordered by a single time column.\");\n        }\n\n        if (!isAscendingOrders[0]) {\n            throw new TableException(\"The window can only be ordered in ASCENDING mode.\");\n        }\n\n        final int[] partitionKeys = overSpec.getPartition().getFieldIndices();\n        if (partitionKeys.length > 0 && config.getStateRetentionTime() < 0) {\n            LOG.warn(\n                    \"No state retention interval configured for a query which accumulates state. \"\n                            + \"Please provide a query configuration with valid retention interval to prevent \"\n                            + \"excessive state size. You may specify a retention time of 0 to not clean up the state.\");\n        }\n\n        final ExecEdge inputEdge = getInputEdges().get(0);\n        final Transformation<RowData> inputTransform =\n                (Transformation<RowData>) inputEdge.translateToPlan(planner);\n        final RowType inputRowType = (RowType) inputEdge.getOutputType();\n\n        final int orderKey = orderKeys[0];\n        final LogicalType orderKeyType = inputRowType.getFields().get(orderKey).getType();\n        // check time field && identify window rowtime attribute\n        final int rowTimeIdx;\n        if (isRowtimeAttribute(orderKeyType)) {\n            rowTimeIdx = orderKey;\n        } else if (isProctimeAttribute(orderKeyType)) {\n            rowTimeIdx = -1;\n        } else {\n            throw new TableException(\n                    \"OVER windows' ordering in stream mode must be defined on a time attribute.\");\n        }\n\n        final List<RexLiteral> constants = overSpec.getConstants();\n        final List<String> fieldNames = new ArrayList<>(inputRowType.getFieldNames());\n        final List<LogicalType> fieldTypes = new ArrayList<>(inputRowType.getChildren());\n        IntStream.range(0, constants.size()).forEach(i -> fieldNames.add(\"TMP\" + i));\n        for (int i = 0; i < constants.size(); ++i) {\n            fieldNames.add(\"TMP\" + i);\n            fieldTypes.add(FlinkTypeFactory.toLogicalType(constants.get(i).getType()));\n        }\n\n        final RowType aggInputRowType =\n                RowType.of(\n                        fieldTypes.toArray(new LogicalType[0]), fieldNames.toArray(new String[0]));\n\n        final CodeGeneratorContext ctx =\n                new CodeGeneratorContext(config, planner.getFlinkContext().getClassLoader());\n        final KeyedProcessFunction<RowData, RowData, RowData> overProcessFunction;\n        if (group.getLowerBound().isPreceding()\n                && group.getLowerBound().isUnbounded()\n                && group.getUpperBound().isCurrentRow()) {\n            // unbounded OVER window\n            overProcessFunction =\n                    createUnboundedOverProcessFunction(\n                            ctx,\n                            group.getAggCalls(),\n                            constants,\n                            aggInputRowType,\n                            inputRowType,\n                            rowTimeIdx,\n                            group.isRows(),\n                            config,\n                            planner.createRelBuilder(),\n                            planner.getTypeFactory());\n        } else if (group.getLowerBound().isPreceding()\n                && !group.getLowerBound().isUnbounded()\n                && group.getUpperBound().isCurrentRow()) {\n            final Object boundValue =\n                    OverAggregateUtil.getBoundary(overSpec, group.getLowerBound());\n\n            if (boundValue instanceof BigDecimal) {\n                throw new TableException(\n                        \"the specific value is decimal which haven not supported yet.\");\n            }\n            // bounded OVER window\n            final long precedingOffset = -1 * (long) boundValue + (group.isRows() ? 1 : 0);\n            overProcessFunction =\n                    createBoundedOverProcessFunction(\n                            ctx,\n                            group.getAggCalls(),\n                            constants,\n                            aggInputRowType,\n                            inputRowType,\n                            rowTimeIdx,\n                            group.isRows(),\n                            precedingOffset,\n                            config,\n                            planner.createRelBuilder(),\n                            planner.getTypeFactory());\n        } else {\n            throw new TableException(\"OVER RANGE FOLLOWING windows are not supported yet.\");\n        }\n\n        final KeyedProcessOperator<RowData, RowData, RowData> operator =\n                new KeyedProcessOperator<>(overProcessFunction);\n\n        OneInputTransformation<RowData, RowData> transform =\n                ExecNodeUtil.createOneInputTransformation(\n                        inputTransform,\n                        createTransformationMeta(OVER_AGGREGATE_TRANSFORMATION, config),\n                        operator,\n                        InternalTypeInfo.of(getOutputType()),\n                        inputTransform.getParallelism(),\n                        false);\n\n        // set KeyType and Selector for state\n        final RowDataKeySelector selector =\n                KeySelectorUtil.getRowDataSelector(\n                        planner.getFlinkContext().getClassLoader(),\n                        partitionKeys,\n                        InternalTypeInfo.of(inputRowType));\n        transform.setStateKeySelector(selector);\n        transform.setStateKeyType(selector.getProducedType());\n\n        return transform;\n    }",
          "conflictNames": [
              "planner",
              "config",
              "group",
              "orderKeys",
              "isAscendingOrders",
              "partitionKeys",
              "inputEdge",
              "inputTransform",
              "inputRowType",
              "orderKey",
              "orderKeyType",
              "constants",
              "fieldNames",
              "fieldTypes",
              "i",
              "aggInputRowType",
              "ctx",
              "overProcessFunction",
              "boundValue",
              "precedingOffset",
              "operator",
              "transform",
              "selector"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e06fddc95541cb10df1b605087acc4b49252c254^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/exec/stream/StreamExecOverAggregate.java",
      "locators": [
          {
              "line": 285,
              "column": 24
          },
          {
              "line": 317,
              "column": 34
          },
          {
              "line": 325,
              "column": 17
          },
          {
              "line": 386,
              "column": 24
          },
          {
              "line": 422,
              "column": 34
          },
          {
              "line": 430,
              "column": 17
          }
      ],
      "old_name": "generator",
      "new_name": "aggsGenerator",
      "ctx": {
          "symbolName": "generator",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "AggsHandlerCodeGenerator",
          "scopeHint": "in createUnboundedOverProcessFunction(...)",
          "filePath": "StreamExecOverAggregate.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Create an ProcessFunction for unbounded OVER window to evaluate final aggregate value.\n     *\n     * @param ctx code generator context\n     * @param aggCalls physical calls to aggregate functions and their output field names\n     * @param constants the constants in aggregates parameters, such as sum(1)\n     * @param aggInputRowType physical type of the input row which consists of input and constants.\n     * @param inputRowType physical type of the input row which only consists of input.\n     * @param rowTimeIdx the index of the rowtime field or None in case of processing time.\n     * @param isRowsClause it is a tag that indicates whether the OVER clause is ROWS clause\n     */\n    private KeyedProcessFunction<RowData, RowData, RowData> createUnboundedOverProcessFunction(\n            CodeGeneratorContext ctx,\n            List<AggregateCall> aggCalls,\n            List<RexLiteral> constants,\n            RowType aggInputRowType,\n            RowType inputRowType,\n            int rowTimeIdx,\n            boolean isRowsClause,\n            ExecNodeConfig config,\n            RelBuilder relBuilder,\n            FlinkTypeFactory typeFactory) {\n        AggregateInfoList aggInfoList =\n                AggregateUtil.transformToStreamAggregateInfoList(\n                        typeFactory,\n                        // use aggInputType which considers constants as input instead of\n                        // inputSchema.relDataType\n                        aggInputRowType,\n                        JavaScalaConversionUtil.toScala(aggCalls),\n                        new boolean[aggCalls.size()],\n                        false, // needRetraction\n                        true, // isStateBackendDataViews\n                        true); // needDistinctInfo\n\n        LogicalType[] fieldTypes = inputRowType.getChildren().toArray(new LogicalType[0]);\n        AggsHandlerCodeGenerator generator =\n                new AggsHandlerCodeGenerator(\n                        ctx,\n                        relBuilder,\n                        JavaScalaConversionUtil.toScala(Arrays.asList(fieldTypes)),\n                        false); // copyInputField\n\n        GeneratedAggsHandleFunction genAggsHandler =\n                generator\n                        .needAccumulate()\n                        // over agg code gen must pass the constants\n                        .withConstants(JavaScalaConversionUtil.toScala(constants))\n                        .generateAggsHandler(\"UnboundedOverAggregateHelper\", aggInfoList);\n\n        LogicalType[] flattenAccTypes =\n                Arrays.stream(aggInfoList.getAccTypes())\n                        .map(LogicalTypeDataTypeConverter::fromDataTypeToLogicalType)\n                        .toArray(LogicalType[]::new);\n\n        if (rowTimeIdx >= 0) {\n            switch (unboundedOverVersion) {\n                // Currently there is no migration path between first and second versions.\n                case AbstractRowTimeUnboundedPrecedingOver.FIRST_OVER_VERSION:\n                    if (isRowsClause) {\n                        // ROWS unbounded over process function\n                        return new RowTimeRowsUnboundedPrecedingFunction<>(\n                                config.getStateRetentionTime(),\n                                TableConfigUtils.getMaxIdleStateRetentionTime(config),\n                                genAggsHandler,\n                                flattenAccTypes,\n                                fieldTypes,\n                                rowTimeIdx);\n                    } else {\n                        // RANGE unbounded over process function\n                        return new RowTimeRangeUnboundedPrecedingFunction<>(\n                                config.getStateRetentionTime(),\n                                TableConfigUtils.getMaxIdleStateRetentionTime(config),\n                                genAggsHandler,\n                                flattenAccTypes,\n                                fieldTypes,\n                                rowTimeIdx);\n                    }\n                case RowTimeUnboundedPrecedingOverFunctionV2.SECOND_OVER_VERSION:\n                    return new RowTimeUnboundedPrecedingOverFunctionV2<>(\n                            isRowsClause,\n                            config.getStateRetentionTime(),\n                            TableConfigUtils.getMaxIdleStateRetentionTime(config),\n                            genAggsHandler,\n                            flattenAccTypes,\n                            fieldTypes,\n                            rowTimeIdx);\n                default:\n                    throw new UnsupportedOperationException(\n                            \"Unsupported unbounded over version: \"\n                                    + unboundedOverVersion\n                                    + \". Valid versions are 1 and 2.\");\n            }\n        } else {\n            return new ProcTimeUnboundedPrecedingFunction<>(\n                    StateConfigUtil.createTtlConfig(config.getStateRetentionTime()),\n                    genAggsHandler,\n                    flattenAccTypes);\n        }\n    }",
          "conflictNames": [
              "ctx",
              "aggCalls",
              "constants",
              "aggInputRowType",
              "inputRowType",
              "rowTimeIdx",
              "isRowsClause",
              "config",
              "relBuilder",
              "typeFactory",
              "aggInfoList",
              "fieldTypes",
              "genAggsHandler",
              "flattenAccTypes"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e15126561dc42b5571d5f03b4ebd85499180d083^1/flink-clients/src/main/java/org/apache/flink/client/program/rest/RestClusterClient.java",
      "locators": [
          {
              "line": 357,
              "column": 47
          },
          {
              "line": 361,
              "column": 58
          },
          {
              "line": 366,
              "column": 71
          },
          {
              "line": 369,
              "column": 40
          },
          {
              "line": 378,
              "column": 17
          },
          {
              "line": 379,
              "column": 25
          },
          {
              "line": 387,
              "column": 45
          },
          {
              "line": 425,
              "column": 45
          },
          {
              "line": 466,
              "column": 41
          },
          {
              "line": 468,
              "column": 25
          },
          {
              "line": 470,
              "column": 46
          },
          {
              "line": 472,
              "column": 81
          }
      ],
      "old_name": "jobGraphFile",
      "new_name": "executionPlanFile",
      "ctx": {
          "symbolName": "jobGraphFile",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Path",
          "scopeHint": "in submitJob(...)",
          "filePath": "RestClusterClient.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public CompletableFuture<JobID> submitJob(@Nonnull JobGraph jobGraph) {\n        CompletableFuture<java.nio.file.Path> jobGraphFileFuture =\n                CompletableFuture.supplyAsync(\n                        () -> {\n                            try {\n                                final java.nio.file.Path jobGraphFile =\n                                        Files.createTempFile(\n                                                \"flink-jobgraph-\" + jobGraph.getJobID(), \".bin\");\n                                try (ObjectOutputStream objectOut =\n                                        new ObjectOutputStream(\n                                                Files.newOutputStream(jobGraphFile))) {\n                                    objectOut.writeObject(jobGraph);\n                                }\n                                return jobGraphFile;\n                            } catch (IOException e) {\n                                throw new CompletionException(\n                                        new FlinkException(\"Failed to serialize JobGraph.\", e));\n                            }\n                        },\n                        executorService);\n\n        CompletableFuture<Tuple2<JobSubmitRequestBody, Collection<FileUpload>>> requestFuture =\n                jobGraphFileFuture.thenApply(\n                        jobGraphFile -> {\n                            List<String> jarFileNames = new ArrayList<>(8);\n                            List<JobSubmitRequestBody.DistributedCacheFile> artifactFileNames =\n                                    new ArrayList<>(8);\n                            Collection<FileUpload> filesToUpload = new ArrayList<>(8);\n\n                            filesToUpload.add(\n                                    new FileUpload(\n                                            jobGraphFile, RestConstants.CONTENT_TYPE_BINARY));\n\n                            for (Path jar : jobGraph.getUserJars()) {\n                                jarFileNames.add(jar.getName());\n                                filesToUpload.add(\n                                        new FileUpload(\n                                                Paths.get(jar.toUri()),\n                                                RestConstants.CONTENT_TYPE_JAR));\n                            }\n\n                            for (Map.Entry<String, DistributedCache.DistributedCacheEntry>\n                                    artifacts : jobGraph.getUserArtifacts().entrySet()) {\n                                final Path artifactFilePath =\n                                        new Path(artifacts.getValue().filePath);\n                                try {\n                                    // Only local artifacts need to be uploaded.\n                                    if (!artifactFilePath.getFileSystem().isDistributedFS()) {\n                                        artifactFileNames.add(\n                                                new JobSubmitRequestBody.DistributedCacheFile(\n                                                        artifacts.getKey(),\n                                                        artifactFilePath.getName()));\n                                        filesToUpload.add(\n                                                new FileUpload(\n                                                        Paths.get(artifactFilePath.getPath()),\n                                                        RestConstants.CONTENT_TYPE_BINARY));\n                                    }\n                                } catch (IOException e) {\n                                    throw new CompletionException(\n                                            new FlinkException(\n                                                    \"Failed to get the FileSystem of artifact \"\n                                                            + artifactFilePath\n                                                            + \".\",\n                                                    e));\n                                }\n                            }\n\n                            final JobSubmitRequestBody requestBody =\n                                    new JobSubmitRequestBody(\n                                            jobGraphFile.getFileName().toString(),\n                                            jarFileNames,\n                                            artifactFileNames);\n\n                            return Tuple2.of(\n                                    requestBody, Collections.unmodifiableCollection(filesToUpload));\n                        });\n\n        final CompletableFuture<JobSubmitResponseBody> submissionFuture =\n                requestFuture.thenCompose(\n                        requestAndFileUploads -> {\n                            LOG.info(\n                                    \"Submitting job '{}' ({}).\",\n                                    jobGraph.getName(),\n                                    jobGraph.getJobID());\n                            return sendRetriableRequest(\n                                    JobSubmitHeaders.getInstance(),\n                                    EmptyMessageParameters.getInstance(),\n                                    requestAndFileUploads.f0,\n                                    requestAndFileUploads.f1,\n                                    isConnectionProblemOrServiceUnavailable(),\n                                    (receiver, error) -> {\n                                        if (error != null) {\n                                            LOG.warn(\n                                                    \"Attempt to submit job '{}' ({}) to '{}' has failed.\",\n                                                    jobGraph.getName(),\n                                                    jobGraph.getJobID(),\n                                                    receiver,\n                                                    error);\n                                        } else {\n                                            LOG.info(\n                                                    \"Successfully submitted job '{}' ({}) to '{}'.\",\n                                                    jobGraph.getName(),\n                                                    jobGraph.getJobID(),\n                                                    receiver);\n                                        }\n                                    });\n                        });\n\n        submissionFuture\n                .exceptionally(ignored -> null) // ignore errors\n                .thenCompose(ignored -> jobGraphFileFuture)\n                .thenAccept(\n                        jobGraphFile -> {\n                            try {\n                                Files.delete(jobGraphFile);\n                            } catch (IOException e) {\n                                LOG.warn(\"Could not delete temporary file {}.\", jobGraphFile, e);\n                            }\n                        });\n\n        return submissionFuture\n                .thenApply(ignore -> jobGraph.getJobID())\n                .exceptionally(\n                        (Throwable throwable) -> {\n                            throw new CompletionException(\n                                    new JobSubmissionException(\n                                            jobGraph.getJobID(),\n                                            \"Failed to submit JobGraph.\",\n                                            ExceptionUtils.stripCompletionException(throwable)));\n                        });\n    }",
          "conflictNames": [
              "jobGraph",
              "jobGraphFileFuture",
              "objectOut",
              "requestFuture",
              "jarFileNames",
              "artifactFileNames",
              "filesToUpload",
              "artifactFilePath",
              "requestBody",
              "submissionFuture"
          ]
      },
      "suggestions": [
          {
              "name": "executionPlanFile",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/e15126561dc42b5571d5f03b4ebd85499180d083^1/flink-clients/src/main/java/org/apache/flink/client/program/rest/RestClusterClient.java",
      "locators": [
          {
              "line": 357,
              "column": 47
          },
          {
              "line": 378,
              "column": 17
          },
          {
              "line": 466,
              "column": 41
          }
      ],
      "old_name": "jobGraphFileFuture",
      "new_name": "executionPlanFileFuture",
      "ctx": {
          "symbolName": "jobGraphFileFuture",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CompletableFuture<Path>",
          "scopeHint": "in submitJob(...)",
          "filePath": "RestClusterClient.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public CompletableFuture<JobID> submitJob(@Nonnull JobGraph jobGraph) {\n        CompletableFuture<java.nio.file.Path> jobGraphFileFuture =\n                CompletableFuture.supplyAsync(\n                        () -> {\n                            try {\n                                final java.nio.file.Path jobGraphFile =\n                                        Files.createTempFile(\n                                                \"flink-jobgraph-\" + jobGraph.getJobID(), \".bin\");\n                                try (ObjectOutputStream objectOut =\n                                        new ObjectOutputStream(\n                                                Files.newOutputStream(jobGraphFile))) {\n                                    objectOut.writeObject(jobGraph);\n                                }\n                                return jobGraphFile;\n                            } catch (IOException e) {\n                                throw new CompletionException(\n                                        new FlinkException(\"Failed to serialize JobGraph.\", e));\n                            }\n                        },\n                        executorService);\n\n        CompletableFuture<Tuple2<JobSubmitRequestBody, Collection<FileUpload>>> requestFuture =\n                jobGraphFileFuture.thenApply(\n                        jobGraphFile -> {\n                            List<String> jarFileNames = new ArrayList<>(8);\n                            List<JobSubmitRequestBody.DistributedCacheFile> artifactFileNames =\n                                    new ArrayList<>(8);\n                            Collection<FileUpload> filesToUpload = new ArrayList<>(8);\n\n                            filesToUpload.add(\n                                    new FileUpload(\n                                            jobGraphFile, RestConstants.CONTENT_TYPE_BINARY));\n\n                            for (Path jar : jobGraph.getUserJars()) {\n                                jarFileNames.add(jar.getName());\n                                filesToUpload.add(\n                                        new FileUpload(\n                                                Paths.get(jar.toUri()),\n                                                RestConstants.CONTENT_TYPE_JAR));\n                            }\n\n                            for (Map.Entry<String, DistributedCache.DistributedCacheEntry>\n                                    artifacts : jobGraph.getUserArtifacts().entrySet()) {\n                                final Path artifactFilePath =\n                                        new Path(artifacts.getValue().filePath);\n                                try {\n                                    // Only local artifacts need to be uploaded.\n                                    if (!artifactFilePath.getFileSystem().isDistributedFS()) {\n                                        artifactFileNames.add(\n                                                new JobSubmitRequestBody.DistributedCacheFile(\n                                                        artifacts.getKey(),\n                                                        artifactFilePath.getName()));\n                                        filesToUpload.add(\n                                                new FileUpload(\n                                                        Paths.get(artifactFilePath.getPath()),\n                                                        RestConstants.CONTENT_TYPE_BINARY));\n                                    }\n                                } catch (IOException e) {\n                                    throw new CompletionException(\n                                            new FlinkException(\n                                                    \"Failed to get the FileSystem of artifact \"\n                                                            + artifactFilePath\n                                                            + \".\",\n                                                    e));\n                                }\n                            }\n\n                            final JobSubmitRequestBody requestBody =\n                                    new JobSubmitRequestBody(\n                                            jobGraphFile.getFileName().toString(),\n                                            jarFileNames,\n                                            artifactFileNames);\n\n                            return Tuple2.of(\n                                    requestBody, Collections.unmodifiableCollection(filesToUpload));\n                        });\n\n        final CompletableFuture<JobSubmitResponseBody> submissionFuture =\n                requestFuture.thenCompose(\n                        requestAndFileUploads -> {\n                            LOG.info(\n                                    \"Submitting job '{}' ({}).\",\n                                    jobGraph.getName(),\n                                    jobGraph.getJobID());\n                            return sendRetriableRequest(\n                                    JobSubmitHeaders.getInstance(),\n                                    EmptyMessageParameters.getInstance(),\n                                    requestAndFileUploads.f0,\n                                    requestAndFileUploads.f1,\n                                    isConnectionProblemOrServiceUnavailable(),\n                                    (receiver, error) -> {\n                                        if (error != null) {\n                                            LOG.warn(\n                                                    \"Attempt to submit job '{}' ({}) to '{}' has failed.\",\n                                                    jobGraph.getName(),\n                                                    jobGraph.getJobID(),\n                                                    receiver,\n                                                    error);\n                                        } else {\n                                            LOG.info(\n                                                    \"Successfully submitted job '{}' ({}) to '{}'.\",\n                                                    jobGraph.getName(),\n                                                    jobGraph.getJobID(),\n                                                    receiver);\n                                        }\n                                    });\n                        });\n\n        submissionFuture\n                .exceptionally(ignored -> null) // ignore errors\n                .thenCompose(ignored -> jobGraphFileFuture)\n                .thenAccept(\n                        jobGraphFile -> {\n                            try {\n                                Files.delete(jobGraphFile);\n                            } catch (IOException e) {\n                                LOG.warn(\"Could not delete temporary file {}.\", jobGraphFile, e);\n                            }\n                        });\n\n        return submissionFuture\n                .thenApply(ignore -> jobGraph.getJobID())\n                .exceptionally(\n                        (Throwable throwable) -> {\n                            throw new CompletionException(\n                                    new JobSubmissionException(\n                                            jobGraph.getJobID(),\n                                            \"Failed to submit JobGraph.\",\n                                            ExceptionUtils.stripCompletionException(throwable)));\n                        });\n    }",
          "conflictNames": [
              "jobGraph",
              "jobGraphFile",
              "objectOut",
              "requestFuture",
              "jarFileNames",
              "artifactFileNames",
              "filesToUpload",
              "artifactFilePath",
              "requestBody",
              "submissionFuture"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e15126561dc42b5571d5f03b4ebd85499180d083^1/flink-runtime-web/src/test/java/org/apache/flink/runtime/webmonitor/handlers/JarRunHandlerParameterTest.java",
      "locators": [
          {
              "line": 265,
              "column": 18
          },
          {
              "line": 266,
              "column": 20
          },
          {
              "line": 279,
              "column": 18
          },
          {
              "line": 280,
              "column": 20
          },
          {
              "line": 292,
              "column": 18
          },
          {
              "line": 294,
              "column": 17
          },
          {
              "line": 297,
              "column": 16
          },
          {
              "line": 302,
              "column": 18
          },
          {
              "line": 304,
              "column": 17
          },
          {
              "line": 306,
              "column": 16
          },
          {
              "line": 310,
              "column": 48
          },
          {
              "line": 311,
              "column": 68
          },
          {
              "line": 321,
              "column": 17
          }
      ],
      "old_name": "jobGraph",
      "new_name": "executionPlan",
      "ctx": {
          "symbolName": "jobGraph",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraph",
          "scopeHint": "in testConfigurationWithEmptySavepointPath(...)",
          "filePath": "JarRunHandlerParameterTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testConfigurationWithEmptySavepointPath() throws Exception {\n        final JarRunRequestBody requestBody = getJarRequestBodyWithSavepointPath(\"\");\n        handleRequest(\n                createRequest(\n                        requestBody,\n                        getUnresolvedJarMessageParameters(),\n                        getUnresolvedJarMessageParameters(),\n                        jarWithEagerSink));\n        JobGraph jobGraph = LAST_SUBMITTED_JOB_GRAPH_REFERENCE.get();\n        assertThat(jobGraph.getSavepointRestoreSettings())\n                .isEqualTo(SavepointRestoreSettings.none());\n    }",
          "conflictNames": [
              "requestBody"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e15126561dc42b5571d5f03b4ebd85499180d083^1/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniCluster.java",
      "locators": [
          {
              "line": 1068,
              "column": 24
          },
          {
              "line": 1069,
              "column": 50
          },
          {
              "line": 1075,
              "column": 63
          },
          {
              "line": 1081,
              "column": 69
          },
          {
              "line": 1084,
              "column": 66
          }
      ],
      "old_name": "clonedJobGraph",
      "new_name": "clonedExecutionPlan",
      "ctx": {
          "symbolName": "clonedJobGraph",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraph",
          "scopeHint": "in submitJob(...)",
          "filePath": "MiniCluster.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public CompletableFuture<JobSubmissionResult> submitJob(JobGraph jobGraph) {\n        // When MiniCluster uses the local RPC, the provided JobGraph is passed directly to the\n        // Dispatcher. This means that any mutations to the JG can affect the Dispatcher behaviour,\n        // so we rather clone it to guard against this.\n        final JobGraph clonedJobGraph = InstantiationUtil.cloneUnchecked(jobGraph);\n        checkRestoreModeForChangelogStateBackend(clonedJobGraph);\n        final CompletableFuture<DispatcherGateway> dispatcherGatewayFuture =\n                getDispatcherGatewayFuture();\n        final CompletableFuture<InetSocketAddress> blobServerAddressFuture =\n                createBlobServerAddress(dispatcherGatewayFuture);\n        final CompletableFuture<Void> jarUploadFuture =\n                uploadAndSetJobFiles(blobServerAddressFuture, clonedJobGraph);\n        final CompletableFuture<Acknowledge> acknowledgeCompletableFuture =\n                jarUploadFuture\n                        .thenCombine(\n                                dispatcherGatewayFuture,\n                                (Void ack, DispatcherGateway dispatcherGateway) ->\n                                        dispatcherGateway.submitJob(clonedJobGraph, rpcTimeout))\n                        .thenCompose(Function.identity());\n        return acknowledgeCompletableFuture.thenApply(\n                (Acknowledge ignored) -> new JobSubmissionResult(clonedJobGraph.getJobID()));\n    }",
          "conflictNames": [
              "jobGraph",
              "dispatcherGatewayFuture",
              "blobServerAddressFuture",
              "jarUploadFuture",
              "acknowledgeCompletableFuture"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e15126561dc42b5571d5f03b4ebd85499180d083^1/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/job/JobSubmitHandler.java",
      "locators": [
          {
              "line": 111,
              "column": 37
          },
          {
              "line": 119,
              "column": 46
          },
          {
              "line": 126,
              "column": 17
          },
          {
              "line": 183,
              "column": 41
          },
          {
              "line": 189,
              "column": 16
          }
      ],
      "old_name": "jobGraphFuture",
      "new_name": "executionPlanFuture",
      "ctx": {
          "symbolName": "jobGraphFuture",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CompletableFuture<JobGraph>",
          "scopeHint": "in handleRequest(...)",
          "filePath": "JobSubmitHandler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    protected CompletableFuture<JobSubmitResponseBody> handleRequest(\n            @Nonnull HandlerRequest<JobSubmitRequestBody> request,\n            @Nonnull DispatcherGateway gateway)\n            throws RestHandlerException {\n        final Collection<File> uploadedFiles = request.getUploadedFiles();\n        final Map<String, Path> nameToFile =\n                uploadedFiles.stream()\n                        .collect(Collectors.toMap(File::getName, Path::fromLocalFile));\n\n        if (uploadedFiles.size() != nameToFile.size()) {\n            throw new RestHandlerException(\n                    String.format(\n                            \"The number of uploaded files was %s than the expected count. Expected: %s Actual %s\",\n                            uploadedFiles.size() < nameToFile.size() ? \"lower\" : \"higher\",\n                            nameToFile.size(),\n                            uploadedFiles.size()),\n                    HttpResponseStatus.BAD_REQUEST);\n        }\n\n        final JobSubmitRequestBody requestBody = request.getRequestBody();\n\n        if (requestBody.jobGraphFileName == null) {\n            throw new RestHandlerException(\n                    String.format(\n                            \"The %s field must not be omitted or be null.\",\n                            JobSubmitRequestBody.FIELD_NAME_JOB_GRAPH),\n                    HttpResponseStatus.BAD_REQUEST);\n        }\n\n        CompletableFuture<JobGraph> jobGraphFuture = loadJobGraph(requestBody, nameToFile);\n\n        Collection<Path> jarFiles = getJarFilesToUpload(requestBody.jarFileNames, nameToFile);\n\n        Collection<Tuple2<String, Path>> artifacts =\n                getArtifactFilesToUpload(requestBody.artifactFileNames, nameToFile);\n\n        CompletableFuture<JobGraph> finalizedJobGraphFuture =\n                uploadJobGraphFiles(gateway, jobGraphFuture, jarFiles, artifacts, configuration);\n\n        CompletableFuture<Acknowledge> jobSubmissionFuture =\n                finalizedJobGraphFuture.thenCompose(\n                        jobGraph -> gateway.submitJob(jobGraph, timeout));\n\n        return jobSubmissionFuture.thenCombine(\n                jobGraphFuture,\n                (ack, jobGraph) -> new JobSubmitResponseBody(\"/jobs/\" + jobGraph.getJobID()));\n    }",
          "conflictNames": [
              "request",
              "gateway",
              "uploadedFiles",
              "nameToFile",
              "requestBody",
              "jarFiles",
              "artifacts",
              "finalizedJobGraphFuture",
              "jobSubmissionFuture"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e15126561dc42b5571d5f03b4ebd85499180d083^1/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/job/JobSubmitHandler.java",
      "locators": [
          {
              "line": 118,
              "column": 37
          },
          {
              "line": 122,
              "column": 17
          }
      ],
      "old_name": "finalizedJobGraphFuture",
      "new_name": "finalizedExecutionPlanFuture",
      "ctx": {
          "symbolName": "finalizedJobGraphFuture",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CompletableFuture<JobGraph>",
          "scopeHint": "in handleRequest(...)",
          "filePath": "JobSubmitHandler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    protected CompletableFuture<JobSubmitResponseBody> handleRequest(\n            @Nonnull HandlerRequest<JobSubmitRequestBody> request,\n            @Nonnull DispatcherGateway gateway)\n            throws RestHandlerException {\n        final Collection<File> uploadedFiles = request.getUploadedFiles();\n        final Map<String, Path> nameToFile =\n                uploadedFiles.stream()\n                        .collect(Collectors.toMap(File::getName, Path::fromLocalFile));\n\n        if (uploadedFiles.size() != nameToFile.size()) {\n            throw new RestHandlerException(\n                    String.format(\n                            \"The number of uploaded files was %s than the expected count. Expected: %s Actual %s\",\n                            uploadedFiles.size() < nameToFile.size() ? \"lower\" : \"higher\",\n                            nameToFile.size(),\n                            uploadedFiles.size()),\n                    HttpResponseStatus.BAD_REQUEST);\n        }\n\n        final JobSubmitRequestBody requestBody = request.getRequestBody();\n\n        if (requestBody.jobGraphFileName == null) {\n            throw new RestHandlerException(\n                    String.format(\n                            \"The %s field must not be omitted or be null.\",\n                            JobSubmitRequestBody.FIELD_NAME_JOB_GRAPH),\n                    HttpResponseStatus.BAD_REQUEST);\n        }\n\n        CompletableFuture<JobGraph> jobGraphFuture = loadJobGraph(requestBody, nameToFile);\n\n        Collection<Path> jarFiles = getJarFilesToUpload(requestBody.jarFileNames, nameToFile);\n\n        Collection<Tuple2<String, Path>> artifacts =\n                getArtifactFilesToUpload(requestBody.artifactFileNames, nameToFile);\n\n        CompletableFuture<JobGraph> finalizedJobGraphFuture =\n                uploadJobGraphFiles(gateway, jobGraphFuture, jarFiles, artifacts, configuration);\n\n        CompletableFuture<Acknowledge> jobSubmissionFuture =\n                finalizedJobGraphFuture.thenCompose(\n                        jobGraph -> gateway.submitJob(jobGraph, timeout));\n\n        return jobSubmissionFuture.thenCombine(\n                jobGraphFuture,\n                (ack, jobGraph) -> new JobSubmitResponseBody(\"/jobs/\" + jobGraph.getJobID()));\n    }",
          "conflictNames": [
              "request",
              "gateway",
              "uploadedFiles",
              "nameToFile",
              "requestBody",
              "jobGraphFuture",
              "jarFiles",
              "artifacts",
              "jobSubmissionFuture"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e15126561dc42b5571d5f03b4ebd85499180d083^1/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/job/JobSubmitHandler.java",
      "locators": [
          {
              "line": 103,
              "column": 25
          },
          {
              "line": 133,
              "column": 20
          },
          {
              "line": 135,
              "column": 37
          },
          {
              "line": 142,
              "column": 37
          },
          {
              "line": 142,
              "column": 71
          }
      ],
      "old_name": "jobGraphFile",
      "new_name": "executionPlanFile",
      "ctx": {
          "symbolName": "jobGraphFile",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Path",
          "scopeHint": "in loadJobGraph(...)",
          "filePath": "JobSubmitHandler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private CompletableFuture<JobGraph> loadJobGraph(\n            JobSubmitRequestBody requestBody, Map<String, Path> nameToFile)\n            throws MissingFileException {\n        final Path jobGraphFile =\n                getPathAndAssertUpload(\n                        requestBody.jobGraphFileName, FILE_TYPE_JOB_GRAPH, nameToFile);\n\n        return CompletableFuture.supplyAsync(\n                () -> {\n                    JobGraph jobGraph;\n                    try (ObjectInputStream objectIn =\n                            new ObjectInputStream(\n                                    jobGraphFile.getFileSystem().open(jobGraphFile))) {\n                        jobGraph = (JobGraph) objectIn.readObject();\n                    } catch (Exception e) {\n                        throw new CompletionException(\n                                new RestHandlerException(\n                                        \"Failed to deserialize JobGraph.\",\n                                        HttpResponseStatus.BAD_REQUEST,\n                                        e));\n                    }\n                    return jobGraph;\n                },\n                executor);\n    }",
          "conflictNames": [
              "requestBody",
              "nameToFile",
              "jobGraph",
              "objectIn"
          ]
      },
      "suggestions": [
          {
              "name": "executionPlanFile",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/e15126561dc42b5571d5f03b4ebd85499180d083^1/flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/job/JobSubmitHandlerTest.java",
      "locators": [
          {
              "line": 230,
              "column": 37
          },
          {
              "line": 236,
              "column": 37
          },
          {
              "line": 281,
              "column": 20
          },
          {
              "line": 282,
              "column": 44
          }
      ],
      "old_name": "submittedJobGraphFuture",
      "new_name": "submittedExecutionPlanFuture",
      "ctx": {
          "symbolName": "submittedJobGraphFuture",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CompletableFuture<JobGraph>",
          "scopeHint": "in testFileHandling(...)",
          "filePath": "JobSubmitHandlerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@TestTemplate\n    void testFileHandling() throws Exception {\n        final String dcEntryName = \"entry\";\n\n        CompletableFuture<JobGraph> submittedJobGraphFuture = new CompletableFuture<>();\n        DispatcherGateway dispatcherGateway =\n                TestingDispatcherGateway.newBuilder()\n                        .setBlobServerPort(blobServer.getPort())\n                        .setSubmitFunction(\n                                submittedJobGraph -> {\n                                    submittedJobGraphFuture.complete(submittedJobGraph);\n                                    return CompletableFuture.completedFuture(Acknowledge.get());\n                                })\n                        .build();\n\n        JobSubmitHandler handler =\n                new JobSubmitHandler(\n                        () -> CompletableFuture.completedFuture(dispatcherGateway),\n                        RpcUtils.INF_TIMEOUT,\n                        Collections.emptyMap(),\n                        Executors.directExecutor(),\n                        configuration);\n\n        final Path jobGraphFile = TempDirUtils.newFile(temporaryFolder).toPath();\n        final Path jarFile = TempDirUtils.newFile(temporaryFolder).toPath();\n        final Path artifactFile = TempDirUtils.newFile(temporaryFolder).toPath();\n\n        final JobGraph jobGraph = JobGraphTestUtils.emptyJobGraph();\n        // the entry that should be updated\n        jobGraph.addUserArtifact(\n                dcEntryName, new DistributedCache.DistributedCacheEntry(\"random\", false));\n        try (ObjectOutputStream objectOut =\n                new ObjectOutputStream(Files.newOutputStream(jobGraphFile))) {\n            objectOut.writeObject(jobGraph);\n        }\n\n        JobSubmitRequestBody request =\n                new JobSubmitRequestBody(\n                        jobGraphFile.getFileName().toString(),\n                        Collections.singletonList(jarFile.getFileName().toString()),\n                        Collections.singleton(\n                                new JobSubmitRequestBody.DistributedCacheFile(\n                                        dcEntryName, artifactFile.getFileName().toString())));\n\n        handler.handleRequest(\n                        HandlerRequest.create(\n                                request,\n                                EmptyMessageParameters.getInstance(),\n                                Arrays.asList(\n                                        jobGraphFile.toFile(),\n                                        jarFile.toFile(),\n                                        artifactFile.toFile())),\n                        dispatcherGateway)\n                .get();\n\n        assertThat(submittedJobGraphFuture).as(\"No JobGraph was submitted.\").isCompleted();\n        final JobGraph submittedJobGraph = submittedJobGraphFuture.get();\n        assertThat(submittedJobGraph.getUserJarBlobKeys()).hasSize(1);\n        assertThat(submittedJobGraph.getUserArtifacts()).hasSize(1);\n        assertThat(submittedJobGraph.getUserArtifacts().get(dcEntryName).blobKey).isNotNull();\n    }",
          "conflictNames": [
              "dcEntryName",
              "dispatcherGateway",
              "handler",
              "jobGraphFile",
              "jarFile",
              "artifactFile",
              "jobGraph",
              "objectOut",
              "request",
              "submittedJobGraph"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e2b6588ef39cbeb1825cacf553a80272ae7b9418^1/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBIncrementalCheckpointUtils.java",
      "locators": [
          {
              "line": 125,
              "column": 22
          },
          {
              "line": 134,
              "column": 13
          },
          {
              "line": 135,
              "column": 13
          },
          {
              "line": 145,
              "column": 13
          },
          {
              "line": 146,
              "column": 13
          },
          {
              "line": 149,
              "column": 50
          }
      ],
      "old_name": "deletedRanges",
      "new_name": "deleteFilesRanges",
      "ctx": {
          "symbolName": "deletedRanges",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<byte[]>",
          "scopeHint": "in clipDBWithKeyGroupRange(...)",
          "filePath": "RocksDBIncrementalCheckpointUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * The method to clip the db instance according to the target key group range using the {@link\n     * RocksDB#delete(ColumnFamilyHandle, byte[])}.\n     *\n     * @param db the RocksDB instance to be clipped.\n     * @param columnFamilyHandles the column families in the db instance.\n     * @param targetKeyGroupRange the target key group range.\n     * @param currentKeyGroupRange the key group range of the db instance.\n     * @param keyGroupPrefixBytes Number of bytes required to prefix the key groups.\n     * @param useDeleteFilesInRange Whether to use deleteFilesInRange to clean up redundant files.\n     */\n    public static void clipDBWithKeyGroupRange(\n            @Nonnull RocksDB db,\n            @Nonnull List<ColumnFamilyHandle> columnFamilyHandles,\n            @Nonnull KeyGroupRange targetKeyGroupRange,\n            @Nonnull KeyGroupRange currentKeyGroupRange,\n            @Nonnegative int keyGroupPrefixBytes,\n            boolean useDeleteFilesInRange)\n            throws RocksDBException {\n        List<byte[]> deletedRanges = new ArrayList<>(4);\n\n        if (currentKeyGroupRange.getStartKeyGroup() < targetKeyGroupRange.getStartKeyGroup()) {\n            final byte[] beginKeyGroupBytes = new byte[keyGroupPrefixBytes];\n            final byte[] endKeyGroupBytes = new byte[keyGroupPrefixBytes];\n            CompositeKeySerializationUtils.serializeKeyGroup(\n                    currentKeyGroupRange.getStartKeyGroup(), beginKeyGroupBytes);\n            CompositeKeySerializationUtils.serializeKeyGroup(\n                    targetKeyGroupRange.getStartKeyGroup(), endKeyGroupBytes);\n            deletedRanges.add(beginKeyGroupBytes);\n            deletedRanges.add(endKeyGroupBytes);\n        }\n\n        if (currentKeyGroupRange.getEndKeyGroup() > targetKeyGroupRange.getEndKeyGroup()) {\n            final byte[] beginKeyGroupBytes = new byte[keyGroupPrefixBytes];\n            final byte[] endKeyGroupBytes = new byte[keyGroupPrefixBytes];\n            CompositeKeySerializationUtils.serializeKeyGroup(\n                    targetKeyGroupRange.getEndKeyGroup() + 1, beginKeyGroupBytes);\n            CompositeKeySerializationUtils.serializeKeyGroup(\n                    currentKeyGroupRange.getEndKeyGroup() + 1, endKeyGroupBytes);\n            deletedRanges.add(beginKeyGroupBytes);\n            deletedRanges.add(endKeyGroupBytes);\n        }\n\n        deleteRangeData(db, columnFamilyHandles, deletedRanges, useDeleteFilesInRange);\n    }",
          "conflictNames": [
              "db",
              "columnFamilyHandles",
              "targetKeyGroupRange",
              "currentKeyGroupRange",
              "keyGroupPrefixBytes",
              "useDeleteFilesInRange",
              "beginKeyGroupBytes",
              "endKeyGroupBytes"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e4972c003f68da6dc4066459d4c6e5d981f07e96^1/flink-table/flink-sql-gateway/src/main/java/org/apache/flink/table/gateway/service/materializedtable/MaterializedTableManager.java",
      "locators": [
          {
              "line": 19,
              "column": 26
          },
          {
              "line": 19,
              "column": 60
          },
          {
              "line": 24,
              "column": 25
          },
          {
              "line": 25,
              "column": 25
          },
          {
              "line": 26,
              "column": 25
          },
          {
              "line": 27,
              "column": 25
          },
          {
              "line": 28,
              "column": 25
          },
          {
              "line": 29,
              "column": 25
          },
          {
              "line": 30,
              "column": 25
          },
          {
              "line": 31,
              "column": 25
          },
          {
              "line": 32,
              "column": 25
          },
          {
              "line": 33,
              "column": 25
          },
          {
              "line": 34,
              "column": 25
          },
          {
              "line": 35,
              "column": 25
          },
          {
              "line": 36,
              "column": 25
          },
          {
              "line": 37,
              "column": 25
          },
          {
              "line": 37,
              "column": 54
          },
          {
              "line": 38,
              "column": 25
          },
          {
              "line": 38,
              "column": 54
          },
          {
              "line": 39,
              "column": 25
          },
          {
              "line": 39,
              "column": 54
          },
          {
              "line": 40,
              "column": 25
          },
          {
              "line": 40,
              "column": 54
          },
          {
              "line": 41,
              "column": 25
          },
          {
              "line": 41,
              "column": 54
          },
          {
              "line": 42,
              "column": 25
          },
          {
              "line": 43,
              "column": 25
          },
          {
              "line": 44,
              "column": 25
          },
          {
              "line": 61,
              "column": 32
          },
          {
              "line": 62,
              "column": 32
          },
          {
              "line": 85,
              "column": 68
          },
          {
              "line": 99,
              "column": 55
          },
          {
              "line": 102,
              "column": 53
          },
          {
              "line": 110,
              "column": 32
          },
          {
              "line": 111,
              "column": 36
          },
          {
              "line": 123,
              "column": 39
          },
          {
              "line": 155,
              "column": 31
          },
          {
              "line": 156,
              "column": 13
          },
          {
              "line": 159,
              "column": 13
          },
          {
              "line": 165,
              "column": 58
          },
          {
              "line": 166,
              "column": 40
          },
          {
              "line": 169,
              "column": 34
          },
          {
              "line": 171,
              "column": 40
          },
          {
              "line": 176,
              "column": 69
          },
          {
              "line": 181,
              "column": 77
          },
          {
              "line": 193,
              "column": 37
          },
          {
              "line": 194,
              "column": 35
          },
          {
              "line": 197,
              "column": 34
          },
          {
              "line": 197,
              "column": 67
          },
          {
              "line": 202,
              "column": 52
          },
          {
              "line": 207,
              "column": 81
          },
          {
              "line": 213,
              "column": 39
          },
          {
              "line": 226,
              "column": 71
          },
          {
              "line": 234,
              "column": 62
          },
          {
              "line": 239,
              "column": 70
          },
          {
              "line": 246,
              "column": 81
          },
          {
              "line": 247,
              "column": 33
          },
          {
              "line": 248,
              "column": 54
          },
          {
              "line": 281,
              "column": 74
          },
          {
              "line": 289,
              "column": 20
          },
          {
              "line": 294,
              "column": 33
          }
      ],
      "old_name": "table",
      "new_name": "resolvedCatalogBaseTable",
      "ctx": {
          "symbolName": "table",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ResolvedCatalogBaseTable<?>",
          "scopeHint": "in callAlterMaterializedTableRefreshOperation(...)",
          "filePath": "MaterializedTableManager.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static ResultFetcher callAlterMaterializedTableRefreshOperation(\n            OperationExecutor operationExecutor,\n            OperationHandle handle,\n            AlterMaterializedTableRefreshOperation alterMaterializedTableRefreshOperation) {\n        ObjectIdentifier materializedTableIdentifier =\n                alterMaterializedTableRefreshOperation.getTableIdentifier();\n        ResolvedCatalogBaseTable<?> table = operationExecutor.getTable(materializedTableIdentifier);\n        if (MATERIALIZED_TABLE != table.getTableKind()) {\n            throw new ValidationException(\n                    String.format(\n                            \"The table '%s' is not a materialized table.\",\n                            materializedTableIdentifier));\n        }\n\n        ResolvedCatalogMaterializedTable materializedTable =\n                (ResolvedCatalogMaterializedTable) table;\n\n        Map<String, String> partitionSpec =\n                alterMaterializedTableRefreshOperation.getPartitionSpec();\n\n        validatePartitionSpec(partitionSpec, (ResolvedCatalogMaterializedTable) table);\n\n        // Set job name, runtime mode\n        Configuration customConfig = new Configuration();\n        String jobName =\n                String.format(\n                        \"Materialized_table_%s_one_time_refresh_job\",\n                        materializedTableIdentifier.asSerializableString());\n        customConfig.set(NAME, jobName);\n        customConfig.set(RUNTIME_MODE, BATCH);\n\n        String insertStatement =\n                getManuallyRefreshStatement(\n                        materializedTableIdentifier.toString(),\n                        materializedTable.getDefinitionQuery(),\n                        partitionSpec);\n\n        try {\n            LOG.debug(\n                    \"Begin to manually refreshing the materialization table {}, statement: {}\",\n                    materializedTableIdentifier,\n                    insertStatement);\n            return operationExecutor.executeStatement(\n                    handle, customConfig, insertStatement.toString());\n        } catch (Exception e) {\n            // log and throw exception\n            LOG.error(\n                    \"Manually refreshing the materialization table {} occur exception.\",\n                    materializedTableIdentifier,\n                    e);\n            throw new SqlExecutionException(\n                    String.format(\n                            \"Manually refreshing the materialization table %s occur exception.\",\n                            materializedTableIdentifier),\n                    e);\n        }\n    }",
          "conflictNames": [
              "operationExecutor",
              "handle",
              "alterMaterializedTableRefreshOperation",
              "materializedTableIdentifier",
              "materializedTable",
              "partitionSpec",
              "customConfig",
              "jobName",
              "insertStatement"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e5b553a12068511949b0415fc7e4c7b6930819ad^1/flink-runtime/src/main/java/org/apache/flink/runtime/metrics/MetricRegistryImpl.java",
      "locators": [
          {
              "line": 350,
              "column": 47
          },
          {
              "line": 354,
              "column": 40
          }
      ],
      "old_name": "executorShutdownFuture",
      "new_name": "reporterExecutorShutdownFuture",
      "ctx": {
          "symbolName": "executorShutdownFuture",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CompletableFuture<Void>",
          "scopeHint": "in closeAsync(...)",
          "filePath": "MetricRegistryImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Shuts down this registry and the associated {@link MetricReporter}.\n     *\n     * <p>NOTE: This operation is asynchronous and returns a future which is completed once the\n     * shutdown operation has been completed.\n     *\n     * @return Future which is completed once the {@link MetricRegistryImpl} is shut down.\n     */\n    @Override\n    public CompletableFuture<Void> closeAsync() {\n        synchronized (lock) {\n            if (isShutdown) {\n                return terminationFuture;\n            } else {\n                isShutdown = true;\n                final Collection<CompletableFuture<Void>> terminationFutures = new ArrayList<>(3);\n                final Time gracePeriod = Time.seconds(1L);\n\n                if (metricQueryServiceRpcService != null) {\n                    final CompletableFuture<Void> metricQueryServiceRpcServiceTerminationFuture =\n                            metricQueryServiceRpcService.closeAsync();\n                    terminationFutures.add(metricQueryServiceRpcServiceTerminationFuture);\n                }\n\n                Throwable throwable = null;\n                for (ReporterAndSettings reporterAndSettings : reporters) {\n                    try {\n                        reporterAndSettings.getReporter().close();\n                    } catch (Throwable t) {\n                        throwable = ExceptionUtils.firstOrSuppressed(t, throwable);\n                    }\n                }\n                reporters.clear();\n\n                if (throwable != null) {\n                    terminationFutures.add(\n                            FutureUtils.completedExceptionally(\n                                    new FlinkException(\n                                            \"Could not shut down the metric reporters properly.\",\n                                            throwable)));\n                }\n\n                final CompletableFuture<Void> executorShutdownFuture =\n                        ExecutorUtils.nonBlockingShutdown(\n                                gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS, executor);\n\n                terminationFutures.add(executorShutdownFuture);\n\n                FutureUtils.completeAll(terminationFutures)\n                        .whenComplete(\n                                (Void ignored, Throwable error) -> {\n                                    if (error != null) {\n                                        terminationFuture.completeExceptionally(error);\n                                    } else {\n                                        terminationFuture.complete(null);\n                                    }\n                                });\n\n                return terminationFuture;\n            }\n        }\n    }",
          "conflictNames": [
              "terminationFutures",
              "gracePeriod",
              "metricQueryServiceRpcServiceTerminationFuture",
              "throwable"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e63aa12252843d0098a56f3091b28d48aff5b5af^1/flink-container/src/test/java/org/apache/flink/container/entrypoint/StandaloneApplicationClusterConfigurationParserFactoryTest.java",
      "locators": [
          {
              "line": 247,
              "column": 22
          },
          {
              "line": 258,
              "column": 13
          }
      ],
      "old_name": "jobJarFile",
      "new_name": "jars",
      "ctx": {
          "symbolName": "jobJarFile",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in testShortOptions(...)",
          "filePath": "StandaloneApplicationClusterConfigurationParserFactoryTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testShortOptions() throws FlinkParseException {\n        final String jobClassName = JOB_CLASS_NAME;\n        final JobID jobId = new JobID();\n        final String savepointRestorePath = \"s3://foo/bar\";\n        final String jobJarFile = JOB_JAR_FILE;\n        final String[] args = {\n            \"-c\",\n            confDirPath,\n            \"-j\",\n            jobClassName,\n            \"-jid\",\n            jobId.toString(),\n            \"-s\",\n            savepointRestorePath,\n            \"-jarfile\",\n            jobJarFile,\n            \"-n\"\n        };\n\n        final StandaloneApplicationClusterConfiguration clusterConfiguration =\n                commandLineParser.parse(args);\n\n        assertThat(clusterConfiguration.getConfigDir()).isEqualTo(confDirPath);\n        assertThat(clusterConfiguration.getJobClassName()).isEqualTo(jobClassName);\n        assertThat(clusterConfiguration.getJobId()).isEqualTo(jobId);\n\n        final SavepointRestoreSettings savepointRestoreSettings =\n                clusterConfiguration.getSavepointRestoreSettings();\n        assertThat(savepointRestoreSettings.restoreSavepoint()).isTrue();\n        assertThat(savepointRestoreSettings.getRestorePath()).isEqualTo(savepointRestorePath);\n        assertThat(savepointRestoreSettings.allowNonRestoredState()).isTrue();\n    }",
          "conflictNames": [
              "jobClassName",
              "jobId",
              "savepointRestorePath",
              "args",
              "clusterConfiguration",
              "savepointRestoreSettings"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e63aa12252843d0098a56f3091b28d48aff5b5af^1/flink-container/src/main/java/org/apache/flink/container/entrypoint/StandaloneApplicationClusterConfigurationParserFactory.java",
      "locators": [
          {
              "line": 103,
              "column": 22
          },
          {
              "line": 114,
              "column": 17
          }
      ],
      "old_name": "jarFile",
      "new_name": "jarFiles",
      "ctx": {
          "symbolName": "jarFile",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in createResult(...)",
          "filePath": "StandaloneApplicationClusterConfigurationParserFactory.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public StandaloneApplicationClusterConfiguration createResult(@Nonnull CommandLine commandLine)\n            throws FlinkParseException {\n        final String configDir = commandLine.getOptionValue(CONFIG_DIR_OPTION.getOpt());\n        final Properties dynamicProperties =\n                commandLine.getOptionProperties(DYNAMIC_PROPERTY_OPTION.getOpt());\n        final int restPort = getRestPort(commandLine);\n        final String hostname = commandLine.getOptionValue(HOST_OPTION.getOpt());\n        final SavepointRestoreSettings savepointRestoreSettings =\n                CliFrontendParser.createSavepointRestoreSettings(commandLine);\n        final JobID jobId = getJobId(commandLine);\n        final String jobClassName = commandLine.getOptionValue(JOB_CLASS_NAME_OPTION.getOpt());\n        final String jarFile = commandLine.getOptionValue(JOB_JAR_FILE.getOpt());\n\n        return new StandaloneApplicationClusterConfiguration(\n                configDir,\n                dynamicProperties,\n                commandLine.getArgs(),\n                hostname,\n                restPort,\n                savepointRestoreSettings,\n                jobId,\n                jobClassName,\n                jarFile);\n    }",
          "conflictNames": [
              "commandLine",
              "configDir",
              "dynamicProperties",
              "restPort",
              "hostname",
              "savepointRestoreSettings",
              "jobId",
              "jobClassName"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e63aa12252843d0098a56f3091b28d48aff5b5af^1/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/entrypoint/KubernetesApplicationClusterEntrypoint.java",
      "locators": [
          {
              "line": 129,
              "column": 30
          },
          {
              "line": 130,
              "column": 41
          },
          {
              "line": 133,
              "column": 21
          }
      ],
      "old_name": "pipelineJarFiles",
      "new_name": "fetchRes",
      "ctx": {
          "symbolName": "pipelineJarFiles",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<File>",
          "scopeHint": "in getPackagedProgramRetriever(...)",
          "filePath": "KubernetesApplicationClusterEntrypoint.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static PackagedProgramRetriever getPackagedProgramRetriever(\n            final Configuration configuration,\n            final String[] programArguments,\n            @Nullable final String jobClassName)\n            throws FlinkException {\n\n        final File userLibDir = ClusterEntrypointUtils.tryFindUserLibDirectory().orElse(null);\n\n        // No need to do pipelineJars validation if it is a PyFlink job.\n        if (!(PackagedProgramUtils.isPython(jobClassName)\n                || PackagedProgramUtils.isPython(programArguments))) {\n            final List<File> pipelineJarFiles = fetchJarFileForApplicationMode(configuration);\n            Preconditions.checkArgument(pipelineJarFiles.size() == 1, \"Should only have one jar\");\n            return DefaultPackagedProgramRetriever.create(\n                    userLibDir,\n                    pipelineJarFiles.get(0),\n                    jobClassName,\n                    programArguments,\n                    configuration);\n        }\n\n        return DefaultPackagedProgramRetriever.create(\n                userLibDir, jobClassName, programArguments, configuration);\n    }",
          "conflictNames": [
              "configuration",
              "programArguments",
              "jobClassName",
              "userLibDir"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e69e6514d0b901eb03f1a8bfc499680d076248c9^1/flink-table/flink-sql-parser/src/main/java/org/apache/flink/sql/parser/SqlConstraintValidator.java",
      "locators": [
          {
              "line": 38,
              "column": 28
          },
          {
              "line": 38,
              "column": 55
          },
          {
              "line": 55,
              "column": 25
          },
          {
              "line": 59,
              "column": 34
          },
          {
              "line": 64,
              "column": 13
          },
          {
              "line": 66,
              "column": 21
          },
          {
              "line": 67,
              "column": 20
          },
          {
              "line": 69,
              "column": 35
          }
      ],
      "old_name": "constraints",
      "new_name": "fullConstraints",
      "ctx": {
          "symbolName": "constraints",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<SqlTableConstraint>",
          "scopeHint": "in validateAndChangeColumnNullability(...)",
          "filePath": "SqlConstraintValidator.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Check duplicate constraints and change the nullability of primary key columns. */\n    public static void validateAndChangeColumnNullability(\n            List<SqlTableConstraint> tableConstraints, SqlNodeList columnList)\n            throws SqlValidateException {\n        List<SqlTableConstraint> constraints =\n                getFullConstraints(tableConstraints, columnList).stream()\n                        .filter(SqlTableConstraint::isPrimaryKey)\n                        .collect(Collectors.toList());\n\n        if (constraints.size() > 1) {\n            throw new SqlValidateException(\n                    constraints.get(1).getParserPosition(), \"Duplicate primary key definition\");\n        } else if (constraints.size() == 1) {\n            Set<String> primaryKeyColumns =\n                    Arrays.stream(constraints.get(0).getColumnNames()).collect(Collectors.toSet());\n\n            for (SqlNode column : columnList) {\n                SqlTableColumn tableColumn = (SqlTableColumn) column;\n                if (tableColumn instanceof SqlTableColumn.SqlRegularColumn\n                        && primaryKeyColumns.contains(tableColumn.getName().getSimple())) {\n                    SqlTableColumn.SqlRegularColumn regularColumn =\n                            (SqlTableColumn.SqlRegularColumn) column;\n                    SqlDataTypeSpec notNullType = regularColumn.getType().withNullable(false);\n                    regularColumn.setType(notNullType);\n                }\n            }\n        }\n    }",
          "conflictNames": [
              "tableConstraints",
              "columnList",
              "primaryKeyColumns",
              "tableColumn",
              "regularColumn",
              "notNullType"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e69e6514d0b901eb03f1a8bfc499680d076248c9^1/flink-table/flink-sql-parser/src/test/java/org/apache/flink/sql/parser/FlinkSqlParserImplTest.java",
      "locators": [
          {
              "line": 19,
              "column": 26
          },
          {
              "line": 21,
              "column": 25
          },
          {
              "line": 22,
              "column": 25
          },
          {
              "line": 23,
              "column": 25
          },
          {
              "line": 25,
              "column": 27
          },
          {
              "line": 26,
              "column": 27
          },
          {
              "line": 27,
              "column": 27
          },
          {
              "line": 28,
              "column": 27
          },
          {
              "line": 52,
              "column": 9
          },
          {
              "line": 57,
              "column": 9
          },
          {
              "line": 62,
              "column": 9
          },
          {
              "line": 64,
              "column": 9
          },
          {
              "line": 102,
              "column": 9
          },
          {
              "line": 107,
              "column": 9
          },
          {
              "line": 122,
              "column": 9
          },
          {
              "line": 127,
              "column": 9
          },
          {
              "line": 132,
              "column": 9
          },
          {
              "line": 137,
              "column": 9
          },
          {
              "line": 138,
              "column": 9
          },
          {
              "line": 143,
              "column": 9
          },
          {
              "line": 144,
              "column": 9
          },
          {
              "line": 145,
              "column": 9
          },
          {
              "line": 146,
              "column": 22
          },
          {
              "line": 148,
              "column": 9
          },
          {
              "line": 148,
              "column": 13
          },
          {
              "line": 149,
              "column": 22
          },
          {
              "line": 158,
              "column": 9
          },
          {
              "line": 158,
              "column": 13
          },
          {
              "line": 163,
              "column": 9
          },
          {
              "line": 164,
              "column": 9
          },
          {
              "line": 165,
              "column": 9
          },
          {
              "line": 166,
              "column": 9
          },
          {
              "line": 171,
              "column": 22
          },
          {
              "line": 177,
              "column": 9
          },
          {
              "line": 177,
              "column": 13
          },
          {
              "line": 182,
              "column": 9
          },
          {
              "line": 183,
              "column": 9
          },
          {
              "line": 184,
              "column": 9
          },
          {
              "line": 186,
              "column": 9
          },
          {
              "line": 187,
              "column": 9
          },
          {
              "line": 188,
              "column": 9
          },
          {
              "line": 193,
              "column": 9
          },
          {
              "line": 196,
              "column": 9
          },
          {
              "line": 199,
              "column": 9
          },
          {
              "line": 203,
              "column": 9
          },
          {
              "line": 207,
              "column": 9
          },
          {
              "line": 214,
              "column": 9
          },
          {
              "line": 215,
              "column": 9
          },
          {
              "line": 220,
              "column": 9
          },
          {
              "line": 221,
              "column": 9
          },
          {
              "line": 223,
              "column": 9
          },
          {
              "line": 224,
              "column": 9
          },
          {
              "line": 226,
              "column": 9
          },
          {
              "line": 227,
              "column": 9
          },
          {
              "line": 229,
              "column": 9
          },
          {
              "line": 230,
              "column": 9
          },
          {
              "line": 232,
              "column": 9
          },
          {
              "line": 234,
              "column": 9
          },
          {
              "line": 236,
              "column": 9
          },
          {
              "line": 237,
              "column": 9
          },
          {
              "line": 239,
              "column": 9
          },
          {
              "line": 241,
              "column": 9
          },
          {
              "line": 244,
              "column": 9
          },
          {
              "line": 245,
              "column": 9
          },
          {
              "line": 248,
              "column": 9
          },
          {
              "line": 251,
              "column": 9
          },
          {
              "line": 257,
              "column": 9
          },
          {
              "line": 258,
              "column": 9
          },
          {
              "line": 263,
              "column": 9
          },
          {
              "line": 264,
              "column": 9
          },
          {
              "line": 265,
              "column": 9
          },
          {
              "line": 270,
              "column": 9
          },
          {
              "line": 271,
              "column": 9
          },
          {
              "line": 272,
              "column": 9
          },
          {
              "line": 274,
              "column": 9
          },
          {
              "line": 275,
              "column": 9
          },
          {
              "line": 276,
              "column": 9
          },
          {
              "line": 281,
              "column": 9
          },
          {
              "line": 282,
              "column": 9
          },
          {
              "line": 284,
              "column": 9
          },
          {
              "line": 285,
              "column": 9
          },
          {
              "line": 287,
              "column": 9
          },
          {
              "line": 288,
              "column": 9
          },
          {
              "line": 290,
              "column": 9
          },
          {
              "line": 291,
              "column": 9
          },
          {
              "line": 293,
              "column": 9
          },
          {
              "line": 294,
              "column": 9
          },
          {
              "line": 296,
              "column": 9
          },
          {
              "line": 298,
              "column": 9
          },
          {
              "line": 301,
              "column": 9
          },
          {
              "line": 302,
              "column": 9
          },
          {
              "line": 304,
              "column": 9
          },
          {
              "line": 306,
              "column": 9
          },
          {
              "line": 308,
              "column": 9
          },
          {
              "line": 310,
              "column": 9
          },
          {
              "line": 316,
              "column": 9
          },
          {
              "line": 317,
              "column": 9
          },
          {
              "line": 319,
              "column": 9
          },
          {
              "line": 320,
              "column": 9
          },
          {
              "line": 322,
              "column": 9
          },
          {
              "line": 324,
              "column": 9
          },
          {
              "line": 326,
              "column": 9
          },
          {
              "line": 331,
              "column": 9
          },
          {
              "line": 336,
              "column": 9
          },
          {
              "line": 338,
              "column": 9
          },
          {
              "line": 340,
              "column": 9
          },
          {
              "line": 341,
              "column": 9
          },
          {
              "line": 343,
              "column": 9
          },
          {
              "line": 344,
              "column": 9
          },
          {
              "line": 346,
              "column": 9
          },
          {
              "line": 353,
              "column": 9
          },
          {
              "line": 359,
              "column": 9
          },
          {
              "line": 367,
              "column": 9
          },
          {
              "line": 371,
              "column": 9
          },
          {
              "line": 380,
              "column": 9
          },
          {
              "line": 385,
              "column": 9
          },
          {
              "line": 390,
              "column": 9
          },
          {
              "line": 395,
              "column": 9
          },
          {
              "line": 401,
              "column": 9
          },
          {
              "line": 407,
              "column": 9
          },
          {
              "line": 416,
              "column": 9
          },
          {
              "line": 418,
              "column": 9
          },
          {
              "line": 423,
              "column": 9
          },
          {
              "line": 428,
              "column": 9
          },
          {
              "line": 434,
              "column": 9
          },
          {
              "line": 443,
              "column": 22
          },
          {
              "line": 463,
              "column": 9
          },
          {
              "line": 463,
              "column": 13
          },
          {
              "line": 465,
              "column": 22
          },
          {
              "line": 475,
              "column": 9
          },
          {
              "line": 475,
              "column": 13
          },
          {
              "line": 480,
              "column": 9
          },
          {
              "line": 485,
              "column": 9
          },
          {
              "line": 490,
              "column": 9
          },
          {
              "line": 495,
              "column": 9
          },
          {
              "line": 501,
              "column": 9
          },
          {
              "line": 508,
              "column": 9
          },
          {
              "line": 514,
              "column": 9
          },
          {
              "line": 521,
              "column": 9
          },
          {
              "line": 528,
              "column": 9
          },
          {
              "line": 537,
              "column": 9
          },
          {
              "line": 542,
              "column": 9
          },
          {
              "line": 547,
              "column": 9
          },
          {
              "line": 552,
              "column": 9
          },
          {
              "line": 558,
              "column": 9
          },
          {
              "line": 567,
              "column": 9
          },
          {
              "line": 572,
              "column": 9
          },
          {
              "line": 578,
              "column": 22
          },
          {
              "line": 598,
              "column": 9
          },
          {
              "line": 598,
              "column": 13
          },
          {
              "line": 603,
              "column": 9
          },
          {
              "line": 605,
              "column": 9
          },
          {
              "line": 607,
              "column": 9
          },
          {
              "line": 609,
              "column": 9
          },
          {
              "line": 615,
              "column": 9
          },
          {
              "line": 623,
              "column": 9
          },
          {
              "line": 635,
              "column": 9
          },
          {
              "line": 637,
              "column": 9
          },
          {
              "line": 642,
              "column": 9
          },
          {
              "line": 644,
              "column": 9
          },
          {
              "line": 646,
              "column": 9
          },
          {
              "line": 652,
              "column": 9
          },
          {
              "line": 654,
              "column": 9
          },
          {
              "line": 659,
              "column": 9
          },
          {
              "line": 662,
              "column": 9
          },
          {
              "line": 664,
              "column": 9
          },
          {
              "line": 667,
              "column": 9
          },
          {
              "line": 672,
              "column": 9
          },
          {
              "line": 674,
              "column": 9
          },
          {
              "line": 676,
              "column": 9
          },
          {
              "line": 678,
              "column": 9
          },
          {
              "line": 680,
              "column": 9
          },
          {
              "line": 683,
              "column": 9
          },
          {
              "line": 689,
              "column": 22
          },
          {
              "line": 727,
              "column": 9
          },
          {
              "line": 727,
              "column": 13
          },
          {
              "line": 732,
              "column": 22
          },
          {
              "line": 762,
              "column": 9
          },
          {
              "line": 762,
              "column": 13
          },
          {
              "line": 767,
              "column": 22
          },
          {
              "line": 807,
              "column": 9
          },
          {
              "line": 807,
              "column": 13
          },
          {
              "line": 812,
              "column": 22
          },
          {
              "line": 844,
              "column": 9
          },
          {
              "line": 844,
              "column": 13
          },
          {
              "line": 849,
              "column": 22
          },
          {
              "line": 877,
              "column": 9
          },
          {
              "line": 877,
              "column": 13
          },
          {
              "line": 882,
              "column": 22
          },
          {
              "line": 910,
              "column": 9
          },
          {
              "line": 910,
              "column": 13
          },
          {
              "line": 915,
              "column": 22
          },
          {
              "line": 941,
              "column": 9
          },
          {
              "line": 941,
              "column": 13
          },
          {
              "line": 946,
              "column": 22
          },
          {
              "line": 959,
              "column": 9
          },
          {
              "line": 959,
              "column": 13
          },
          {
              "line": 964,
              "column": 22
          },
          {
              "line": 983,
              "column": 9
          },
          {
              "line": 983,
              "column": 13
          },
          {
              "line": 988,
              "column": 22
          },
          {
              "line": 1007,
              "column": 9
          },
          {
              "line": 1007,
              "column": 13
          },
          {
              "line": 1012,
              "column": 22
          },
          {
              "line": 1029,
              "column": 9
          },
          {
              "line": 1029,
              "column": 13
          },
          {
              "line": 1034,
              "column": 16
          },
          {
              "line": 1046,
              "column": 9
          },
          {
              "line": 1046,
              "column": 13
          },
          {
              "line": 1051,
              "column": 16
          },
          {
              "line": 1062,
              "column": 9
          },
          {
              "line": 1062,
              "column": 13
          },
          {
              "line": 1067,
              "column": 22
          },
          {
              "line": 1089,
              "column": 9
          },
          {
              "line": 1089,
              "column": 13
          },
          {
              "line": 1094,
              "column": 22
          },
          {
              "line": 1116,
              "column": 9
          },
          {
              "line": 1116,
              "column": 13
          },
          {
              "line": 1121,
              "column": 22
          },
          {
              "line": 1137,
              "column": 9
          },
          {
              "line": 1137,
              "column": 13
          },
          {
              "line": 1142,
              "column": 22
          },
          {
              "line": 1159,
              "column": 9
          },
          {
              "line": 1159,
              "column": 13
          },
          {
              "line": 1161,
              "column": 22
          },
          {
              "line": 1172,
              "column": 9
          },
          {
              "line": 1172,
              "column": 13
          },
          {
              "line": 1177,
              "column": 22
          },
          {
              "line": 1194,
              "column": 9
          },
          {
              "line": 1194,
              "column": 13
          },
          {
              "line": 1199,
              "column": 22
          },
          {
              "line": 1222,
              "column": 9
          },
          {
              "line": 1222,
              "column": 13
          },
          {
              "line": 1227,
              "column": 22
          },
          {
              "line": 1235,
              "column": 9
          },
          {
              "line": 1235,
              "column": 13
          },
          {
              "line": 1240,
              "column": 22
          },
          {
              "line": 1254,
              "column": 9
          },
          {
              "line": 1254,
              "column": 13
          },
          {
              "line": 1259,
              "column": 22
          },
          {
              "line": 1285,
              "column": 9
          },
          {
              "line": 1285,
              "column": 13
          },
          {
              "line": 1290,
              "column": 22
          },
          {
              "line": 1314,
              "column": 9
          },
          {
              "line": 1314,
              "column": 13
          },
          {
              "line": 1319,
              "column": 22
          },
          {
              "line": 1337,
              "column": 9
          },
          {
              "line": 1337,
              "column": 13
          },
          {
              "line": 1342,
              "column": 22
          },
          {
              "line": 1349,
              "column": 9
          },
          {
              "line": 1349,
              "column": 13
          },
          {
              "line": 1354,
              "column": 22
          },
          {
              "line": 1368,
              "column": 9
          },
          {
              "line": 1368,
              "column": 13
          },
          {
              "line": 1373,
              "column": 22
          },
          {
              "line": 1375,
              "column": 9
          },
          {
              "line": 1375,
              "column": 13
          },
          {
              "line": 1380,
              "column": 22
          },
          {
              "line": 1382,
              "column": 9
          },
          {
              "line": 1382,
              "column": 13
          },
          {
              "line": 1387,
              "column": 22
          },
          {
              "line": 1389,
              "column": 9
          },
          {
              "line": 1389,
              "column": 13
          },
          {
              "line": 1394,
              "column": 22
          },
          {
              "line": 1396,
              "column": 9
          },
          {
              "line": 1396,
              "column": 13
          },
          {
              "line": 1401,
              "column": 22
          },
          {
              "line": 1408,
              "column": 9
          },
          {
              "line": 1408,
              "column": 13
          },
          {
              "line": 1409,
              "column": 22
          },
          {
              "line": 1417,
              "column": 9
          },
          {
              "line": 1417,
              "column": 13
          },
          {
              "line": 1425,
              "column": 22
          },
          {
              "line": 1430,
              "column": 9
          },
          {
              "line": 1430,
              "column": 13
          },
          {
              "line": 1447,
              "column": 9
          },
          {
              "line": 1460,
              "column": 9
          },
          {
              "line": 1467,
              "column": 33
          },
          {
              "line": 1478,
              "column": 22
          },
          {
              "line": 1480,
              "column": 9
          },
          {
              "line": 1480,
              "column": 13
          },
          {
              "line": 1483,
              "column": 22
          },
          {
              "line": 1490,
              "column": 9
          },
          {
              "line": 1490,
              "column": 13
          },
          {
              "line": 1495,
              "column": 9
          },
          {
              "line": 1501,
              "column": 22
          },
          {
              "line": 1503,
              "column": 9
          },
          {
              "line": 1503,
              "column": 13
          },
          {
              "line": 1516,
              "column": 9
          },
          {
              "line": 1521,
              "column": 22
          },
          {
              "line": 1528,
              "column": 9
          },
          {
              "line": 1528,
              "column": 13
          },
          {
              "line": 1533,
              "column": 22
          },
          {
              "line": 1539,
              "column": 9
          },
          {
              "line": 1539,
              "column": 13
          },
          {
              "line": 1544,
              "column": 22
          },
          {
              "line": 1547,
              "column": 9
          },
          {
              "line": 1547,
              "column": 13
          },
          {
              "line": 1552,
              "column": 22
          },
          {
              "line": 1555,
              "column": 9
          },
          {
              "line": 1555,
              "column": 13
          },
          {
              "line": 1560,
              "column": 22
          },
          {
              "line": 1566,
              "column": 9
          },
          {
              "line": 1566,
              "column": 13
          },
          {
              "line": 1571,
              "column": 22
          },
          {
              "line": 1574,
              "column": 9
          },
          {
              "line": 1574,
              "column": 13
          },
          {
              "line": 1579,
              "column": 22
          },
          {
              "line": 1581,
              "column": 9
          },
          {
              "line": 1581,
              "column": 13
          },
          {
              "line": 1586,
              "column": 22
          },
          {
              "line": 1588,
              "column": 9
          },
          {
              "line": 1588,
              "column": 13
          },
          {
              "line": 1593,
              "column": 9
          },
          {
              "line": 1594,
              "column": 9
          },
          {
              "line": 1600,
              "column": 9
          },
          {
              "line": 1634,
              "column": 16
          },
          {
              "line": 1635,
              "column": 9
          },
          {
              "line": 1635,
              "column": 13
          },
          {
              "line": 1640,
              "column": 16
          },
          {
              "line": 1641,
              "column": 9
          },
          {
              "line": 1641,
              "column": 13
          },
          {
              "line": 1646,
              "column": 9
          },
          {
              "line": 1650,
              "column": 9
          },
          {
              "line": 1654,
              "column": 9
          },
          {
              "line": 1658,
              "column": 9
          },
          {
              "line": 1662,
              "column": 9
          },
          {
              "line": 1666,
              "column": 9
          },
          {
              "line": 1670,
              "column": 9
          },
          {
              "line": 1675,
              "column": 9
          },
          {
              "line": 1678,
              "column": 9
          },
          {
              "line": 1685,
              "column": 9
          },
          {
              "line": 1689,
              "column": 9
          },
          {
              "line": 1693,
              "column": 9
          },
          {
              "line": 1697,
              "column": 9
          },
          {
              "line": 1701,
              "column": 9
          },
          {
              "line": 1701,
              "column": 100
          },
          {
              "line": 1704,
              "column": 9
          },
          {
              "line": 1707,
              "column": 9
          },
          {
              "line": 1717,
              "column": 9
          },
          {
              "line": 1720,
              "column": 9
          },
          {
              "line": 1723,
              "column": 9
          },
          {
              "line": 1726,
              "column": 9
          },
          {
              "line": 1732,
              "column": 9
          },
          {
              "line": 1734,
              "column": 9
          },
          {
              "line": 1742,
              "column": 9
          },
          {
              "line": 1748,
              "column": 9
          },
          {
              "line": 1750,
              "column": 9
          },
          {
              "line": 1756,
              "column": 9
          },
          {
              "line": 1758,
              "column": 9
          },
          {
              "line": 1760,
              "column": 9
          },
          {
              "line": 1762,
              "column": 9
          },
          {
              "line": 1768,
              "column": 9
          },
          {
              "line": 1770,
              "column": 9
          },
          {
              "line": 1775,
              "column": 9
          },
          {
              "line": 1780,
              "column": 9
          },
          {
              "line": 1785,
              "column": 9
          },
          {
              "line": 1801,
              "column": 9
          },
          {
              "line": 1817,
              "column": 16
          },
          {
              "line": 1819,
              "column": 14
          },
          {
              "line": 1819,
              "column": 18
          },
          {
              "line": 1824,
              "column": 16
          },
          {
              "line": 1826,
              "column": 14
          },
          {
              "line": 1826,
              "column": 18
          },
          {
              "line": 1831,
              "column": 16
          },
          {
              "line": 1833,
              "column": 14
          },
          {
              "line": 1833,
              "column": 18
          },
          {
              "line": 1838,
              "column": 16
          },
          {
              "line": 1840,
              "column": 14
          },
          {
              "line": 1840,
              "column": 18
          },
          {
              "line": 1845,
              "column": 16
          },
          {
              "line": 1847,
              "column": 14
          },
          {
              "line": 1847,
              "column": 18
          },
          {
              "line": 1852,
              "column": 16
          },
          {
              "line": 1859,
              "column": 14
          },
          {
              "line": 1859,
              "column": 18
          },
          {
              "line": 1894,
              "column": 16
          },
          {
              "line": 1896,
              "column": 14
          },
          {
              "line": 1896,
              "column": 18
          },
          {
              "line": 1901,
              "column": 16
          },
          {
              "line": 1903,
              "column": 14
          },
          {
              "line": 1903,
              "column": 18
          },
          {
              "line": 1908,
              "column": 16
          },
          {
              "line": 1913,
              "column": 14
          },
          {
              "line": 1913,
              "column": 18
          },
          {
              "line": 1919,
              "column": 14
          },
          {
              "line": 1925,
              "column": 14
          },
          {
              "line": 1930,
              "column": 9
          },
          {
              "line": 1931,
              "column": 9
          },
          {
              "line": 1937,
              "column": 9
          },
          {
              "line": 1942,
              "column": 9
          },
          {
              "line": 1948,
              "column": 9
          },
          {
              "line": 1961,
              "column": 9
          },
          {
              "line": 1978,
              "column": 9
          },
          {
              "line": 1984,
              "column": 9
          },
          {
              "line": 2001,
              "column": 16
          },
          {
              "line": 2003,
              "column": 14
          },
          {
              "line": 2003,
              "column": 18
          },
          {
              "line": 2008,
              "column": 16
          },
          {
              "line": 2009,
              "column": 14
          },
          {
              "line": 2009,
              "column": 18
          },
          {
              "line": 2014,
              "column": 16
          },
          {
              "line": 2015,
              "column": 14
          },
          {
              "line": 2015,
              "column": 18
          },
          {
              "line": 2020,
              "column": 9
          },
          {
              "line": 2020,
              "column": 30
          },
          {
              "line": 2020,
              "column": 57
          },
          {
              "line": 2021,
              "column": 9
          },
          {
              "line": 2022,
              "column": 9
          },
          {
              "line": 2027,
              "column": 9
          },
          {
              "line": 2027,
              "column": 33
          },
          {
              "line": 2027,
              "column": 63
          },
          {
              "line": 2028,
              "column": 9
          },
          {
              "line": 2030,
              "column": 9
          },
          {
              "line": 2035,
              "column": 9
          },
          {
              "line": 2040,
              "column": 9
          },
          {
              "line": 2041,
              "column": 9
          },
          {
              "line": 2042,
              "column": 9
          },
          {
              "line": 2043,
              "column": 9
          },
          {
              "line": 2062,
              "column": 9
          },
          {
              "line": 2063,
              "column": 9
          },
          {
              "line": 2064,
              "column": 9
          },
          {
              "line": 2066,
              "column": 9
          },
          {
              "line": 2068,
              "column": 9
          },
          {
              "line": 2070,
              "column": 9
          },
          {
              "line": 2072,
              "column": 9
          },
          {
              "line": 2074,
              "column": 9
          },
          {
              "line": 2076,
              "column": 9
          },
          {
              "line": 2078,
              "column": 9
          },
          {
              "line": 2080,
              "column": 9
          },
          {
              "line": 2082,
              "column": 9
          },
          {
              "line": 2085,
              "column": 9
          },
          {
              "line": 2088,
              "column": 9
          },
          {
              "line": 2094,
              "column": 9
          },
          {
              "line": 2099,
              "column": 9
          },
          {
              "line": 2105,
              "column": 9
          },
          {
              "line": 2111,
              "column": 9
          },
          {
              "line": 2120,
              "column": 9
          },
          {
              "line": 2129,
              "column": 9
          },
          {
              "line": 2138,
              "column": 9
          },
          {
              "line": 2147,
              "column": 9
          },
          {
              "line": 2156,
              "column": 9
          },
          {
              "line": 2161,
              "column": 9
          },
          {
              "line": 2162,
              "column": 9
          },
          {
              "line": 2163,
              "column": 9
          },
          {
              "line": 2165,
              "column": 9
          },
          {
              "line": 2167,
              "column": 9
          }
      ],
      "old_name": "sql",
      "new_name": "sql1",
      "ctx": {
          "symbolName": "sql",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in testCreateDatabase(...)",
          "filePath": "FlinkSqlParserImplTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testCreateDatabase() {\n        sql(\"create database db1\").ok(\"CREATE DATABASE `DB1`\");\n        sql(\"create database if not exists db1\").ok(\"CREATE DATABASE IF NOT EXISTS `DB1`\");\n        sql(\"create database catalog1.db1\").ok(\"CREATE DATABASE `CATALOG1`.`DB1`\");\n        final String sql = \"create database db1 comment 'test create database'\";\n        final String expected = \"CREATE DATABASE `DB1`\\n\" + \"COMMENT 'test create database'\";\n        sql(sql).ok(expected);\n        final String sql1 =\n                \"create database db1 comment 'test create database'\"\n                        + \"with ( 'key1' = 'value1', 'key2.a' = 'value2.a')\";\n        final String expected1 =\n                \"CREATE DATABASE `DB1`\\n\"\n                        + \"COMMENT 'test create database' WITH (\\n\"\n                        + \"  'key1' = 'value1',\\n\"\n                        + \"  'key2.a' = 'value2.a'\\n\"\n                        + \")\";\n        sql(sql1).ok(expected1);\n    }",
          "conflictNames": [
              "expected",
              "sql1",
              "expected1"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e69e6514d0b901eb03f1a8bfc499680d076248c9^1/flink-table/flink-sql-parser/src/test/java/org/apache/flink/sql/parser/FlinkSqlParserImplTest.java",
      "locators": [
          {
              "line": 147,
              "column": 22
          },
          {
              "line": 148,
              "column": 21
          },
          {
              "line": 152,
              "column": 22
          },
          {
              "line": 158,
              "column": 22
          },
          {
              "line": 172,
              "column": 22
          },
          {
              "line": 177,
              "column": 21
          },
          {
              "line": 453,
              "column": 22
          },
          {
              "line": 463,
              "column": 22
          },
          {
              "line": 588,
              "column": 22
          },
          {
              "line": 598,
              "column": 22
          },
          {
              "line": 708,
              "column": 22
          },
          {
              "line": 727,
              "column": 21
          },
          {
              "line": 747,
              "column": 22
          },
          {
              "line": 762,
              "column": 21
          },
          {
              "line": 787,
              "column": 22
          },
          {
              "line": 807,
              "column": 21
          },
          {
              "line": 828,
              "column": 22
          },
          {
              "line": 844,
              "column": 21
          },
          {
              "line": 863,
              "column": 22
          },
          {
              "line": 877,
              "column": 21
          },
          {
              "line": 896,
              "column": 22
          },
          {
              "line": 910,
              "column": 33
          },
          {
              "line": 928,
              "column": 22
          },
          {
              "line": 941,
              "column": 21
          },
          {
              "line": 974,
              "column": 22
          },
          {
              "line": 983,
              "column": 21
          },
          {
              "line": 998,
              "column": 22
          },
          {
              "line": 1007,
              "column": 21
          },
          {
              "line": 1021,
              "column": 22
          },
          {
              "line": 1029,
              "column": 21
          },
          {
              "line": 1078,
              "column": 22
          },
          {
              "line": 1089,
              "column": 21
          },
          {
              "line": 1105,
              "column": 22
          },
          {
              "line": 1116,
              "column": 21
          },
          {
              "line": 1129,
              "column": 22
          },
          {
              "line": 1137,
              "column": 21
          },
          {
              "line": 1190,
              "column": 22
          },
          {
              "line": 1194,
              "column": 63
          },
          {
              "line": 1210,
              "column": 22
          },
          {
              "line": 1222,
              "column": 21
          },
          {
              "line": 1247,
              "column": 22
          },
          {
              "line": 1254,
              "column": 21
          },
          {
              "line": 1272,
              "column": 22
          },
          {
              "line": 1285,
              "column": 21
          },
          {
              "line": 1302,
              "column": 22
          },
          {
              "line": 1314,
              "column": 21
          },
          {
              "line": 1328,
              "column": 22
          },
          {
              "line": 1337,
              "column": 21
          },
          {
              "line": 1344,
              "column": 22
          },
          {
              "line": 1349,
              "column": 21
          },
          {
              "line": 1361,
              "column": 22
          },
          {
              "line": 1368,
              "column": 21
          },
          {
              "line": 1374,
              "column": 22
          },
          {
              "line": 1375,
              "column": 21
          },
          {
              "line": 1381,
              "column": 22
          },
          {
              "line": 1382,
              "column": 21
          },
          {
              "line": 1388,
              "column": 22
          },
          {
              "line": 1389,
              "column": 21
          },
          {
              "line": 1395,
              "column": 22
          },
          {
              "line": 1396,
              "column": 21
          },
          {
              "line": 1402,
              "column": 22
          },
          {
              "line": 1408,
              "column": 22
          },
          {
              "line": 1441,
              "column": 22
          },
          {
              "line": 1449,
              "column": 21
          },
          {
              "line": 1454,
              "column": 22
          },
          {
              "line": 1460,
              "column": 91
          },
          {
              "line": 1479,
              "column": 22
          },
          {
              "line": 1480,
              "column": 21
          },
          {
              "line": 1484,
              "column": 22
          },
          {
              "line": 1490,
              "column": 22
          },
          {
              "line": 1502,
              "column": 22
          },
          {
              "line": 1503,
              "column": 21
          },
          {
              "line": 1508,
              "column": 22
          },
          {
              "line": 1516,
              "column": 61
          },
          {
              "line": 1522,
              "column": 22
          },
          {
              "line": 1528,
              "column": 21
          },
          {
              "line": 1534,
              "column": 22
          },
          {
              "line": 1539,
              "column": 21
          },
          {
              "line": 1545,
              "column": 22
          },
          {
              "line": 1547,
              "column": 24
          },
          {
              "line": 1553,
              "column": 22
          },
          {
              "line": 1555,
              "column": 21
          },
          {
              "line": 1561,
              "column": 22
          },
          {
              "line": 1566,
              "column": 21
          },
          {
              "line": 1572,
              "column": 22
          },
          {
              "line": 1574,
              "column": 21
          },
          {
              "line": 1580,
              "column": 22
          },
          {
              "line": 1581,
              "column": 21
          },
          {
              "line": 1587,
              "column": 22
          },
          {
              "line": 1588,
              "column": 21
          },
          {
              "line": 1608,
              "column": 22
          },
          {
              "line": 1609,
              "column": 23
          },
          {
              "line": 1612,
              "column": 22
          },
          {
              "line": 1613,
              "column": 24
          },
          {
              "line": 1618,
              "column": 22
          },
          {
              "line": 1621,
              "column": 24
          },
          {
              "line": 1624,
              "column": 22
          },
          {
              "line": 1625,
              "column": 24
          },
          {
              "line": 1628,
              "column": 22
          },
          {
              "line": 1629,
              "column": 24
          },
          {
              "line": 1818,
              "column": 16
          },
          {
              "line": 1819,
              "column": 26
          },
          {
              "line": 1825,
              "column": 16
          },
          {
              "line": 1826,
              "column": 26
          },
          {
              "line": 1832,
              "column": 16
          },
          {
              "line": 1833,
              "column": 26
          },
          {
              "line": 1839,
              "column": 16
          },
          {
              "line": 1840,
              "column": 26
          },
          {
              "line": 1846,
              "column": 16
          },
          {
              "line": 1847,
              "column": 26
          },
          {
              "line": 1853,
              "column": 16
          },
          {
              "line": 1859,
              "column": 26
          },
          {
              "line": 1895,
              "column": 16
          },
          {
              "line": 1896,
              "column": 26
          },
          {
              "line": 1902,
              "column": 16
          },
          {
              "line": 1903,
              "column": 26
          },
          {
              "line": 1910,
              "column": 16
          },
          {
              "line": 1913,
              "column": 26
          },
          {
              "line": 1918,
              "column": 16
          },
          {
              "line": 1919,
              "column": 79
          },
          {
              "line": 1924,
              "column": 16
          },
          {
              "line": 1925,
              "column": 70
          },
          {
              "line": 2002,
              "column": 16
          },
          {
              "line": 2003,
              "column": 26
          },
          {
              "line": 2203,
              "column": 24
          },
          {
              "line": 2207,
              "column": 18
          },
          {
              "line": 2228,
              "column": 31
          },
          {
              "line": 2233,
              "column": 21
          },
          {
              "line": 2235,
              "column": 40
          }
      ],
      "old_name": "expected",
      "new_name": "expected1",
      "ctx": {
          "symbolName": "expected",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in testCreateDatabase(...)",
          "filePath": "FlinkSqlParserImplTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testCreateDatabase() {\n        sql(\"create database db1\").ok(\"CREATE DATABASE `DB1`\");\n        sql(\"create database if not exists db1\").ok(\"CREATE DATABASE IF NOT EXISTS `DB1`\");\n        sql(\"create database catalog1.db1\").ok(\"CREATE DATABASE `CATALOG1`.`DB1`\");\n        final String sql = \"create database db1 comment 'test create database'\";\n        final String expected = \"CREATE DATABASE `DB1`\\n\" + \"COMMENT 'test create database'\";\n        sql(sql).ok(expected);\n        final String sql1 =\n                \"create database db1 comment 'test create database'\"\n                        + \"with ( 'key1' = 'value1', 'key2.a' = 'value2.a')\";\n        final String expected1 =\n                \"CREATE DATABASE `DB1`\\n\"\n                        + \"COMMENT 'test create database' WITH (\\n\"\n                        + \"  'key1' = 'value1',\\n\"\n                        + \"  'key2.a' = 'value2.a'\\n\"\n                        + \")\";\n        sql(sql1).ok(expected1);\n    }",
          "conflictNames": [
              "sql",
              "sql1",
              "expected1"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e9353319ad625baa5b2c20fa709ab5b23f83c0f4^1/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/windowing/functions/InternalWindowFunctionTest.java",
      "locators": [
          {
              "line": 26,
              "column": 25
          },
          {
              "line": 90,
              "column": 23
          },
          {
              "line": 92,
              "column": 29
          },
          {
              "line": 93,
              "column": 27
          },
          {
              "line": 134,
              "column": 23
          },
          {
              "line": 136,
              "column": 29
          },
          {
              "line": 137,
              "column": 27
          },
          {
              "line": 177,
              "column": 23
          },
          {
              "line": 179,
              "column": 29
          },
          {
              "line": 180,
              "column": 27
          },
          {
              "line": 220,
              "column": 23
          },
          {
              "line": 222,
              "column": 29
          },
          {
              "line": 223,
              "column": 27
          },
          {
              "line": 285,
              "column": 23
          },
          {
              "line": 287,
              "column": 29
          },
          {
              "line": 288,
              "column": 27
          },
          {
              "line": 333,
              "column": 23
          },
          {
              "line": 335,
              "column": 29
          },
          {
              "line": 336,
              "column": 27
          },
          {
              "line": 380,
              "column": 23
          },
          {
              "line": 382,
              "column": 29
          },
          {
              "line": 383,
              "column": 27
          },
          {
              "line": 426,
              "column": 23
          },
          {
              "line": 428,
              "column": 29
          },
          {
              "line": 429,
              "column": 27
          },
          {
              "line": 526,
              "column": 23
          },
          {
              "line": 528,
              "column": 29
          },
          {
              "line": 529,
              "column": 27
          },
          {
              "line": 636,
              "column": 23
          },
          {
              "line": 638,
              "column": 29
          },
          {
              "line": 639,
              "column": 27
          }
      ],
      "old_name": "config",
      "new_name": "openContext",
      "ctx": {
          "symbolName": "config",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Configuration",
          "scopeHint": "in testInternalIterableAllWindowFunction(...)",
          "filePath": "InternalWindowFunctionTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@SuppressWarnings(\"unchecked\")\n    @Test\n    public void testInternalIterableAllWindowFunction() throws Exception {\n\n        AllWindowFunctionMock mock = mock(AllWindowFunctionMock.class);\n        InternalIterableAllWindowFunction<Long, String, TimeWindow> windowFunction =\n                new InternalIterableAllWindowFunction<>(mock);\n\n        // check setOutputType\n        TypeInformation<String> stringType = BasicTypeInfo.STRING_TYPE_INFO;\n        ExecutionConfig execConf = new ExecutionConfig();\n        execConf.setParallelism(42);\n\n        StreamingFunctionUtils.setOutputType(windowFunction, stringType, execConf);\n        verify(mock).setOutputType(stringType, execConf);\n\n        // check open\n        Configuration config = new Configuration();\n\n        windowFunction.open(config);\n        verify(mock).open(config);\n\n        // check setRuntimeContext\n        RuntimeContext rCtx = mock(RuntimeContext.class);\n\n        windowFunction.setRuntimeContext(rCtx);\n        verify(mock).setRuntimeContext(rCtx);\n\n        // check apply\n        TimeWindow w = mock(TimeWindow.class);\n        Iterable<Long> i = (Iterable<Long>) mock(Iterable.class);\n        Collector<String> c = (Collector<String>) mock(Collector.class);\n\n        InternalWindowFunction.InternalWindowContext ctx =\n                mock(InternalWindowFunction.InternalWindowContext.class);\n\n        windowFunction.process(((byte) 0), w, ctx, i, c);\n        verify(mock).apply(w, i, c);\n\n        // check close\n        windowFunction.close();\n        verify(mock).close();\n    }",
          "conflictNames": [
              "mock",
              "windowFunction",
              "stringType",
              "execConf",
              "rCtx",
              "w",
              "i",
              "c",
              "ctx"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e93b55aaea9b029079a2712ab5bc413ac5cba0ec^1/flink-core/src/test/java/org/apache/flink/api/common/typeutils/CompositeTypeSerializerUtilTest.java",
      "locators": [
          {
              "line": 40,
              "column": 43
          },
          {
              "line": 56,
              "column": 45
          },
          {
              "line": 66,
              "column": 43
          },
          {
              "line": 81,
              "column": 45
          },
          {
              "line": 97,
              "column": 43
          },
          {
              "line": 115,
              "column": 45
          },
          {
              "line": 123,
              "column": 43
          },
          {
              "line": 143,
              "column": 45
          }
      ],
      "old_name": "testSerializerSnapshots",
      "new_name": "previousSerializerSnapshots",
      "ctx": {
          "symbolName": "testSerializerSnapshots",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TypeSerializerSnapshot<?>[]",
          "scopeHint": "in testCompatibleAsIsIntermediateCompatibilityResult(...)",
          "filePath": "CompositeTypeSerializerUtilTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testCompatibleAsIsIntermediateCompatibilityResult() {\n        final TypeSerializerSnapshot<?>[] testSerializerSnapshots =\n                new TypeSerializerSnapshot<?>[] {\n                    SchemaCompatibilityTestingSnapshot.thatIsCompatibleWithNextSerializer(\n                            \"first serializer\"),\n                    SchemaCompatibilityTestingSnapshot.thatIsCompatibleWithNextSerializer(\n                            \"second serializer\"),\n                };\n\n        final TypeSerializer<?>[] testNewSerializers =\n                new TypeSerializer<?>[] {\n                    new SchemaCompatibilityTestingSerializer(\"first serializer\"),\n                    new SchemaCompatibilityTestingSerializer(\"second serializer\"),\n                };\n\n        IntermediateCompatibilityResult<?> intermediateCompatibilityResult =\n                CompositeTypeSerializerUtil.constructIntermediateCompatibilityResult(\n                        testNewSerializers, testSerializerSnapshots);\n\n        assertTrue(intermediateCompatibilityResult.isCompatibleAsIs());\n        assertTrue(intermediateCompatibilityResult.getFinalResult().isCompatibleAsIs());\n        assertArrayEquals(\n                testNewSerializers, intermediateCompatibilityResult.getNestedSerializers());\n    }",
          "conflictNames": [
              "testNewSerializers",
              "intermediateCompatibilityResult"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e93b55aaea9b029079a2712ab5bc413ac5cba0ec^1/flink-core/src/test/java/org/apache/flink/api/common/typeutils/CompositeTypeSerializerUtilTest.java",
      "locators": [
          {
              "line": 48,
              "column": 35
          },
          {
              "line": 56,
              "column": 25
          },
          {
              "line": 61,
              "column": 17
          },
          {
              "line": 73,
              "column": 35
          },
          {
              "line": 81,
              "column": 25
          },
          {
              "line": 106,
              "column": 35
          },
          {
              "line": 115,
              "column": 25
          },
          {
              "line": 133,
              "column": 35
          },
          {
              "line": 143,
              "column": 25
          }
      ],
      "old_name": "testNewSerializers",
      "new_name": "newSerializerSnapshots",
      "ctx": {
          "symbolName": "testNewSerializers",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TypeSerializer<?>[]",
          "scopeHint": "in testCompatibleAsIsIntermediateCompatibilityResult(...)",
          "filePath": "CompositeTypeSerializerUtilTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testCompatibleAsIsIntermediateCompatibilityResult() {\n        final TypeSerializerSnapshot<?>[] testSerializerSnapshots =\n                new TypeSerializerSnapshot<?>[] {\n                    SchemaCompatibilityTestingSnapshot.thatIsCompatibleWithNextSerializer(\n                            \"first serializer\"),\n                    SchemaCompatibilityTestingSnapshot.thatIsCompatibleWithNextSerializer(\n                            \"second serializer\"),\n                };\n\n        final TypeSerializer<?>[] testNewSerializers =\n                new TypeSerializer<?>[] {\n                    new SchemaCompatibilityTestingSerializer(\"first serializer\"),\n                    new SchemaCompatibilityTestingSerializer(\"second serializer\"),\n                };\n\n        IntermediateCompatibilityResult<?> intermediateCompatibilityResult =\n                CompositeTypeSerializerUtil.constructIntermediateCompatibilityResult(\n                        testNewSerializers, testSerializerSnapshots);\n\n        assertTrue(intermediateCompatibilityResult.isCompatibleAsIs());\n        assertTrue(intermediateCompatibilityResult.getFinalResult().isCompatibleAsIs());\n        assertArrayEquals(\n                testNewSerializers, intermediateCompatibilityResult.getNestedSerializers());\n    }",
          "conflictNames": [
              "testSerializerSnapshots",
              "intermediateCompatibilityResult"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e93b55aaea9b029079a2712ab5bc413ac5cba0ec^1/flink-core/src/main/java/org/apache/flink/api/common/typeutils/CompositeTypeSerializerUtil.java",
      "locators": [
          {
              "line": 222,
              "column": 35
          },
          {
              "line": 224,
              "column": 16
          }
      ],
      "old_name": "typedSnapshot",
      "new_name": "typedNewSnapshot",
      "ctx": {
          "symbolName": "typedSnapshot",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TypeSerializerSnapshot<E>",
          "scopeHint": "in resolveCompatibility(...)",
          "filePath": "CompositeTypeSerializerUtil.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@SuppressWarnings(\"unchecked\")\n    private static <E> TypeSerializerSchemaCompatibility<E> resolveCompatibility(\n            TypeSerializer<?> serializer, TypeSerializerSnapshot<?> snapshot) {\n\n        TypeSerializer<E> typedSerializer = (TypeSerializer<E>) serializer;\n        TypeSerializerSnapshot<E> typedSnapshot = (TypeSerializerSnapshot<E>) snapshot;\n\n        return typedSnapshot.resolveSchemaCompatibility(typedSerializer);\n    }",
          "conflictNames": [
              "serializer",
              "snapshot",
              "typedSerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e93b55aaea9b029079a2712ab5bc413ac5cba0ec^1/flink-core/src/main/java/org/apache/flink/api/common/typeutils/CompositeTypeSerializerUtil.java",
      "locators": [
          {
              "line": 221,
              "column": 27
          },
          {
              "line": 224,
              "column": 57
          }
      ],
      "old_name": "typedSerializer",
      "new_name": "typedOldSnapshot",
      "ctx": {
          "symbolName": "typedSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TypeSerializer<E>",
          "scopeHint": "in resolveCompatibility(...)",
          "filePath": "CompositeTypeSerializerUtil.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@SuppressWarnings(\"unchecked\")\n    private static <E> TypeSerializerSchemaCompatibility<E> resolveCompatibility(\n            TypeSerializer<?> serializer, TypeSerializerSnapshot<?> snapshot) {\n\n        TypeSerializer<E> typedSerializer = (TypeSerializer<E>) serializer;\n        TypeSerializerSnapshot<E> typedSnapshot = (TypeSerializerSnapshot<E>) snapshot;\n\n        return typedSnapshot.resolveSchemaCompatibility(typedSerializer);\n    }",
          "conflictNames": [
              "serializer",
              "snapshot",
              "typedSnapshot"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e93b55aaea9b029079a2712ab5bc413ac5cba0ec^1/flink-core/src/main/java/org/apache/flink/api/common/typeutils/CompositeTypeSerializerSnapshot.java",
      "locators": [
          {
              "line": 198,
              "column": 35
          },
          {
              "line": 200,
              "column": 13
          },
          {
              "line": 205,
              "column": 17
          },
          {
              "line": 372,
              "column": 33
          },
          {
              "line": 378,
              "column": 25
          }
      ],
      "old_name": "newNestedSerializers",
      "new_name": "newNestedSerializerSnapshots",
      "ctx": {
          "symbolName": "newNestedSerializers",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TypeSerializer<?>[]",
          "scopeHint": "in internalResolveSchemaCompatibility(...)",
          "filePath": "CompositeTypeSerializerSnapshot.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Internal\n    TypeSerializerSchemaCompatibility<T> internalResolveSchemaCompatibility(\n            TypeSerializer<T> newSerializer, TypeSerializerSnapshot<?>[] snapshots) {\n        if (newSerializer.getClass() != correspondingSerializerClass) {\n            return TypeSerializerSchemaCompatibility.incompatible();\n        }\n\n        S castedNewSerializer = correspondingSerializerClass.cast(newSerializer);\n\n        final OuterSchemaCompatibility outerSchemaCompatibility =\n                resolveOuterSchemaCompatibility(castedNewSerializer);\n\n        final TypeSerializer<?>[] newNestedSerializers = getNestedSerializers(castedNewSerializer);\n        // check that nested serializer arity remains identical; if not, short circuit result\n        if (newNestedSerializers.length != snapshots.length) {\n            return TypeSerializerSchemaCompatibility.incompatible();\n        }\n\n        return constructFinalSchemaCompatibilityResult(\n                newNestedSerializers, snapshots, outerSchemaCompatibility);\n    }",
          "conflictNames": [
              "newSerializer",
              "snapshots",
              "castedNewSerializer",
              "outerSchemaCompatibility"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/e93b55aaea9b029079a2712ab5bc413ac5cba0ec^1/flink-core/src/test/java/org/apache/flink/testutils/migration/SchemaCompatibilityTestingSerializer.java",
      "locators": [
          {
              "line": 271,
              "column": 50
          },
          {
              "line": 274,
              "column": 21
          }
      ],
      "old_name": "schemaCompatibilityTestingSerializer",
      "new_name": "schemaCompatibilityTestingSnapshot",
      "ctx": {
          "symbolName": "schemaCompatibilityTestingSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "SchemaCompatibilityTestingSerializer",
          "scopeHint": "in resolveSchemaCompatibility(...)",
          "filePath": "SchemaCompatibilityTestingSerializer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public TypeSerializerSchemaCompatibility<Integer> resolveSchemaCompatibility(\n                TypeSerializer<Integer> newSerializer) {\n            if (!(newSerializer instanceof SchemaCompatibilityTestingSerializer)) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            }\n            SchemaCompatibilityTestingSerializer schemaCompatibilityTestingSerializer =\n                    (SchemaCompatibilityTestingSerializer) newSerializer;\n            if (!(Objects.equals(\n                    schemaCompatibilityTestingSerializer.tokenForEqualityChecks,\n                    tokenForEqualityChecks))) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            }\n            return resolver.apply(newSerializer);\n        }",
          "conflictNames": [
              "newSerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/eaef742964aa3adb04936b4803acf97f9bafeb21^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java",
      "locators": [
          {
              "line": 477,
              "column": 19
          },
          {
              "line": 478,
              "column": 75
          },
          {
              "line": 488,
              "column": 37
          },
          {
              "line": 488,
              "column": 54
          },
          {
              "line": 488,
              "column": 71
          },
          {
              "line": 646,
              "column": 19
          },
          {
              "line": 647,
              "column": 75
          },
          {
              "line": 657,
              "column": 37
          },
          {
              "line": 657,
              "column": 54
          },
          {
              "line": 657,
              "column": 71
          },
          {
              "line": 735,
              "column": 19
          },
          {
              "line": 736,
              "column": 75
          },
          {
              "line": 746,
              "column": 37
          },
          {
              "line": 746,
              "column": 54
          },
          {
              "line": 746,
              "column": 71
          },
          {
              "line": 915,
              "column": 19
          },
          {
              "line": 916,
              "column": 75
          },
          {
              "line": 1047,
              "column": 19
          },
          {
              "line": 1050,
              "column": 75
          },
          {
              "line": 1062,
              "column": 29
          },
          {
              "line": 1062,
              "column": 46
          },
          {
              "line": 1062,
              "column": 63
          },
          {
              "line": 1113,
              "column": 19
          },
          {
              "line": 1114,
              "column": 75
          },
          {
              "line": 1126,
              "column": 29
          },
          {
              "line": 1126,
              "column": 46
          },
          {
              "line": 1126,
              "column": 63
          },
          {
              "line": 1155,
              "column": 84
          },
          {
              "line": 1156,
              "column": 32
          },
          {
              "line": 1178,
              "column": 19
          },
          {
              "line": 1179,
              "column": 75
          },
          {
              "line": 1190,
              "column": 29
          },
          {
              "line": 1190,
              "column": 46
          },
          {
              "line": 1190,
              "column": 63
          },
          {
              "line": 1215,
              "column": 53
          },
          {
              "line": 1261,
              "column": 19
          },
          {
              "line": 1262,
              "column": 75
          },
          {
              "line": 1272,
              "column": 29
          },
          {
              "line": 1272,
              "column": 46
          },
          {
              "line": 1272,
              "column": 63
          },
          {
              "line": 1277,
              "column": 33
          },
          {
              "line": 1285,
              "column": 49
          }
      ],
      "old_name": "numTotalBuffers",
      "new_name": "numFloatingBuffers",
      "ctx": {
          "symbolName": "numTotalBuffers",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in testAvailableBuffersLessThanRequiredBuffers(...)",
          "filePath": "RemoteInputChannelTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Tests to verify the behaviours of three different processes if the number of available\n     * buffers is less than required buffers.\n     *\n     * <ol>\n     *   <li>Recycle the floating buffer\n     *   <li>Recycle the exclusive buffer\n     *   <li>Decrease the sender's backlog\n     * </ol>\n     */\n    @Test\n    void testAvailableBuffersLessThanRequiredBuffers() throws Exception {\n        // Setup\n        final int numTotalBuffers = 16;\n        final NetworkBufferPool networkBufferPool = new NetworkBufferPool(numTotalBuffers, 32);\n\n        final SingleInputGate inputGate = createSingleInputGate(1, networkBufferPool);\n        final RemoteInputChannel inputChannel = createRemoteInputChannel(inputGate);\n        inputGate.setInputChannels(inputChannel);\n        Throwable thrown = null;\n        try {\n            final BufferPool bufferPool =\n                    spy(\n                            networkBufferPool.createBufferPool(\n                                    numTotalBuffers, numTotalBuffers, numTotalBuffers));\n            inputGate.setBufferPool(bufferPool);\n            inputGate.setupChannels();\n            inputChannel.requestSubpartitions();\n\n            // Prepare the exclusive and floating buffers to verify recycle logic later\n            final Buffer exclusiveBuffer = inputChannel.requestBuffer();\n            assertThat(exclusiveBuffer).isNotNull();\n\n            final int numRecycleFloatingBuffers = 2;\n            final ArrayDeque<Buffer> floatingBufferQueue =\n                    new ArrayDeque<>(numRecycleFloatingBuffers);\n            for (int i = 0; i < numRecycleFloatingBuffers; i++) {\n                Buffer floatingBuffer = bufferPool.requestBuffer();\n                assertThat(floatingBuffer).isNotNull();\n                floatingBufferQueue.add(floatingBuffer);\n            }\n\n            verify(bufferPool, times(numRecycleFloatingBuffers)).requestBuffer();\n\n            // Receive the producer's backlog more than the number of available floating buffers\n            inputChannel.onSenderBacklog(14);\n\n            // The channel requests (backlog + numExclusiveBuffers) floating buffers from local\n            // pool.\n            // It does not get enough floating buffers and register as buffer listener\n            verify(bufferPool, times(15)).requestBuffer();\n            verify(bufferPool, times(1)).addBufferListener(inputChannel.getBufferManager());\n            assertThat(inputChannel.getNumberOfAvailableBuffers())\n                    .withFailMessage(\"There should be 13 buffers available in the channel\")\n                    .isEqualTo(13);\n            assertThat(inputChannel.getNumberOfRequiredBuffers())\n                    .withFailMessage(\"There should be 16 buffers required in the channel\")\n                    .isEqualTo(16);\n            assertThat(bufferPool.getNumberOfAvailableMemorySegments())\n                    .withFailMessage(\"There should be 0 buffers available in local pool\")\n                    .isZero();\n            assertThat(inputChannel.isWaitingForFloatingBuffers()).isTrue();\n\n            // Increase the backlog\n            inputChannel.onSenderBacklog(16);\n\n            // The channel is already in the status of waiting for buffers and will not request any\n            // more\n            verify(bufferPool, times(15)).requestBuffer();\n            verify(bufferPool, times(1)).addBufferListener(inputChannel.getBufferManager());\n            assertThat(inputChannel.getNumberOfAvailableBuffers())\n                    .withFailMessage(\"There should be 13 buffers available in the channel\")\n                    .isEqualTo(13);\n            assertThat(inputChannel.getNumberOfRequiredBuffers())\n                    .withFailMessage(\"There should be 18 buffers required in the channel\")\n                    .isEqualTo(18);\n            assertThat(bufferPool.getNumberOfAvailableMemorySegments())\n                    .withFailMessage(\"There should be 0 buffers available in local pool\")\n                    .isZero();\n            assertThat(inputChannel.isWaitingForFloatingBuffers()).isTrue();\n\n            // Recycle one exclusive buffer\n            exclusiveBuffer.recycleBuffer();\n\n            // The exclusive buffer is returned to the channel directly\n            verify(bufferPool, times(15)).requestBuffer();\n            verify(bufferPool, times(1)).addBufferListener(inputChannel.getBufferManager());\n            assertThat(inputChannel.getNumberOfAvailableBuffers())\n                    .withFailMessage(\"There should be 14 buffers available in the channel\")\n                    .isEqualTo(14);\n            assertThat(inputChannel.getNumberOfRequiredBuffers())\n                    .withFailMessage(\"There should be 18 buffers required in the channel\")\n                    .isEqualTo(18);\n            assertThat(bufferPool.getNumberOfAvailableMemorySegments())\n                    .withFailMessage(\"There should be 0 buffers available in local pool\")\n                    .isZero();\n            assertThat(inputChannel.isWaitingForFloatingBuffers()).isTrue();\n\n            // Recycle one floating buffer\n            floatingBufferQueue.poll().recycleBuffer();\n\n            // Assign the floating buffer to the listener and the channel is still waiting for more\n            // floating buffers\n            verify(bufferPool, times(16)).requestBuffer();\n            verify(bufferPool, times(2)).addBufferListener(inputChannel.getBufferManager());\n            assertThat(inputChannel.getNumberOfAvailableBuffers())\n                    .withFailMessage(\"There should be 15 buffers available in the channel\")\n                    .isEqualTo(15);\n            assertThat(inputChannel.getNumberOfRequiredBuffers())\n                    .withFailMessage(\"There should be 18 buffers required in the channel\")\n                    .isEqualTo(18);\n            assertThat(bufferPool.getNumberOfAvailableMemorySegments())\n                    .withFailMessage(\"There should be 0 buffers available in local pool\")\n                    .isZero();\n            assertThat(inputChannel.isWaitingForFloatingBuffers()).isTrue();\n\n            // Decrease the backlog\n            inputChannel.onSenderBacklog(13);\n\n            // Only the number of required buffers is changed by (backlog + numExclusiveBuffers)\n            verify(bufferPool, times(16)).requestBuffer();\n            verify(bufferPool, times(2)).addBufferListener(inputChannel.getBufferManager());\n            assertThat(inputChannel.getNumberOfAvailableBuffers())\n                    .withFailMessage(\"There should be 15 buffers available in the channel\")\n                    .isEqualTo(15);\n            assertThat(inputChannel.getNumberOfRequiredBuffers())\n                    .withFailMessage(\"There should be 15 buffers required in the channel\")\n                    .isEqualTo(15);\n            assertThat(bufferPool.getNumberOfAvailableMemorySegments())\n                    .withFailMessage(\"There should be 0 buffers available in local pool\")\n                    .isZero();\n            assertThat(inputChannel.isWaitingForFloatingBuffers()).isTrue();\n\n            // Recycle one more floating buffer\n            floatingBufferQueue.poll().recycleBuffer();\n\n            // Return the floating buffer to the buffer pool and the channel is not waiting for more\n            // floating buffers\n            verify(bufferPool, times(16)).requestBuffer();\n            verify(bufferPool, times(2)).addBufferListener(inputChannel.getBufferManager());\n            assertThat(inputChannel.getNumberOfAvailableBuffers())\n                    .withFailMessage(\"There should be 15 buffers available in the channel\")\n                    .isEqualTo(15);\n            assertThat(inputChannel.getNumberOfRequiredBuffers())\n                    .withFailMessage(\"There should be 15 buffers required in the channel\")\n                    .isEqualTo(15);\n            assertThat(bufferPool.getNumberOfAvailableMemorySegments())\n                    .withFailMessage(\"There should be 1 buffers available in local pool\")\n                    .isOne();\n            assertThat(inputChannel.isWaitingForFloatingBuffers()).isFalse();\n\n            // Increase the backlog again\n            inputChannel.onSenderBacklog(15);\n\n            // The floating buffer is requested from the buffer pool and the channel is registered\n            // as listener again.\n            verify(bufferPool, times(18)).requestBuffer();\n            verify(bufferPool, times(3)).addBufferListener(inputChannel.getBufferManager());\n            assertThat(inputChannel.getNumberOfAvailableBuffers())\n                    .withFailMessage(\"There should be 16 buffers available in the channel\")\n                    .isEqualTo(16);\n            assertThat(inputChannel.getNumberOfRequiredBuffers())\n                    .withFailMessage(\"There should be 17 buffers required in the channel\")\n                    .isEqualTo(17);\n            assertThat(bufferPool.getNumberOfAvailableMemorySegments())\n                    .withFailMessage(\"There should be 0 buffers available in local pool\")\n                    .isZero();\n            assertThat(inputChannel.isWaitingForFloatingBuffers()).isTrue();\n        } catch (Throwable t) {\n            thrown = t;\n        } finally {\n            cleanup(networkBufferPool, null, null, thrown, inputChannel);\n        }\n    }",
          "conflictNames": [
              "networkBufferPool",
              "inputGate",
              "inputChannel",
              "thrown",
              "bufferPool",
              "exclusiveBuffer",
              "numRecycleFloatingBuffers",
              "floatingBufferQueue",
              "i",
              "floatingBuffer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/eaef742964aa3adb04936b4803acf97f9bafeb21^1/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java",
      "locators": [
          {
              "line": 1293,
              "column": 13
          },
          {
              "line": 1295,
              "column": 13
          },
          {
              "line": 1297,
              "column": 13
          },
          {
              "line": 1300,
              "column": 28
          }
      ],
      "old_name": "expectedBuffersPerGate",
      "new_name": "minBuffersPerGate",
      "ctx": {
          "symbolName": "expectedBuffersPerGate",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in verifyBuffersInBufferPool(...)",
          "filePath": "SingleInputGateTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void verifyBuffersInBufferPool(boolean isPipeline, int subpartitionRandSize)\n            throws Exception {\n        IntermediateResultPartitionID[] partitionIds =\n                new IntermediateResultPartitionID[] {\n                    new IntermediateResultPartitionID(),\n                    new IntermediateResultPartitionID(),\n                    new IntermediateResultPartitionID()\n                };\n\n        IndexRange subpartitionIndexRange = new IndexRange(0, subpartitionRandSize - 1);\n        NettyShuffleEnvironmentBuilder nettyShuffleEnvironmentBuilder =\n                new NettyShuffleEnvironmentBuilder();\n        Optional<Integer> expectMaxRequiredBuffersPerGate =\n                isPipeline\n                        ? Optional.of(\n                                InputGateSpecUtils.DEFAULT_MAX_REQUIRED_BUFFERS_PER_GATE_FOR_STREAM)\n                        : Optional.of(\n                                InputGateSpecUtils.DEFAULT_MAX_REQUIRED_BUFFERS_PER_GATE_FOR_BATCH);\n        nettyShuffleEnvironmentBuilder.setMaxRequiredBuffersPerGate(\n                expectMaxRequiredBuffersPerGate);\n        NettyShuffleEnvironment netEnv = nettyShuffleEnvironmentBuilder.build();\n\n        SingleInputGate gate =\n                createSingleInputGate(\n                        partitionIds,\n                        isPipeline ? ResultPartitionType.PIPELINED : ResultPartitionType.BLOCKING,\n                        subpartitionIndexRange,\n                        netEnv,\n                        ResourceID.generate(),\n                        new TestingConnectionManager(),\n                        new TestingResultPartitionManager(new NoOpResultSubpartitionView()));\n        gate.setup();\n\n        for (InputChannel inputChannel : gate.inputChannels()) {\n            if (inputChannel instanceof RemoteInputChannel) {\n                assertThat(((RemoteInputChannel) inputChannel).getNumExclusiveBuffers())\n                        .isEqualTo(0);\n            }\n        }\n\n        int numNonLocalInputChannels =\n                gate.getNumberOfInputChannels()\n                        - gate.unsynchronizedGetNumberOfLocalInputChannels();\n        int maxBuffersPerGate = 2 * numNonLocalInputChannels + 8;\n        int expectedBuffersPerGate;\n        if (maxBuffersPerGate >= expectMaxRequiredBuffersPerGate.get()) {\n            expectedBuffersPerGate = expectMaxRequiredBuffersPerGate.get();\n        } else {\n            expectedBuffersPerGate = 2 * numNonLocalInputChannels + 1;\n        }\n        assertThat(gate.getBufferPool().getExpectedNumberOfMemorySegments())\n                .isEqualTo(expectedBuffersPerGate);\n        assertThat(gate.getBufferPool().getMaxNumberOfMemorySegments())\n                .isEqualTo(maxBuffersPerGate);\n    }",
          "conflictNames": [
              "isPipeline",
              "subpartitionRandSize",
              "partitionIds",
              "subpartitionIndexRange",
              "nettyShuffleEnvironmentBuilder",
              "expectMaxRequiredBuffersPerGate",
              "netEnv",
              "gate",
              "numNonLocalInputChannels",
              "maxBuffersPerGate"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/eb046b662fe22fada64874681c28dbb139f617fa^1/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DefaultResourceAllocationStrategy.java",
      "locators": [
          {
              "line": 182,
              "column": 17
          },
          {
              "line": 189,
              "column": 13
          },
          {
              "line": 198,
              "column": 17
          },
          {
              "line": 200,
              "column": 17
          },
          {
              "line": 207,
              "column": 17
          },
          {
              "line": 209,
              "column": 17
          },
          {
              "line": 216,
              "column": 14
          }
      ],
      "old_name": "redundantFulfilled",
      "new_name": "resourceFulfilled",
      "ctx": {
          "symbolName": "redundantFulfilled",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "boolean",
          "scopeHint": "in tryReconcileClusterResources(...)",
          "filePath": "DefaultResourceAllocationStrategy.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public ResourceReconcileResult tryReconcileClusterResources(\n            TaskManagerResourceInfoProvider taskManagerResourceInfoProvider) {\n        ResourceProfile requiredRedundantResources =\n                totalResourceProfile.multiply(redundantTaskManagerNum);\n        ResourceReconcileResult.Builder builder = ResourceReconcileResult.builder();\n\n        List<TaskManagerInfo> taskManagersIdleTimeout = new ArrayList<>();\n        List<TaskManagerInfo> taskManagersNonTimeout = new ArrayList<>();\n        long currentTime = System.currentTimeMillis();\n        taskManagerResourceInfoProvider\n                .getRegisteredTaskManagers()\n                .forEach(\n                        taskManagerInfo -> {\n                            if (taskManagerInfo.isIdle()\n                                    && currentTime - taskManagerInfo.getIdleSince()\n                                            >= taskManagerTimeout.toMilliseconds()) {\n                                taskManagersIdleTimeout.add(taskManagerInfo);\n                            } else {\n                                taskManagersNonTimeout.add(taskManagerInfo);\n                            }\n                        });\n\n        List<PendingTaskManager> pendingTaskManagersNonUse = new ArrayList<>();\n        List<PendingTaskManager> pendingTaskManagersInuse = new ArrayList<>();\n        taskManagerResourceInfoProvider\n                .getPendingTaskManagers()\n                .forEach(\n                        pendingTaskManager -> {\n                            if (pendingTaskManager.getPendingSlotAllocationRecords().isEmpty()) {\n                                pendingTaskManagersNonUse.add(pendingTaskManager);\n                            } else {\n                                pendingTaskManagersInuse.add(pendingTaskManager);\n                            }\n                        });\n\n        if (taskManagersIdleTimeout.isEmpty() && pendingTaskManagersNonUse.isEmpty()) {\n            // short-cut for nothing to release\n            return builder.build();\n        }\n\n        ResourceProfile resourcesToKeep = ResourceProfile.ZERO;\n        boolean redundantFulfilled = false;\n\n        // check whether available resources of used (pending) task manager is enough.\n        ResourceProfile availableResourcesOfNonIdle =\n                getAvailableResourceOfTaskManagers(taskManagersNonTimeout);\n        resourcesToKeep = resourcesToKeep.merge(availableResourcesOfNonIdle);\n        if (canFulfillRequirement(requiredRedundantResources, resourcesToKeep)) {\n            redundantFulfilled = true;\n        } else {\n            ResourceProfile availableResourcesOfNonIdlePendingTaskManager =\n                    getAvailableResourceOfPendingTaskManagers(pendingTaskManagersInuse);\n            resourcesToKeep = resourcesToKeep.merge(availableResourcesOfNonIdlePendingTaskManager);\n        }\n\n        // try reserve or release unused (pending) task managers\n        for (TaskManagerInfo taskManagerInfo : taskManagersIdleTimeout) {\n            if (redundantFulfilled\n                    || canFulfillRequirement(requiredRedundantResources, resourcesToKeep)) {\n                redundantFulfilled = true;\n                builder.addTaskManagerToRelease(taskManagerInfo);\n            } else {\n                resourcesToKeep = resourcesToKeep.merge(taskManagerInfo.getAvailableResource());\n            }\n        }\n        for (PendingTaskManager pendingTaskManager : pendingTaskManagersNonUse) {\n            if (redundantFulfilled\n                    || canFulfillRequirement(requiredRedundantResources, resourcesToKeep)) {\n                redundantFulfilled = true;\n                builder.addPendingTaskManagerToRelease(pendingTaskManager);\n            } else {\n                resourcesToKeep = resourcesToKeep.merge(pendingTaskManager.getUnusedResource());\n            }\n        }\n\n        if (!redundantFulfilled) {\n            // fulfill redundant resources\n            tryFulFillRedundantResourcesWithAction(\n                    requiredRedundantResources,\n                    resourcesToKeep,\n                    builder::addPendingTaskManagerToAllocate);\n        }\n\n        return builder.build();\n    }",
          "conflictNames": [
              "taskManagerResourceInfoProvider",
              "requiredRedundantResources",
              "builder",
              "taskManagersIdleTimeout",
              "taskManagersNonTimeout",
              "currentTime",
              "pendingTaskManagersNonUse",
              "pendingTaskManagersInuse",
              "resourcesToKeep",
              "availableResourcesOfNonIdle",
              "availableResourcesOfNonIdlePendingTaskManager"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/eb046b662fe22fada64874681c28dbb139f617fa^1/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DefaultResourceAllocationStrategy.java",
      "locators": [
          {
              "line": 185,
              "column": 25
          },
          {
              "line": 187,
              "column": 49
          },
          {
              "line": 191,
              "column": 29
          },
          {
              "line": 193,
              "column": 53
          }
      ],
      "old_name": "availableResourcesOfNonIdle",
      "new_name": "resourcesAvailableOfNonIdle",
      "ctx": {
          "symbolName": "availableResourcesOfNonIdle",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ResourceProfile",
          "scopeHint": "in tryReconcileClusterResources(...)",
          "filePath": "DefaultResourceAllocationStrategy.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public ResourceReconcileResult tryReconcileClusterResources(\n            TaskManagerResourceInfoProvider taskManagerResourceInfoProvider) {\n        ResourceProfile requiredRedundantResources =\n                totalResourceProfile.multiply(redundantTaskManagerNum);\n        ResourceReconcileResult.Builder builder = ResourceReconcileResult.builder();\n\n        List<TaskManagerInfo> taskManagersIdleTimeout = new ArrayList<>();\n        List<TaskManagerInfo> taskManagersNonTimeout = new ArrayList<>();\n        long currentTime = System.currentTimeMillis();\n        taskManagerResourceInfoProvider\n                .getRegisteredTaskManagers()\n                .forEach(\n                        taskManagerInfo -> {\n                            if (taskManagerInfo.isIdle()\n                                    && currentTime - taskManagerInfo.getIdleSince()\n                                            >= taskManagerTimeout.toMilliseconds()) {\n                                taskManagersIdleTimeout.add(taskManagerInfo);\n                            } else {\n                                taskManagersNonTimeout.add(taskManagerInfo);\n                            }\n                        });\n\n        List<PendingTaskManager> pendingTaskManagersNonUse = new ArrayList<>();\n        List<PendingTaskManager> pendingTaskManagersInuse = new ArrayList<>();\n        taskManagerResourceInfoProvider\n                .getPendingTaskManagers()\n                .forEach(\n                        pendingTaskManager -> {\n                            if (pendingTaskManager.getPendingSlotAllocationRecords().isEmpty()) {\n                                pendingTaskManagersNonUse.add(pendingTaskManager);\n                            } else {\n                                pendingTaskManagersInuse.add(pendingTaskManager);\n                            }\n                        });\n\n        if (taskManagersIdleTimeout.isEmpty() && pendingTaskManagersNonUse.isEmpty()) {\n            // short-cut for nothing to release\n            return builder.build();\n        }\n\n        ResourceProfile resourcesToKeep = ResourceProfile.ZERO;\n        boolean redundantFulfilled = false;\n\n        // check whether available resources of used (pending) task manager is enough.\n        ResourceProfile availableResourcesOfNonIdle =\n                getAvailableResourceOfTaskManagers(taskManagersNonTimeout);\n        resourcesToKeep = resourcesToKeep.merge(availableResourcesOfNonIdle);\n        if (canFulfillRequirement(requiredRedundantResources, resourcesToKeep)) {\n            redundantFulfilled = true;\n        } else {\n            ResourceProfile availableResourcesOfNonIdlePendingTaskManager =\n                    getAvailableResourceOfPendingTaskManagers(pendingTaskManagersInuse);\n            resourcesToKeep = resourcesToKeep.merge(availableResourcesOfNonIdlePendingTaskManager);\n        }\n\n        // try reserve or release unused (pending) task managers\n        for (TaskManagerInfo taskManagerInfo : taskManagersIdleTimeout) {\n            if (redundantFulfilled\n                    || canFulfillRequirement(requiredRedundantResources, resourcesToKeep)) {\n                redundantFulfilled = true;\n                builder.addTaskManagerToRelease(taskManagerInfo);\n            } else {\n                resourcesToKeep = resourcesToKeep.merge(taskManagerInfo.getAvailableResource());\n            }\n        }\n        for (PendingTaskManager pendingTaskManager : pendingTaskManagersNonUse) {\n            if (redundantFulfilled\n                    || canFulfillRequirement(requiredRedundantResources, resourcesToKeep)) {\n                redundantFulfilled = true;\n                builder.addPendingTaskManagerToRelease(pendingTaskManager);\n            } else {\n                resourcesToKeep = resourcesToKeep.merge(pendingTaskManager.getUnusedResource());\n            }\n        }\n\n        if (!redundantFulfilled) {\n            // fulfill redundant resources\n            tryFulFillRedundantResourcesWithAction(\n                    requiredRedundantResources,\n                    resourcesToKeep,\n                    builder::addPendingTaskManagerToAllocate);\n        }\n\n        return builder.build();\n    }",
          "conflictNames": [
              "taskManagerResourceInfoProvider",
              "requiredRedundantResources",
              "builder",
              "taskManagersIdleTimeout",
              "taskManagersNonTimeout",
              "currentTime",
              "pendingTaskManagersNonUse",
              "pendingTaskManagersInuse",
              "resourcesToKeep",
              "redundantFulfilled",
              "availableResourcesOfNonIdlePendingTaskManager"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/eb046b662fe22fada64874681c28dbb139f617fa^1/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DefaultResourceAllocationStrategy.java",
      "locators": [
          {
              "line": 191,
              "column": 29
          },
          {
              "line": 193,
              "column": 53
          }
      ],
      "old_name": "availableResourcesOfNonIdlePendingTaskManager",
      "new_name": "resourcesAvailableOfNonIdlePendingTaskManager",
      "ctx": {
          "symbolName": "availableResourcesOfNonIdlePendingTaskManager",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ResourceProfile",
          "scopeHint": "in tryReconcileClusterResources(...)",
          "filePath": "DefaultResourceAllocationStrategy.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public ResourceReconcileResult tryReconcileClusterResources(\n            TaskManagerResourceInfoProvider taskManagerResourceInfoProvider) {\n        ResourceProfile requiredRedundantResources =\n                totalResourceProfile.multiply(redundantTaskManagerNum);\n        ResourceReconcileResult.Builder builder = ResourceReconcileResult.builder();\n\n        List<TaskManagerInfo> taskManagersIdleTimeout = new ArrayList<>();\n        List<TaskManagerInfo> taskManagersNonTimeout = new ArrayList<>();\n        long currentTime = System.currentTimeMillis();\n        taskManagerResourceInfoProvider\n                .getRegisteredTaskManagers()\n                .forEach(\n                        taskManagerInfo -> {\n                            if (taskManagerInfo.isIdle()\n                                    && currentTime - taskManagerInfo.getIdleSince()\n                                            >= taskManagerTimeout.toMilliseconds()) {\n                                taskManagersIdleTimeout.add(taskManagerInfo);\n                            } else {\n                                taskManagersNonTimeout.add(taskManagerInfo);\n                            }\n                        });\n\n        List<PendingTaskManager> pendingTaskManagersNonUse = new ArrayList<>();\n        List<PendingTaskManager> pendingTaskManagersInuse = new ArrayList<>();\n        taskManagerResourceInfoProvider\n                .getPendingTaskManagers()\n                .forEach(\n                        pendingTaskManager -> {\n                            if (pendingTaskManager.getPendingSlotAllocationRecords().isEmpty()) {\n                                pendingTaskManagersNonUse.add(pendingTaskManager);\n                            } else {\n                                pendingTaskManagersInuse.add(pendingTaskManager);\n                            }\n                        });\n\n        if (taskManagersIdleTimeout.isEmpty() && pendingTaskManagersNonUse.isEmpty()) {\n            // short-cut for nothing to release\n            return builder.build();\n        }\n\n        ResourceProfile resourcesToKeep = ResourceProfile.ZERO;\n        boolean redundantFulfilled = false;\n\n        // check whether available resources of used (pending) task manager is enough.\n        ResourceProfile availableResourcesOfNonIdle =\n                getAvailableResourceOfTaskManagers(taskManagersNonTimeout);\n        resourcesToKeep = resourcesToKeep.merge(availableResourcesOfNonIdle);\n        if (canFulfillRequirement(requiredRedundantResources, resourcesToKeep)) {\n            redundantFulfilled = true;\n        } else {\n            ResourceProfile availableResourcesOfNonIdlePendingTaskManager =\n                    getAvailableResourceOfPendingTaskManagers(pendingTaskManagersInuse);\n            resourcesToKeep = resourcesToKeep.merge(availableResourcesOfNonIdlePendingTaskManager);\n        }\n\n        // try reserve or release unused (pending) task managers\n        for (TaskManagerInfo taskManagerInfo : taskManagersIdleTimeout) {\n            if (redundantFulfilled\n                    || canFulfillRequirement(requiredRedundantResources, resourcesToKeep)) {\n                redundantFulfilled = true;\n                builder.addTaskManagerToRelease(taskManagerInfo);\n            } else {\n                resourcesToKeep = resourcesToKeep.merge(taskManagerInfo.getAvailableResource());\n            }\n        }\n        for (PendingTaskManager pendingTaskManager : pendingTaskManagersNonUse) {\n            if (redundantFulfilled\n                    || canFulfillRequirement(requiredRedundantResources, resourcesToKeep)) {\n                redundantFulfilled = true;\n                builder.addPendingTaskManagerToRelease(pendingTaskManager);\n            } else {\n                resourcesToKeep = resourcesToKeep.merge(pendingTaskManager.getUnusedResource());\n            }\n        }\n\n        if (!redundantFulfilled) {\n            // fulfill redundant resources\n            tryFulFillRedundantResourcesWithAction(\n                    requiredRedundantResources,\n                    resourcesToKeep,\n                    builder::addPendingTaskManagerToAllocate);\n        }\n\n        return builder.build();\n    }",
          "conflictNames": [
              "taskManagerResourceInfoProvider",
              "requiredRedundantResources",
              "builder",
              "taskManagersIdleTimeout",
              "taskManagersNonTimeout",
              "currentTime",
              "pendingTaskManagersNonUse",
              "pendingTaskManagersInuse",
              "resourcesToKeep",
              "redundantFulfilled",
              "availableResourcesOfNonIdle"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/eb8af0c589ce46b091f403e848c7dc84b7e3ee8b^1/flink-runtime/src/test/java/org/apache/flink/runtime/state/CheckpointStorageLoaderTest.java",
      "locators": [
          {
              "line": 22,
              "column": 25
          },
          {
              "line": 23,
              "column": 25
          },
          {
              "line": 24,
              "column": 25
          },
          {
              "line": 25,
              "column": 25
          },
          {
              "line": 26,
              "column": 25
          },
          {
              "line": 27,
              "column": 25
          },
          {
              "line": 49,
              "column": 73
          },
          {
              "line": 69,
              "column": 27
          },
          {
              "line": 72,
              "column": 20
          },
          {
              "line": 82,
              "column": 27
          },
          {
              "line": 85,
              "column": 20
          },
          {
              "line": 92,
              "column": 29
          },
          {
              "line": 94,
              "column": 9
          },
          {
              "line": 96,
              "column": 84
          },
          {
              "line": 109,
              "column": 23
          },
          {
              "line": 110,
              "column": 9
          },
          {
              "line": 112,
              "column": 84
          },
          {
              "line": 119,
              "column": 29
          },
          {
              "line": 121,
              "column": 9
          },
          {
              "line": 125,
              "column": 79
          },
          {
              "line": 129,
              "column": 9
          },
          {
              "line": 133,
              "column": 79
          },
          {
              "line": 137,
              "column": 9
          },
          {
              "line": 141,
              "column": 79
          },
          {
              "line": 149,
              "column": 77
          },
          {
              "line": 152,
              "column": 15
          },
          {
              "line": 154,
              "column": 29
          },
          {
              "line": 156,
              "column": 29
          },
          {
              "line": 157,
              "column": 9
          },
          {
              "line": 159,
              "column": 72
          },
          {
              "line": 165,
              "column": 16
          },
          {
              "line": 172,
              "column": 15
          },
          {
              "line": 174,
              "column": 29
          },
          {
              "line": 176,
              "column": 29
          },
          {
              "line": 177,
              "column": 9
          },
          {
              "line": 178,
              "column": 9
          },
          {
              "line": 180,
              "column": 73
          },
          {
              "line": 190,
              "column": 36
          },
          {
              "line": 199,
              "column": 29
          },
          {
              "line": 200,
              "column": 9
          },
          {
              "line": 203,
              "column": 9
          },
          {
              "line": 210,
              "column": 25
          },
          {
              "line": 222,
              "column": 64
          },
          {
              "line": 228,
              "column": 29
          },
          {
              "line": 229,
              "column": 9
          },
          {
              "line": 236,
              "column": 25
          },
          {
              "line": 251,
              "column": 16
          },
          {
              "line": 262,
              "column": 15
          },
          {
              "line": 264,
              "column": 29
          },
          {
              "line": 265,
              "column": 29
          },
          {
              "line": 266,
              "column": 9
          },
          {
              "line": 267,
              "column": 9
          },
          {
              "line": 268,
              "column": 9
          },
          {
              "line": 269,
              "column": 9
          },
          {
              "line": 270,
              "column": 9
          },
          {
              "line": 272,
              "column": 73
          },
          {
              "line": 287,
              "column": 36
          },
          {
              "line": 288,
              "column": 24
          },
          {
              "line": 304,
              "column": 29
          },
          {
              "line": 305,
              "column": 9
          },
          {
              "line": 308,
              "column": 9
          },
          {
              "line": 311,
              "column": 9
          },
          {
              "line": 312,
              "column": 9
          },
          {
              "line": 315,
              "column": 9
          },
          {
              "line": 320,
              "column": 66
          },
          {
              "line": 335,
              "column": 56
          },
          {
              "line": 336,
              "column": 12
          },
          {
              "line": 362,
              "column": 29
          },
          {
              "line": 363,
              "column": 9
          },
          {
              "line": 364,
              "column": 9
          },
          {
              "line": 365,
              "column": 9
          },
          {
              "line": 367,
              "column": 29
          },
          {
              "line": 368,
              "column": 9
          },
          {
              "line": 369,
              "column": 9
          },
          {
              "line": 370,
              "column": 9
          },
          {
              "line": 371,
              "column": 9
          },
          {
              "line": 374,
              "column": 13
          },
          {
              "line": 376,
              "column": 13
          },
          {
              "line": 384,
              "column": 66
          },
          {
              "line": 387,
              "column": 63
          },
          {
              "line": 467,
              "column": 60
          },
          {
              "line": 476,
              "column": 66
          }
      ],
      "old_name": "config",
      "new_name": "jobConfig",
      "ctx": {
          "symbolName": "config",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Configuration",
          "scopeHint": "in testLoadingFromFactory(...)",
          "filePath": "CheckpointStorageLoaderTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testLoadingFromFactory() throws Exception {\n        final Configuration config = new Configuration();\n\n        config.set(CheckpointingOptions.CHECKPOINT_STORAGE, WorkingFactory.class.getName());\n        CheckpointStorage storage =\n                CheckpointStorageLoader.load(null, null, new ModernStateBackend(), config, cl, LOG);\n        assertThat(storage).isInstanceOf(MockStorage.class);\n    }",
          "conflictNames": [
              "storage"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/eb8af0c589ce46b091f403e848c7dc84b7e3ee8b^1/flink-runtime/src/test/java/org/apache/flink/runtime/state/CheckpointStorageLoaderTest.java",
      "locators": [
          {
              "line": 30,
              "column": 39
          },
          {
              "line": 31,
              "column": 39
          },
          {
              "line": 49,
              "column": 41
          },
          {
              "line": 67,
              "column": 27
          },
          {
              "line": 70,
              "column": 46
          },
          {
              "line": 80,
              "column": 27
          },
          {
              "line": 83,
              "column": 46
          },
          {
              "line": 87,
              "column": 28
          },
          {
              "line": 95,
              "column": 27
          },
          {
              "line": 97,
              "column": 20
          },
          {
              "line": 102,
              "column": 27
          },
          {
              "line": 106,
              "column": 20
          },
          {
              "line": 111,
              "column": 27
          },
          {
              "line": 114,
              "column": 20
          },
          {
              "line": 149,
              "column": 52
          },
          {
              "line": 159,
              "column": 27
          },
          {
              "line": 160,
              "column": 20
          },
          {
              "line": 164,
              "column": 51
          },
          {
              "line": 180,
              "column": 27
          },
          {
              "line": 182,
              "column": 20
          },
          {
              "line": 184,
              "column": 51
          },
          {
              "line": 189,
              "column": 72
          },
          {
              "line": 205,
              "column": 27
          },
          {
              "line": 214,
              "column": 20
          },
          {
              "line": 215,
              "column": 79
          },
          {
              "line": 231,
              "column": 27
          },
          {
              "line": 240,
              "column": 20
          },
          {
              "line": 241,
              "column": 79
          },
          {
              "line": 250,
              "column": 51
          },
          {
              "line": 272,
              "column": 27
          },
          {
              "line": 274,
              "column": 20
          },
          {
              "line": 276,
              "column": 73
          },
          {
              "line": 301,
              "column": 43
          },
          {
              "line": 320,
              "column": 25
          },
          {
              "line": 380,
              "column": 43
          },
          {
              "line": 384,
              "column": 25
          },
          {
              "line": 409,
              "column": 56
          }
      ],
      "old_name": "storage",
      "new_name": "storage1",
      "ctx": {
          "symbolName": "storage",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CheckpointStorage",
          "scopeHint": "in testLegacyStateBackendTakesPrecedence(...)",
          "filePath": "CheckpointStorageLoaderTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testLegacyStateBackendTakesPrecedence() throws Exception {\n        StateBackend legacy = new LegacyStateBackend();\n        CheckpointStorage storage = new MockStorage();\n\n        CheckpointStorage configured =\n                CheckpointStorageLoader.load(storage, null, legacy, new Configuration(), cl, LOG);\n\n        assertThat(configured)\n                .withFailMessage(\"Legacy state backends should always take precedence\")\n                .isEqualTo(legacy);\n    }",
          "conflictNames": [
              "legacy",
              "configured"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/eb8af0c589ce46b091f403e848c7dc84b7e3ee8b^1/flink-runtime/src/test/java/org/apache/flink/runtime/state/CheckpointStorageLoaderTest.java",
      "locators": [
          {
              "line": 108,
              "column": 22
          },
          {
              "line": 110,
              "column": 64
          },
          {
              "line": 255,
              "column": 22
          },
          {
              "line": 257,
              "column": 55
          },
          {
              "line": 267,
              "column": 65
          },
          {
              "line": 293,
              "column": 22
          },
          {
              "line": 310,
              "column": 17
          }
      ],
      "old_name": "checkpointDir",
      "new_name": "checkpointDir1",
      "ctx": {
          "symbolName": "checkpointDir",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in testDefaultCheckpointStorage(...)",
          "filePath": "CheckpointStorageLoaderTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testDefaultCheckpointStorage() throws Exception {\n        CheckpointStorage storage1 =\n                CheckpointStorageLoader.load(\n                        null, null, new ModernStateBackend(), new Configuration(), cl, LOG);\n\n        assertThat(storage1).isInstanceOf(JobManagerCheckpointStorage.class);\n\n        final String checkpointDir = new Path(TempDirUtils.newFolder(tmp).toURI()).toString();\n        Configuration config = new Configuration();\n        config.set(CheckpointingOptions.CHECKPOINTS_DIRECTORY, checkpointDir);\n        CheckpointStorage storage2 =\n                CheckpointStorageLoader.load(null, null, new ModernStateBackend(), config, cl, LOG);\n\n        assertThat(storage2).isInstanceOf(FileSystemCheckpointStorage.class);\n    }",
          "conflictNames": [
              "storage1",
              "config",
              "storage2"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/eb8af0c589ce46b091f403e848c7dc84b7e3ee8b^1/flink-runtime/src/test/java/org/apache/flink/runtime/state/CheckpointStorageLoaderTest.java",
      "locators": [
          {
              "line": 318,
              "column": 33
          },
          {
              "line": 321,
              "column": 20
          },
          {
              "line": 323,
              "column": 78
          }
      ],
      "old_name": "loadedStorage",
      "new_name": "loadedStorage1",
      "ctx": {
          "symbolName": "loadedStorage",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "CheckpointStorage",
          "scopeHint": "in testLoadFileSystemCheckpointStorageMixed(...)",
          "filePath": "CheckpointStorageLoaderTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Validates taking the application-defined file system state backend and adding with additional\n     * parameters from the cluster configuration, but giving precedence to application-defined\n     * parameters over configuration-defined parameters.\n     */\n    @Test\n    void testLoadFileSystemCheckpointStorageMixed() throws Exception {\n        final Path appCheckpointDir = new Path(TempDirUtils.newFolder(tmp).toURI());\n        final String checkpointDir = new Path(TempDirUtils.newFolder(tmp).toURI()).toString();\n        final String savepointDir = new Path(TempDirUtils.newFolder(tmp).toURI()).toString();\n\n        final Path expectedSavepointsPath = new Path(savepointDir);\n\n        final int threshold = 1000000;\n        final int writeBufferSize = 4000000;\n\n        final FileSystemCheckpointStorage storage =\n                new FileSystemCheckpointStorage(appCheckpointDir, threshold, writeBufferSize);\n\n        final Configuration config = new Configuration();\n        config.set(\n                CheckpointingOptions.CHECKPOINT_STORAGE,\n                \"jobmanager\"); // this should not be picked up\n        config.set(\n                CheckpointingOptions.CHECKPOINTS_DIRECTORY,\n                checkpointDir); // this should not be picked up\n        config.set(CheckpointingOptions.SAVEPOINT_DIRECTORY, savepointDir);\n        config.set(\n                CheckpointingOptions.FS_SMALL_FILE_THRESHOLD,\n                MemorySize.parse(\"20\")); // this should not be picked up\n        config.setInteger(\n                CheckpointingOptions.FS_WRITE_BUFFER_SIZE, 3000000); // this should not be picked up\n\n        final CheckpointStorage loadedStorage =\n                CheckpointStorageLoader.load(\n                        storage, null, new ModernStateBackend(), config, cl, LOG);\n        assertThat(loadedStorage).isInstanceOf(FileSystemCheckpointStorage.class);\n\n        final FileSystemCheckpointStorage fs = (FileSystemCheckpointStorage) loadedStorage;\n        assertThat(fs.getCheckpointPath()).is(matching(normalizedPath(appCheckpointDir)));\n        assertThat(fs.getSavepointPath()).is(matching(normalizedPath(expectedSavepointsPath)));\n        assertThat(fs.getMinFileSizeThreshold()).isEqualTo(threshold);\n        assertThat(fs.getWriteBufferSize()).isEqualTo(writeBufferSize);\n    }",
          "conflictNames": [
              "appCheckpointDir",
              "checkpointDir",
              "savepointDir",
              "expectedSavepointsPath",
              "threshold",
              "writeBufferSize",
              "storage",
              "config",
              "fs"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/eb8af0c589ce46b091f403e848c7dc84b7e3ee8b^1/flink-runtime/src/test/java/org/apache/flink/runtime/state/CheckpointStorageLoaderTest.java",
      "locators": [
          {
              "line": 28,
              "column": 30
          },
          {
              "line": 29,
              "column": 30
          },
          {
              "line": 276,
              "column": 37
          },
          {
              "line": 278,
              "column": 20
          },
          {
              "line": 279,
              "column": 20
          },
          {
              "line": 280,
              "column": 20
          },
          {
              "line": 281,
              "column": 20
          },
          {
              "line": 323,
              "column": 43
          },
          {
              "line": 324,
              "column": 20
          },
          {
              "line": 325,
              "column": 20
          },
          {
              "line": 326,
              "column": 20
          },
          {
              "line": 327,
              "column": 20
          }
      ],
      "old_name": "fs",
      "new_name": "fs1",
      "ctx": {
          "symbolName": "fs",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "FileSystemCheckpointStorage",
          "scopeHint": "in testLoadFileSystemCheckpointStorageMixed(...)",
          "filePath": "CheckpointStorageLoaderTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Validates taking the application-defined file system state backend and adding with additional\n     * parameters from the cluster configuration, but giving precedence to application-defined\n     * parameters over configuration-defined parameters.\n     */\n    @Test\n    void testLoadFileSystemCheckpointStorageMixed() throws Exception {\n        final Path appCheckpointDir = new Path(TempDirUtils.newFolder(tmp).toURI());\n        final String checkpointDir = new Path(TempDirUtils.newFolder(tmp).toURI()).toString();\n        final String savepointDir = new Path(TempDirUtils.newFolder(tmp).toURI()).toString();\n\n        final Path expectedSavepointsPath = new Path(savepointDir);\n\n        final int threshold = 1000000;\n        final int writeBufferSize = 4000000;\n\n        final FileSystemCheckpointStorage storage =\n                new FileSystemCheckpointStorage(appCheckpointDir, threshold, writeBufferSize);\n\n        final Configuration config = new Configuration();\n        config.set(\n                CheckpointingOptions.CHECKPOINT_STORAGE,\n                \"jobmanager\"); // this should not be picked up\n        config.set(\n                CheckpointingOptions.CHECKPOINTS_DIRECTORY,\n                checkpointDir); // this should not be picked up\n        config.set(CheckpointingOptions.SAVEPOINT_DIRECTORY, savepointDir);\n        config.set(\n                CheckpointingOptions.FS_SMALL_FILE_THRESHOLD,\n                MemorySize.parse(\"20\")); // this should not be picked up\n        config.setInteger(\n                CheckpointingOptions.FS_WRITE_BUFFER_SIZE, 3000000); // this should not be picked up\n\n        final CheckpointStorage loadedStorage =\n                CheckpointStorageLoader.load(\n                        storage, null, new ModernStateBackend(), config, cl, LOG);\n        assertThat(loadedStorage).isInstanceOf(FileSystemCheckpointStorage.class);\n\n        final FileSystemCheckpointStorage fs = (FileSystemCheckpointStorage) loadedStorage;\n        assertThat(fs.getCheckpointPath()).is(matching(normalizedPath(appCheckpointDir)));\n        assertThat(fs.getSavepointPath()).is(matching(normalizedPath(expectedSavepointsPath)));\n        assertThat(fs.getMinFileSizeThreshold()).isEqualTo(threshold);\n        assertThat(fs.getWriteBufferSize()).isEqualTo(writeBufferSize);\n    }",
          "conflictNames": [
              "appCheckpointDir",
              "checkpointDir",
              "savepointDir",
              "expectedSavepointsPath",
              "threshold",
              "writeBufferSize",
              "storage",
              "config",
              "loadedStorage"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/eb8af0c589ce46b091f403e848c7dc84b7e3ee8b^1/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendLoadingTest.java",
      "locators": [
          {
              "line": 174,
              "column": 22
          },
          {
              "line": 177,
              "column": 20
          },
          {
              "line": 179,
              "column": 68
          },
          {
              "line": 208,
              "column": 22
          },
          {
              "line": 211,
              "column": 20
          },
          {
              "line": 213,
              "column": 68
          },
          {
              "line": 305,
              "column": 28
          },
          {
              "line": 308,
              "column": 20
          },
          {
              "line": 310,
              "column": 52
          }
      ],
      "old_name": "loadedBackend",
      "new_name": "loadedBackendFromJobConfig",
      "ctx": {
          "symbolName": "loadedBackend",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "StateBackend",
          "scopeHint": "in testConfigureMemoryStateBackend(...)",
          "filePath": "StateBackendLoadingTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Validates taking the application-defined memory state backend and adding additional\n     * parameters from the cluster configuration.\n     */\n    @Test\n    void testConfigureMemoryStateBackend() throws Exception {\n        final String checkpointDir = new Path(TempDirUtils.newFolder(tmp).toURI()).toString();\n        final String savepointDir = new Path(TempDirUtils.newFolder(tmp).toURI()).toString();\n        final Path expectedCheckpointPath = new Path(checkpointDir);\n        final Path expectedSavepointPath = new Path(savepointDir);\n\n        final int maxSize = 100;\n\n        final MemoryStateBackend backend = new MemoryStateBackend(maxSize);\n\n        final Configuration config = new Configuration();\n        config.setString(backendKey, \"filesystem\"); // check that this is not accidentally picked up\n        config.setString(CheckpointingOptions.CHECKPOINTS_DIRECTORY, checkpointDir);\n        config.setString(CheckpointingOptions.SAVEPOINT_DIRECTORY, savepointDir);\n\n        StateBackend loadedBackend =\n                StateBackendLoader.fromApplicationOrConfigOrDefault(\n                        backend, TernaryBoolean.UNDEFINED, config, cl, null);\n        assertThat(loadedBackend).isInstanceOf(MemoryStateBackend.class);\n\n        final MemoryStateBackend memBackend = (MemoryStateBackend) loadedBackend;\n        assertThat(memBackend.getCheckpointPath()).isEqualTo(expectedCheckpointPath);\n        assertThat(memBackend.getSavepointPath()).isEqualTo(expectedSavepointPath);\n        assertThat(memBackend.getMaxStateSize()).isEqualTo(maxSize);\n    }",
          "conflictNames": [
              "checkpointDir",
              "savepointDir",
              "expectedCheckpointPath",
              "expectedSavepointPath",
              "maxSize",
              "backend",
              "config",
              "memBackend"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/eb8af0c589ce46b091f403e848c7dc84b7e3ee8b^1/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendLoadingTest.java",
      "locators": [
          {
              "line": 179,
              "column": 34
          },
          {
              "line": 180,
              "column": 20
          },
          {
              "line": 181,
              "column": 20
          },
          {
              "line": 182,
              "column": 20
          },
          {
              "line": 213,
              "column": 34
          },
          {
              "line": 214,
              "column": 20
          },
          {
              "line": 215,
              "column": 20
          },
          {
              "line": 420,
              "column": 34
          },
          {
              "line": 421,
              "column": 34
          },
          {
              "line": 423,
              "column": 20
          },
          {
              "line": 426,
              "column": 24
          },
          {
              "line": 427,
              "column": 24
          },
          {
              "line": 429,
              "column": 24
          },
          {
              "line": 430,
              "column": 24
          },
          {
              "line": 432,
              "column": 24
          },
          {
              "line": 433,
              "column": 24
          }
      ],
      "old_name": "memBackend",
      "new_name": "memBackend1",
      "ctx": {
          "symbolName": "memBackend",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "MemoryStateBackend",
          "scopeHint": "in testConfigureMemoryStateBackend(...)",
          "filePath": "StateBackendLoadingTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Validates taking the application-defined memory state backend and adding additional\n     * parameters from the cluster configuration.\n     */\n    @Test\n    void testConfigureMemoryStateBackend() throws Exception {\n        final String checkpointDir = new Path(TempDirUtils.newFolder(tmp).toURI()).toString();\n        final String savepointDir = new Path(TempDirUtils.newFolder(tmp).toURI()).toString();\n        final Path expectedCheckpointPath = new Path(checkpointDir);\n        final Path expectedSavepointPath = new Path(savepointDir);\n\n        final int maxSize = 100;\n\n        final MemoryStateBackend backend = new MemoryStateBackend(maxSize);\n\n        final Configuration config = new Configuration();\n        config.setString(backendKey, \"filesystem\"); // check that this is not accidentally picked up\n        config.setString(CheckpointingOptions.CHECKPOINTS_DIRECTORY, checkpointDir);\n        config.setString(CheckpointingOptions.SAVEPOINT_DIRECTORY, savepointDir);\n\n        StateBackend loadedBackend =\n                StateBackendLoader.fromApplicationOrConfigOrDefault(\n                        backend, TernaryBoolean.UNDEFINED, config, cl, null);\n        assertThat(loadedBackend).isInstanceOf(MemoryStateBackend.class);\n\n        final MemoryStateBackend memBackend = (MemoryStateBackend) loadedBackend;\n        assertThat(memBackend.getCheckpointPath()).isEqualTo(expectedCheckpointPath);\n        assertThat(memBackend.getSavepointPath()).isEqualTo(expectedSavepointPath);\n        assertThat(memBackend.getMaxStateSize()).isEqualTo(maxSize);\n    }",
          "conflictNames": [
              "checkpointDir",
              "savepointDir",
              "expectedCheckpointPath",
              "expectedSavepointPath",
              "maxSize",
              "backend",
              "config",
              "loadedBackend"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ed07a70e45a753a259287c9fdbdae73e3415cc21^1/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/SlotManagerConfiguration.java",
      "locators": [
          {
              "line": 44,
              "column": 27
          },
          {
              "line": 62,
              "column": 21
          },
          {
              "line": 79,
              "column": 14
          },
          {
              "line": 79,
              "column": 37
          },
          {
              "line": 203,
              "column": 16
          },
          {
              "line": 263,
              "column": 17
          },
          {
              "line": 266,
              "column": 17
          },
          {
              "line": 285,
              "column": 17
          }
      ],
      "old_name": "evenlySpreadOutSlots",
      "new_name": "taskManagerLoadBalanceMode",
      "ctx": {
          "symbolName": "evenlySpreadOutSlots",
          "symbolKind": "field",
          "language": "JAVA",
          "type": "boolean",
          "scopeHint": "in SlotManagerConfiguration",
          "filePath": "SlotManagerConfiguration.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "erTimeout;\n    private final Duration requirementCheckDelay;\n    private final Duration declareNeededResourceDelay;\n    private final boolean waitResultConsumedBeforeRelease;\n    private final SlotMatchingStrategy slotMatchingStrategy;\n    private final boolean evenlySpreadOutSlots;\n    private final WorkerResourceSpec defaultWorkerResourceSpec;\n    private final int numSlotsPerWorker;\n    private final int minSlotNum;\n    private final int maxSlotNum;\n    private final CPUResource minTotalCpu;\n    private final CPURe",
          "conflictNames": [
              "taskManagerRequestTimeout",
              "taskManagerTimeout",
              "requirementCheckDelay",
              "declareNeededResourceDelay",
              "waitResultConsumedBeforeRelease",
              "slotMatchingStrategy",
              "defaultWorkerResourceSpec",
              "numSlotsPerWorker",
              "minSlotNum",
              "maxSlotNum",
              "minTotalCpu",
              "maxTotalCpu",
              "minTotalMem",
              "maxTotalMem",
              "redundantTaskManagerNum"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ed36b2062dd04ccf5cdc7f9bdde239c41cc6cab2^1/flink-end-to-end-tests/flink-end-to-end-tests-sql/src/test/java/org/apache/flink/table/sql/codegen/SqlITCaseBase.java",
      "locators": [
          {
              "line": 177,
              "column": 16
          },
          {
              "line": 179,
              "column": 13
          },
          {
              "line": 180,
              "column": 30
          }
      ],
      "old_name": "csvFiles",
      "new_name": "files",
      "ctx": {
          "symbolName": "csvFiles",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "File[]",
          "scopeHint": "in readJsonResultFiles(...)",
          "filePath": "SqlITCaseBase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static List<String> readJsonResultFiles(Path path) throws IOException {\n        File filePath = path.toFile();\n        // list all the non-hidden files\n        File[] csvFiles = filePath.listFiles((dir, name) -> !name.startsWith(\".\"));\n        List<String> result = new ArrayList<>();\n        if (csvFiles != null) {\n            for (File file : csvFiles) {\n                result.addAll(Files.readAllLines(file.toPath()));\n            }\n        }\n        return result;\n    }",
          "conflictNames": [
              "path",
              "filePath",
              "result"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ed36b2062dd04ccf5cdc7f9bdde239c41cc6cab2^1/flink-end-to-end-tests/flink-end-to-end-tests-sql/src/test/java/org/apache/flink/table/sql/codegen/UsingRemoteJarITCase.java",
      "locators": [
          {
              "line": 171,
              "column": 29
          },
          {
              "line": 172,
              "column": 9
          },
          {
              "line": 173,
              "column": 16
          },
          {
              "line": 182,
              "column": 33
          },
          {
              "line": 182,
              "column": 40
          }
      ],
      "old_name": "map",
      "new_name": "varsMap",
      "ctx": {
          "symbolName": "map",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Map<String, String>",
          "scopeHint": "in generateReplaceVars(...)",
          "filePath": "UsingRemoteJarITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    protected Map<String, String> generateReplaceVars() {\n        String remoteJarPath =\n                String.format(\n                        \"hdfs://%s:%s/%s\",\n                        hdfsCluster.getURI().getHost(), hdfsCluster.getNameNodePort(), hdPath);\n\n        Map<String, String> map = super.generateReplaceVars();\n        map.put(\"$JAR_PATH\", remoteJarPath);\n        return map;\n    }",
          "conflictNames": [
              "remoteJarPath"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/edc96b6c4ae8b94e47efce33001de1493cea17a7^1/flink-core/src/test/java/org/apache/flink/core/fs/InitOutputPathTest.java",
      "locators": [
          {
              "line": 40,
              "column": 29
          },
          {
              "line": 57,
              "column": 27
          },
          {
              "line": 58,
              "column": 15
          },
          {
              "line": 59,
              "column": 9
          },
          {
              "line": 63,
              "column": 26
          },
          {
              "line": 63,
              "column": 32
          },
          {
              "line": 65,
              "column": 9
          },
          {
              "line": 69,
              "column": 9
          },
          {
              "line": 304,
              "column": 21
          },
          {
              "line": 307,
              "column": 21
          },
          {
              "line": 310,
              "column": 23
          }
      ],
      "old_name": "lock",
      "new_name": "lockField",
      "ctx": {
          "symbolName": "lock",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Field",
          "scopeHint": "in testErrorOccursUnSynchronized(...)",
          "filePath": "InitOutputPathTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * This test validates that this test case makes sense - that the error can be produced in the\n     * absence of synchronization, if the threads make progress in a certain way, here enforced by\n     * latches.\n     */\n    @Test\n    void testErrorOccursUnSynchronized() throws Exception {\n        // deactivate the lock to produce the original un-synchronized state\n        Field lock = FileSystem.class.getDeclaredField(\"OUTPUT_DIRECTORY_INIT_LOCK\");\n        lock.setAccessible(true);\n\n        Field modifiers = getModifiersField();\n        modifiers.setAccessible(true);\n        modifiers.setInt(lock, lock.getModifiers() & ~Modifier.FINAL);\n\n        lock.set(null, new NoOpLock());\n        // in the original un-synchronized state, we can force the race to occur by using\n        // the proper latch order to control the process of the concurrent threads\n        assertThatThrownBy(() -> runTest(true)).isInstanceOf(FileNotFoundException.class);\n        lock.set(null, new ReentrantLock(true));\n    }",
          "conflictNames": [
              "modifiers"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/edeb7929172a28c0e0edd9c023db745cf6a80490^1/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/catalog/DatabaseCalciteSchemaTest.java",
      "locators": [
          {
              "line": 19,
              "column": 26
          },
          {
              "line": 21,
              "column": 25
          },
          {
              "line": 22,
              "column": 25
          },
          {
              "line": 23,
              "column": 25
          },
          {
              "line": 24,
              "column": 25
          },
          {
              "line": 25,
              "column": 25
          },
          {
              "line": 26,
              "column": 25
          },
          {
              "line": 27,
              "column": 25
          },
          {
              "line": 32,
              "column": 32
          },
          {
              "line": 33,
              "column": 32
          },
          {
              "line": 53,
              "column": 21
          },
          {
              "line": 54,
              "column": 20
          },
          {
              "line": 55,
              "column": 42
          },
          {
              "line": 71,
              "column": 21
          },
          {
              "line": 72,
              "column": 20
          },
          {
              "line": 73,
              "column": 42
          }
      ],
      "old_name": "table",
      "new_name": "model",
      "ctx": {
          "symbolName": "table",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Table",
          "scopeHint": "in testPermanentTableWithPrimaryKey(...)",
          "filePath": "DatabaseCalciteSchemaTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testPermanentTableWithPrimaryKey() {\n        final CatalogManager catalogManager = CatalogManagerMocks.createEmptyCatalogManager();\n\n        final DatabaseCalciteSchema calciteSchema =\n                new DatabaseCalciteSchema(DEFAULT_CATALOG, DEFAULT_DATABASE, catalogManager, true);\n\n        catalogManager.createTable(\n                createTable(),\n                ObjectIdentifier.of(DEFAULT_CATALOG, DEFAULT_DATABASE, TABLE_NAME),\n                false);\n\n        final Table table = calciteSchema.getTable(TABLE_NAME);\n        assertThat(table).isInstanceOf(CatalogSchemaTable.class);\n        assertThat(((CatalogSchemaTable) table).getStatistic().getUniqueKeys().iterator().next())\n                .containsExactlyInAnyOrder(\"a\", \"b\");\n    }",
          "conflictNames": [
              "catalogManager",
              "calciteSchema"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/eef14cb8781ae06e53dedcd6848b1707b2081a17^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/data/binary/BinaryStringDataUtil.java",
      "locators": [
          {
              "line": 589,
              "column": 17
          },
          {
              "line": 590,
              "column": 13
          },
          {
              "line": 594,
              "column": 16
          },
          {
              "line": 598,
              "column": 17
          },
          {
              "line": 599,
              "column": 13
          },
          {
              "line": 603,
              "column": 16
          }
      ],
      "old_name": "date",
      "new_name": "milliSeconds",
      "ctx": {
          "symbolName": "date",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Integer",
          "scopeHint": "in toDate(...)",
          "filePath": "BinaryStringDataUtil.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static int toDate(BinaryStringData input) throws DateTimeException {\n        Integer date = DateTimeUtils.parseDate(input.toString());\n        if (date == null) {\n            throw new DateTimeException(\"For input string: '\" + input + \"'.\");\n        }\n\n        return date;\n    }",
          "conflictNames": [
              "input"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ef09e1716924d1e6ed64bfc273859f2de979b027^1/flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/ValueSerializer.java",
      "locators": [
          {
              "line": 141,
              "column": 46
          },
          {
              "line": 143,
              "column": 13
          },
          {
              "line": 144,
              "column": 42
          }
      ],
      "old_name": "instantiatorStrategy",
      "new_name": "initStrategy",
      "ctx": {
          "symbolName": "instantiatorStrategy",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "DefaultInstantiatorStrategy",
          "scopeHint": "in checkKryoInitialized(...)",
          "filePath": "ValueSerializer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void checkKryoInitialized() {\n        if (this.kryo == null) {\n            this.kryo = new Kryo();\n\n            Kryo.DefaultInstantiatorStrategy instantiatorStrategy =\n                    new Kryo.DefaultInstantiatorStrategy();\n            instantiatorStrategy.setFallbackInstantiatorStrategy(new StdInstantiatorStrategy());\n            kryo.setInstantiatorStrategy(instantiatorStrategy);\n\n            this.kryo.setAsmEnabled(true);\n\n            KryoUtils.applyRegistrations(\n                    this.kryo, kryoRegistrations.values(), this.kryo.getNextRegistrationId());\n        }\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ef9e490efb2535fe7be710afab8491f2310fce22^1/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/collect/CollectSinkOperatorCoordinatorTest.java",
      "locators": [
          {
              "line": 162,
              "column": 19
          },
          {
              "line": 163,
              "column": 53
          },
          {
              "line": 164,
              "column": 29
          },
          {
              "line": 166,
              "column": 29
          }
      ],
      "old_name": "results",
      "new_name": "actualResult",
      "ctx": {
          "symbolName": "results",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<Row>",
          "scopeHint": "in assertResponse(...)",
          "filePath": "CollectSinkOperatorCoordinatorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void assertResponse(\n            CompletableFuture<CoordinationResponse> responseFuture,\n            String expectedVersion,\n            long expectedOffset,\n            List<Row> expectedResults)\n            throws Exception {\n        final CollectCoordinationResponse response =\n                (CollectCoordinationResponse) responseFuture.get();\n\n        Assert.assertEquals(expectedVersion, response.getVersion());\n        Assert.assertEquals(expectedOffset, response.getLastCheckpointedOffset());\n        List<Row> results = response.getResults(serializer);\n        Assert.assertEquals(expectedResults.size(), results.size());\n        for (int i = 0; i < results.size(); i++) {\n            Row expectedRow = expectedResults.get(i);\n            Row actualRow = results.get(i);\n            Assert.assertEquals(expectedRow.getArity(), actualRow.getArity());\n            for (int j = 0; j < actualRow.getArity(); j++) {\n                Assert.assertEquals(expectedRow.getField(j), actualRow.getField(j));\n            }\n        }\n    }",
          "conflictNames": [
              "responseFuture",
              "expectedVersion",
              "expectedOffset",
              "expectedResults",
              "response",
              "i",
              "expectedRow",
              "actualRow",
              "j"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/ef9e490efb2535fe7be710afab8491f2310fce22^1/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/collect/CollectSinkOperatorCoordinatorTest.java",
      "locators": [
          {
              "line": 2,
              "column": 5
          },
          {
              "line": 2,
              "column": 43
          },
          {
              "line": 3,
              "column": 9
          },
          {
              "line": 3,
              "column": 17
          },
          {
              "line": 3,
              "column": 53
          },
          {
              "line": 3,
              "column": 58
          },
          {
              "line": 3,
              "column": 62
          },
          {
              "line": 3,
              "column": 70
          },
          {
              "line": 4,
              "column": 6
          },
          {
              "line": 4,
              "column": 21
          },
          {
              "line": 4,
              "column": 23
          },
          {
              "line": 4,
              "column": 29
          },
          {
              "line": 4,
              "column": 37
          },
          {
              "line": 4,
              "column": 47
          },
          {
              "line": 4,
              "column": 56
          },
          {
              "line": 4,
              "column": 68
          },
          {
              "line": 5,
              "column": 13
          },
          {
              "line": 5,
              "column": 23
          },
          {
              "line": 5,
              "column": 27
          },
          {
              "line": 5,
              "column": 56
          },
          {
              "line": 5,
              "column": 68
          },
          {
              "line": 6,
              "column": 11
          },
          {
              "line": 6,
              "column": 39
          },
          {
              "line": 6,
              "column": 43
          },
          {
              "line": 6,
              "column": 54
          },
          {
              "line": 6,
              "column": 62
          },
          {
              "line": 6,
              "column": 69
          },
          {
              "line": 7,
              "column": 9
          },
          {
              "line": 7,
              "column": 30
          },
          {
              "line": 7,
              "column": 48
          },
          {
              "line": 9,
              "column": 30
          },
          {
              "line": 11,
              "column": 15
          },
          {
              "line": 11,
              "column": 27
          },
          {
              "line": 11,
              "column": 51
          },
          {
              "line": 11,
              "column": 56
          },
          {
              "line": 11,
              "column": 58
          },
          {
              "line": 12,
              "column": 5
          },
          {
              "line": 12,
              "column": 9
          },
          {
              "line": 12,
              "column": 27
          },
          {
              "line": 12,
              "column": 34
          },
          {
              "line": 12,
              "column": 38
          },
          {
              "line": 12,
              "column": 42
          },
          {
              "line": 13,
              "column": 51
          },
          {
              "line": 13,
              "column": 68
          },
          {
              "line": 13,
              "column": 72
          },
          {
              "line": 14,
              "column": 13
          },
          {
              "line": 14,
              "column": 32
          },
          {
              "line": 14,
              "column": 34
          },
          {
              "line": 14,
              "column": 52
          },
          {
              "line": 14,
              "column": 60
          },
          {
              "line": 14,
              "column": 63
          },
          {
              "line": 15,
              "column": 5
          },
          {
              "line": 15,
              "column": 7
          },
          {
              "line": 15,
              "column": 11
          },
          {
              "line": 15,
              "column": 27
          },
          {
              "line": 18,
              "column": 22
          },
          {
              "line": 18,
              "column": 32
          },
          {
              "line": 18,
              "column": 38
          },
          {
              "line": 20,
              "column": 1
          },
          {
              "line": 20,
              "column": 21
          },
          {
              "line": 20,
              "column": 27
          },
          {
              "line": 20,
              "column": 42
          },
          {
              "line": 20,
              "column": 49
          },
          {
              "line": 21,
              "column": 1
          },
          {
              "line": 21,
              "column": 21
          },
          {
              "line": 21,
              "column": 27
          },
          {
              "line": 21,
              "column": 40
          },
          {
              "line": 21,
              "column": 48
          },
          {
              "line": 22,
              "column": 1
          },
          {
              "line": 22,
              "column": 21
          },
          {
              "line": 22,
              "column": 27
          },
          {
              "line": 22,
              "column": 42
          },
          {
              "line": 22,
              "column": 53
          },
          {
              "line": 22,
              "column": 56
          },
          {
              "line": 23,
              "column": 1
          },
          {
              "line": 23,
              "column": 21
          },
          {
              "line": 23,
              "column": 27
          },
          {
              "line": 23,
              "column": 40
          },
          {
              "line": 24,
              "column": 1
          },
          {
              "line": 24,
              "column": 21
          },
          {
              "line": 24,
              "column": 47
          },
          {
              "line": 25,
              "column": 1
          },
          {
              "line": 25,
              "column": 21
          },
          {
              "line": 25,
              "column": 48
          },
          {
              "line": 26,
              "column": 1
          },
          {
              "line": 26,
              "column": 21
          },
          {
              "line": 26,
              "column": 29
          },
          {
              "line": 26,
              "column": 48
          },
          {
              "line": 26,
              "column": 52
          },
          {
              "line": 26,
              "column": 61
          },
          {
              "line": 26,
              "column": 65
          },
          {
              "line": 27,
              "column": 1
          },
          {
              "line": 27,
              "column": 21
          },
          {
              "line": 27,
              "column": 29
          },
          {
              "line": 27,
              "column": 48
          },
          {
              "line": 27,
              "column": 52
          },
          {
              "line": 27,
              "column": 61
          },
          {
              "line": 27,
              "column": 65
          },
          {
              "line": 28,
              "column": 1
          },
          {
              "line": 28,
              "column": 21
          },
          {
              "line": 28,
              "column": 31
          },
          {
              "line": 28,
              "column": 37
          },
          {
              "line": 28,
              "column": 59
          },
          {
              "line": 28,
              "column": 76
          },
          {
              "line": 29,
              "column": 1
          },
          {
              "line": 29,
              "column": 21
          },
          {
              "line": 30,
              "column": 1
          },
          {
              "line": 30,
              "column": 21
          },
          {
              "line": 30,
              "column": 27
          },
          {
              "line": 30,
              "column": 35
          },
          {
              "line": 32,
              "column": 1
          },
          {
              "line": 32,
              "column": 15
          },
          {
              "line": 33,
              "column": 1
          },
          {
              "line": 33,
              "column": 15
          },
          {
              "line": 35,
              "column": 1
          },
          {
              "line": 35,
              "column": 13
          },
          {
              "line": 35,
              "column": 24
          },
          {
              "line": 36,
              "column": 1
          },
          {
              "line": 37,
              "column": 1
          },
          {
              "line": 38,
              "column": 1
          },
          {
              "line": 39,
              "column": 1
          },
          {
              "line": 40,
              "column": 1
          },
          {
              "line": 40,
              "column": 15
          },
          {
              "line": 41,
              "column": 1
          },
          {
              "line": 41,
              "column": 15
          },
          {
              "line": 41,
              "column": 25
          },
          {
              "line": 42,
              "column": 1
          },
          {
              "line": 42,
              "column": 15
          },
          {
              "line": 42,
              "column": 19
          },
          {
              "line": 42,
              "column": 25
          },
          {
              "line": 43,
              "column": 1
          },
          {
              "line": 43,
              "column": 15
          },
          {
              "line": 43,
              "column": 19
          },
          {
              "line": 44,
              "column": 1
          },
          {
              "line": 44,
              "column": 15
          },
          {
              "line": 46,
              "column": 18
          },
          {
              "line": 46,
              "column": 30
          },
          {
              "line": 46,
              "column": 46
          },
          {
              "line": 47,
              "column": 5
          },
          {
              "line": 47,
              "column": 22
          },
          {
              "line": 47,
              "column": 38
          },
          {
              "line": 49,
              "column": 7
          },
          {
              "line": 49,
              "column": 17
          },
          {
              "line": 49,
              "column": 21
          },
          {
              "line": 49,
              "column": 26
          },
          {
              "line": 51,
              "column": 7
          },
          {
              "line": 51,
              "column": 17
          },
          {
              "line": 51,
              "column": 21
          },
          {
              "line": 51,
              "column": 33
          },
          {
              "line": 51,
              "column": 36
          },
          {
              "line": 51,
              "column": 49
          },
          {
              "line": 51,
              "column": 52
          },
          {
              "line": 52,
              "column": 32
          },
          {
              "line": 52,
              "column": 61
          },
          {
              "line": 53,
              "column": 31
          },
          {
              "line": 53,
              "column": 34
          },
          {
              "line": 53,
              "column": 49
          },
          {
              "line": 53,
              "column": 56
          },
          {
              "line": 56,
              "column": 9
          },
          {
              "line": 56,
              "column": 14
          },
          {
              "line": 56,
              "column": 46
          },
          {
              "line": 57,
              "column": 17
          },
          {
              "line": 57,
              "column": 33
          },
          {
              "line": 57,
              "column": 45
          },
          {
              "line": 58,
              "column": 29
          },
          {
              "line": 58,
              "column": 45
          },
          {
              "line": 59,
              "column": 14
          },
          {
              "line": 61,
              "column": 10
          },
          {
              "line": 61,
              "column": 18
          },
          {
              "line": 61,
              "column": 34
          },
          {
              "line": 61,
              "column": 45
          },
          {
              "line": 62,
              "column": 10
          },
          {
              "line": 62,
              "column": 38
          },
          {
              "line": 62,
              "column": 42
          },
          {
              "line": 63,
              "column": 22
          },
          {
              "line": 63,
              "column": 40
          },
          {
              "line": 63,
              "column": 44
          },
          {
              "line": 64,
              "column": 43
          },
          {
              "line": 64,
              "column": 77
          },
          {
              "line": 65,
              "column": 43
          },
          {
              "line": 65,
              "column": 70
          },
          {
              "line": 67,
              "column": 14
          },
          {
              "line": 71,
              "column": 9
          },
          {
              "line": 71,
              "column": 14
          },
          {
              "line": 71,
              "column": 29
          },
          {
              "line": 71,
              "column": 50
          },
          {
              "line": 72,
              "column": 17
          },
          {
              "line": 72,
              "column": 33
          },
          {
              "line": 72,
              "column": 45
          },
          {
              "line": 73,
              "column": 29
          },
          {
              "line": 73,
              "column": 45
          },
          {
              "line": 74,
              "column": 14
          },
          {
              "line": 76,
              "column": 10
          },
          {
              "line": 76,
              "column": 15
          },
          {
              "line": 77,
              "column": 27
          },
          {
              "line": 78,
              "column": 35
          },
          {
              "line": 79,
              "column": 35
          },
          {
              "line": 82,
              "column": 14
          },
          {
              "line": 83,
              "column": 35
          },
          {
              "line": 86,
              "column": 32
          },
          {
              "line": 86,
              "column": 36
          },
          {
              "line": 87,
              "column": 22
          },
          {
              "line": 87,
              "column": 40
          },
          {
              "line": 87,
              "column": 44
          },
          {
              "line": 88,
              "column": 24
          },
          {
              "line": 91,
              "column": 25
          },
          {
              "line": 91,
              "column": 43
          },
          {
              "line": 91,
              "column": 47
          },
          {
              "line": 92,
              "column": 24
          },
          {
              "line": 95,
              "column": 10
          },
          {
              "line": 95,
              "column": 18
          },
          {
              "line": 95,
              "column": 34
          },
          {
              "line": 95,
              "column": 45
          },
          {
              "line": 96,
              "column": 32
          },
          {
              "line": 96,
              "column": 36
          },
          {
              "line": 97,
              "column": 22
          },
          {
              "line": 97,
              "column": 40
          },
          {
              "line": 97,
              "column": 44
          },
          {
              "line": 98,
              "column": 43
          },
          {
              "line": 98,
              "column": 77
          },
          {
              "line": 99,
              "column": 14
          },
          {
              "line": 99,
              "column": 27
          },
          {
              "line": 99,
              "column": 39
          },
          {
              "line": 102,
              "column": 27
          },
          {
              "line": 102,
              "column": 33
          },
          {
              "line": 102,
              "column": 42
          },
          {
              "line": 102,
              "column": 56
          },
          {
              "line": 105,
              "column": 14
          },
          {
              "line": 106,
              "column": 35
          },
          {
              "line": 108,
              "column": 20
          },
          {
              "line": 109,
              "column": 43
          },
          {
              "line": 109,
              "column": 76
          },
          {
              "line": 112,
              "column": 25
          },
          {
              "line": 112,
              "column": 43
          },
          {
              "line": 112,
              "column": 47
          },
          {
              "line": 113,
              "column": 24
          },
          {
              "line": 116,
              "column": 14
          },
          {
              "line": 119,
              "column": 7
          },
          {
              "line": 119,
              "column": 17
          },
          {
              "line": 119,
              "column": 25
          },
          {
              "line": 119,
              "column": 29
          },
          {
              "line": 120,
              "column": 10
          },
          {
              "line": 120,
              "column": 18
          },
          {
              "line": 120,
              "column": 32
          },
          {
              "line": 120,
              "column": 50
          },
          {
              "line": 121,
              "column": 34
          },
          {
              "line": 121,
              "column": 66
          },
          {
              "line": 124,
              "column": 7
          },
          {
              "line": 124,
              "column": 17
          },
          {
              "line": 124,
              "column": 25
          },
          {
              "line": 124,
              "column": 29
          },
          {
              "line": 124,
              "column": 58
          },
          {
              "line": 124,
              "column": 83
          },
          {
              "line": 124,
              "column": 91
          },
          {
              "line": 125,
              "column": 10
          },
          {
              "line": 125,
              "column": 15
          },
          {
              "line": 126,
              "column": 32
          },
          {
              "line": 126,
              "column": 36
          },
          {
              "line": 126,
              "column": 51
          },
          {
              "line": 129,
              "column": 7
          },
          {
              "line": 129,
              "column": 17
          },
          {
              "line": 129,
              "column": 22
          },
          {
              "line": 130,
              "column": 36
          },
          {
              "line": 130,
              "column": 40
          },
          {
              "line": 130,
              "column": 82
          },
          {
              "line": 131,
              "column": 43
          },
          {
              "line": 135,
              "column": 7
          },
          {
              "line": 135,
              "column": 17
          },
          {
              "line": 135,
              "column": 22
          },
          {
              "line": 135,
              "column": 59
          },
          {
              "line": 136,
              "column": 36
          },
          {
              "line": 136,
              "column": 40
          },
          {
              "line": 136,
              "column": 72
          },
          {
              "line": 136,
              "column": 88
          },
          {
              "line": 137,
              "column": 26
          },
          {
              "line": 138,
              "column": 52
          },
          {
              "line": 138,
              "column": 68
          },
          {
              "line": 138,
              "column": 79
          },
          {
              "line": 141,
              "column": 7
          },
          {
              "line": 141,
              "column": 17
          },
          {
              "line": 141,
              "column": 22
          },
          {
              "line": 141,
              "column": 40
          },
          {
              "line": 142,
              "column": 36
          },
          {
              "line": 142,
              "column": 40
          },
          {
              "line": 142,
              "column": 70
          },
          {
              "line": 143,
              "column": 26
          },
          {
              "line": 151,
              "column": 7
          },
          {
              "line": 151,
              "column": 17
          },
          {
              "line": 151,
              "column": 22
          },
          {
              "line": 152,
              "column": 36
          },
          {
              "line": 152,
              "column": 40
          },
          {
              "line": 153,
              "column": 16
          },
          {
              "line": 153,
              "column": 32
          },
          {
              "line": 155,
              "column": 14
          },
          {
              "line": 156,
              "column": 26
          },
          {
              "line": 157,
              "column": 10
          },
          {
              "line": 157,
              "column": 27
          },
          {
              "line": 157,
              "column": 31
          },
          {
              "line": 158,
              "column": 30
          },
          {
              "line": 158,
              "column": 34
          },
          {
              "line": 160,
              "column": 41
          },
          {
              "line": 160,
              "column": 62
          },
          {
              "line": 161,
              "column": 68
          },
          {
              "line": 162,
              "column": 10
          },
          {
              "line": 162,
              "column": 52
          },
          {
              "line": 162,
              "column": 55
          },
          {
              "line": 163,
              "column": 46
          },
          {
              "line": 163,
              "column": 62
          },
          {
              "line": 164,
              "column": 14
          },
          {
              "line": 164,
              "column": 18
          },
          {
              "line": 164,
              "column": 25
          },
          {
              "line": 164,
              "column": 38
          },
          {
              "line": 164,
              "column": 45
          },
          {
              "line": 165,
              "column": 51
          },
          {
              "line": 166,
              "column": 41
          },
          {
              "line": 167,
              "column": 50
          },
          {
              "line": 167,
              "column": 72
          },
          {
              "line": 168,
              "column": 18
          },
          {
              "line": 168,
              "column": 48
          },
          {
              "line": 169,
              "column": 53
          },
          {
              "line": 169,
              "column": 76
          },
          {
              "line": 174,
              "column": 7
          },
          {
              "line": 174,
              "column": 17
          },
          {
              "line": 176,
              "column": 13
          },
          {
              "line": 176,
              "column": 17
          },
          {
              "line": 176,
              "column": 25
          },
          {
              "line": 176,
              "column": 84
          },
          {
              "line": 177,
              "column": 13
          },
          {
              "line": 177,
              "column": 17
          },
          {
              "line": 177,
              "column": 22
          },
          {
              "line": 179,
              "column": 11
          },
          {
              "line": 179,
              "column": 18
          },
          {
              "line": 179,
              "column": 24
          },
          {
              "line": 179,
              "column": 30
          },
          {
              "line": 179,
              "column": 35
          },
          {
              "line": 180,
              "column": 11
          },
          {
              "line": 180,
              "column": 18
          },
          {
              "line": 180,
              "column": 23
          },
          {
              "line": 182,
              "column": 11
          },
          {
              "line": 182,
              "column": 18
          },
          {
              "line": 183,
              "column": 11
          },
          {
              "line": 183,
              "column": 29
          },
          {
              "line": 185,
              "column": 11
          },
          {
              "line": 185,
              "column": 31
          },
          {
              "line": 185,
              "column": 36
          },
          {
              "line": 185,
              "column": 52
          },
          {
              "line": 185,
              "column": 88
          },
          {
              "line": 186,
              "column": 15
          },
          {
              "line": 186,
              "column": 30
          },
          {
              "line": 186,
              "column": 36
          },
          {
              "line": 187,
              "column": 15
          },
          {
              "line": 189,
              "column": 15
          },
          {
              "line": 192,
              "column": 15
          },
          {
              "line": 193,
              "column": 13
          },
          {
              "line": 193,
              "column": 18
          },
          {
              "line": 194,
              "column": 17
          },
          {
              "line": 196,
              "column": 13
          },
          {
              "line": 198,
              "column": 23
          },
          {
              "line": 198,
              "column": 40
          },
          {
              "line": 199,
              "column": 24
          },
          {
              "line": 202,
              "column": 19
          },
          {
              "line": 202,
              "column": 28
          },
          {
              "line": 203,
              "column": 21
          },
          {
              "line": 204,
              "column": 39
          },
          {
              "line": 204,
              "column": 50
          },
          {
              "line": 204,
              "column": 57
          },
          {
              "line": 205,
              "column": 25
          },
          {
              "line": 205,
              "column": 50
          },
          {
              "line": 206,
              "column": 52
          },
          {
              "line": 209,
              "column": 28
          },
          {
              "line": 209,
              "column": 72
          },
          {
              "line": 210,
              "column": 37
          },
          {
              "line": 210,
              "column": 41
          },
          {
              "line": 210,
              "column": 52
          },
          {
              "line": 213,
              "column": 21
          },
          {
              "line": 215,
              "column": 29
          },
          {
              "line": 219,
              "column": 27
          },
          {
              "line": 219,
              "column": 30
          },
          {
              "line": 219,
              "column": 39
          },
          {
              "line": 219,
              "column": 66
          },
          {
              "line": 220,
              "column": 37
          },
          {
              "line": 220,
              "column": 41
          },
          {
              "line": 223,
              "column": 50
          },
          {
              "line": 223,
              "column": 62
          },
          {
              "line": 223,
              "column": 78
          },
          {
              "line": 223,
              "column": 89
          },
          {
              "line": 223,
              "column": 92
          },
          {
              "line": 224,
              "column": 33
          },
          {
              "line": 224,
              "column": 36
          },
          {
              "line": 229,
              "column": 30
          },
          {
              "line": 230,
              "column": 20
          },
          {
              "line": 234,
              "column": 13
          },
          {
              "line": 234,
              "column": 18
          },
          {
              "line": 235,
              "column": 17
          },
          {
              "line": 238,
              "column": 13
          }
      ],
      "old_name": "i",
      "new_name": "rowId",
      "ctx": {
          "symbolName": "i",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "int",
          "scopeHint": "in assertResponse(...)",
          "filePath": "CollectSinkOperatorCoordinatorTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void assertResponse(\n            CompletableFuture<CoordinationResponse> responseFuture,\n            String expectedVersion,\n            long expectedOffset,\n            List<Row> expectedResults)\n            throws Exception {\n        final CollectCoordinationResponse response =\n                (CollectCoordinationResponse) responseFuture.get();\n\n        Assert.assertEquals(expectedVersion, response.getVersion());\n        Assert.assertEquals(expectedOffset, response.getLastCheckpointedOffset());\n        List<Row> results = response.getResults(serializer);\n        Assert.assertEquals(expectedResults.size(), results.size());\n        for (int i = 0; i < results.size(); i++) {\n            Row expectedRow = expectedResults.get(i);\n            Row actualRow = results.get(i);\n            Assert.assertEquals(expectedRow.getArity(), actualRow.getArity());\n            for (int j = 0; j < actualRow.getArity(); j++) {\n                Assert.assertEquals(expectedRow.getField(j), actualRow.getField(j));\n            }\n        }\n    }",
          "conflictNames": [
              "responseFuture",
              "expectedVersion",
              "expectedOffset",
              "expectedResults",
              "response",
              "results",
              "expectedRow",
              "actualRow",
              "j"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f1597d5b2184ddcdd8e2e94c5c081b5a85eabf40^1/flink-python/src/main/java/org/apache/flink/table/runtime/typeutils/serializers/python/TimestampSerializer.java",
      "locators": [
          {
              "line": 194,
              "column": 33
          },
          {
              "line": 195,
              "column": 38
          }
      ],
      "old_name": "timestampSerializer",
      "new_name": "timestampSerializerSnapshot",
      "ctx": {
          "symbolName": "timestampSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TimestampSerializer",
          "scopeHint": "in resolveSchemaCompatibility(...)",
          "filePath": "TimestampSerializer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public TypeSerializerSchemaCompatibility<Timestamp> resolveSchemaCompatibility(\n                TypeSerializer<Timestamp> newSerializer) {\n            if (!(newSerializer instanceof TimestampSerializer)) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            }\n\n            TimestampSerializer timestampSerializer = (TimestampSerializer) newSerializer;\n            if (previousPrecision != timestampSerializer.precision) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            } else {\n                return TypeSerializerSchemaCompatibility.compatibleAsIs();\n            }\n        }",
          "conflictNames": [
              "newSerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f1597d5b2184ddcdd8e2e94c5c081b5a85eabf40^1/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/typeutils/TimestampDataSerializer.java",
      "locators": [
          {
              "line": 184,
              "column": 37
          },
          {
              "line": 186,
              "column": 38
          }
      ],
      "old_name": "timestampDataSerializer",
      "new_name": "timestampDataSerializerSnapshot",
      "ctx": {
          "symbolName": "timestampDataSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TimestampDataSerializer",
          "scopeHint": "in resolveSchemaCompatibility(...)",
          "filePath": "TimestampDataSerializer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public TypeSerializerSchemaCompatibility<TimestampData> resolveSchemaCompatibility(\n                TypeSerializer<TimestampData> newSerializer) {\n            if (!(newSerializer instanceof TimestampDataSerializer)) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            }\n\n            TimestampDataSerializer timestampDataSerializer =\n                    (TimestampDataSerializer) newSerializer;\n            if (previousPrecision != timestampDataSerializer.precision) {\n                return TypeSerializerSchemaCompatibility.incompatible();\n            } else {\n                return TypeSerializerSchemaCompatibility.compatibleAsIs();\n            }\n        }",
          "conflictNames": [
              "newSerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f1a079f95e409d3a81ff5dd199ea3c0dc30470cc^1/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotProviderImpl.java",
      "locators": [
          {
              "line": 88,
              "column": 45
          },
          {
              "line": 91,
              "column": 64
          }
      ],
      "old_name": "slotInfoList",
      "new_name": "freeSlotInfoTracker",
      "ctx": {
          "symbolName": "slotInfoList",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Collection<SlotInfoWithUtilization>",
          "scopeHint": "in tryAllocateFromAvailable(...)",
          "filePath": "PhysicalSlotProviderImpl.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private Optional<PhysicalSlot> tryAllocateFromAvailable(\n            SlotRequestId slotRequestId, SlotProfile slotProfile) {\n        Collection<SlotInfoWithUtilization> slotInfoList = slotPool.getAvailableSlotsInformation();\n\n        Optional<SlotSelectionStrategy.SlotInfoAndLocality> selectedAvailableSlot =\n                slotSelectionStrategy.selectBestSlotForProfile(slotInfoList, slotProfile);\n\n        return selectedAvailableSlot.flatMap(\n                slotInfoAndLocality ->\n                        slotPool.allocateAvailableSlot(\n                                slotRequestId,\n                                slotInfoAndLocality.getSlotInfo().getAllocationId(),\n                                slotProfile.getPhysicalSlotResourceProfile()));\n    }",
          "conflictNames": [
              "slotRequestId",
              "slotProfile",
              "selectedAvailableSlot"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f1a7a10581c89ef59e2a8bbfdc83471661bc7fae^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/calcite/FlinkCalciteSqlValidator.java",
      "locators": [
          {
              "line": 365,
              "column": 35
          },
          {
              "line": 376,
              "column": 17
          },
          {
              "line": 386,
              "column": 48
          }
      ],
      "old_name": "explicitTableArgs",
      "new_name": "tableArgs",
      "ctx": {
          "symbolName": "explicitTableArgs",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<SqlIdentifier>",
          "scopeHint": "in performUnconditionalRewrites(...)",
          "filePath": "FlinkCalciteSqlValidator.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    protected @PolyNull SqlNode performUnconditionalRewrites(\n            @PolyNull SqlNode node, boolean underFrom) {\n\n        // Special case for window TVFs like:\n        // TUMBLE(TABLE t, DESCRIPTOR(metadata_virtual), INTERVAL '1' MINUTE))\n        //\n        // \"TABLE t\" is translated into an implicit \"SELECT * FROM t\". This would ignore columns\n        // that are not expanded by default. However, the descriptor explicitly states the need\n        // for this column. Therefore, explicit table expressions (for window TVFs at most one)\n        // are captured before rewriting and replaced with a \"marker\" SqlSelect that contains the\n        // descriptor information. The \"marker\" SqlSelect is considered during column expansion.\n        final List<SqlIdentifier> explicitTableArgs = getExplicitTableOperands(node);\n\n        final SqlNode rewritten = super.performUnconditionalRewrites(node, underFrom);\n\n        if (!(node instanceof SqlBasicCall)) {\n            return rewritten;\n        }\n        final SqlBasicCall call = (SqlBasicCall) node;\n        final SqlOperator operator = call.getOperator();\n\n        if (operator instanceof SqlWindowTableFunction) {\n            if (explicitTableArgs.stream().allMatch(Objects::isNull)) {\n                return rewritten;\n            }\n\n            final List<SqlIdentifier> descriptors =\n                    call.getOperandList().stream()\n                            .flatMap(FlinkCalciteSqlValidator::extractDescriptors)\n                            .collect(Collectors.toList());\n\n            for (int i = 0; i < call.operandCount(); i++) {\n                final SqlIdentifier tableArg = explicitTableArgs.get(i);\n                if (tableArg != null) {\n                    final SqlNode opReplacement = new ExplicitTableSqlSelect(tableArg, descriptors);\n                    if (call.operand(i).getKind() == SqlKind.ARGUMENT_ASSIGNMENT) {\n                        // for TUMBLE(DATA => TABLE t3, ...)\n                        final SqlCall assignment = call.operand(i);\n                        assignment.setOperand(0, opReplacement);\n                    } else {\n                        // for TUMBLE(TABLE t3, ...)\n                        call.setOperand(i, opReplacement);\n                    }\n                }\n                // for TUMBLE([DATA =>] SELECT ..., ...)\n            }\n        }\n\n        return rewritten;\n    }",
          "conflictNames": [
              "node",
              "underFrom",
              "rewritten",
              "call",
              "operator",
              "descriptors",
              "i",
              "tableArg",
              "opReplacement",
              "assignment"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f1ca261e1e917fa1c79715ff6ed415076aa4295a^1/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesLeaderElectionDriverTest.java",
      "locators": [
          {
              "line": 93,
              "column": 42
          },
          {
              "line": 97,
              "column": 49
          },
          {
              "line": 136,
              "column": 42
          },
          {
              "line": 142,
              "column": 49
          },
          {
              "line": 201,
              "column": 42
          },
          {
              "line": 205,
              "column": 49
          },
          {
              "line": 225,
              "column": 42
          },
          {
              "line": 229,
              "column": 49
          }
      ],
      "old_name": "errorMsg",
      "new_name": "expectedErrorMessage",
      "ctx": {
          "symbolName": "errorMsg",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in testHasLeadershipWhenConfigMapNotExist(...)",
          "filePath": "KubernetesLeaderElectionDriverTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testHasLeadershipWhenConfigMapNotExist() throws Exception {\n        new Context() {\n            {\n                runTest(\n                        () -> {\n                            leaderElectionDriver.hasLeadership();\n                            electionEventHandler.waitForError();\n                            final String errorMsg =\n                                    \"ConfigMap \" + LEADER_CONFIGMAP_NAME + \" does not exist.\";\n                            assertThat(electionEventHandler.getError())\n                                    .isInstanceOf(KubernetesException.class)\n                                    .hasMessage(errorMsg);\n                        });\n            }\n        };\n    }"
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f2417a74bd7592ddf78adffebf754f829081ebbf^1/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/watermarkstatus/StatusWatermarkValve.java",
      "locators": [
          {
              "line": 194,
              "column": 17
          },
          {
              "line": 198,
              "column": 13
          }
      ],
      "old_name": "hasAlignedChannels",
      "new_name": "hasAlignedSubpartitions",
      "ctx": {
          "symbolName": "hasAlignedChannels",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "boolean",
          "scopeHint": "in findAndOutputNewMinWatermarkAcrossAlignedChannels(...)",
          "filePath": "StatusWatermarkValve.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void findAndOutputNewMinWatermarkAcrossAlignedChannels(DataOutput<?> output)\n            throws Exception {\n        boolean hasAlignedChannels = !alignedChannelStatuses.isEmpty();\n\n        // we acknowledge and output the new overall watermark if it really is aggregated\n        // from some remaining aligned channel, and is also larger than the last output watermark\n        if (hasAlignedChannels && alignedChannelStatuses.peek().watermark > lastOutputWatermark) {\n            lastOutputWatermark = alignedChannelStatuses.peek().watermark;\n            output.emitWatermark(new Watermark(lastOutputWatermark));\n        }\n    }",
          "conflictNames": [
              "output"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f2417a74bd7592ddf78adffebf754f829081ebbf^1/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/watermarkstatus/StatusWatermarkValve.java",
      "locators": [
          {
              "line": 50,
              "column": 40
          },
          {
              "line": 68,
              "column": 14
          },
          {
              "line": 74,
              "column": 13
          },
          {
              "line": 75,
              "column": 13
          },
          {
              "line": 76,
              "column": 13
          },
          {
              "line": 77,
              "column": 34
          },
          {
              "line": 98,
              "column": 20
          },
          {
              "line": 103,
              "column": 35
          },
          {
              "line": 104,
              "column": 17
          },
          {
              "line": 106,
              "column": 21
          },
          {
              "line": 107,
              "column": 50
          },
          {
              "line": 111,
              "column": 42
          },
          {
              "line": 136,
              "column": 41
          },
          {
              "line": 138,
              "column": 13
          },
          {
              "line": 141,
              "column": 36
          },
          {
              "line": 145,
              "column": 55
          },
          {
              "line": 157,
              "column": 21
          },
          {
              "line": 163,
              "column": 24
          },
          {
              "line": 170,
              "column": 20
          },
          {
              "line": 172,
              "column": 13
          },
          {
              "line": 178,
              "column": 17
          },
          {
              "line": 179,
              "column": 38
          },
          {
              "line": 244,
              "column": 33
          },
          {
              "line": 244,
              "column": 49
          },
          {
              "line": 245,
              "column": 37
          },
          {
              "line": 285,
              "column": 71
          },
          {
              "line": 286,
              "column": 46
          },
          {
              "line": 319,
              "column": 53
          },
          {
              "line": 320,
              "column": 71
          },
          {
              "line": 322,
              "column": 16
          }
      ],
      "old_name": "channelStatus",
      "new_name": "subpartitionStatus",
      "ctx": {
          "symbolName": "channelStatus",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "InputChannelStatus",
          "scopeHint": "in findAndOutputMaxWatermarkAcrossAllChannels(...)",
          "filePath": "StatusWatermarkValve.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "        alignedChannelStatuses.adjustModifiedElement(inputChannelStatus);\n    }\n\n    private void findAndOutputMaxWatermarkAcrossAllChannels(DataOutput<?> output) throws Exception {\n        long maxWatermark = Long.MIN_VALUE;\n\n        for (InputChannelStatus channelStatus : channelStatuses) {\n            maxWatermark = Math.max(channelStatus.watermark, maxWatermark);\n        }\n\n        if (maxWatermark > lastOutputWatermark) {\n            lastOutputWatermark = maxWatermark;\n            output.emitWatermark(",
          "conflictNames": [
              "output",
              "maxWatermark"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f2568dee63138899cb80982a9659ab25f0d38c2c^1/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/state/rocksdb/RocksDBListState.java",
      "locators": [
          {
              "line": 207,
              "column": 27
          },
          {
              "line": 217,
              "column": 58
          }
      ],
      "old_name": "priorElementSerializer",
      "new_name": "priorTtlAwareElementSerializer",
      "ctx": {
          "symbolName": "priorElementSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TypeSerializer<V>",
          "scopeHint": "in migrateSerializedValue(...)",
          "filePath": "RocksDBListState.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void migrateSerializedValue(\n            DataInputDeserializer serializedOldValueInput,\n            DataOutputSerializer serializedMigratedValueOutput,\n            TypeSerializer<List<V>> priorSerializer,\n            TypeSerializer<List<V>> newSerializer)\n            throws StateMigrationException {\n\n        Preconditions.checkArgument(priorSerializer instanceof ListSerializer);\n        Preconditions.checkArgument(newSerializer instanceof ListSerializer);\n\n        TypeSerializer<V> priorElementSerializer =\n                ((ListSerializer<V>) priorSerializer).getElementSerializer();\n\n        TypeSerializer<V> newElementSerializer =\n                ((ListSerializer<V>) newSerializer).getElementSerializer();\n\n        try {\n            while (serializedOldValueInput.available() > 0) {\n                V element =\n                        ListDelimitedSerializer.deserializeNextElement(\n                                serializedOldValueInput, priorElementSerializer);\n                newElementSerializer.serialize(element, serializedMigratedValueOutput);\n                if (serializedOldValueInput.available() > 0) {\n                    serializedMigratedValueOutput.write(DELIMITER);\n                }\n            }\n        } catch (Exception e) {\n            throw new StateMigrationException(\n                    \"Error while trying to migrate RocksDB list state.\", e);\n        }\n    }",
          "conflictNames": [
              "serializedOldValueInput",
              "serializedMigratedValueOutput",
              "priorSerializer",
              "newSerializer",
              "newElementSerializer",
              "element"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f2568dee63138899cb80982a9659ab25f0d38c2c^1/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/state/rocksdb/RocksDBListState.java",
      "locators": [
          {
              "line": 210,
              "column": 27
          },
          {
              "line": 218,
              "column": 17
          }
      ],
      "old_name": "newElementSerializer",
      "new_name": "newTtlAwareElementSerializer",
      "ctx": {
          "symbolName": "newElementSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TypeSerializer<V>",
          "scopeHint": "in migrateSerializedValue(...)",
          "filePath": "RocksDBListState.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void migrateSerializedValue(\n            DataInputDeserializer serializedOldValueInput,\n            DataOutputSerializer serializedMigratedValueOutput,\n            TypeSerializer<List<V>> priorSerializer,\n            TypeSerializer<List<V>> newSerializer)\n            throws StateMigrationException {\n\n        Preconditions.checkArgument(priorSerializer instanceof ListSerializer);\n        Preconditions.checkArgument(newSerializer instanceof ListSerializer);\n\n        TypeSerializer<V> priorElementSerializer =\n                ((ListSerializer<V>) priorSerializer).getElementSerializer();\n\n        TypeSerializer<V> newElementSerializer =\n                ((ListSerializer<V>) newSerializer).getElementSerializer();\n\n        try {\n            while (serializedOldValueInput.available() > 0) {\n                V element =\n                        ListDelimitedSerializer.deserializeNextElement(\n                                serializedOldValueInput, priorElementSerializer);\n                newElementSerializer.serialize(element, serializedMigratedValueOutput);\n                if (serializedOldValueInput.available() > 0) {\n                    serializedMigratedValueOutput.write(DELIMITER);\n                }\n            }\n        } catch (Exception e) {\n            throw new StateMigrationException(\n                    \"Error while trying to migrate RocksDB list state.\", e);\n        }\n    }",
          "conflictNames": [
              "serializedOldValueInput",
              "serializedMigratedValueOutput",
              "priorSerializer",
              "newSerializer",
              "priorElementSerializer",
              "element"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f2568dee63138899cb80982a9659ab25f0d38c2c^1/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/state/rocksdb/RocksDBMapState.java",
      "locators": [
          {
              "line": 234,
              "column": 28
          },
          {
              "line": 243,
              "column": 32
          }
      ],
      "old_name": "priorMapValueSerializer",
      "new_name": "priorTtlAwareMapValueSerializer",
      "ctx": {
          "symbolName": "priorMapValueSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TypeSerializer<UV>",
          "scopeHint": "in migrateSerializedValue(...)",
          "filePath": "RocksDBMapState.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void migrateSerializedValue(\n            DataInputDeserializer serializedOldValueInput,\n            DataOutputSerializer serializedMigratedValueOutput,\n            TypeSerializer<Map<UK, UV>> priorSerializer,\n            TypeSerializer<Map<UK, UV>> newSerializer)\n            throws StateMigrationException {\n\n        checkArgument(priorSerializer instanceof MapSerializer);\n        checkArgument(newSerializer instanceof MapSerializer);\n\n        TypeSerializer<UV> priorMapValueSerializer =\n                ((MapSerializer<UK, UV>) priorSerializer).getValueSerializer();\n        TypeSerializer<UV> newMapValueSerializer =\n                ((MapSerializer<UK, UV>) newSerializer).getValueSerializer();\n\n        try {\n            boolean isNull = serializedOldValueInput.readBoolean();\n            UV mapUserValue = null;\n            if (!isNull) {\n                mapUserValue = priorMapValueSerializer.deserialize(serializedOldValueInput);\n            }\n            serializedMigratedValueOutput.writeBoolean(mapUserValue == null);\n            newMapValueSerializer.serialize(mapUserValue, serializedMigratedValueOutput);\n        } catch (Exception e) {\n            throw new StateMigrationException(\n                    \"Error while trying to migrate RocksDB map state.\", e);\n        }\n    }",
          "conflictNames": [
              "serializedOldValueInput",
              "serializedMigratedValueOutput",
              "priorSerializer",
              "newSerializer",
              "newMapValueSerializer",
              "isNull",
              "mapUserValue"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f2568dee63138899cb80982a9659ab25f0d38c2c^1/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/state/rocksdb/RocksDBMapState.java",
      "locators": [
          {
              "line": 236,
              "column": 28
          },
          {
              "line": 246,
              "column": 13
          }
      ],
      "old_name": "newMapValueSerializer",
      "new_name": "newTtlAwareMapValueSerializer",
      "ctx": {
          "symbolName": "newMapValueSerializer",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TypeSerializer<UV>",
          "scopeHint": "in migrateSerializedValue(...)",
          "filePath": "RocksDBMapState.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public void migrateSerializedValue(\n            DataInputDeserializer serializedOldValueInput,\n            DataOutputSerializer serializedMigratedValueOutput,\n            TypeSerializer<Map<UK, UV>> priorSerializer,\n            TypeSerializer<Map<UK, UV>> newSerializer)\n            throws StateMigrationException {\n\n        checkArgument(priorSerializer instanceof MapSerializer);\n        checkArgument(newSerializer instanceof MapSerializer);\n\n        TypeSerializer<UV> priorMapValueSerializer =\n                ((MapSerializer<UK, UV>) priorSerializer).getValueSerializer();\n        TypeSerializer<UV> newMapValueSerializer =\n                ((MapSerializer<UK, UV>) newSerializer).getValueSerializer();\n\n        try {\n            boolean isNull = serializedOldValueInput.readBoolean();\n            UV mapUserValue = null;\n            if (!isNull) {\n                mapUserValue = priorMapValueSerializer.deserialize(serializedOldValueInput);\n            }\n            serializedMigratedValueOutput.writeBoolean(mapUserValue == null);\n            newMapValueSerializer.serialize(mapUserValue, serializedMigratedValueOutput);\n        } catch (Exception e) {\n            throw new StateMigrationException(\n                    \"Error while trying to migrate RocksDB map state.\", e);\n        }\n    }",
          "conflictNames": [
              "serializedOldValueInput",
              "serializedMigratedValueOutput",
              "priorSerializer",
              "newSerializer",
              "priorMapValueSerializer",
              "isNull",
              "mapUserValue"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f32b2a9e347d7539819a88252e4e32deba247515^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/hint/CapitalizeQueryHintsShuttle.java",
      "locators": [
          {
              "line": 36,
              "column": 18
          },
          {
              "line": 39,
              "column": 17
          },
          {
              "line": 72,
              "column": 32
          }
      ],
      "old_name": "hBiRel",
      "new_name": "hNode",
      "ctx": {
          "symbolName": "hBiRel",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Hintable",
          "scopeHint": "in visitBiRel(...)",
          "filePath": "CapitalizeQueryHintsShuttle.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    protected RelNode visitBiRel(BiRel biRel) {\n        Hintable hBiRel = (Hintable) biRel;\n        AtomicBoolean changed = new AtomicBoolean(false);\n        List<RelHint> hintsWithCapitalJoinHints =\n                hBiRel.getHints().stream()\n                        .map(\n                                hint -> {\n                                    String capitalHintName = hint.hintName.toUpperCase(Locale.ROOT);\n                                    if (!FlinkHints.isQueryHint(capitalHintName)\n                                            || hint.hintName.equals(capitalHintName)) {\n                                        return hint;\n                                    }\n\n                                    changed.set(true);\n                                    if (JoinStrategy.isJoinStrategy(capitalHintName)) {\n                                        if (JoinStrategy.isLookupHint(hint.hintName)) {\n                                            return RelHint.builder(capitalHintName)\n                                                    .hintOptions(hint.kvOptions)\n                                                    .inheritPath(hint.inheritPath)\n                                                    .build();\n                                        }\n                                        return RelHint.builder(capitalHintName)\n                                                .hintOptions(hint.listOptions)\n                                                .inheritPath(hint.inheritPath)\n                                                .build();\n                                    } else if (StateTtlHint.isStateTtlHint(hint.hintName)) {\n                                        return RelHint.builder(capitalHintName)\n                                                .hintOptions(hint.kvOptions)\n                                                .inheritPath(hint.inheritPath)\n                                                .build();\n                                    }\n                                    throw new IllegalStateException(\n                                            \"Unknown hint: \" + hint.hintName);\n                                })\n                        .collect(Collectors.toList());\n\n        if (changed.get()) {\n            return super.visit(hBiRel.withHints(hintsWithCapitalJoinHints));\n        } else {\n            return super.visit(biRel);\n        }\n    }",
          "conflictNames": [
              "biRel",
              "changed",
              "hintsWithCapitalJoinHints",
              "capitalHintName"
          ]
      },
      "suggestions": [
          {
              "name": "hNode",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/f32b2a9e347d7539819a88252e4e32deba247515^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/hint/ClearQueryHintsWithInvalidPropagationShuttle.java",
      "locators": [
          {
              "line": 140,
              "column": 22
          },
          {
              "line": 141,
              "column": 51
          },
          {
              "line": 147,
              "column": 36
          }
      ],
      "old_name": "hBiRel",
      "new_name": "hNode",
      "ctx": {
          "symbolName": "hBiRel",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Hintable",
          "scopeHint": "in visitBiRel(...)",
          "filePath": "ClearQueryHintsWithInvalidPropagationShuttle.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private RelNode visitBiRel(BiRel biRel) {\n            Hintable hBiRel = (Hintable) biRel;\n            List<RelHint> hints = new ArrayList<>(hBiRel.getHints());\n            Optional<RelHint> invalidQueryHint = getInvalidQueryHint(hints);\n\n            // if this node contains the query hint that needs to be removed\n            if (invalidQueryHint.isPresent()) {\n                hints.remove(invalidQueryHint.get());\n                return super.visit(hBiRel.withHints(hints));\n            }\n\n            return super.visit(biRel);\n        }",
          "conflictNames": [
              "biRel",
              "hints",
              "invalidQueryHint"
          ]
      },
      "suggestions": [
          {
              "name": "hNode",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/f37d41cf557e9acd113a063dbee442a3a92bf09e^1/flink-runtime/src/test/java/org/apache/flink/runtime/highavailability/nonha/embedded/EmbeddedHaServicesTest.java",
      "locators": [
          {
              "line": 145,
              "column": 36
          },
          {
              "line": 148,
              "column": 20
          },
          {
              "line": 149,
              "column": 20
          }
      ],
      "old_name": "leaderConnectionInfo",
      "new_name": "leaderInformation",
      "ctx": {
          "symbolName": "leaderConnectionInfo",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "LeaderConnectionInfo",
          "scopeHint": "in runLeaderRetrievalTest(...)",
          "filePath": "EmbeddedHaServicesTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void runLeaderRetrievalTest(\n            LeaderElection leaderElection, LeaderRetrievalService leaderRetrievalService)\n            throws Exception {\n        LeaderRetrievalUtils.LeaderConnectionInfoListener leaderRetrievalListener =\n                new LeaderRetrievalUtils.LeaderConnectionInfoListener();\n        TestingLeaderContender leaderContender = new TestingLeaderContender();\n\n        leaderRetrievalService.start(leaderRetrievalListener);\n        leaderElection.startLeaderElection(leaderContender);\n\n        final UUID leaderId = leaderContender.getLeaderSessionFuture().get();\n\n        leaderElection.confirmLeadership(leaderId, ADDRESS);\n\n        final LeaderConnectionInfo leaderConnectionInfo =\n                leaderRetrievalListener.getLeaderConnectionInfoFuture().get();\n\n        assertThat(leaderConnectionInfo.getAddress(), is(ADDRESS));\n        assertThat(leaderConnectionInfo.getLeaderSessionId(), is(leaderId));\n    }",
          "conflictNames": [
              "leaderElection",
              "leaderRetrievalService",
              "leaderRetrievalListener",
              "leaderContender",
              "leaderId"
          ]
      },
      "suggestions": [
          {
              "name": "leaderInformation",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/f37d41cf557e9acd113a063dbee442a3a92bf09e^1/flink-runtime/src/main/java/org/apache/flink/runtime/util/LeaderRetrievalUtils.java",
      "locators": [
          {
              "line": 128,
              "column": 44
          },
          {
              "line": 130,
              "column": 47
          }
      ],
      "old_name": "leaderConnectionInfo",
      "new_name": "leaderInformation",
      "ctx": {
          "symbolName": "leaderConnectionInfo",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "LeaderConnectionInfo",
          "scopeHint": "in notifyLeaderAddress(...)",
          "filePath": "LeaderRetrievalUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public void notifyLeaderAddress(String leaderAddress, UUID leaderSessionID) {\n            if (leaderAddress != null\n                    && !leaderAddress.equals(\"\")\n                    && !connectionInfoFuture.isDone()) {\n                final LeaderConnectionInfo leaderConnectionInfo =\n                        new LeaderConnectionInfo(leaderSessionID, leaderAddress);\n                connectionInfoFuture.complete(leaderConnectionInfo);\n            }\n        }",
          "conflictNames": [
              "leaderAddress",
              "leaderSessionID"
          ]
      },
      "suggestions": [
          {
              "name": "leaderInformation",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/f476675d4545ef2fa547ecabeebaf991ed1d91dd^1/flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/table/planner/delegation/hive/parse/HiveParserDDLSemanticAnalyzer.java",
      "locators": [
          {
              "line": 2183,
              "column": 37
          },
          {
              "line": 2185,
              "column": 17
          },
          {
              "line": 2189,
              "column": 17
          },
          {
              "line": 2193,
              "column": 16
          }
      ],
      "old_name": "catalogBaseTable",
      "new_name": "resolvedCatalogBaseTable",
      "ctx": {
          "symbolName": "catalogBaseTable",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ResolvedCatalogBaseTable<?>",
          "scopeHint": "in getAlteredTable(...)",
          "filePath": "HiveParserDDLSemanticAnalyzer.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private ResolvedCatalogBaseTable<?> getAlteredTable(String tableName, boolean expectView) {\n        ObjectIdentifier objectIdentifier = parseObjectIdentifier(tableName);\n        ResolvedCatalogBaseTable<?> catalogBaseTable = getCatalogBaseTable(objectIdentifier);\n        if (expectView) {\n            if (catalogBaseTable instanceof CatalogTable) {\n                throw new ValidationException(\"ALTER VIEW for a table is not allowed\");\n            }\n        } else {\n            if (catalogBaseTable instanceof CatalogView) {\n                throw new ValidationException(\"ALTER TABLE for a view is not allowed\");\n            }\n        }\n        return catalogBaseTable;\n    }",
          "conflictNames": [
              "tableName",
              "expectView",
              "objectIdentifier"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f47b3704867b1d5aa754b1f7325f54e1830014cd^1/flink-table/flink-table-common/src/main/java/org/apache/flink/table/factories/FactoryUtil.java",
      "locators": [
          {
              "line": 804,
              "column": 29
          },
          {
              "line": 822,
              "column": 29
          },
          {
              "line": 824,
              "column": 16
          }
      ],
      "old_name": "result",
      "new_name": "loadResults",
      "ctx": {
          "symbolName": "result",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<Factory>",
          "scopeHint": "in discoverFactories(...)",
          "filePath": "FactoryUtil.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "static List<Factory> discoverFactories(ClassLoader classLoader) {\n        final List<Factory> result = new LinkedList<>();\n        ServiceLoaderUtil.load(Factory.class, classLoader)\n                .forEach(\n                        loadResult -> {\n                            if (loadResult.hasFailed()) {\n                                if (loadResult.getError() instanceof NoClassDefFoundError) {\n                                    LOG.debug(\n                                            \"NoClassDefFoundError when loading a \"\n                                                    + Factory.class\n                                                    + \". This is expected when trying to load a format dependency but no flink-connector-files is loaded.\",\n                                            loadResult.getError());\n                                    // After logging, we just ignore this failure\n                                    return;\n                                }\n                                throw new TableException(\n                                        \"Unexpected error when trying to load service provider for factories.\",\n                                        loadResult.getError());\n                            }\n                            result.add(loadResult.getService());\n                        });\n        return result;\n    }",
          "conflictNames": [
              "classLoader"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f480b6d313f64ff5d8d1e6f1d74f2dacc3ea133b^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/exec/batch/BatchExecMultipleInput.java",
      "locators": [
          {
              "line": 143,
              "column": 43
          },
          {
              "line": 168,
              "column": 17
          },
          {
              "line": 187,
              "column": 79
          }
      ],
      "old_name": "multipleInputSpecs",
      "new_name": "inputSelectionSpecs",
      "ctx": {
          "symbolName": "multipleInputSpecs",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<MultipleInputSpec>",
          "scopeHint": "in translateToPlanInternal(...)",
          "filePath": "BatchExecMultipleInput.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    protected Transformation<RowData> translateToPlanInternal(\n            PlannerBase planner, ExecNodeConfig config) {\n        List<Transformation<?>> inputTransforms = new ArrayList<>();\n        for (ExecEdge inputEdge : getInputEdges()) {\n            inputTransforms.add(inputEdge.translateToPlan(planner));\n        }\n        final Transformation<?> outputTransform = rootNode.translateToPlan(planner);\n        final int[] readOrders =\n                getInputProperties().stream()\n                        .map(InputProperty::getPriority)\n                        .mapToInt(i -> i)\n                        .toArray();\n\n        StreamOperatorFactory<RowData> operatorFactory;\n        int parallelism;\n        int maxParallelism;\n        long memoryBytes;\n        ResourceSpec minResources = null;\n        ResourceSpec preferredResources = null;\n\n        boolean fusionCodegenEnabled = config.get(TABLE_EXEC_OPERATOR_FUSION_CODEGEN_ENABLED);\n        // multiple operator fusion codegen\n        if (fusionCodegenEnabled && allSupportFusionCodegen()) {\n            final List<MultipleInputSpec> multipleInputSpecs = new ArrayList<>();\n            int i = 0;\n            for (ExecEdge inputEdge : originalEdges) {\n                int multipleInputId = i + 1;\n                BatchExecNode<RowData> source = (BatchExecNode<RowData>) inputEdge.getSource();\n                BatchExecInputAdapter inputAdapter =\n                        new BatchExecInputAdapter(\n                                multipleInputId,\n                                TableConfig.getDefault(),\n                                InputProperty.builder().priority(readOrders[i]).build(),\n                                source.getOutputType(),\n                                \"BatchInputAdapter\");\n                inputAdapter.setInputEdges(\n                        Collections.singletonList(\n                                ExecEdge.builder().source(source).target(inputAdapter).build()));\n\n                BatchExecNode<RowData> target = (BatchExecNode<RowData>) inputEdge.getTarget();\n                int edgeIdxInTargetNode = target.getInputEdges().indexOf(inputEdge);\n                checkArgument(edgeIdxInTargetNode >= 0);\n\n                target.replaceInputEdge(\n                        edgeIdxInTargetNode,\n                        ExecEdge.builder().source(inputAdapter).target(target).build());\n\n                // The input id and read order\n                multipleInputSpecs.add(new MultipleInputSpec(multipleInputId, readOrders[i]));\n                i++;\n            }\n\n            OpFusionCodegenSpecGenerator inputGenerator =\n                    rootNode.translateToFusionCodegenSpec(planner);\n            // wrap output operator spec generator of fusion codegen\n            OpFusionCodegenSpecGenerator outputGenerator =\n                    new OneInputOpFusionCodegenSpecGenerator(\n                            inputGenerator,\n                            0L,\n                            (RowType) getOutputType(),\n                            new OutputFusionCodegenSpec(\n                                    new CodeGeneratorContext(\n                                            config, planner.getFlinkContext().getClassLoader())));\n            inputGenerator.addOutput(1, outputGenerator);\n\n            // generate fusion operator\n            Tuple2<OperatorFusionCodegenFactory<RowData>, Object> multipleOperatorTuple =\n                    FusionCodegenUtil.generateFusionOperator(outputGenerator, multipleInputSpecs);\n            operatorFactory = multipleOperatorTuple._1;\n\n            Pair<Integer, Integer> parallelismPair = getInputMaxParallelism(inputTransforms);\n            parallelism = parallelismPair.getLeft();\n            maxParallelism = parallelismPair.getRight();\n            memoryBytes = (long) multipleOperatorTuple._2;\n        } else {\n            final TableOperatorWrapperGenerator generator =\n                    new TableOperatorWrapperGenerator(inputTransforms, outputTransform, readOrders);\n            generator.generate();\n\n            final List<Pair<Transformation<?>, InputSpec>> inputTransformAndInputSpecPairs =\n                    generator.getInputTransformAndInputSpecPairs();\n            operatorFactory =\n                    new BatchMultipleInputStreamOperatorFactory(\n                            inputTransformAndInputSpecPairs.stream()\n                                    .map(Pair::getValue)\n                                    .collect(Collectors.toList()),\n                            generator.getHeadWrappers(),\n                            generator.getTailWrapper());\n\n            parallelism = generator.getParallelism();\n            maxParallelism = generator.getMaxParallelism();\n            final int memoryWeight = generator.getManagedMemoryWeight();\n            memoryBytes = (long) memoryWeight << 20;\n\n            minResources = generator.getMinResources();\n            preferredResources = generator.getPreferredResources();\n            // here set the all elements of InputTransformation and its id index indicates the order\n            inputTransforms =\n                    inputTransformAndInputSpecPairs.stream()\n                            .map(Pair::getKey)\n                            .collect(Collectors.toList());\n        }\n\n        final MultipleInputTransformation<RowData> multipleInputTransform =\n                new MultipleInputTransformation<>(\n                        createTransformationName(config),\n                        operatorFactory,\n                        InternalTypeInfo.of(getOutputType()),\n                        parallelism,\n                        false);\n        multipleInputTransform.setDescription(createTransformationDescription(config));\n        if (maxParallelism > 0) {\n            multipleInputTransform.setMaxParallelism(maxParallelism);\n        }\n\n        for (Transformation input : inputTransforms) {\n            multipleInputTransform.addInput(input);\n        }\n\n        // set resources\n        if (minResources != null && preferredResources != null) {\n            multipleInputTransform.setResources(minResources, preferredResources);\n        }\n\n        multipleInputTransform.setDescription(createTransformationDescription(config));\n        ExecNodeUtil.setManagedMemoryWeight(multipleInputTransform, memoryBytes);\n\n        // set chaining strategy for source chaining\n        multipleInputTransform.setChainingStrategy(ChainingStrategy.HEAD_WITH_SOURCES);\n\n        return multipleInputTransform;\n    }",
          "conflictNames": [
              "planner",
              "config",
              "inputTransforms",
              "outputTransform",
              "readOrders",
              "operatorFactory",
              "parallelism",
              "maxParallelism",
              "memoryBytes",
              "minResources",
              "preferredResources",
              "fusionCodegenEnabled",
              "i",
              "multipleInputId",
              "source",
              "inputAdapter",
              "target",
              "edgeIdxInTargetNode",
              "inputGenerator",
              "outputGenerator",
              "multipleOperatorTuple",
              "parallelismPair",
              "generator",
              "inputTransformAndInputSpecPairs",
              "memoryWeight",
              "multipleInputTransform"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f611ea8cb5deddb42429df2c99f0c68d7382e9bd^1/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManagerTest.java",
      "locators": [
          {
              "line": 322,
              "column": 40
          },
          {
              "line": 324,
              "column": 58
          },
          {
              "line": 330,
              "column": 72
          },
          {
              "line": 336,
              "column": 69
          },
          {
              "line": 341,
              "column": 93
          },
          {
              "line": 392,
              "column": 80
          }
      ],
      "old_name": "resourceID1",
      "new_name": "normalResource",
      "ctx": {
          "symbolName": "resourceID1",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ResourceID",
          "scopeHint": "in testMoreThanDeclaredResource(...)",
          "filePath": "ActiveResourceManagerTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/** Test release workers if more than resources declared. */\n    @Test\n    public void testMoreThanDeclaredResource() throws Exception {\n        new Context() {\n            {\n                final AtomicInteger requestCount = new AtomicInteger(0);\n                final List<CompletableFuture<ResourceID>> resourceIdFutures =\n                        Arrays.asList(\n                                CompletableFuture.completedFuture(ResourceID.generate()),\n                                CompletableFuture.completedFuture(ResourceID.generate()));\n\n                final AtomicInteger releaseCount = new AtomicInteger(0);\n                final List<CompletableFuture<ResourceID>> releaseResourceFutures =\n                        Collections.singletonList(new CompletableFuture<>());\n\n                driverBuilder\n                        .setRequestResourceFunction(\n                                taskExecutorProcessSpec ->\n                                        resourceIdFutures.get(requestCount.getAndIncrement()))\n                        .setReleaseResourceConsumer(\n                                resourceID ->\n                                        releaseResourceFutures\n                                                .get(releaseCount.getAndIncrement())\n                                                .complete(resourceID));\n\n                runTest(\n                        () -> {\n                            // request two new workers.\n                            runInMainThread(\n                                    () -> {\n                                        for (int i = 0; i < 2; i++) {\n                                            getResourceManager()\n                                                    .requestNewWorker(WORKER_RESOURCE_SPEC);\n                                        }\n                                    });\n                            ResourceID resourceID1 = resourceIdFutures.get(0).get();\n                            CompletableFuture<RegistrationResponse> registerTaskExecutorFuture =\n                                    registerTaskExecutor(resourceID1);\n                            assertThat(\n                                    registerTaskExecutorFuture.get(TIMEOUT_SEC, TimeUnit.SECONDS),\n                                    instanceOf(RegistrationResponse.Success.class));\n                            InstanceID instanceID1 =\n                                    getResourceManager()\n                                            .getInstanceIdByResourceId(resourceID1)\n                                            .get();\n                            runInMainThread(\n                                            () ->\n                                                    getResourceManager()\n                                                            .sendSlotReport(\n                                                                    resourceID1,\n                                                                    instanceID1,\n                                                                    new SlotReport(\n                                                                            new SlotStatus(\n                                                                                    new SlotID(\n                                                                                            resourceID1,\n                                                                                            0),\n                                                                                    ResourceProfile\n                                                                                            .ANY)),\n                                                                    TIMEOUT_TIME))\n                                    .get(TIMEOUT_SEC, TimeUnit.SECONDS);\n\n                            ResourceID resourceID2 = resourceIdFutures.get(1).get();\n                            registerTaskExecutorFuture = registerTaskExecutor(resourceID2);\n                            assertThat(\n                                    registerTaskExecutorFuture.get(TIMEOUT_SEC, TimeUnit.SECONDS),\n                                    instanceOf(RegistrationResponse.Success.class));\n                            InstanceID instanceID2 =\n                                    getResourceManager()\n                                            .getInstanceIdByResourceId(resourceID2)\n                                            .get();\n                            runInMainThread(\n                                            () ->\n                                                    getResourceManager()\n                                                            .sendSlotReport(\n                                                                    resourceID2,\n                                                                    instanceID2,\n                                                                    new SlotReport(\n                                                                            new SlotStatus(\n                                                                                    new SlotID(\n                                                                                            resourceID2,\n                                                                                            0),\n                                                                                    ResourceProfile\n                                                                                            .ANY)),\n                                                                    TIMEOUT_TIME))\n                                    .get(TIMEOUT_SEC, TimeUnit.SECONDS);\n\n                            // declare resource needed, will release unwanted worker.\n                            CompletableFuture<Void> declareResourceFuture =\n                                    runInMainThread(\n                                            () ->\n                                                    getResourceManager()\n                                                            .declareResourceNeeded(\n                                                                    Collections.singleton(\n                                                                            new ResourceDeclaration(\n                                                                                    WORKER_RESOURCE_SPEC,\n                                                                                    1,\n                                                                                    Collections\n                                                                                            .singleton(\n                                                                                                    instanceID1)))));\n\n                            declareResourceFuture.get(TIMEOUT_SEC, TimeUnit.SECONDS);\n\n                            // release 1 worker.\n                            assertThat(releaseCount.get(), is(1));\n                            // release less wanted worker.\n                            assertThat(releaseResourceFutures.get(0).get(), is(resourceID1));\n                        });\n            }\n        };\n    }",
          "conflictNames": [
              "requestCount",
              "resourceIdFutures",
              "releaseCount",
              "releaseResourceFutures",
              "i",
              "registerTaskExecutorFuture",
              "instanceID1",
              "resourceID2",
              "instanceID2",
              "declareResourceFuture"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f68967a7c938f6258125c3221be74522965d1ff2^1/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/catalog/FileCatalogStore.java",
      "locators": [
          {
              "line": 100,
              "column": 14
          },
          {
              "line": 102,
              "column": 25
          },
          {
              "line": 107,
              "column": 46
          },
          {
              "line": 113,
              "column": 82
          },
          {
              "line": 118,
              "column": 42
          }
      ],
      "old_name": "filePath",
      "new_name": "catalogPath",
      "ctx": {
          "symbolName": "filePath",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Path",
          "scopeHint": "in storeCatalog(...)",
          "filePath": "FileCatalogStore.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Stores the specified catalog in the catalog store.\n     *\n     * @param catalogName the name of the catalog\n     * @param catalog the catalog descriptor to store\n     * @throws CatalogException if the catalog store is not open or if there is an error storing the\n     *     catalog\n     */\n    @Override\n    public void storeCatalog(String catalogName, CatalogDescriptor catalog)\n            throws CatalogException {\n        checkOpenState();\n\n        Path filePath = getCatalogPath(catalogName);\n        try {\n            File file = filePath.toFile();\n            if (file.exists()) {\n                throw new CatalogException(\n                        String.format(\n                                \"Catalog %s's store file %s is already exist.\",\n                                catalogName, filePath));\n            }\n            // create a new file\n            file.createNewFile();\n            String yamlString = yaml.dumpAsMap(catalog.getConfiguration().toMap());\n            FileUtils.writeFile(file, yamlString, charset);\n            LOG.info(\"Catalog {}'s configuration saved to file {}\", catalogName, filePath);\n        } catch (Throwable e) {\n            throw new CatalogException(\n                    String.format(\n                            \"Failed to save catalog %s's configuration to file %s : %s\",\n                            catalogName, filePath, e.getMessage()),\n                    e);\n        }\n    }",
          "conflictNames": [
              "catalogName",
              "catalog",
              "file",
              "yamlString"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f68967a7c938f6258125c3221be74522965d1ff2^1/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/catalog/FileCatalogStore.java",
      "locators": [
          {
              "line": 51,
              "column": 23
          },
          {
              "line": 61,
              "column": 85
          },
          {
              "line": 63,
              "column": 51
          },
          {
              "line": 136,
              "column": 14
          },
          {
              "line": 138,
              "column": 25
          },
          {
              "line": 144,
              "column": 50
          },
          {
              "line": 146,
              "column": 38
          },
          {
              "line": 151,
              "column": 93
          },
          {
              "line": 176,
              "column": 14
          },
          {
              "line": 178,
              "column": 25
          },
          {
              "line": 180,
              "column": 85
          }
      ],
      "old_name": "path",
      "new_name": "catalogPath",
      "ctx": {
          "symbolName": "path",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Path",
          "scopeHint": "in removeCatalog(...)",
          "filePath": "FileCatalogStore.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Removes the specified catalog from the catalog store.\n     *\n     * @param catalogName the name of the catalog to remove\n     * @param ignoreIfNotExists whether to ignore if the catalog does not exist in the catalog store\n     * @throws CatalogException if the catalog store is not open or if there is an error removing\n     *     the catalog\n     */\n    @Override\n    public void removeCatalog(String catalogName, boolean ignoreIfNotExists)\n            throws CatalogException {\n        checkOpenState();\n\n        Path path = getCatalogPath(catalogName);\n        try {\n            File file = path.toFile();\n            if (file.exists()) {\n                if (!file.isFile()) {\n                    throw new CatalogException(\n                            String.format(\n                                    \"Catalog %s's store file %s is not a regular file\",\n                                    catalogName, path.getFileName()));\n                }\n                Files.deleteIfExists(path);\n            } else {\n                if (!ignoreIfNotExists) {\n                    throw new CatalogException(\n                            String.format(\n                                    \"Catalog %s's store file %s is not exist\", catalogName, path));\n                }\n            }\n        } catch (Throwable e) {\n            throw new CatalogException(\n                    String.format(\n                            \"Failed to delete catalog %s's store file: %s\",\n                            catalogName, e.getMessage()),\n                    e);\n        }\n    }",
          "conflictNames": [
              "catalogName",
              "ignoreIfNotExists",
              "file"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f68967a7c938f6258125c3221be74522965d1ff2^1/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/catalog/FileCatalogStore.java",
      "locators": [
          {
              "line": 2,
              "column": 13
          },
          {
              "line": 2,
              "column": 16
          },
          {
              "line": 2,
              "column": 30
          },
          {
              "line": 2,
              "column": 42
          },
          {
              "line": 3,
              "column": 15
          },
          {
              "line": 3,
              "column": 20
          },
          {
              "line": 3,
              "column": 40
          },
          {
              "line": 3,
              "column": 49
          },
          {
              "line": 4,
              "column": 7
          },
          {
              "line": 4,
              "column": 12
          },
          {
              "line": 4,
              "column": 18
          },
          {
              "line": 4,
              "column": 21
          },
          {
              "line": 4,
              "column": 39
          },
          {
              "line": 4,
              "column": 53
          },
          {
              "line": 5,
              "column": 22
          },
          {
              "line": 5,
              "column": 53
          },
          {
              "line": 6,
              "column": 4
          },
          {
              "line": 6,
              "column": 17
          },
          {
              "line": 6,
              "column": 50
          },
          {
              "line": 7,
              "column": 26
          },
          {
              "line": 7,
              "column": 32
          },
          {
              "line": 7,
              "column": 47
          },
          {
              "line": 8,
              "column": 6
          },
          {
              "line": 8,
              "column": 9
          },
          {
              "line": 8,
              "column": 33
          },
          {
              "line": 8,
              "column": 48
          },
          {
              "line": 8,
              "column": 61
          },
          {
              "line": 10,
              "column": 9
          },
          {
              "line": 10,
              "column": 10
          },
          {
              "line": 12,
              "column": 48
          },
          {
              "line": 12,
              "column": 57
          },
          {
              "line": 12,
              "column": 66
          },
          {
              "line": 13,
              "column": 7
          },
          {
              "line": 13,
              "column": 12
          },
          {
              "line": 13,
              "column": 22
          },
          {
              "line": 13,
              "column": 40
          },
          {
              "line": 13,
              "column": 45
          },
          {
              "line": 14,
              "column": 52
          },
          {
              "line": 15,
              "column": 8
          },
          {
              "line": 15,
              "column": 24
          },
          {
              "line": 16,
              "column": 8
          },
          {
              "line": 16,
              "column": 10
          },
          {
              "line": 16,
              "column": 22
          },
          {
              "line": 19,
              "column": 26
          },
          {
              "line": 19,
              "column": 34
          },
          {
              "line": 21,
              "column": 6
          },
          {
              "line": 21,
              "column": 34
          },
          {
              "line": 21,
              "column": 48
          },
          {
              "line": 22,
              "column": 6
          },
          {
              "line": 22,
              "column": 25
          },
          {
              "line": 22,
              "column": 33
          },
          {
              "line": 22,
              "column": 44
          },
          {
              "line": 22,
              "column": 52
          },
          {
              "line": 22,
              "column": 62
          },
          {
              "line": 23,
              "column": 6
          },
          {
              "line": 23,
              "column": 26
          },
          {
              "line": 23,
              "column": 35
          },
          {
              "line": 25,
              "column": 6
          },
          {
              "line": 27,
              "column": 6
          },
          {
              "line": 28,
              "column": 6
          },
          {
              "line": 28,
              "column": 27
          },
          {
              "line": 30,
              "column": 6
          },
          {
              "line": 31,
              "column": 6
          },
          {
              "line": 32,
              "column": 6
          },
          {
              "line": 32,
              "column": 24
          },
          {
              "line": 33,
              "column": 6
          },
          {
              "line": 33,
              "column": 24
          },
          {
              "line": 34,
              "column": 6
          },
          {
              "line": 34,
              "column": 14
          },
          {
              "line": 34,
              "column": 24
          },
          {
              "line": 35,
              "column": 6
          },
          {
              "line": 35,
              "column": 14
          },
          {
              "line": 36,
              "column": 6
          },
          {
              "line": 36,
              "column": 14
          },
          {
              "line": 37,
              "column": 6
          },
          {
              "line": 37,
              "column": 14
          },
          {
              "line": 37,
              "column": 20
          },
          {
              "line": 38,
              "column": 6
          },
          {
              "line": 38,
              "column": 14
          },
          {
              "line": 38,
              "column": 20
          },
          {
              "line": 41,
              "column": 15
          },
          {
              "line": 41,
              "column": 21
          },
          {
              "line": 41,
              "column": 27
          },
          {
              "line": 41,
              "column": 30
          },
          {
              "line": 41,
              "column": 33
          },
          {
              "line": 41,
              "column": 45
          },
          {
              "line": 41,
              "column": 60
          },
          {
              "line": 41,
              "column": 65
          },
          {
              "line": 41,
              "column": 75
          },
          {
              "line": 41,
              "column": 90
          },
          {
              "line": 42,
              "column": 12
          },
          {
              "line": 42,
              "column": 34
          },
          {
              "line": 42,
              "column": 77
          },
          {
              "line": 43,
              "column": 10
          },
          {
              "line": 45,
              "column": 20
          },
          {
              "line": 45,
              "column": 26
          },
          {
              "line": 45,
              "column": 33
          },
          {
              "line": 45,
              "column": 42
          },
          {
              "line": 45,
              "column": 46
          },
          {
              "line": 45,
              "column": 49
          },
          {
              "line": 45,
              "column": 55
          },
          {
              "line": 47,
              "column": 10
          },
          {
              "line": 47,
              "column": 14
          },
          {
              "line": 47,
              "column": 16
          },
          {
              "line": 47,
              "column": 48
          },
          {
              "line": 47,
              "column": 55
          },
          {
              "line": 47,
              "column": 69
          },
          {
              "line": 47,
              "column": 75
          },
          {
              "line": 49,
              "column": 10
          },
          {
              "line": 49,
              "column": 14
          },
          {
              "line": 49,
              "column": 16
          },
          {
              "line": 49,
              "column": 27
          },
          {
              "line": 51,
              "column": 18
          },
          {
              "line": 51,
              "column": 25
          },
          {
              "line": 51,
              "column": 36
          },
          {
              "line": 51,
              "column": 51
          },
          {
              "line": 51,
              "column": 66
          },
          {
              "line": 52,
              "column": 10
          },
          {
              "line": 52,
              "column": 20
          },
          {
              "line": 52,
              "column": 28
          },
          {
              "line": 52,
              "column": 34
          },
          {
              "line": 52,
              "column": 43
          },
          {
              "line": 54,
              "column": 19
          },
          {
              "line": 54,
              "column": 25
          },
          {
              "line": 54,
              "column": 27
          },
          {
              "line": 54,
              "column": 54
          },
          {
              "line": 54,
              "column": 61
          },
          {
              "line": 55,
              "column": 10
          },
          {
              "line": 55,
              "column": 20
          },
          {
              "line": 55,
              "column": 32
          },
          {
              "line": 57,
              "column": 25
          },
          {
              "line": 57,
              "column": 52
          },
          {
              "line": 57,
              "column": 59
          },
          {
              "line": 58,
              "column": 10
          },
          {
              "line": 61,
              "column": 12
          },
          {
              "line": 61,
              "column": 35
          },
          {
              "line": 61,
              "column": 41
          },
          {
              "line": 61,
              "column": 50
          },
          {
              "line": 61,
              "column": 58
          },
          {
              "line": 61,
              "column": 61
          },
          {
              "line": 61,
              "column": 80
          },
          {
              "line": 61,
              "column": 87
          },
          {
              "line": 63,
              "column": 17
          },
          {
              "line": 63,
              "column": 23
          },
          {
              "line": 63,
              "column": 32
          },
          {
              "line": 63,
              "column": 37
          },
          {
              "line": 63,
              "column": 46
          },
          {
              "line": 63,
              "column": 53
          },
          {
              "line": 63,
              "column": 64
          },
          {
              "line": 63,
              "column": 79
          },
          {
              "line": 63,
              "column": 94
          },
          {
              "line": 65,
              "column": 18
          },
          {
              "line": 65,
              "column": 24
          },
          {
              "line": 65,
              "column": 30
          },
          {
              "line": 65,
              "column": 38
          },
          {
              "line": 65,
              "column": 44
          },
          {
              "line": 65,
              "column": 53
          },
          {
              "line": 65,
              "column": 60
          },
          {
              "line": 65,
              "column": 72
          },
          {
              "line": 66,
              "column": 9
          },
          {
              "line": 66,
              "column": 16
          },
          {
              "line": 66,
              "column": 22
          },
          {
              "line": 66,
              "column": 31
          },
          {
              "line": 66,
              "column": 40
          },
          {
              "line": 66,
              "column": 46
          },
          {
              "line": 66,
              "column": 55
          },
          {
              "line": 67,
              "column": 9
          },
          {
              "line": 67,
              "column": 20
          },
          {
              "line": 67,
              "column": 30
          },
          {
              "line": 71,
              "column": 14
          },
          {
              "line": 71,
              "column": 20
          },
          {
              "line": 71,
              "column": 27
          },
          {
              "line": 71,
              "column": 39
          },
          {
              "line": 71,
              "column": 48
          },
          {
              "line": 71,
              "column": 54
          },
          {
              "line": 73,
              "column": 9
          },
          {
              "line": 73,
              "column": 18
          },
          {
              "line": 73,
              "column": 28
          },
          {
              "line": 73,
              "column": 36
          },
          {
              "line": 73,
              "column": 42
          },
          {
              "line": 73,
              "column": 49
          },
          {
              "line": 73,
              "column": 59
          },
          {
              "line": 73,
              "column": 71
          },
          {
              "line": 73,
              "column": 77
          },
          {
              "line": 73,
              "column": 85
          },
          {
              "line": 74,
              "column": 26
          },
          {
              "line": 74,
              "column": 35
          },
          {
              "line": 77,
              "column": 24
          },
          {
              "line": 77,
              "column": 33
          },
          {
              "line": 77,
              "column": 43
          },
          {
              "line": 80,
              "column": 9
          },
          {
              "line": 82,
              "column": 13
          },
          {
              "line": 83,
              "column": 13
          },
          {
              "line": 83,
              "column": 25
          },
          {
              "line": 83,
              "column": 35
          },
          {
              "line": 83,
              "column": 48
          },
          {
              "line": 83,
              "column": 63
          },
          {
              "line": 83,
              "column": 70
          },
          {
              "line": 83,
              "column": 80
          },
          {
              "line": 88,
              "column": 9
          },
          {
              "line": 88,
              "column": 15
          },
          {
              "line": 88,
              "column": 31
          },
          {
              "line": 88,
              "column": 40
          },
          {
              "line": 88,
              "column": 46
          },
          {
              "line": 88,
              "column": 53
          },
          {
              "line": 90,
              "column": 17
          },
          {
              "line": 90,
              "column": 27
          },
          {
              "line": 90,
              "column": 39
          },
          {
              "line": 90,
              "column": 45
          },
          {
              "line": 91,
              "column": 17
          },
          {
              "line": 91,
              "column": 23
          },
          {
              "line": 91,
              "column": 29
          },
          {
              "line": 91,
              "column": 42
          },
          {
              "line": 91,
              "column": 46
          },
          {
              "line": 91,
              "column": 50
          },
          {
              "line": 92,
              "column": 9
          },
          {
              "line": 92,
              "column": 18
          },
          {
              "line": 92,
              "column": 28
          },
          {
              "line": 92,
              "column": 36
          },
          {
              "line": 92,
              "column": 42
          },
          {
              "line": 92,
              "column": 49
          },
          {
              "line": 92,
              "column": 59
          },
          {
              "line": 92,
              "column": 72
          },
          {
              "line": 92,
              "column": 91
          },
          {
              "line": 92,
              "column": 98
          },
          {
              "line": 93,
              "column": 14
          },
          {
              "line": 96,
              "column": 18
          },
          {
              "line": 96,
              "column": 24
          },
          {
              "line": 96,
              "column": 31
          },
          {
              "line": 96,
              "column": 39
          },
          {
              "line": 96,
              "column": 52
          },
          {
              "line": 96,
              "column": 64
          },
          {
              "line": 96,
              "column": 70
          },
          {
              "line": 97,
              "column": 13
          },
          {
              "line": 97,
              "column": 22
          },
          {
              "line": 97,
              "column": 32
          },
          {
              "line": 98,
              "column": 19
          },
          {
              "line": 98,
              "column": 21
          },
          {
              "line": 100,
              "column": 11
          },
          {
              "line": 100,
              "column": 20
          },
          {
              "line": 100,
              "column": 27
          },
          {
              "line": 100,
              "column": 30
          },
          {
              "line": 100,
              "column": 37
          },
          {
              "line": 100,
              "column": 42
          },
          {
              "line": 101,
              "column": 9
          },
          {
              "line": 102,
              "column": 31
          },
          {
              "line": 102,
              "column": 34
          },
          {
              "line": 103,
              "column": 26
          },
          {
              "line": 104,
              "column": 17
          },
          {
              "line": 104,
              "column": 29
          },
          {
              "line": 104,
              "column": 39
          },
          {
              "line": 105,
              "column": 26
          },
          {
              "line": 105,
              "column": 37
          },
          {
              "line": 106,
              "column": 36
          },
          {
              "line": 106,
              "column": 48
          },
          {
              "line": 106,
              "column": 76
          },
          {
              "line": 107,
              "column": 35
          },
          {
              "line": 107,
              "column": 52
          },
          {
              "line": 109,
              "column": 20
          },
          {
              "line": 110,
              "column": 22
          },
          {
              "line": 111,
              "column": 14
          },
          {
              "line": 111,
              "column": 25
          },
          {
              "line": 111,
              "column": 50
          },
          {
              "line": 111,
              "column": 58
          },
          {
              "line": 111,
              "column": 68
          },
          {
              "line": 111,
              "column": 75
          },
          {
              "line": 112,
              "column": 18
          },
          {
              "line": 112,
              "column": 26
          },
          {
              "line": 112,
              "column": 44
          },
          {
              "line": 112,
              "column": 57
          },
          {
              "line": 113,
              "column": 25
          },
          {
              "line": 113,
              "column": 45
          },
          {
              "line": 113,
              "column": 56
          },
          {
              "line": 113,
              "column": 71
          },
          {
              "line": 113,
              "column": 88
          },
          {
              "line": 114,
              "column": 13
          },
          {
              "line": 115,
              "column": 13
          },
          {
              "line": 115,
              "column": 25
          },
          {
              "line": 115,
              "column": 35
          },
          {
              "line": 116,
              "column": 22
          },
          {
              "line": 116,
              "column": 33
          },
          {
              "line": 117,
              "column": 37
          },
          {
              "line": 117,
              "column": 47
          },
          {
              "line": 117,
              "column": 67
          },
          {
              "line": 117,
              "column": 72
          },
          {
              "line": 118,
              "column": 31
          },
          {
              "line": 118,
              "column": 48
          },
          {
              "line": 118,
              "column": 56
          },
          {
              "line": 124,
              "column": 16
          },
          {
              "line": 124,
              "column": 32
          },
          {
              "line": 124,
              "column": 43
          },
          {
              "line": 124,
              "column": 49
          },
          {
              "line": 124,
              "column": 56
          },
          {
              "line": 126,
              "column": 17
          },
          {
              "line": 126,
              "column": 27
          },
          {
              "line": 126,
              "column": 39
          },
          {
              "line": 126,
              "column": 45
          },
          {
              "line": 126,
              "column": 51
          },
          {
              "line": 127,
              "column": 25
          },
          {
              "line": 127,
              "column": 30
          },
          {
              "line": 127,
              "column": 36
          },
          {
              "line": 127,
              "column": 41
          },
          {
              "line": 127,
              "column": 54
          },
          {
              "line": 127,
              "column": 60
          },
          {
              "line": 127,
              "column": 73
          },
          {
              "line": 127,
              "column": 79
          },
          {
              "line": 127,
              "column": 84
          },
          {
              "line": 127,
              "column": 90
          },
          {
              "line": 127,
              "column": 97
          },
          {
              "line": 128,
              "column": 9
          },
          {
              "line": 128,
              "column": 18
          },
          {
              "line": 128,
              "column": 28
          },
          {
              "line": 128,
              "column": 36
          },
          {
              "line": 128,
              "column": 42
          },
          {
              "line": 128,
              "column": 49
          },
          {
              "line": 128,
              "column": 59
          },
          {
              "line": 128,
              "column": 72
          },
          {
              "line": 129,
              "column": 12
          },
          {
              "line": 129,
              "column": 18
          },
          {
              "line": 132,
              "column": 25
          },
          {
              "line": 132,
              "column": 32
          },
          {
              "line": 132,
              "column": 40
          },
          {
              "line": 132,
              "column": 69
          },
          {
              "line": 132,
              "column": 74
          },
          {
              "line": 133,
              "column": 13
          },
          {
              "line": 133,
              "column": 22
          },
          {
              "line": 133,
              "column": 32
          },
          {
              "line": 134,
              "column": 19
          },
          {
              "line": 134,
              "column": 21
          },
          {
              "line": 136,
              "column": 11
          },
          {
              "line": 136,
              "column": 16
          },
          {
              "line": 136,
              "column": 23
          },
          {
              "line": 136,
              "column": 26
          },
          {
              "line": 136,
              "column": 33
          },
          {
              "line": 136,
              "column": 38
          },
          {
              "line": 137,
              "column": 9
          },
          {
              "line": 138,
              "column": 27
          },
          {
              "line": 138,
              "column": 30
          },
          {
              "line": 139,
              "column": 26
          },
          {
              "line": 141,
              "column": 21
          },
          {
              "line": 141,
              "column": 33
          },
          {
              "line": 141,
              "column": 43
          },
          {
              "line": 142,
              "column": 30
          },
          {
              "line": 142,
              "column": 41
          },
          {
              "line": 143,
              "column": 40
          },
          {
              "line": 143,
              "column": 52
          },
          {
              "line": 143,
              "column": 70
          },
          {
              "line": 144,
              "column": 39
          },
          {
              "line": 144,
              "column": 52
          },
          {
              "line": 144,
              "column": 57
          },
          {
              "line": 146,
              "column": 27
          },
          {
              "line": 146,
              "column": 35
          },
          {
              "line": 146,
              "column": 40
          },
          {
              "line": 148,
              "column": 32
          },
          {
              "line": 148,
              "column": 37
          },
          {
              "line": 149,
              "column": 21
          },
          {
              "line": 149,
              "column": 33
          },
          {
              "line": 149,
              "column": 43
          },
          {
              "line": 150,
              "column": 30
          },
          {
              "line": 150,
              "column": 41
          },
          {
              "line": 151,
              "column": 40
          },
          {
              "line": 151,
              "column": 52
          },
          {
              "line": 151,
              "column": 70
          },
          {
              "line": 151,
              "column": 76
          },
          {
              "line": 151,
              "column": 82
          },
          {
              "line": 151,
              "column": 95
          },
          {
              "line": 154,
              "column": 13
          },
          {
              "line": 155,
              "column": 13
          },
          {
              "line": 155,
              "column": 25
          },
          {
              "line": 155,
              "column": 35
          },
          {
              "line": 156,
              "column": 22
          },
          {
              "line": 156,
              "column": 33
          },
          {
              "line": 157,
              "column": 37
          },
          {
              "line": 157,
              "column": 44
          },
          {
              "line": 157,
              "column": 49
          },
          {
              "line": 157,
              "column": 61
          },
          {
              "line": 158,
              "column": 31
          },
          {
              "line": 158,
              "column": 46
          },
          {
              "line": 164,
              "column": 10
          },
          {
              "line": 164,
              "column": 16
          },
          {
              "line": 164,
              "column": 22
          },
          {
              "line": 164,
              "column": 35
          },
          {
              "line": 164,
              "column": 43
          },
          {
              "line": 164,
              "column": 59
          },
          {
              "line": 164,
              "column": 70
          },
          {
              "line": 164,
              "column": 76
          },
          {
              "line": 164,
              "column": 82
          },
          {
              "line": 164,
              "column": 88
          },
          {
              "line": 164,
              "column": 95
          },
          {
              "line": 166,
              "column": 17
          },
          {
              "line": 166,
              "column": 27
          },
          {
              "line": 166,
              "column": 39
          },
          {
              "line": 166,
              "column": 45
          },
          {
              "line": 166,
              "column": 51
          },
          {
              "line": 166,
              "column": 56
          },
          {
              "line": 167,
              "column": 11
          },
          {
              "line": 167,
              "column": 28
          },
          {
              "line": 167,
              "column": 39
          },
          {
              "line": 167,
              "column": 47
          },
          {
              "line": 167,
              "column": 53
          },
          {
              "line": 167,
              "column": 66
          },
          {
              "line": 167,
              "column": 80
          },
          {
              "line": 167,
              "column": 92
          },
          {
              "line": 168,
              "column": 15
          },
          {
              "line": 168,
              "column": 21
          },
          {
              "line": 168,
              "column": 34
          },
          {
              "line": 168,
              "column": 40
          },
          {
              "line": 168,
              "column": 45
          },
          {
              "line": 168,
              "column": 51
          },
          {
              "line": 168,
              "column": 58
          },
          {
              "line": 169,
              "column": 9
          },
          {
              "line": 169,
              "column": 18
          },
          {
              "line": 169,
              "column": 28
          },
          {
              "line": 169,
              "column": 36
          },
          {
              "line": 169,
              "column": 42
          },
          {
              "line": 169,
              "column": 49
          },
          {
              "line": 169,
              "column": 59
          },
          {
              "line": 169,
              "column": 72
          },
          {
              "line": 169,
              "column": 92
          },
          {
              "line": 170,
              "column": 12
          },
          {
              "line": 170,
              "column": 18
          },
          {
              "line": 173,
              "column": 14
          },
          {
              "line": 173,
              "column": 23
          },
          {
              "line": 173,
              "column": 35
          },
          {
              "line": 173,
              "column": 42
          },
          {
              "line": 173,
              "column": 45
          },
          {
              "line": 173,
              "column": 52
          },
          {
              "line": 173,
              "column": 60
          },
          {
              "line": 173,
              "column": 71
          },
          {
              "line": 173,
              "column": 80
          },
          {
              "line": 173,
              "column": 90
          },
          {
              "line": 174,
              "column": 19
          },
          {
              "line": 174,
              "column": 21
          },
          {
              "line": 176,
              "column": 11
          },
          {
              "line": 176,
              "column": 16
          },
          {
              "line": 176,
              "column": 23
          },
          {
              "line": 176,
              "column": 26
          },
          {
              "line": 176,
              "column": 33
          },
          {
              "line": 176,
              "column": 38
          },
          {
              "line": 177,
              "column": 9
          },
          {
              "line": 178,
              "column": 27
          },
          {
              "line": 178,
              "column": 30
          },
          {
              "line": 179,
              "column": 27
          },
          {
              "line": 180,
              "column": 29
          },
          {
              "line": 180,
              "column": 41
          },
          {
              "line": 180,
              "column": 61
          },
          {
              "line": 180,
              "column": 67
          },
          {
              "line": 180,
              "column": 74
          },
          {
              "line": 180,
              "column": 87
          },
          {
              "line": 181,
              "column": 19
          },
          {
              "line": 181,
              "column": 26
          },
          {
              "line": 181,
              "column": 36
          },
          {
              "line": 183,
              "column": 14
          },
          {
              "line": 183,
              "column": 23
          },
          {
              "line": 183,
              "column": 26
          },
          {
              "line": 183,
              "column": 35
          },
          {
              "line": 183,
              "column": 61
          },
          {
              "line": 184,
              "column": 18
          },
          {
              "line": 184,
              "column": 26
          },
          {
              "line": 184,
              "column": 35
          },
          {
              "line": 184,
              "column": 56
          },
          {
              "line": 184,
              "column": 59
          },
          {
              "line": 185,
              "column": 15
          },
          {
              "line": 185,
              "column": 22
          },
          {
              "line": 185,
              "column": 34
          },
          {
              "line": 185,
              "column": 46
          },
          {
              "line": 185,
              "column": 55
          },
          {
              "line": 185,
              "column": 75
          },
          {
              "line": 185,
              "column": 90
          },
          {
              "line": 186,
              "column": 13
          },
          {
              "line": 186,
              "column": 28
          },
          {
              "line": 187,
              "column": 13
          },
          {
              "line": 187,
              "column": 25
          },
          {
              "line": 187,
              "column": 35
          },
          {
              "line": 188,
              "column": 22
          },
          {
              "line": 188,
              "column": 33
          },
          {
              "line": 189,
              "column": 37
          },
          {
              "line": 189,
              "column": 47
          },
          {
              "line": 189,
              "column": 67
          },
          {
              "line": 189,
              "column": 86
          },
          {
              "line": 190,
              "column": 21
          },
          {
              "line": 195,
              "column": 10
          },
          {
              "line": 195,
              "column": 20
          },
          {
              "line": 195,
              "column": 31
          },
          {
              "line": 195,
              "column": 46
          },
          {
              "line": 195,
              "column": 52
          },
          {
              "line": 195,
              "column": 59
          },
          {
              "line": 197,
              "column": 11
          },
          {
              "line": 197,
              "column": 20
          },
          {
              "line": 197,
              "column": 31
          },
          {
              "line": 197,
              "column": 46
          },
          {
              "line": 197,
              "column": 52
          },
          {
              "line": 197,
              "column": 59
          },
          {
              "line": 198,
              "column": 9
          },
          {
              "line": 198,
              "column": 18
          },
          {
              "line": 198,
              "column": 28
          },
          {
              "line": 198,
              "column": 36
          },
          {
              "line": 198,
              "column": 42
          },
          {
              "line": 198,
              "column": 49
          },
          {
              "line": 198,
              "column": 59
          },
          {
              "line": 198,
              "column": 72
          },
          {
              "line": 198,
              "column": 92
          },
          {
              "line": 199,
              "column": 12
          },
          {
              "line": 199,
              "column": 19
          },
          {
              "line": 199,
              "column": 26
          },
          {
              "line": 202,
              "column": 14
          },
          {
              "line": 202,
              "column": 17
          },
          {
              "line": 202,
              "column": 27
          },
          {
              "line": 202,
              "column": 30
          },
          {
              "line": 202,
              "column": 39
          },
          {
              "line": 202,
              "column": 48
          },
          {
              "line": 202,
              "column": 58
          },
          {
              "line": 203,
              "column": 19
          },
          {
              "line": 203,
              "column": 21
          },
          {
              "line": 205,
              "column": 11
          },
          {
              "line": 205,
              "column": 22
          },
          {
              "line": 205,
              "column": 42
          },
          {
              "line": 205,
              "column": 47
          },
          {
              "line": 205,
              "column": 53
          },
          {
              "line": 205,
              "column": 71
          },
          {
              "line": 209,
              "column": 10
          },
          {
              "line": 209,
              "column": 19
          },
          {
              "line": 209,
              "column": 24
          },
          {
              "line": 209,
              "column": 40
          },
          {
              "line": 209,
              "column": 50
          },
          {
              "line": 209,
              "column": 56
          },
          {
              "line": 209,
              "column": 62
          },
          {
              "line": 209,
              "column": 69
          },
          {
              "line": 211,
              "column": 17
          },
          {
              "line": 211,
              "column": 27
          },
          {
              "line": 211,
              "column": 39
          },
          {
              "line": 211,
              "column": 45
          },
          {
              "line": 211,
              "column": 51
          },
          {
              "line": 212,
              "column": 11
          },
          {
              "line": 212,
              "column": 23
          },
          {
              "line": 212,
              "column": 32
          },
          {
              "line": 212,
              "column": 38
          },
          {
              "line": 212,
              "column": 48
          },
          {
              "line": 212,
              "column": 54
          },
          {
              "line": 212,
              "column": 60
          },
          {
              "line": 212,
              "column": 67
          },
          {
              "line": 212,
              "column": 88
          },
          {
              "line": 213,
              "column": 9
          },
          {
              "line": 213,
              "column": 18
          },
          {
              "line": 213,
              "column": 28
          },
          {
              "line": 213,
              "column": 36
          },
          {
              "line": 213,
              "column": 42
          },
          {
              "line": 213,
              "column": 49
          },
          {
              "line": 213,
              "column": 59
          },
          {
              "line": 213,
              "column": 72
          },
          {
              "line": 214,
              "column": 16
          },
          {
              "line": 214,
              "column": 22
          },
          {
              "line": 217,
              "column": 23
          },
          {
              "line": 217,
              "column": 30
          },
          {
              "line": 217,
              "column": 38
          },
          {
              "line": 217,
              "column": 49
          },
          {
              "line": 217,
              "column": 58
          },
          {
              "line": 217,
              "column": 68
          },
          {
              "line": 218,
              "column": 19
          },
          {
              "line": 218,
              "column": 21
          },
          {
              "line": 220,
              "column": 11
          },
          {
              "line": 220,
              "column": 19
          },
          {
              "line": 220,
              "column": 25
          },
          {
              "line": 220,
              "column": 41
          },
          {
              "line": 220,
              "column": 52
          },
          {
              "line": 223,
              "column": 10
          },
          {
              "line": 223,
              "column": 18
          },
          {
              "line": 223,
              "column": 27
          },
          {
              "line": 223,
              "column": 34
          },
          {
              "line": 223,
              "column": 40
          },
          {
              "line": 223,
              "column": 53
          },
          {
              "line": 223,
              "column": 62
          },
          {
              "line": 223,
              "column": 72
          },
          {
              "line": 224,
              "column": 14
          },
          {
              "line": 224,
              "column": 23
          },
          {
              "line": 225,
              "column": 19
          },
          {
              "line": 225,
              "column": 41
          },
          {
              "line": 225,
              "column": 47
          },
          {
              "line": 225,
              "column": 56
          },
          {
              "line": 226,
              "column": 19
          },
          {
              "line": 226,
              "column": 35
          },
          {
              "line": 227,
              "column": 13
          },
          {
              "line": 227,
              "column": 25
          },
          {
              "line": 227,
              "column": 35
          },
          {
              "line": 227,
              "column": 48
          },
          {
              "line": 227,
              "column": 55
          },
          {
              "line": 227,
              "column": 71
          },
          {
              "line": 227,
              "column": 84
          },
          {
              "line": 230,
              "column": 9
          },
          {
              "line": 231,
              "column": 22
          },
          {
              "line": 231,
              "column": 29
          },
          {
              "line": 231,
              "column": 38
          },
          {
              "line": 231,
              "column": 42
          },
          {
              "line": 232,
              "column": 25
          },
          {
              "line": 232,
              "column": 44
          },
          {
              "line": 232,
              "column": 56
          },
          {
              "line": 232,
              "column": 59
          },
          {
              "line": 232,
              "column": 73
          },
          {
              "line": 233,
              "column": 25
          },
          {
              "line": 236,
              "column": 45
          },
          {
              "line": 237,
              "column": 49
          },
          {
              "line": 237,
              "column": 61
          },
          {
              "line": 237,
              "column": 64
          },
          {
              "line": 239,
              "column": 13
          },
          {
              "line": 239,
              "column": 28
          },
          {
              "line": 240,
              "column": 13
          },
          {
              "line": 240,
              "column": 25
          },
          {
              "line": 240,
              "column": 35
          },
          {
              "line": 240,
              "column": 48
          },
          {
              "line": 240,
              "column": 54
          },
          {
              "line": 240,
              "column": 63
          },
          {
              "line": 240,
              "column": 70
          },
          {
              "line": 240,
              "column": 80
          },
          {
              "line": 240,
              "column": 87
          },
          {
              "line": 242,
              "column": 11
          },
          {
              "line": 245,
              "column": 10
          },
          {
              "line": 245,
              "column": 15
          },
          {
              "line": 245,
              "column": 20
          },
          {
              "line": 245,
              "column": 23
          },
          {
              "line": 245,
              "column": 30
          },
          {
              "line": 245,
              "column": 34
          },
          {
              "line": 245,
              "column": 42
          },
          {
              "line": 246,
              "column": 11
          },
          {
              "line": 246,
              "column": 18
          },
          {
              "line": 246,
              "column": 24
          },
          {
              "line": 246,
              "column": 28
          },
          {
              "line": 246,
              "column": 34
          },
          {
              "line": 246,
              "column": 43
          },
          {
              "line": 246,
              "column": 51
          }
      ],
      "old_name": "t",
      "new_name": "e",
      "ctx": {
          "symbolName": "t",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "Throwable",
          "scopeHint": "in getCatalog(...)",
          "filePath": "FileCatalogStore.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "          String content = FileUtils.readFile(file, charset);\n            Map<String, String> options = yaml.load(content);\n            return Optional.of(CatalogDescriptor.of(catalogName, Configuration.fromMap(options)));\n        } catch (Throwable t) {\n            throw new CatalogException(\n                    String.format(\n                            \"Failed to load catalog %s's configuration from file\", catalogName),\n                    t);\n        }\n    }\n\n    /**\n     * Returns ",
          "conflictNames": [
              "catalogName",
              "path",
              "file",
              "content",
              "options"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f77dbdfd0c7d510ae32ce932c7b84ed968496130^1/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/job/SubtasksAllAccumulatorsHandler.java",
      "locators": [
          {
              "line": 81,
              "column": 24
          },
          {
              "line": 94,
              "column": 33
          }
      ],
      "old_name": "locationString",
      "new_name": "host",
      "ctx": {
          "symbolName": "locationString",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in handleRequest(...)",
          "filePath": "SubtasksAllAccumulatorsHandler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    protected SubtasksAllAccumulatorsInfo handleRequest(\n            HandlerRequest<EmptyRequestBody> request, AccessExecutionJobVertex jobVertex)\n            throws RestHandlerException {\n        JobVertexID jobVertexId = jobVertex.getJobVertexId();\n        int parallelism = jobVertex.getParallelism();\n\n        final List<SubtasksAllAccumulatorsInfo.SubtaskAccumulatorsInfo> subtaskAccumulatorsInfos =\n                new ArrayList<>();\n\n        for (AccessExecutionVertex vertex : jobVertex.getTaskVertices()) {\n            for (AccessExecution execution : vertex.getCurrentExecutions()) {\n                TaskManagerLocation location = execution.getAssignedResourceLocation();\n                String locationString = location == null ? \"(unassigned)\" : location.getHostname();\n\n                StringifiedAccumulatorResult[] accs = execution.getUserAccumulatorsStringified();\n                List<UserAccumulator> userAccumulators = new ArrayList<>(accs.length);\n                for (StringifiedAccumulatorResult acc : accs) {\n                    userAccumulators.add(\n                            new UserAccumulator(acc.getName(), acc.getType(), acc.getValue()));\n                }\n\n                subtaskAccumulatorsInfos.add(\n                        new SubtasksAllAccumulatorsInfo.SubtaskAccumulatorsInfo(\n                                execution.getParallelSubtaskIndex(),\n                                execution.getAttemptNumber(),\n                                locationString,\n                                userAccumulators));\n            }\n        }\n\n        return new SubtasksAllAccumulatorsInfo(jobVertexId, parallelism, subtaskAccumulatorsInfos);\n    }",
          "conflictNames": [
              "request",
              "jobVertex",
              "jobVertexId",
              "parallelism",
              "subtaskAccumulatorsInfos",
              "location",
              "accs",
              "userAccumulators"
          ]
      },
      "suggestions": [
          {
              "name": "host",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/f77dbdfd0c7d510ae32ce932c7b84ed968496130^1/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/job/SubtasksTimesHandler.java",
      "locators": [
          {
              "line": 116,
              "column": 20
          },
          {
              "line": 126,
              "column": 36
          }
      ],
      "old_name": "locationString",
      "new_name": "host",
      "ctx": {
          "symbolName": "locationString",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in createSubtaskTimesInfo(...)",
          "filePath": "SubtasksTimesHandler.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static SubtasksTimesInfo createSubtaskTimesInfo(AccessExecutionJobVertex jobVertex) {\n        final String id = jobVertex.getJobVertexId().toString();\n        final String name = jobVertex.getName();\n        final long now = System.currentTimeMillis();\n        final List<SubtasksTimesInfo.SubtaskTimeInfo> subtasks = new ArrayList<>();\n\n        int num = 0;\n        for (AccessExecutionVertex vertex : jobVertex.getTaskVertices()) {\n            // Use one of the current execution attempts to represent the subtask, rather than\n            // adding times info of all attempts.\n            long[] timestamps = vertex.getCurrentExecutionAttempt().getStateTimestamps();\n            ExecutionState status = vertex.getExecutionState();\n\n            long scheduledTime = timestamps[ExecutionState.SCHEDULED.ordinal()];\n\n            long start = scheduledTime > 0 ? scheduledTime : -1;\n            long end = status.isTerminal() ? timestamps[status.ordinal()] : now;\n            long duration = start >= 0 ? end - start : -1L;\n\n            TaskManagerLocation location = vertex.getCurrentAssignedResourceLocation();\n            String locationString = location == null ? \"(unassigned)\" : location.getHostname();\n\n            Map<ExecutionState, Long> timestampMap =\n                    CollectionUtil.newHashMapWithExpectedSize(ExecutionState.values().length);\n            for (ExecutionState state : ExecutionState.values()) {\n                timestampMap.put(state, timestamps[state.ordinal()]);\n            }\n\n            subtasks.add(\n                    new SubtasksTimesInfo.SubtaskTimeInfo(\n                            num++, locationString, duration, timestampMap));\n        }\n        return new SubtasksTimesInfo(id, name, now, subtasks);\n    }",
          "conflictNames": [
              "jobVertex",
              "id",
              "name",
              "now",
              "subtasks",
              "num",
              "timestamps",
              "status",
              "scheduledTime",
              "start",
              "end",
              "duration",
              "location",
              "timestampMap"
          ]
      },
      "suggestions": [
          {
              "name": "host",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/f7f96af5355f0bc20e3c0e251bd75657b131c1db^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/exec/stream/StreamExecMultiJoin.java",
      "locators": [
          {
              "line": 224,
              "column": 31
          },
          {
              "line": 232,
              "column": 25
          },
          {
              "line": 261,
              "column": 31
          },
          {
              "line": 276,
              "column": 21
          },
          {
              "line": 283,
              "column": 16
          }
      ],
      "old_name": "instantiatedJoinConditions",
      "new_name": "generatedJoinConditions",
      "ctx": {
          "symbolName": "instantiatedJoinConditions",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JoinCondition[]",
          "scopeHint": "in translateToPlanInternal(...)",
          "filePath": "StreamExecMultiJoin.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    @SuppressWarnings(\"unchecked\")\n    protected Transformation<RowData> translateToPlanInternal(\n            final PlannerBase planner, final ExecNodeConfig config) {\n        final List<ExecEdge> inputEdges = getInputEdges();\n        final int numInputs = inputEdges.size();\n        final ClassLoader classLoader = planner.getFlinkContext().getClassLoader();\n\n        final List<Transformation<RowData>> inputTransforms = new ArrayList<>(numInputs);\n        final List<InternalTypeInfo<RowData>> inputTypeInfos = new ArrayList<>(numInputs);\n        final List<RowType> inputRowTypes = new ArrayList<>(numInputs);\n\n        for (final ExecEdge inputEdge : inputEdges) {\n            final Transformation<RowData> transform =\n                    (Transformation<RowData>) inputEdge.translateToPlan(planner);\n            inputTransforms.add(transform);\n            final RowType inputType = (RowType) inputEdge.getOutputType();\n            inputRowTypes.add(inputType);\n            inputTypeInfos.add(InternalTypeInfo.of(inputType));\n        }\n\n        final JoinKeyExtractor keyExtractor =\n                new AttributeBasedJoinKeyExtractor(joinAttributeMap, inputRowTypes);\n\n        final List<JoinInputSideSpec> inputSideSpecs = new ArrayList<>();\n        for (int i = 0; i < numInputs; i++) {\n            inputSideSpecs.add(\n                    JoinUtil.analyzeJoinInput(\n                            planner.getFlinkContext().getClassLoader(),\n                            inputTypeInfos.get(i),\n                            keyExtractor.getJoinKeyIndices(i),\n                            inputUpsertKeys.get(i)));\n        }\n\n        final JoinCondition[] instantiatedJoinConditions =\n                createJoinConditions(config, classLoader, inputRowTypes);\n\n        final StreamOperatorFactory<RowData> operatorFactory =\n                createOperatorFactory(\n                        config,\n                        inputTypeInfos,\n                        inputSideSpecs,\n                        instantiatedJoinConditions,\n                        keyExtractor);\n\n        final List<KeySelector<RowData, RowData>> commonJoinKeySelectors =\n                createKeySelectors(planner, inputTypeInfos, keyExtractor);\n\n        final TransformationMetadata metadata =\n                createTransformationMeta(MULTI_JOIN_TRANSFORMATION, config);\n\n        final Transformation<RowData> transform =\n                createTransformation(\n                        inputTransforms,\n                        metadata,\n                        operatorFactory,\n                        commonJoinKeySelectors,\n                        keyExtractor);\n\n        if (inputsContainSingleton()) {\n            transform.setParallelism(1);\n            transform.setMaxParallelism(1);\n        }\n\n        return transform;\n    }",
          "conflictNames": [
              "planner",
              "config",
              "inputEdges",
              "numInputs",
              "classLoader",
              "inputTransforms",
              "inputTypeInfos",
              "inputRowTypes",
              "transform",
              "inputType",
              "keyExtractor",
              "inputSideSpecs",
              "i",
              "operatorFactory",
              "commonJoinKeySelectors",
              "metadata"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f7f96af5355f0bc20e3c0e251bd75657b131c1db^1/flink-table/flink-table-runtime/src/test/java/org/apache/flink/table/runtime/operators/join/stream/multijoin/StreamingMultiJoinOperatorTestBase.java",
      "locators": [
          {
              "line": 387,
              "column": 31
          },
          {
              "line": 400,
              "column": 25
          }
      ],
      "old_name": "createdJoinConditions",
      "new_name": "generatedJoinConditions",
      "ctx": {
          "symbolName": "createdJoinConditions",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JoinCondition[]",
          "scopeHint": "in createTestHarness(...)",
          "filePath": "StreamingMultiJoinOperatorTestBase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "protected KeyedMultiInputStreamOperatorTestHarness<RowData, RowData> createTestHarness()\n            throws Exception {\n        var joinKeyType = this.keyExtractor.getCommonJoinKeyType();\n        InternalTypeInfo<RowData> partitionKeyTypeInfo = InternalTypeInfo.of(joinKeyType);\n\n        final JoinCondition[] createdJoinConditions = createJoinConditions(this.joinConditions);\n        final long[] retentionTime = new long[inputSpecs.size()];\n        Arrays.fill(retentionTime, 9999999L);\n        final List<InternalTypeInfo<RowData>> internalTypeInfos =\n                this.inputTypeInfos.stream().map(InternalTypeInfo::of).collect(Collectors.toList());\n\n        StreamingMultiJoinOperatorFactory factory =\n                new StreamingMultiJoinOperatorFactory(\n                        internalTypeInfos,\n                        this.inputSpecs,\n                        this.joinTypes,\n                        null,\n                        retentionTime,\n                        createdJoinConditions,\n                        this.keyExtractor,\n                        this.joinAttributeMap);\n\n        KeyedMultiInputStreamOperatorTestHarness<RowData, RowData> harness =\n                new KeyedMultiInputStreamOperatorTestHarness<>(factory, partitionKeyTypeInfo);\n\n        setupKeySelectorsForTestHarness(harness);\n\n        harness.setStateBackend(getStateBackend());\n        harness.setCheckpointStorage(getCheckpointStorage());\n        return harness;\n    }",
          "conflictNames": [
              "joinKeyType",
              "partitionKeyTypeInfo",
              "retentionTime",
              "internalTypeInfos",
              "factory",
              "harness"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f7f96af5355f0bc20e3c0e251bd75657b131c1db^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/FlinkJoinToMultiJoinRule.java",
      "locators": [
          {
              "line": 655,
              "column": 89
          },
          {
              "line": 656,
              "column": 56
          },
          {
              "line": 658,
              "column": 13
          },
          {
              "line": 660,
              "column": 16
          },
          {
              "line": 708,
              "column": 58
          }
      ],
      "old_name": "builder",
      "new_name": "aMap",
      "ctx": {
          "symbolName": "builder",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Builder<Integer, ImmutableIntList>",
          "scopeHint": "in addOnJoinFieldRefCounts(...)",
          "filePath": "FlinkJoinToMultiJoinRule.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "/**\n     * Adds on to the existing join condition reference counts the references from the new join\n     * condition.\n     *\n     * @param multiJoinInputs inputs into the new MultiJoin\n     * @param nTotalFields total number of fields in the MultiJoin\n     * @param joinCondition the new join condition\n     * @param origJoinFieldRefCounts existing join condition reference counts\n     * @return Map containing the new join condition\n     */\n    private com.google.common.collect.ImmutableMap<Integer, ImmutableIntList>\n            addOnJoinFieldRefCounts(\n                    List<RelNode> multiJoinInputs,\n                    int nTotalFields,\n                    RexNode joinCondition,\n                    List<int[]> origJoinFieldRefCounts) {\n        // count the input references in the join condition\n        int[] joinCondRefCounts = new int[nTotalFields];\n        joinCondition.accept(new InputReferenceCounter(joinCondRefCounts));\n\n        // first, make a copy of the ref counters\n        final Map<Integer, int[]> refCountsMap = new HashMap<>();\n        int nInputs = multiJoinInputs.size();\n        int currInput = 0;\n        for (int[] origRefCounts : origJoinFieldRefCounts) {\n            refCountsMap.put(currInput, origRefCounts.clone());\n            currInput++;\n        }\n\n        // add on to the counts for each input into the MultiJoin the\n        // reference counts computed for the current join condition\n        currInput = -1;\n        int startField = 0;\n        int nFields = 0;\n        for (int i = 0; i < nTotalFields; i++) {\n            if (joinCondRefCounts[i] == 0) {\n                continue;\n            }\n            while (i >= (startField + nFields)) {\n                startField += nFields;\n                currInput++;\n                assert currInput < nInputs;\n                nFields = multiJoinInputs.get(currInput).getRowType().getFieldCount();\n            }\n            int[] refCounts = refCountsMap.get(currInput);\n            refCounts[i - startField] += joinCondRefCounts[i];\n        }\n\n        final com.google.common.collect.ImmutableMap.Builder<Integer, ImmutableIntList> builder =\n                com.google.common.collect.ImmutableMap.builder();\n        for (Map.Entry<Integer, int[]> entry : refCountsMap.entrySet()) {\n            builder.put(entry.getKey(), ImmutableIntList.of(entry.getValue()));\n        }\n        return builder.build();\n    }",
          "conflictNames": [
              "multiJoinInputs",
              "nTotalFields",
              "joinCondition",
              "origJoinFieldRefCounts",
              "joinCondRefCounts",
              "refCountsMap",
              "nInputs",
              "currInput",
              "startField",
              "nFields",
              "i",
              "refCounts"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f8105bb584f8e7b6302a15c1c9270b988ff574cb^1/flink-tests/src/test/java/org/apache/flink/test/state/TaskManagerWideRocksDbMemorySharingITCase.java",
      "locators": [
          {
              "line": 130,
              "column": 41
          },
          {
              "line": 137,
              "column": 33
          },
          {
              "line": 138,
              "column": 25
          },
          {
              "line": 139,
              "column": 25
          },
          {
              "line": 147,
              "column": 33
          },
          {
              "line": 148,
              "column": 25
          }
      ],
      "old_name": "stats",
      "new_name": "percentile",
      "ctx": {
          "symbolName": "stats",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "DoubleSummaryStatistics",
          "scopeHint": "in testBlockCache(...)",
          "filePath": "TaskManagerWideRocksDbMemorySharingITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testBlockCache() throws Exception {\n        List<JobID> jobIDs = new ArrayList<>(NUMBER_OF_JOBS);\n        try {\n            // launch jobs\n            for (int i = 0; i < NUMBER_OF_JOBS; i++) {\n                jobIDs.add(cluster.getRestClusterClient().submitJob(dag()).get());\n            }\n\n            // wait for init\n            Deadline initDeadline = Deadline.fromNow(Duration.ofMinutes(1));\n            for (JobID jid : jobIDs) {\n                waitForAllTaskRunning(cluster.getMiniCluster(), jid, false);\n                waitForAllMetricsReported(jid, initDeadline);\n            }\n\n            // check declared capacity\n            collectGaugeValues(jobIDs, \"rocksdb.block-cache-capacity\")\n                    .forEach(\n                            size ->\n                                    assertEquals(\n                                            \"Unexpected rocksdb block cache capacity\",\n                                            EXPECTED_BLOCK_CACHE_SIZE,\n                                            size,\n                                            0));\n\n            // do some work and check the actual usage of memory\n            for (int i = 0; i < 10; i++) {\n                Thread.sleep(50L);\n                DoubleSummaryStatistics stats =\n                        collectGaugeValues(jobIDs, \"rocksdb.block-cache-usage\")\n                                .collect(Collectors.summarizingDouble((Double::doubleValue)));\n                assertEquals(\n                        String.format(\n                                \"Block cache usage reported by different tasks varies too much: %s\\n\"\n                                        + \"That likely mean that they use different cache objects\",\n                                stats),\n                        stats.getMax(),\n                        stats.getMin(),\n                        // some deviation is possible because:\n                        // 1. records are being processed in parallel with requesting metrics\n                        // 2. reporting metrics is not synchronized\n                        500_000d);\n                assertTrue(\n                        String.format(\n                                \"total block cache usage is too high: %s (limit: %s, effective limit: %s)\",\n                                stats, EXPECTED_BLOCK_CACHE_SIZE, EFFECTIVE_LIMIT),\n                        stats.getMax() <= EFFECTIVE_LIMIT);\n            }\n\n        } finally {\n            for (JobID jobID : jobIDs) {\n                cluster.getRestClusterClient().cancel(jobID).get();\n            }\n        }\n    }",
          "conflictNames": [
              "jobIDs",
              "i",
              "initDeadline"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f8105bb584f8e7b6302a15c1c9270b988ff574cb^1/flink-tests/src/test/java/org/apache/flink/test/state/TaskManagerWideRocksDbMemorySharingITCase.java",
      "locators": [
          {
              "line": 130,
              "column": 41
          },
          {
              "line": 137,
              "column": 33
          },
          {
              "line": 138,
              "column": 25
          },
          {
              "line": 139,
              "column": 25
          },
          {
              "line": 147,
              "column": 33
          },
          {
              "line": 148,
              "column": 25
          }
      ],
      "old_name": "stats",
      "new_name": "blockCacheUsages",
      "ctx": {
          "symbolName": "stats",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "DoubleSummaryStatistics",
          "scopeHint": "in testBlockCache(...)",
          "filePath": "TaskManagerWideRocksDbMemorySharingITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    public void testBlockCache() throws Exception {\n        List<JobID> jobIDs = new ArrayList<>(NUMBER_OF_JOBS);\n        try {\n            // launch jobs\n            for (int i = 0; i < NUMBER_OF_JOBS; i++) {\n                jobIDs.add(cluster.getRestClusterClient().submitJob(dag()).get());\n            }\n\n            // wait for init\n            Deadline initDeadline = Deadline.fromNow(Duration.ofMinutes(1));\n            for (JobID jid : jobIDs) {\n                waitForAllTaskRunning(cluster.getMiniCluster(), jid, false);\n                waitForAllMetricsReported(jid, initDeadline);\n            }\n\n            // check declared capacity\n            collectGaugeValues(jobIDs, \"rocksdb.block-cache-capacity\")\n                    .forEach(\n                            size ->\n                                    assertEquals(\n                                            \"Unexpected rocksdb block cache capacity\",\n                                            EXPECTED_BLOCK_CACHE_SIZE,\n                                            size,\n                                            0));\n\n            // do some work and check the actual usage of memory\n            for (int i = 0; i < 10; i++) {\n                Thread.sleep(50L);\n                DoubleSummaryStatistics stats =\n                        collectGaugeValues(jobIDs, \"rocksdb.block-cache-usage\")\n                                .collect(Collectors.summarizingDouble((Double::doubleValue)));\n                assertEquals(\n                        String.format(\n                                \"Block cache usage reported by different tasks varies too much: %s\\n\"\n                                        + \"That likely mean that they use different cache objects\",\n                                stats),\n                        stats.getMax(),\n                        stats.getMin(),\n                        // some deviation is possible because:\n                        // 1. records are being processed in parallel with requesting metrics\n                        // 2. reporting metrics is not synchronized\n                        500_000d);\n                assertTrue(\n                        String.format(\n                                \"total block cache usage is too high: %s (limit: %s, effective limit: %s)\",\n                                stats, EXPECTED_BLOCK_CACHE_SIZE, EFFECTIVE_LIMIT),\n                        stats.getMax() <= EFFECTIVE_LIMIT);\n            }\n\n        } finally {\n            for (JobID jobID : jobIDs) {\n                cluster.getRestClusterClient().cancel(jobID).get();\n            }\n        }\n    }",
          "conflictNames": [
              "jobIDs",
              "i",
              "initDeadline"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f82556d06e3146c9e823ccb9736421088d7d81f9^1/flink-tests/src/test/java/org/apache/flink/test/misc/JobIDLoggingITCase.java",
      "locators": [
          {
              "line": 241,
              "column": 30
          },
          {
              "line": 257,
              "column": 21
          },
          {
              "line": 271,
              "column": 17
          },
          {
              "line": 273,
              "column": 20
          }
      ],
      "old_name": "eventsWithWrongJobId",
      "new_name": "eventsWithWrongValue",
      "ctx": {
          "symbolName": "eventsWithWrongJobId",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<LogEvent>",
          "scopeHint": "in assertJobIDPresent(...)",
          "filePath": "JobIDLoggingITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void assertJobIDPresent(\n            JobID jobID,\n            LoggerAuditingExtension ext,\n            List<String> expPatterns,\n            String... ignPatterns) {\n\n        final List<LogEvent> eventsWithMissingJobId = new ArrayList<>();\n        final List<LogEvent> eventsWithWrongJobId = new ArrayList<>();\n        final List<LogEvent> ignoredEvents = new ArrayList<>();\n        final List<Pattern> expectedPatterns =\n                expPatterns.stream().map(Pattern::compile).collect(toList());\n        final List<Pattern> ignorePatterns =\n                Arrays.stream(ignPatterns).map(Pattern::compile).collect(toList());\n\n        for (LogEvent e : ext.getEvents()) {\n            ReadOnlyStringMap context = e.getContextData();\n            if (context.containsKey(JOB_ID)) {\n                if (Objects.equals(context.getValue(JOB_ID), jobID.toHexString())) {\n                    expectedPatterns.removeIf(\n                            pattern ->\n                                    pattern.matcher(e.getMessage().getFormattedMessage())\n                                            .matches());\n                } else {\n                    eventsWithWrongJobId.add(e);\n                }\n            } else if (matchesAny(ignorePatterns, e.getMessage().getFormattedMessage())) {\n                ignoredEvents.add(e);\n            } else {\n                eventsWithMissingJobId.add(e);\n            }\n        }\n\n        logger.debug(\n                \"checked events for {}:\\n  {};\\n  ignored: {},\\n  wrong job id: {},\\n  missing job id: {}\",\n                ext.getLoggerName(),\n                ext.getEvents(),\n                ignoredEvents,\n                eventsWithWrongJobId,\n                eventsWithMissingJobId);\n        assertThat(eventsWithWrongJobId).as(\"events with a wrong Job ID\").isEmpty();\n        assertThat(expectedPatterns)\n                .as(\n                        \"not all expected events logged by %s, logged:\\n%s\",\n                        ext.getLoggerName(), ext.getEvents())\n                .isEmpty();\n        assertThat(eventsWithMissingJobId)\n                .as(\"too many events without Job ID logged by %s\", ext.getLoggerName())\n                .isEmpty();\n    }",
          "conflictNames": [
              "jobID",
              "ext",
              "expPatterns",
              "ignPatterns",
              "eventsWithMissingJobId",
              "ignoredEvents",
              "expectedPatterns",
              "ignorePatterns",
              "context"
          ]
      },
      "suggestions": [
          {
              "name": "eventsWithWrongKey",
              "confidence": 0.75
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/f82556d06e3146c9e823ccb9736421088d7d81f9^1/flink-tests/src/test/java/org/apache/flink/test/misc/JobIDLoggingITCase.java",
      "locators": [
          {
              "line": 240,
              "column": 30
          },
          {
              "line": 262,
              "column": 17
          },
          {
              "line": 272,
              "column": 17
          },
          {
              "line": 279,
              "column": 20
          }
      ],
      "old_name": "eventsWithMissingJobId",
      "new_name": "eventsWithMissingKey",
      "ctx": {
          "symbolName": "eventsWithMissingJobId",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<LogEvent>",
          "scopeHint": "in assertJobIDPresent(...)",
          "filePath": "JobIDLoggingITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static void assertJobIDPresent(\n            JobID jobID,\n            LoggerAuditingExtension ext,\n            List<String> expPatterns,\n            String... ignPatterns) {\n\n        final List<LogEvent> eventsWithMissingJobId = new ArrayList<>();\n        final List<LogEvent> eventsWithWrongJobId = new ArrayList<>();\n        final List<LogEvent> ignoredEvents = new ArrayList<>();\n        final List<Pattern> expectedPatterns =\n                expPatterns.stream().map(Pattern::compile).collect(toList());\n        final List<Pattern> ignorePatterns =\n                Arrays.stream(ignPatterns).map(Pattern::compile).collect(toList());\n\n        for (LogEvent e : ext.getEvents()) {\n            ReadOnlyStringMap context = e.getContextData();\n            if (context.containsKey(JOB_ID)) {\n                if (Objects.equals(context.getValue(JOB_ID), jobID.toHexString())) {\n                    expectedPatterns.removeIf(\n                            pattern ->\n                                    pattern.matcher(e.getMessage().getFormattedMessage())\n                                            .matches());\n                } else {\n                    eventsWithWrongJobId.add(e);\n                }\n            } else if (matchesAny(ignorePatterns, e.getMessage().getFormattedMessage())) {\n                ignoredEvents.add(e);\n            } else {\n                eventsWithMissingJobId.add(e);\n            }\n        }\n\n        logger.debug(\n                \"checked events for {}:\\n  {};\\n  ignored: {},\\n  wrong job id: {},\\n  missing job id: {}\",\n                ext.getLoggerName(),\n                ext.getEvents(),\n                ignoredEvents,\n                eventsWithWrongJobId,\n                eventsWithMissingJobId);\n        assertThat(eventsWithWrongJobId).as(\"events with a wrong Job ID\").isEmpty();\n        assertThat(expectedPatterns)\n                .as(\n                        \"not all expected events logged by %s, logged:\\n%s\",\n                        ext.getLoggerName(), ext.getEvents())\n                .isEmpty();\n        assertThat(eventsWithMissingJobId)\n                .as(\"too many events without Job ID logged by %s\", ext.getLoggerName())\n                .isEmpty();\n    }",
          "conflictNames": [
              "jobID",
              "ext",
              "expPatterns",
              "ignPatterns",
              "eventsWithWrongJobId",
              "ignoredEvents",
              "expectedPatterns",
              "ignorePatterns",
              "context"
          ]
      },
      "suggestions": [
          {
              "name": "eventsWithMissingValue",
              "confidence": 0.75
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/f9738d63391668396072570454fdc1eb61699098^1/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/failover/ExponentialDelayRestartBackoffTimeStrategyTest.java",
      "locators": [
          {
              "line": 41,
              "column": 58
          },
          {
              "line": 46,
              "column": 24
          },
          {
              "line": 47,
              "column": 13
          },
          {
              "line": 49,
              "column": 20
          },
          {
              "line": 56,
              "column": 58
          },
          {
              "line": 60,
              "column": 20
          },
          {
              "line": 67,
              "column": 58
          },
          {
              "line": 72,
              "column": 13
          },
          {
              "line": 73,
              "column": 24
          },
          {
              "line": 83,
              "column": 58
          },
          {
              "line": 94,
              "column": 43
          },
          {
              "line": 96,
              "column": 9
          },
          {
              "line": 97,
              "column": 20
          },
          {
              "line": 102,
              "column": 43
          },
          {
              "line": 103,
              "column": 9
          },
          {
              "line": 104,
              "column": 20
          },
          {
              "line": 116,
              "column": 58
          },
          {
              "line": 126,
              "column": 9
          },
          {
              "line": 127,
              "column": 20
          },
          {
              "line": 129,
              "column": 9
          },
          {
              "line": 130,
              "column": 20
          },
          {
              "line": 138,
              "column": 58
          },
          {
              "line": 148,
              "column": 9
          },
          {
              "line": 149,
              "column": 34
          },
          {
              "line": 151,
              "column": 9
          },
          {
              "line": 152,
              "column": 34
          },
          {
              "line": 154,
              "column": 9
          },
          {
              "line": 155,
              "column": 34
          },
          {
              "line": 163,
              "column": 58
          },
          {
              "line": 173,
              "column": 34
          },
          {
              "line": 175,
              "column": 9
          },
          {
              "line": 176,
              "column": 34
          },
          {
              "line": 178,
              "column": 9
          },
          {
              "line": 179,
              "column": 34
          },
          {
              "line": 191,
              "column": 58
          },
          {
              "line": 202,
              "column": 20
          },
          {
              "line": 203,
              "column": 20
          },
          {
              "line": 207,
              "column": 9
          },
          {
              "line": 208,
              "column": 20
          },
          {
              "line": 209,
              "column": 20
          },
          {
              "line": 213,
              "column": 9
          },
          {
              "line": 214,
              "column": 20
          },
          {
              "line": 215,
              "column": 20
          },
          {
              "line": 218,
              "column": 9
          },
          {
              "line": 219,
              "column": 20
          },
          {
              "line": 220,
              "column": 34
          },
          {
              "line": 223,
              "column": 9
          },
          {
              "line": 224,
              "column": 20
          },
          {
              "line": 225,
              "column": 34
          },
          {
              "line": 229,
              "column": 9
          },
          {
              "line": 230,
              "column": 20
          },
          {
              "line": 231,
              "column": 20
          },
          {
              "line": 234,
              "column": 9
          },
          {
              "line": 235,
              "column": 20
          },
          {
              "line": 236,
              "column": 20
          }
      ],
      "old_name": "restartStrategy",
      "new_name": "restartStrategyFactory",
      "ctx": {
          "symbolName": "restartStrategy",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ExponentialDelayRestartBackoffTimeStrategy",
          "scopeHint": "in testMaxAttempts(...)",
          "filePath": "ExponentialDelayRestartBackoffTimeStrategyTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testMaxAttempts() {\n        int maxAttempts = 13;\n        final ExponentialDelayRestartBackoffTimeStrategy restartStrategy =\n                new ExponentialDelayRestartBackoffTimeStrategy(\n                        new ManualClock(), 1L, 3L, 1.2, 4L, 0.25, maxAttempts);\n\n        for (int i = 0; i <= maxAttempts; i++) {\n            assertThat(restartStrategy.canRestart()).isTrue();\n            restartStrategy.notifyFailure(failure);\n        }\n        assertThat(restartStrategy.canRestart()).isFalse();\n    }",
          "conflictNames": [
              "maxAttempts",
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/f975783ce9a688a99e2f74fe6f2f5ad204589fdc^1/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/datatransfer/CopyDataTransferStrategy.java",
      "locators": [
          {
              "line": 112,
              "column": 27
          },
          {
              "line": 115,
              "column": 13
          },
          {
              "line": 116,
              "column": 72
          },
          {
              "line": 117,
              "column": 42
          }
      ],
      "old_name": "handleByDuplicating",
      "new_name": "targetStateHandle",
      "ctx": {
          "symbolName": "handleByDuplicating",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "StreamStateHandle",
          "scopeHint": "in copyFileToCheckpoint(...)",
          "filePath": "CopyDataTransferStrategy.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private static HandleAndLocalPath copyFileToCheckpoint(\n            FileSystem dbFileSystem,\n            Path filePath,\n            long maxTransferBytes,\n            CheckpointStreamFactory checkpointStreamFactory,\n            CheckpointedStateScope stateScope,\n            CloseableRegistry closeableRegistry,\n            CloseableRegistry tmpResourcesRegistry)\n            throws IOException {\n        StreamStateHandle handleByDuplicating =\n                duplicateFileToCheckpoint(\n                        dbFileSystem, filePath, checkpointStreamFactory, stateScope);\n        if (handleByDuplicating != null) {\n            LOG.trace(\"Duplicate file to checkpoint: {} {}\", filePath, handleByDuplicating);\n            return HandleAndLocalPath.of(handleByDuplicating, filePath.getName());\n        }\n\n        HandleAndLocalPath handleAndLocalPath =\n                HandleAndLocalPath.of(\n                        writeFileToCheckpoint(\n                                dbFileSystem,\n                                filePath,\n                                maxTransferBytes,\n                                checkpointStreamFactory,\n                                stateScope,\n                                closeableRegistry,\n                                tmpResourcesRegistry),\n                        filePath.getName());\n        LOG.trace(\"Write file to checkpoint: {}, {}\", filePath, handleAndLocalPath.getHandle());\n        return handleAndLocalPath;\n    }",
          "conflictNames": [
              "dbFileSystem",
              "filePath",
              "maxTransferBytes",
              "checkpointStreamFactory",
              "stateScope",
              "closeableRegistry",
              "tmpResourcesRegistry",
              "handleAndLocalPath"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/fa4518960fd009531a584ca5450604649e94bac0^1/flink-runtime/src/main/java/org/apache/flink/runtime/deployment/InputGateDeploymentDescriptor.java",
      "locators": [
          {
              "line": 175,
              "column": 53
          },
          {
              "line": 178,
              "column": 56
          },
          {
              "line": 192,
              "column": 41
          },
          {
              "line": 193,
              "column": 68
          }
      ],
      "old_name": "shuffleDescriptorAndIndices",
      "new_name": "shuffleDescriptorGroup",
      "ctx": {
          "symbolName": "shuffleDescriptorAndIndices",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ShuffleDescriptorAndIndex[]",
          "scopeHint": "in getShuffleDescriptors(...)",
          "filePath": "InputGateDeploymentDescriptor.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public ShuffleDescriptor[] getShuffleDescriptors() {\n        try {\n            if (inputChannels == null) {\n                inputChannels = new ShuffleDescriptor[numberOfInputChannels];\n                for (MaybeOffloaded<ShuffleDescriptorAndIndex[]> serializedShuffleDescriptors :\n                        serializedInputChannels) {\n                    if (serializedShuffleDescriptors instanceof NonOffloaded) {\n                        NonOffloaded<ShuffleDescriptorAndIndex[]> nonOffloadedSerializedValue =\n                                (NonOffloaded<ShuffleDescriptorAndIndex[]>)\n                                        serializedShuffleDescriptors;\n                        ShuffleDescriptorAndIndex[] shuffleDescriptorAndIndices =\n                                nonOffloadedSerializedValue.serializedValue.deserializeValue(\n                                        getClass().getClassLoader());\n                        putOrReplaceShuffleDescriptors(shuffleDescriptorAndIndices);\n                    } else {\n                        throw new IllegalStateException(\n                                \"Trying to work with offloaded serialized shuffle descriptors.\");\n                    }\n                }\n            }\n        } catch (IOException | ClassNotFoundException e) {\n            throw new RuntimeException(\"Could not deserialize shuffle descriptors.\", e);\n        }\n        return inputChannels;\n    }",
          "conflictNames": [
              "nonOffloadedSerializedValue"
          ]
      },
      "suggestions": [
          {
              "name": "shuffleDescriptorGroup",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/fa4518960fd009531a584ca5450604649e94bac0^1/flink-runtime/src/test/java/org/apache/flink/runtime/deployment/TaskDeploymentDescriptorFactoryTest.java",
      "locators": [
          {
              "line": 105,
              "column": 65
          },
          {
              "line": 111,
              "column": 47
          },
          {
              "line": 142,
              "column": 59
          },
          {
              "line": 146,
              "column": 20
          },
          {
              "line": 153,
              "column": 9
          },
          {
              "line": 157,
              "column": 20
          }
      ],
      "old_name": "maybeOffloaded",
      "new_name": "serializedShuffleDescriptors",
      "ctx": {
          "symbolName": "maybeOffloaded",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<MaybeOffloaded<ShuffleDescriptorAndIndex[]>>",
          "scopeHint": "in testCacheShuffleDescriptor(...)",
          "filePath": "TaskDeploymentDescriptorFactoryTest.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private void testCacheShuffleDescriptor(Configuration jobMasterConfig) throws Exception {\n        final JobID jobId = new JobID();\n        final TestingBlobWriter blobWriter = new TestingBlobWriter();\n\n        final Tuple2<ExecutionJobVertex, ExecutionJobVertex> executionJobVertices =\n                setupExecutionGraphAndGetVertices(jobId, blobWriter, jobMasterConfig);\n\n        final ExecutionVertex ev21 = executionJobVertices.f1.getTaskVertices()[0];\n        createTaskDeploymentDescriptor(ev21);\n\n        // The ShuffleDescriptors should be cached\n        final IntermediateResult consumedResult = executionJobVertices.f1.getInputs().get(0);\n        final List<MaybeOffloaded<ShuffleDescriptorAndIndex[]>> maybeOffloaded =\n                consumedResult\n                        .getCachedShuffleDescriptors(ev21.getConsumedPartitionGroup(0))\n                        .getAllSerializedShuffleDescriptors();\n\n        final ShuffleDescriptor[] cachedShuffleDescriptors =\n                deserializeShuffleDescriptors(maybeOffloaded, jobId, blobWriter);\n\n        // Check if the ShuffleDescriptors are cached correctly\n        assertThat(ev21.getConsumedPartitionGroup(0)).hasSize(cachedShuffleDescriptors.length);\n\n        int idx = 0;\n        for (IntermediateResultPartitionID consumedPartitionId :\n                ev21.getConsumedPartitionGroup(0)) {\n            assertThat(cachedShuffleDescriptors[idx++].getResultPartitionID().getPartitionId())\n                    .isEqualTo(consumedPartitionId);\n        }\n    }",
          "conflictNames": [
              "jobMasterConfig",
              "jobId",
              "blobWriter",
              "executionJobVertices",
              "ev21",
              "consumedResult",
              "cachedShuffleDescriptors",
              "idx"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/fa4518960fd009531a584ca5450604649e94bac0^1/flink-runtime/src/main/java/org/apache/flink/runtime/deployment/CachedShuffleDescriptors.java",
      "locators": [
          {
              "line": 45,
              "column": 69
          },
          {
              "line": 49,
              "column": 8
          },
          {
              "line": 69,
              "column": 14
          },
          {
              "line": 77,
              "column": 43
          },
          {
              "line": 78,
              "column": 32
          },
          {
              "line": 85,
              "column": 57
          },
          {
              "line": 89,
              "column": 13
          },
          {
              "line": 89,
              "column": 46
          }
      ],
      "old_name": "serializedShuffleDescriptor",
      "new_name": "serializedShuffleDescriptorGroup",
      "ctx": {
          "symbolName": "serializedShuffleDescriptor",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "MaybeOffloaded<ShuffleDescriptorAndIndex[]>",
          "scopeHint": "in serializeShuffleDescriptors(...)",
          "filePath": "CachedShuffleDescriptors.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public void serializeShuffleDescriptors(\n            TaskDeploymentDescriptorFactory.ShuffleDescriptorSerializer shuffleDescriptorSerializer)\n            throws IOException {\n        if (!toBeSerialized.isEmpty()) {\n            MaybeOffloaded<ShuffleDescriptorAndIndex[]> serializedShuffleDescriptor =\n                    shuffleDescriptorSerializer.serializeAndTryOffloadShuffleDescriptor(\n                            toBeSerialized.toArray(new ShuffleDescriptorAndIndex[0]), numConsumers);\n            toBeSerialized.clear();\n            serializedShuffleDescriptors.add(serializedShuffleDescriptor);\n        }\n    }",
          "conflictNames": [
              "shuffleDescriptorSerializer"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/fa4518960fd009531a584ca5450604649e94bac0^1/flink-runtime/src/test/java/org/apache/flink/runtime/deployment/TaskDeploymentDescriptorTestUtils.java",
      "locators": [
          {
              "line": 48,
              "column": 41
          },
          {
              "line": 50,
              "column": 17
          },
          {
              "line": 63,
              "column": 17
          },
          {
              "line": 68,
              "column": 21
          }
      ],
      "old_name": "shuffleDescriptorAndIndices",
      "new_name": "shuffleDescriptorGroup",
      "ctx": {
          "symbolName": "shuffleDescriptorAndIndices",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "ShuffleDescriptorAndIndex[]",
          "scopeHint": "in deserializeShuffleDescriptors(...)",
          "filePath": "TaskDeploymentDescriptorTestUtils.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "public static ShuffleDescriptor[] deserializeShuffleDescriptors(\n            List<MaybeOffloaded<ShuffleDescriptorAndIndex[]>> maybeOffloaded,\n            JobID jobId,\n            TestingBlobWriter blobWriter)\n            throws IOException, ClassNotFoundException {\n        Map<Integer, ShuffleDescriptor> shuffleDescriptorsMap = new HashMap<>();\n        int maxIndex = 0;\n        for (MaybeOffloaded<ShuffleDescriptorAndIndex[]> sd : maybeOffloaded) {\n            ShuffleDescriptorAndIndex[] shuffleDescriptorAndIndices;\n            if (sd instanceof NonOffloaded) {\n                shuffleDescriptorAndIndices =\n                        ((NonOffloaded<ShuffleDescriptorAndIndex[]>) sd)\n                                .serializedValue.deserializeValue(\n                                        ClassLoader.getSystemClassLoader());\n\n            } else {\n                final CompressedSerializedValue<ShuffleDescriptorAndIndex[]>\n                        compressedSerializedValue =\n                                CompressedSerializedValue.fromBytes(\n                                        blobWriter.getBlob(\n                                                jobId,\n                                                ((Offloaded<ShuffleDescriptorAndIndex[]>) sd)\n                                                        .serializedValueKey));\n                shuffleDescriptorAndIndices =\n                        compressedSerializedValue.deserializeValue(\n                                ClassLoader.getSystemClassLoader());\n            }\n            for (ShuffleDescriptorAndIndex shuffleDescriptorAndIndex :\n                    shuffleDescriptorAndIndices) {\n                int index = shuffleDescriptorAndIndex.getIndex();\n                maxIndex = Math.max(maxIndex, shuffleDescriptorAndIndex.getIndex());\n                shuffleDescriptorsMap.put(index, shuffleDescriptorAndIndex.getShuffleDescriptor());\n            }\n        }\n        ShuffleDescriptor[] shuffleDescriptors = new ShuffleDescriptor[maxIndex + 1];\n        shuffleDescriptorsMap.forEach((key, value) -> shuffleDescriptors[key] = value);\n        return shuffleDescriptors;\n    }",
          "conflictNames": [
              "maybeOffloaded",
              "jobId",
              "blobWriter",
              "shuffleDescriptorsMap",
              "maxIndex",
              "compressedSerializedValue",
              "index",
              "shuffleDescriptors"
          ]
      },
      "suggestions": [
          {
              "name": "shuffleDescriptorGroup",
              "confidence": 0.9
          }
      ]
  },
  {
      "path": "https://github.com/apache/flink/blob/fafd86cd648e0b31e3dc78f6426616a9d2c671c5^1/flink-tests/src/test/java/org/apache/flink/test/scheduling/JMFailoverITCase.java",
      "locators": [
          {
              "line": 168,
              "column": 18
          },
          {
              "line": 173,
              "column": 46
          },
          {
              "line": 191,
              "column": 18
          },
          {
              "line": 196,
              "column": 46
          },
          {
              "line": 201,
              "column": 28
          },
          {
              "line": 231,
              "column": 18
          },
          {
              "line": 236,
              "column": 46
          },
          {
              "line": 254,
              "column": 18
          },
          {
              "line": 259,
              "column": 46
          },
          {
              "line": 289,
              "column": 18
          },
          {
              "line": 294,
              "column": 46
          },
          {
              "line": 315,
              "column": 18
          },
          {
              "line": 320,
              "column": 46
          }
      ],
      "old_name": "jobGraph",
      "new_name": "streamGraph",
      "ctx": {
          "symbolName": "jobGraph",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "JobGraph",
          "scopeHint": "in testRecoverFromJMFailover(...)",
          "filePath": "JMFailoverITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Test\n    void testRecoverFromJMFailover() throws Exception {\n        JobGraph jobGraph = prepareEnvAndGetJobGraph();\n\n        // blocking all sink\n        StubRecordSink.blockSubTasks(0, 1, 2, 3);\n\n        JobID jobId = flinkCluster.submitJob(jobGraph).get().getJobID();\n\n        // wait until sink is running.\n        tryWaitUntilCondition(() -> StubRecordSink.attemptIds.size() > 0);\n\n        triggerJMFailover(jobId);\n\n        // unblock all sink.\n        StubRecordSink.unblockSubTasks(0, 1, 2, 3);\n\n        JobResult jobResult = flinkCluster.requestJobResult(jobId).get();\n        assertThat(jobResult.getSerializedThrowable()).isEmpty();\n\n        checkCountResults();\n    }",
          "conflictNames": [
              "jobId",
              "jobResult"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/fbc7d0a66e35f4c167c688c95d3e19bf3b567952^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamPhysicalMultiJoin.java",
      "locators": [
          {
              "line": 169,
              "column": 23
          },
          {
              "line": 178,
              "column": 17
          }
      ],
      "old_name": "multiJoinCondition",
      "new_name": "multijoinCondition",
      "ctx": {
          "symbolName": "multiJoinCondition",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "RexNode",
          "scopeHint": "in translateToExecNode(...)",
          "filePath": "StreamPhysicalMultiJoin.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public ExecNode<?> translateToExecNode() {\n        final RexNode multiJoinCondition = createMultiJoinCondition();\n        final List<List<int[]>> inputUniqueKeys = getUniqueKeysForInputs();\n        final List<FlinkJoinType> execJoinTypes = getExecJoinTypes();\n        final List<InputProperty> inputProperties = createInputProperties();\n\n        return new StreamExecMultiJoin(\n                unwrapTableConfig(this),\n                execJoinTypes,\n                joinConditions,\n                multiJoinCondition,\n                joinAttributeMap,\n                inputUniqueKeys,\n                Collections.emptyMap(), // TODO Enable hint-based state ttl. See ticket\n                // TODO https://issues.apache.org/jira/browse/FLINK-37936\n                inputProperties,\n                FlinkTypeFactory.toLogicalRowType(getRowType()),\n                getRelDetailedDescription());\n    }",
          "conflictNames": [
              "inputUniqueKeys",
              "execJoinTypes",
              "inputProperties"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/fbc7d0a66e35f4c167c688c95d3e19bf3b567952^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamPhysicalMultiJoin.java",
      "locators": [
          {
              "line": 170,
              "column": 33
          },
          {
              "line": 180,
              "column": 17
          },
          {
              "line": 259,
              "column": 36
          },
          {
              "line": 260,
              "column": 13
          },
          {
              "line": 260,
              "column": 40
          },
          {
              "line": 270,
              "column": 16
          }
      ],
      "old_name": "inputUniqueKeys",
      "new_name": "localInputUniqueKeys",
      "ctx": {
          "symbolName": "inputUniqueKeys",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<List<int[]>>",
          "scopeHint": "in translateToExecNode(...)",
          "filePath": "StreamPhysicalMultiJoin.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public ExecNode<?> translateToExecNode() {\n        final RexNode multiJoinCondition = createMultiJoinCondition();\n        final List<List<int[]>> inputUniqueKeys = getUniqueKeysForInputs();\n        final List<FlinkJoinType> execJoinTypes = getExecJoinTypes();\n        final List<InputProperty> inputProperties = createInputProperties();\n\n        return new StreamExecMultiJoin(\n                unwrapTableConfig(this),\n                execJoinTypes,\n                joinConditions,\n                multiJoinCondition,\n                joinAttributeMap,\n                inputUniqueKeys,\n                Collections.emptyMap(), // TODO Enable hint-based state ttl. See ticket\n                // TODO https://issues.apache.org/jira/browse/FLINK-37936\n                inputProperties,\n                FlinkTypeFactory.toLogicalRowType(getRowType()),\n                getRelDetailedDescription());\n    }",
          "conflictNames": [
              "multiJoinCondition",
              "execJoinTypes",
              "inputProperties"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/fbc7d0a66e35f4c167c688c95d3e19bf3b567952^1/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamPhysicalMultiJoin.java",
      "locators": [
          {
              "line": 170,
              "column": 33
          },
          {
              "line": 180,
              "column": 17
          },
          {
              "line": 259,
              "column": 36
          },
          {
              "line": 260,
              "column": 13
          },
          {
              "line": 260,
              "column": 40
          },
          {
              "line": 270,
              "column": 16
          }
      ],
      "old_name": "inputUniqueKeys",
      "new_name": "inputUniqueKeysSet",
      "ctx": {
          "symbolName": "inputUniqueKeys",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "List<List<int[]>>",
          "scopeHint": "in translateToExecNode(...)",
          "filePath": "StreamPhysicalMultiJoin.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n    public ExecNode<?> translateToExecNode() {\n        final RexNode multiJoinCondition = createMultiJoinCondition();\n        final List<List<int[]>> inputUniqueKeys = getUniqueKeysForInputs();\n        final List<FlinkJoinType> execJoinTypes = getExecJoinTypes();\n        final List<InputProperty> inputProperties = createInputProperties();\n\n        return new StreamExecMultiJoin(\n                unwrapTableConfig(this),\n                execJoinTypes,\n                joinConditions,\n                multiJoinCondition,\n                joinAttributeMap,\n                inputUniqueKeys,\n                Collections.emptyMap(), // TODO Enable hint-based state ttl. See ticket\n                // TODO https://issues.apache.org/jira/browse/FLINK-37936\n                inputProperties,\n                FlinkTypeFactory.toLogicalRowType(getRowType()),\n                getRelDetailedDescription());\n    }",
          "conflictNames": [
              "multiJoinCondition",
              "execJoinTypes",
              "inputProperties"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/fc51d4e09b45064e180d48fb3cfcc68865d950d0^1/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ArchivedExecutionGraph.java",
      "locators": [
          {
              "line": 98,
              "column": 26
          },
          {
              "line": 129,
              "column": 20
          },
          {
              "line": 151,
              "column": 14
          },
          {
              "line": 151,
              "column": 52
          },
          {
              "line": 170,
              "column": 16
          },
          {
              "line": 476,
              "column": 16
          },
          {
              "line": 496,
              "column": 17
          }
      ],
      "old_name": "jsonPlan",
      "new_name": "plan",
      "ctx": {
          "symbolName": "jsonPlan",
          "symbolKind": "field",
          "language": "JAVA",
          "type": "String",
          "scopeHint": "in ArchivedExecutionGraph",
          "filePath": "ArchivedExecutionGraph.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": " JobType jobType;\n\n    /**\n     * The exception that caused the job to fail. This is set to the first root exception that was\n     * not recoverable and triggered job failure\n     */\n    @Nullable private final ErrorInfo failureCause;\n\n    // ------ Fields that are only relevant for archived execution graphs ------------\n    private final String jsonPlan;\n    private final StringifiedAccumulatorResult[] archivedUserAccumulators;\n    private final ArchivedExecutionConfig archivedExecutionConfig;\n    private final boolean isStoppable;\n    private final Map<String, SerializedValue<OptionalFail",
          "conflictNames": [
              "serialVersionUID",
              "jobID",
              "jobName",
              "tasks",
              "verticesInCreationOrder",
              "stateTimestamps",
              "state",
              "jobType",
              "failureCause",
              "archivedUserAccumulators",
              "archivedExecutionConfig",
              "isStoppable",
              "serializedUserAccumulators",
              "jobCheckpointingConfiguration",
              "checkpointStatsSnapshot",
              "stateBackendName",
              "checkpointStorageName",
              "stateChangelogEnabled",
              "changelogStorageName",
              "streamGraphJson",
              "pendingOperatorCount"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/fc99b66a1b5532e681d09ce70d3b48ceef31ee48^1/flink-core/src/main/java/org/apache/flink/util/ReflectionUtil.java",
      "locators": [
          {
              "line": 137,
              "column": 65
          },
          {
              "line": 138,
              "column": 41
          },
          {
              "line": 140,
              "column": 38
          },
          {
              "line": 150,
              "column": 27
          },
          {
              "line": 151,
              "column": 41
          },
          {
              "line": 153,
              "column": 38
          }
      ],
      "old_name": "paramterizedType",
      "new_name": "parameterizedType",
      "ctx": {
          "symbolName": "paramterizedType",
          "symbolKind": "parameter",
          "language": "JAVA",
          "type": "ParameterizedType",
          "scopeHint": "in getTemplateTypes(...)",
          "filePath": "ReflectionUtil.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "ateTypes((ParameterizedType) type);\n        } else {\n            throw new IllegalArgumentException(\n                    \"The searched for superclass is not a generic class.\");\n        }\n    }\n\n    public static Class<?>[] getTemplateTypes(ParameterizedType paramterizedType) {\n        Class<?>[] types = new Class<?>[paramterizedType.getActualTypeArguments().length];\n        int i = 0;\n        for (Type templateArgument : paramterizedType.getActualTypeArguments()) {\n            assert templateArgument instance",
          "conflictNames": [
              "types",
              "i"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/fc99b66a1b5532e681d09ce70d3b48ceef31ee48^1/flink-tests/src/test/java/org/apache/flink/test/streaming/api/datastream/StatefulDataStreamV2ITCase.java",
      "locators": [
          {
              "line": 232,
              "column": 18
          },
          {
              "line": 233,
              "column": 13
          },
          {
              "line": 233,
              "column": 28
          },
          {
              "line": 233,
              "column": 56
          },
          {
              "line": 234,
              "column": 42
          },
          {
              "line": 235,
              "column": 42
          }
      ],
      "old_name": "curOccurence",
      "new_name": "curOccurrence",
      "ctx": {
          "symbolName": "curOccurence",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "Long",
          "scopeHint": "in processRecord(...)",
          "filePath": "StatefulDataStreamV2ITCase.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "@Override\n        public void processRecord(\n                Long record, Collector<String> output, PartitionedContext<String> ctx)\n                throws Exception {\n            Optional<MapState<Long, Long>> maybeState =\n                    ctx.getStateManager().getStateOptional(stateDeclaration);\n            if (!maybeState.isPresent()) {\n                throw new FlinkRuntimeException(\"State not found: \" + stateDeclaration);\n            }\n            Long curOccurence = maybeState.get().get(record);\n            curOccurence = curOccurence == null ? 1L : curOccurence + 1L;\n            maybeState.get().put(record, curOccurence);\n            output.collect(Long.toString(curOccurence));\n        }",
          "conflictNames": [
              "record",
              "output",
              "ctx",
              "maybeState"
          ]
      },
      "suggestions": []
  },
  {
      "path": "https://github.com/apache/flink/blob/fd673a2f46206ff65978f05fcb96b525696aead2^1/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/translators/SinkTransformationTranslator.java",
      "locators": [
          {
              "line": 179,
              "column": 56
          },
          {
              "line": 188,
              "column": 45
          },
          {
              "line": 210,
              "column": 45
          }
      ],
      "old_name": "typeInformation",
      "new_name": "committableTypeInformation",
      "ctx": {
          "symbolName": "typeInformation",
          "symbolKind": "localVariable",
          "language": "JAVA",
          "type": "TypeInformation<CommittableMessage<CommT>>",
          "scopeHint": "in addCommittingTopology(...)",
          "filePath": "SinkTransformationTranslator.java",
          "projectStyle": "lowerCamelCase",
          "codeSnippet": "private <CommT> void addCommittingTopology(Sink<T> sink, DataStream<T> inputStream) {\n            TwoPhaseCommittingSink<T, CommT> committingSink =\n                    (TwoPhaseCommittingSink<T, CommT>) sink;\n            TypeInformation<CommittableMessage<CommT>> typeInformation =\n                    CommittableMessageTypeInfo.of(committingSink::getCommittableSerializer);\n\n            DataStream<CommittableMessage<CommT>> written =\n                    adjustTransformations(\n                            inputStream,\n                            input ->\n                                    input.transform(\n                                            WRITER_NAME,\n                                            typeInformation,\n                                            new SinkWriterOperatorFactory<>(sink)),\n                            false,\n                            sink instanceof SupportsConcurrentExecutionAttempts);\n\n            DataStream<CommittableMessage<CommT>> precommitted = addFailOverRegion(written);\n\n            if (sink instanceof WithPreCommitTopology) {\n                precommitted =\n                        adjustTransformations(\n                                precommitted,\n                                ((WithPreCommitTopology<T, CommT>) sink)::addPreCommitTopology,\n                                true,\n                                false);\n            }\n\n            DataStream<CommittableMessage<CommT>> committed =\n                    adjustTransformations(\n                            precommitted,\n                            pc ->\n                                    pc.transform(\n                                            COMMITTER_NAME,\n                                            typeInformation,\n                                            new CommitterOperatorFactory<>(\n                                                    committingSink,\n                                                    isBatchMode,\n                                                    isCheckpointingEnabled)),\n                            false,\n                            false);\n\n            if (sink instanceof WithPostCommitTopology) {\n                DataStream<CommittableMessage<CommT>> postcommitted = addFailOverRegion(committed);\n                adjustTransformations(\n                        postcommitted,\n                        pc -> {\n                            ((WithPostCommitTopology<T, CommT>) sink).addPostCommitTopology(pc);\n                            return null;\n                        },\n                        true,\n                        false);\n            }\n        }",
          "conflictNames": [
              "sink",
              "inputStream",
              "committingSink",
              "written",
              "precommitted",
              "committed",
              "postcommitted"
          ]
      },
      "suggestions": []
  }
  ]
}
